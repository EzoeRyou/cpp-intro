# 文字列

## はじめに

とうとう文字列を学ぶべきときがやってきた。文字列自体は最初から使ってきた。

~~~cpp
auto s = "hello"s ;
~~~ 

これは文字列の表面的な使い方だけだ。しかも、本書ではこれまで文字列に日本語を使ってこなかった。これには理由がある。たとえば、

~~~cpp
int main()
{
    std::cout << "こんにちは"s ;
}
~~~

のようなコードが動くかどうかは実装依存だからだ。試しにコンパイルして実行してみよう。もし画面に「こんにちは」と表示されたのであれば、どうやら読者の環境はこのコードで日本語を出力、表示できるようだ。

## 基本ソース文字セット

C++では、基本ソース文字セットと呼ばれる文字がある。C++のソースコードで安全に使うことができる文字だ。ラテンアルファベットの大文字小文字、記号、制御文字からなる文字セットで、96文字ある。

空白文字、水平タブ、垂直タブ、フォームフィード、改行の5文字と、以下の印字可能な以下の91文字だ。

~~~
a b c d e f g h i j k l m n o p q r s t u v w x y z
A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
0 1 2 3 4 5 6 7 8 9
_ { } [ ] # ( ) < > % : ; . ? * + - / ^ & | ~ ! = , \ " '
~~~


## 基本実行文字セット

基本実行文字セットは基本ソース文字セットにアラート、バックスペース、キャリッジリターン、null文字を加えたものだ。

null文字は整数の`0`に等しいという特別な特徴を持つ文字だ。


## 文字を表現する方法

文字をコンピューターで扱うには、ビット列で文字を表現できなければならない。C++でアドレス可能な最小単位はバイトなので、文字というのはバイト列で表現する。

### ASCII

ASCIIはとても広く普及した文字のエンコード方法だ。ASCIIでは7ビットの整数値で1文字を表現する。

C++の基本実行文字セットは特定の文字エンコードであると規定されていはいないが、ASCIIを参考にしている。ただしASCIIには基本実行文字セットにはない。ダラーサイン($)、アットマーク(@)といくつかの制御文字がある。

### Unicode

Unicode、もしくはISO/IEC 10646(Universal Coded Character Set, UCS)は文字のコードポイントを定める規格だ。

Unicodeは当初、16bitの整数値でコードポイントを表現する規格であった。この当時、1コードポイントは1文字であり16bitであった。

そのような当初の目論見はすぐに破綻し、今では1コードポイントは32bitであり、1コードポイントは1文字を意味しないようになった。複数のコードポイントを組み合わせて1文字が表現されることもあるからだ。

Unicodeはコードポイントについて定めた規格であり、バイト列で文字を表現する規格ではない。Unicodeを元にしたバイト列によって文字を表現するエンコード方式に、UTF-8, UTF-16, UTF-32が存在する。

#### UTF-16

UTF-16は16bitの整数値によってUnicodeのコードポイントを表現するエンコード方式だ。まだUnicodeが16bitのコードポイントですべての文字を表現すると考えていた頃に考案されたUCS-2が元になっている。

その後、Unicodeのコードポイントが32bitに拡張されたので、UCS-2からUTF-16が考案された。

UTF-16は16bitを1単位とした整数で32bitのコードポイントを表現するために、1単位で表現できないコードポイントを、サロゲートペアと呼ばれる連続した2単位で表現する。

そのため、UTF-16の任意の1単位を切り出すと、それは1つのコードポイントを表現するサロゲートペアの片方である可能性があり、文字として壊れてしまう可能性がある。

#### UTF-32

UTF-32は32bitの整数値によってUnicodeのコードポイントを表現するエンコード方式だ。UTF-32の1単位は32bit整数なので、Unicodeの任意の1コードポイントを表現できる。

ただし問題は、Unicodeではもはや1コードポイントは1文字ではないということだ。したがってUTF-32の1単位は1文字ではない。

UTF-32の1単位は1コードポイントだが、UTF-32の任意の1単位を切り出すことはできない。

連続した複数のコードポイントによって表現された1文字は、

#### マルチバイトエンコードの問題点

UTF-16とUTF-32は1単位が複数のバイトからなるエンコード方式だ。これをマルチバイトエンコード方式という

## OS



## リテラル

### 通常の文字リテラル

通常の文字リテラルは単一引用符でひとつの文字を囲む。

~~~c++
`a`
`b`
`c`
~~~

通常の文字リテラルの型はcharだ。

~~~c++
char a = `a` ;
char b = 'b' ;
char c = 'c' ;
~~~

文字リテラルには以下のようなエスケープシーケンスがある。これは一部の印字不可能な文字や、文法上の理由で直接リテラルのなかに書くことができない文字を書けるようにするための代替手段だ。


意味                    リテラル
------------------      --------
改行                    \n
水平タブ                \t
垂直タブ                \v
バックスペース          \b
キャリッジリターン      \r
フォームフィード        \f
アラート                \a
バックスラッシュ        \\
疑問符                  \?
単一引用符              \'
二重引用符              \"


これを使えば、単一引用符の文字リテラルは

~~~c++
char c = '\'' ;
~~~

と書ける。エスケープシーケンスにはバックスラッシュを使うため、文字リテラルのなかでバックスラッシュを使うには、エスケープシーケンスが必要だ。

~~~c++
char c = '\\' ;
~~~





### 通常の文字列リテラル
