<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="江添 亮" />
  <meta name="dcterms.date" content="2018-02-27" />
  <title>江添亮のC++入門</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; position: absolute; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; }
pre.numberSource a.sourceLine:empty
  { position: absolute; }
pre.numberSource a.sourceLine::before
  { content: attr(data-line-number);
    position: absolute; left: -5em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <script src="/usr/share/javascript/mathjax/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
  <style>
  pre > code
  {
      display : block ;
      font-family : monospace ;
      font-size : x-large ;
      border-style : solid ;
      border-width : medium ;
      border-color : black ;
      border-radius : 0.4em ;
      padding : 0.5em ;
      word-wrap : break-word ;
      white-space : pre-wrap ;
  }
  
  h1,h2,h3,h4,h5,h6
  {
      font-size : 2em ;
      font-weight : bold ;
  }
  
  table, th, td {
      border: 1px solid black;
      border-collapse: collapse;
      padding : 0.5em ;
  }
  </style>
</head>
<body>
<header>
<h1 class="title">江添亮のC++入門</h1>
<p class="author">江添 亮</p>
<p class="date">2018-02-27</p>
</header>
<nav id="TOC">
<ul>
<li><a href="#序">序</a></li>
<li><a href="#cの概要">C++の概要</a></li>
<li><a href="#cの実行">C++の実行</a><ul>
<li><a href="#cの実行の仕組み">C++の実行の仕組み</a></li>
<li><a href="#簡単な一つのソースファイルからなるプログラムの実行">簡単な一つのソースファイルからなるプログラムの実行</a><ul>
<li><a href="#サンプルコード">サンプルコード</a></li>
<li><a href="#コンパイル">コンパイル</a></li>
<li><a href="#実行">実行</a></li>
</ul></li>
<li><a href="#gcc-cコンパイラー">GCC: C++コンパイラー</a><ul>
<li><a href="#コンパイラーオプション">コンパイラーオプション</a></li>
<li><a href="#ヘッダーファイルの省略">ヘッダーファイルの省略</a></li>
<li><a href="#コンパイル済みヘッダーprecompiled-header">コンパイル済みヘッダー(precompiled header)</a></li>
</ul></li>
<li><a href="#make-ビルドシステム">Make: ビルドシステム</a><ul>
<li><a href="#コンパイルと実行のまとめ">コンパイルと実行のまとめ</a></li>
<li><a href="#依存関係を解決するビルドシステム">依存関係を解決するビルドシステム</a></li>
<li><a href="#依存関係を記述するルール">依存関係を記述するルール</a></li>
<li><a href="#コメント">コメント</a></li>
<li><a href="#変数">変数</a></li>
<li><a href="#自動変数">自動変数</a><ul>
<li><a href="#ターゲット"><code>$@</code> ターゲット</a></li>
<li><a href="#最初の事前要件"><code>$&lt;</code> 最初の事前要件</a></li>
<li><a href="#すべての事前要件"><code>$^</code> すべての事前要件</a></li>
<li><a href="#自動変数の組み合わせ">自動変数の組み合わせ</a></li>
</ul></li>
<li><a href="#phonyターゲット">PHONYターゲット</a></li>
</ul></li>
<li><a href="#入門用の環境構築">入門用の環境構築</a></li>
</ul></li>
<li><a href="#cヒッチハイクガイド">C++ヒッチハイクガイド</a><ul>
<li><a href="#最小のコード">最小のコード</a></li>
<li><a href="#標準出力">標準出力</a></li>
<li><a href="#文字列">文字列</a></li>
<li><a href="#整数と浮動小数点数">整数と浮動小数点数</a></li>
<li><a href="#変数variable">変数(variable)</a></li>
<li><a href="#関数function">関数(function)</a></li>
<li><a href="#本当の関数">本当の関数</a></li>
</ul></li>
<li><a href="#デバッグコンパイルエラーメッセージの読み方">デバッグ：コンパイルエラーメッセージの読み方</a><ul>
<li><a href="#文法エラー">文法エラー</a></li>
<li><a href="#意味エラー">意味エラー</a></li>
<li><a href="#コンパイラーのバグ">コンパイラーのバグ</a></li>
</ul></li>
<li><a href="#条件分岐の果てのレストラン">条件分岐の果てのレストラン</a><ul>
<li><a href="#複合文">複合文</a></li>
<li><a href="#条件分岐">条件分岐</a></li>
<li><a href="#条件式">条件式</a><ul>
<li><a href="#条件とは何だろう">条件とは何だろう</a></li>
</ul></li>
<li><a href="#bool型">bool型</a></li>
<li><a href="#bool型の演算">bool型の演算</a><ul>
<li><a href="#論理否定-operator">論理否定: operator !</a></li>
<li><a href="#同値比較-operator">同値比較: operator ==, !=</a></li>
<li><a href="#論理積-operator">論理積: operator &amp;&amp;</a></li>
<li><a href="#論理和-operator">論理和: operator ||</a></li>
<li><a href="#短絡評価">短絡評価</a></li>
</ul></li>
<li><a href="#boolの変換">boolの変換</a></li>
</ul></li>
<li><a href="#デバッグ-コンパイル警告メッセージ">デバッグ: コンパイル警告メッセージ</a></li>
<li><a href="#最近体重が気になるあなたのための標準入力">最近体重が気になるあなたのための標準入力</a><ul>
<li><a href="#これまでのおさらい">これまでのおさらい</a></li>
<li><a href="#標準入力">標準入力</a></li>
<li><a href="#リダイレクト">リダイレクト</a></li>
<li><a href="#パイプ">パイプ</a></li>
<li><a href="#プログラムの組み合わせ">プログラムの組み合わせ</a></li>
</ul></li>
<li><a href="#ループ">ループ</a><ul>
<li><a href="#これまでのおさらい-1">これまでのおさらい</a></li>
<li><a href="#goto文">goto文</a><ul>
<li><a href="#無限ループ">無限ループ</a></li>
<li><a href="#終了条件付きループ">終了条件付きループ</a></li>
<li><a href="#インデックスループ">インデックスループ</a></li>
</ul></li>
<li><a href="#while文">while文</a><ul>
<li><a href="#無限ループ-1">無限ループ</a></li>
</ul></li>
<li><a href="#終了条件付きループ-1">終了条件付きループ</a><ul>
<li><a href="#インデックスループ-1">インデックスループ</a></li>
</ul></li>
<li><a href="#for文">for文</a></li>
<li><a href="#do文">do文</a></li>
<li><a href="#break文">break文</a></li>
<li><a href="#continue文">continue文</a></li>
<li><a href="#再帰関数">再帰関数</a></li>
</ul></li>
<li><a href="#メモリを無限に確保する">メモリを無限に確保する</a><ul>
<li><a href="#これまでのまとめ">これまでのまとめ</a></li>
<li><a href="#vector">vector</a></li>
</ul></li>
<li><a href="#デバッグprintfデバッグ">デバッグ：printfデバッグ</a><ul>
<li><a href="#実践例">実践例</a></li>
<li><a href="#stdcerr"><code>std::cerr</code></a></li>
<li><a href="#まとめ">まとめ</a></li>
</ul></li>
<li><a href="#整数">整数</a><ul>
<li><a href="#整数リテラル">整数リテラル</a><ul>
<li><a href="#進数リテラル">10進数リテラル</a></li>
<li><a href="#進数リテラル-1">2進数リテラル</a></li>
<li><a href="#進数リテラル-2">8進数リテラル</a></li>
<li><a href="#進数リテラル-3">16進数リテラル</a></li>
<li><a href="#数値区切り">数値区切り</a></li>
</ul></li>
<li><a href="#整数の仕組み">整数の仕組み</a><ul>
<li><a href="#情報の単位">情報の単位</a></li>
<li><a href="#バイトで表現された整数">1バイトで表現された整数</a><ul>
<li><a href="#符号ビット">符号ビット</a></li>
<li><a href="#の補数">1の補数</a></li>
<li><a href="#の補数-1">2の補数</a></li>
</ul></li>
</ul></li>
<li><a href="#整数型">整数型</a><ul>
<li><a href="#int型">int型</a></li>
<li><a href="#long-int型">long int型</a></li>
<li><a href="#long-long-int型">long long int型</a></li>
<li><a href="#short-int型">short int型</a></li>
<li><a href="#char型">char型</a></li>
</ul></li>
<li><a href="#整数型のサイズ">整数型のサイズ</a></li>
<li><a href="#整数型の表現できる値の範囲">整数型の表現できる値の範囲</a></li>
<li><a href="#整数型の変換">整数型の変換</a></li>
</ul></li>
<li><a href="#浮動小数点数">浮動小数点数</a><ul>
<li><a href="#浮動小数点数リテラル">浮動小数点数リテラル</a></li>
<li><a href="#進浮動小数点数リテラル">10進浮動小数点数リテラル</a><ul>
<li><a href="#進数の仮数と指数による表記">10進数の仮数と指数による表記</a></li>
<li><a href="#進数の仮数と指数による表記-1">16進数の仮数と指数による表記</a></li>
</ul></li>
<li><a href="#浮動小数点数の表現と特性">浮動小数点数の表現と特性</a><ul>
<li><a href="#と-0.0">+0.0と-0.0</a></li>
<li><a href="#と-無限大">+∞と-∞(無限大)</a></li>
<li><a href="#nannot-a-number">NaN(Not a Number)</a></li>
<li><a href="#有効桁数">有効桁数</a></li>
</ul></li>
<li><a href="#浮動小数点数同士の変換">浮動小数点数同士の変換</a></li>
<li><a href="#浮動小数点数と整数の変換">浮動小数点数と整数の変換</a></li>
</ul></li>
<li><a href="#名前">名前</a><ul>
<li><a href="#キーワード">キーワード</a></li>
<li><a href="#名前に使える文字">名前に使える文字</a></li>
<li><a href="#宣言と定義">宣言と定義</a></li>
<li><a href="#名前空間">名前空間</a><ul>
<li><a href="#グローバル名前空間">グローバル名前空間</a></li>
<li><a href="#名前空間のネスト">名前空間のネスト</a></li>
<li><a href="#名前空間名の別名を宣言する名前空間エイリアス">名前空間名の別名を宣言する名前空間エイリアス</a></li>
<li><a href="#名前空間名の指定を省略するusingディレクティブ">名前空間名の指定を省略するusingディレクティブ</a></li>
<li><a href="#名前空間を指定しなくてもよいinline名前空間">名前空間を指定しなくてもよいinline名前空間</a></li>
</ul></li>
<li><a href="#型名">型名</a><ul>
<li><a href="#型名の別名を宣言するエイリアス宣言">型名の別名を宣言するエイリアス宣言</a></li>
</ul></li>
<li><a href="#スコープ">スコープ</a></li>
</ul></li>
<li><a href="#イテレーターの基礎">イテレーターの基礎</a><ul>
<li><a href="#イテレーターの取得方法">イテレーターの取得方法</a></li>
<li><a href="#イテレーターの参照する要素に対する読み書き">イテレーターの参照する要素に対する読み書き。</a></li>
<li><a href="#イテレーターの参照する要素を変更">イテレーターの参照する要素を変更</a></li>
<li><a href="#イテレーターの比較">イテレーターの比較</a></li>
<li><a href="#最後の次の要素へのイテレーター">最後の次の要素へのイテレーター</a></li>
<li><a href="#なんでもイテレーター">なんでもイテレーター</a></li>
<li><a href="#イテレーターと添字の範囲">イテレーターと添字の範囲</a></li>
</ul></li>
<li><a href="#lvalueリファレンスとconst">lvalueリファレンスとconst</a><ul>
<li><a href="#lvalueリファレンス">lvalueリファレンス</a></li>
<li><a href="#const">const</a></li>
</ul></li>
<li><a href="#アルゴリズム">アルゴリズム</a><ul>
<li><a href="#for_each">for_each</a></li>
<li><a href="#all_ofany_ofnone_of">all_of/any_of/none_of</a></li>
<li><a href="#findfind_if">find/find_if</a></li>
<li><a href="#countcount_if">count/count_if</a></li>
<li><a href="#equal">equal</a></li>
<li><a href="#search">search</a></li>
<li><a href="#copy">copy</a></li>
<li><a href="#transform">transform</a></li>
<li><a href="#replace">replace</a></li>
<li><a href="#fill">fill</a></li>
<li><a href="#generate">generate</a></li>
<li><a href="#remove">remove</a></li>
</ul></li>
<li><a href="#ラムダ式">ラムダ式</a><ul>
<li><a href="#基本">基本</a></li>
<li><a href="#キャプチャー">キャプチャー</a><ul>
<li><a href="#コピーキャプチャー">コピーキャプチャー</a></li>
<li><a href="#リファレンスキャプチャー">リファレンスキャプチャー</a></li>
</ul></li>
</ul></li>
<li><a href="#クラスの基本">クラスの基本</a><ul>
<li><a href="#変数をまとめる">変数をまとめる</a></li>
</ul></li>
<li><a href="#まとめた変数に関数を提供する">まとめた変数に関数を提供する</a></li>
<li><a href="#より自然に振る舞うクラス">より自然に振る舞うクラス</a><ul>
<li><a href="#より自然な初期化">より自然な初期化</a></li>
</ul></li>
<li><a href="#自然な演算子">自然な演算子</a><ul>
<li><a href="#演算子のオーバーロード">演算子のオーバーロード</a><ul>
<li><a href="#二項演算子">二項演算子</a></li>
<li><a href="#単項演算子">単項演算子</a></li>
<li><a href="#インクリメントデクリメント">インクリメント/デクリメント</a></li>
<li><a href="#メンバー関数での演算子のオーバーロード">メンバー関数での演算子のオーバーロード</a></li>
</ul></li>
</ul></li>
<li><a href="#stdarray">std::array</a></li>
<li><a href="#プログラマーの三大美徳">プログラマーの三大美徳</a></li>
<li><a href="#配列">配列</a><ul>
<li><a href="#ナイーブなarray実装">ナイーブなarray実装</a></li>
<li><a href="#配列-1">配列</a></li>
</ul></li>
<li><a href="#テンプレート">テンプレート</a><ul>
<li><a href="#問題点">問題点</a></li>
<li><a href="#関数の引数">関数の引数</a></li>
<li><a href="#関数のテンプレート引数">関数のテンプレート引数</a></li>
<li><a href="#テンプレート-1">テンプレート</a></li>
<li><a href="#クラステンプレート">クラステンプレート</a></li>
</ul></li>
<li><a href="#arrayをさらに実装">arrayをさらに実装</a><ul>
<li><a href="#ネストされた型名">ネストされた型名</a></li>
<li><a href="#要素数の取得-size">要素数の取得: size()</a></li>
<li><a href="#メンバー関数のconst修飾">メンバー関数のconst修飾</a></li>
<li><a href="#先頭と末尾の要素frontback">先頭と末尾の要素：front/back</a></li>
<li><a href="#全要素に値を代入-fill">全要素に値を代入: fill</a></li>
</ul></li>
<li><a href="#arrayのイテレーター">arrayのイテレーター</a><ul>
<li><a href="#イテレーターの中身">イテレーターの中身</a></li>
<li><a href="#残りのイテレーターの実装">残りのイテレーターの実装</a></li>
<li><a href="#constなイテレーター-const_iterator">constなイテレーター: const_iterator</a></li>
</ul></li>
<li><a href="#傲慢なエラー処理-例外">傲慢なエラー処理: 例外</a><ul>
<li><a href="#例外を投げる">例外を投げる</a></li>
<li><a href="#例外を捕まえる">例外を捕まえる</a></li>
<li><a href="#例外による巻き戻し">例外による巻き戻し</a></li>
</ul></li>
<li><a href="#ポインター">ポインター</a><ul>
<li><a href="#意味上のポインター">意味上のポインター</a><ul>
<li><a href="#リファレンスと同じ機能">リファレンスと同じ機能</a></li>
<li><a href="#リファレンスと違う機能">リファレンスと違う機能</a></li>
<li><a href="#代入">代入</a></li>
<li><a href="#何も参照しない状態">何も参照しない状態</a></li>
<li><a href="#明示的に何も参照しないポインター-nullptr">明示的に何も参照しないポインター: nullptr</a></li>
<li><a href="#無効な参照先の作り方">無効な参照先の作り方</a></li>
</ul></li>
<li><a href="#文法上のポインター">文法上のポインター</a><ul>
<li><a href="#ポインターとconstの関係">ポインターとconstの関係</a></li>
<li><a href="#ポインターのポインター">ポインターのポインター</a></li>
<li><a href="#関数へのポインター">関数へのポインター</a></li>
<li><a href="#配列へのポインター">配列へのポインター</a></li>
<li><a href="#ポインター型の作り方">ポインター型の作り方</a></li>
<li><a href="#クラスへのポインター">クラスへのポインター</a></li>
<li><a href="#thisポインター">thisポインター</a></li>
<li><a href="#メンバーへのポインター">メンバーへのポインター</a></li>
</ul></li>
<li><a href="#ポインターの内部実装">ポインターの内部実装</a><ul>
<li><a href="#キロバイトとキビバイト">キロバイトとキビバイト</a></li>
<li><a href="#メモリとアドレス">メモリとアドレス</a></li>
<li><a href="#ポインターのサイズ">ポインターのサイズ</a></li>
<li><a href="#ポインターの値">ポインターの値</a></li>
<li><a href="#stdbit_castの実装"><code>std::bit_cast</code>の実装</a></li>
<li><a href="#stdmemcpyの実装"><code>std::memcpy</code>の実装</a><ul>
<li><a href="#void型">void型</a></li>
<li><a href="#void-型">void *型</a></li>
<li><a href="#stdbyte型">std::byte型</a></li>
<li><a href="#配列のメモリ上での表現">配列のメモリ上での表現</a></li>
<li><a href="#ポインターと整数の演算">ポインターと整数の演算</a></li>
<li><a href="#いよいよmemcpyの実装">いよいよmemcpyの実装</a></li>
<li><a href="#memcpyの別の実装">memcpyの別の実装</a></li>
</ul></li>
<li><a href="#データメンバーへのポインターの内部実装">データメンバーへのポインターの内部実装</a></li>
</ul></li>
</ul></li>
<li><a href="#イテレーター詳細">イテレーター詳細</a><ul>
<li><a href="#イテレーターとポインターの関係">イテレーターとポインターの関係</a></li>
<li><a href="#イテレーターカテゴリー">イテレーターカテゴリー</a><ul>
<li><a href="#ランダムアクセスイテレーター">ランダムアクセスイテレーター</a></li>
<li><a href="#双方向イテレーター">双方向イテレーター</a></li>
<li><a href="#前方イテレーター">前方イテレーター</a></li>
<li><a href="#入力イテレーター">入力イテレーター</a></li>
<li><a href="#出力イテレーター">出力イテレーター</a></li>
</ul></li>
<li><a href="#iterator_traits">iterator_traits</a></li>
<li><a href="#イテレーターカテゴリーの実例">イテレーターカテゴリーの実例</a><ul>
<li><a href="#出力イテレーター-1">出力イテレーター</a></li>
<li><a href="#入力イテレーター-1">入力イテレーター</a></li>
<li><a href="#前方イテレーター-1">前方イテレーター</a></li>
<li><a href="#双方向イテレーター-1">双方向イテレーター</a></li>
<li><a href="#ランダムアクセスイテレーター-1">ランダムアクセスイテレーター</a></li>
</ul></li>
<li><a href="#イテレーター操作">イテレーター操作</a><ul>
<li><a href="#advance-i-n-n移動する"><code>advance( i, n )</code>: n移動する</a></li>
<li><a href="#distance-first-last-firstからlastまでの距離"><code>distance( first, last )</code>: firstからlastまでの距離</a></li>
<li><a href="#nextprev-移動したイテレーターを返す">next/prev : 移動したイテレーターを返す</a></li>
</ul></li>
<li><a href="#リバースイテレーター">リバースイテレーター</a></li>
</ul></li>
<li><a href="#動的メモリ確保">動的メモリ確保</a><ul>
<li><a href="#概要">概要</a></li>
<li><a href="#mallocfree">malloc/free</a></li>
<li><a href="#operator-newoperator-delete">operator new/operator delete</a></li>
<li><a href="#生のバイト列を基本的な型の値として使う方法">生のバイト列を基本的な型の値として使う方法。</a></li>
<li><a href="#メモリ確保の失敗">メモリ確保の失敗</a></li>
<li><a href="#クラス型の値の構築">クラス型の値の構築</a></li>
<li><a href="#newdelete">new/delete</a></li>
<li><a href="#配列版newdelete">配列版new/delete</a></li>
<li><a href="#スマートポインター">スマートポインター</a></li>
</ul></li>
<li><a href="#vectorの実装-基礎">vectorの実装 : 基礎</a><ul>
<li><a href="#stdallocatortの概要"><code>std::allocator&lt;T&gt;</code>の概要</a></li>
<li><a href="#stdallocatortの使い方"><code>std::allocator&lt;T&gt;</code>の使い方</a></li>
<li><a href="#stdallocator_traitsalloc"><code>std::allocator_traits&lt;Alloc&gt;</code></a></li>
<li><a href="#簡易vectorの概要">簡易vectorの概要</a></li>
<li><a href="#classとアクセス指定">classとアクセス指定</a></li>
<li><a href="#ネストされた型名-1">ネストされた型名</a></li>
<li><a href="#簡易vectorのデータメンバー">簡易vectorのデータメンバー</a></li>
<li><a href="#簡単なメンバー関数の実装">簡単なメンバー関数の実装</a><ul>
<li><a href="#イテレーター">イテレーター</a></li>
<li><a href="#容量確認">容量確認</a></li>
<li><a href="#要素アクセス">要素アクセス</a><ul>
<li><a href="#operator">operator []</a></li>
<li><a href="#at">at</a></li>
<li><a href="#frontback">front/back</a></li>
<li><a href="#data">data</a></li>
</ul></li>
</ul></li>
</ul></li>
<li><a href="#vectorの実装-メモリ確保">vectorの実装 : メモリ確保</a><ul>
<li><a href="#メモリ確保の起こるタイミング">メモリ確保の起こるタイミング</a></li>
<li><a href="#デフォルトコンストラクター">デフォルトコンストラクター</a></li>
<li><a href="#アロケーターを取るコンストラクター">アロケーターを取るコンストラクター</a></li>
<li><a href="#要素数と初期値を取るコンストラクターの実装">要素数と初期値を取るコンストラクターの実装</a></li>
<li><a href="#ヘルパー関数">ヘルパー関数</a><ul>
<li><a href="#ネストされた型名traits">ネストされた型名traits</a></li>
<li><a href="#allocatedeallocate">allocate/deallocate</a></li>
<li><a href="#constructdestroy">construct/destroy</a></li>
<li><a href="#destroy_alldestroy_until"><code>destroy_all/destroy_until</code></a></li>
</ul></li>
<li><a href="#デストラクター">デストラクター</a></li>
<li><a href="#reserveの実装">reserveの実装</a></li>
<li><a href="#resize">resize</a></li>
<li><a href="#push_back">push_back</a><ul>
<li><a href="#shrink_to_fit"><code>shrink_to_fit</code></a></li>
</ul></li>
</ul></li>
<li><a href="#cプリプロセッサー">Cプリプロセッサー</a><ul>
<li><a href="#includeディレクティブ">#includeディレクティブ</a></li>
<li><a href="#define">#define</a><ul>
<li><a href="#オブジェクト風マクロ">オブジェクト風マクロ</a></li>
<li><a href="#関数風マクロ">関数風マクロ</a></li>
<li><a href="#va_args__可変長引数マクロ"><code>__VA_ARGS__</code>(可変長引数マクロ)</a></li>
<li><a href="#va_opt__"><code>__VA_OPT__</code></a></li>
<li><a href="#演算子">#演算子</a></li>
<li><a href="#演算子-1">##演算子</a></li>
<li><a href="#複数行の置換リスト">複数行の置換リスト</a></li>
<li><a href="#undefディレクティブ">#undefディレクティブ</a></li>
</ul></li>
<li><a href="#条件付きソースファイル選択">条件付きソースファイル選択</a><ul>
<li><a href="#プリプロセッサーの定数式">プリプロセッサーの定数式</a></li>
<li><a href="#ifディレクティブ">#ifディレクティブ</a></li>
<li><a href="#elifディレクティブ">#elifディレクティブ</a></li>
<li><a href="#elseディレクティブ">#elseディレクティブ</a></li>
<li><a href="#ifdef-ifndefディレクティブ">#ifdef, #ifndefディレクティブ</a></li>
</ul></li>
<li><a href="#lineディレクティブ">#lineディレクティブ</a></li>
<li><a href="#errorディレクティブ">#errorディレクティブ</a></li>
<li><a href="#pragma">#pragma</a></li>
<li><a href="#nullディレクティブ">Nullディレクティブ</a></li>
<li><a href="#定義済みマクロ名">定義済みマクロ名</a></li>
</ul></li>
<li><a href="#分割コンパイル">分割コンパイル</a><ul>
<li><a href="#ソースファイルとコンパイル">ソースファイルとコンパイル</a></li>
<li><a href="#単一のソースファイルのコンパイル">単一のソースファイルのコンパイル</a></li>
<li><a href="#ヘッダーファイルはコピペ">ヘッダーファイルはコピペ</a></li>
<li><a href="#複数のソースファイルのコンパイル">複数のソースファイルのコンパイル</a></li>
<li><a href="#オブジェクトファイル">オブジェクトファイル</a></li>
<li><a href="#複数のソースファイルの書き方">複数のソースファイルの書き方</a><ul>
<li><a href="#関数">関数</a></li>
<li><a href="#変数-1">変数</a></li>
<li><a href="#インライン関数インライン変数">インライン関数/インライン変数</a></li>
<li><a href="#クラス">クラス</a><ul>
<li><a href="#staticメンバー">staticメンバー</a></li>
</ul></li>
<li><a href="#テンプレート-2">テンプレート</a></li>
</ul></li>
</ul></li>
<li><a href="#デバッガー">デバッガー</a><ul>
<li><a href="#gdbのチュートリアル">GDBのチュートリアル</a></li>
<li><a href="#プログラムの実行">プログラムの実行</a></li>
<li><a href="#プログラムの停止方法">プログラムの停止方法</a><ul>
<li><a href="#ブレイクポイント">ブレイクポイント</a><ul>
<li><a href="#行番号へのブレイクポイント">行番号へのブレイクポイント</a></li>
<li><a href="#ブレイクポイントの確認">ブレイクポイントの確認</a></li>
<li><a href="#ブレイクポイントの削除">ブレイクポイントの削除</a></li>
<li><a href="#ブレイクポイントの有効無効">ブレイクポイントの有効/無効</a></li>
<li><a href="#関数名へのブレイクポイント">関数名へのブレイクポイント</a></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
</nav>
<h1 id="序">序</h1>
<p>本書はプログラミング経験者向けのC++入門書である。</p>
<p>本書の対象読者は、すでに何らかの実用的なプログラミング言語を習得していることを想定し、プログラミングの初歩的な概念はすべて理解しているものとして説明しない。そのため、本書には、「変数は箱のようなものである」といったような説明は出てこない。ただし、主要な他の言語とC++として特別に注意が必要な差は解説している。</p>
<h1 id="cの概要">C++の概要</h1>
<p>C++とは何か。C++の原作者にして最初の実装者であるBjarne Stroustrupは、以下のように簡潔にまとめている。</p>
<blockquote>
<p>C++は、Simulaのプログラム構造化のための機構と、Cのシステムプログラミング用の効率性と柔軟性を提供するために設計された。C++は半年ほどで現場で使えることを見込んでいた。結果として成功した。</p>
<p>Bjarne Stroustrup, A History of C++: 1979-1991, HOPL2</p>
</blockquote>
<p>プログラミング言語史に詳しくない読者は、Simulaというプログラミング言語について知らないことだろう。Simulaというのは、初めてオブジェクト指向プログラミングを取り入れたプログラミング言語だ。当時と言えばまだ高級なプログラミング言語はほとんどなく、if else, whileなどのIBMの提唱した構造化プログラミングを可能にする文法を提供しているプログラミング言語すら、多くは研究段階であった。いわんやオブジェクト指向など、当時はまだアカデミックにおいて可能性の一つとして研究されている程度の地に足のついていない夢の機能であった。そのような粗野な時代において、Simulaは先進的なオブジェクト指向プログラミングを実現していた。</p>
<p>問題は、Simulaの設計と実装では実行速度が遅く、大規模なプログラムを開発するには適さなかった。</p>
<p>Cの効率性と柔軟性というのは、要するに実行速度が速いとかメモリ消費量が少ないということだ。なぜCは他の言語に比べて効率と柔軟に優れているのか。これには2つの理由がある。</p>
<p>ひとつ、Cのコードは直接ハードウェアがサポートする命令にまでマッピング可能であるということ。現実のハードウェアにはストレージがあり、メモリがあり、キャッシュがあり、レジスターがあり、命令は投機的に並列実行される泥臭い計算機能を提供している。</p>
<p>ひとつ、使わない機能のコストを支払う必要がないというゼロオーバーヘッドの原則。例えばあらゆるメモリ利用がGCによって管理されている言語では、たとえメモリをすべて明示的に管理していたとしても、GCのコストを支払わなければならない。実行時にメモリレイアウトを判定して実行時に分岐処理ができる言語では、たとえコンパイル時にメモリレイアウトが決定されていたとしても、実行時にメモリレイアウトを判定して条件分岐するコストを支払わなければならない。</p>
<p>C++は、「アセンブリ言語をおいて、C++より下に言語を置かない」と宣言するほど、ハードウェア機能への直接マッピングとゼロオーバーヘッドの原則を重視している。</p>
<p>C++の他の特徴としては、委員会方式による国際標準規格を定めていることがある。特定の一個人や一法人が所有する言語は、個人や法人の意思で簡単に仕様が変わってしまう。短期的な利益を追求するために長期的に問題となる変更をしたり、単一の実装が仕様だと言わんばかりの振る舞いをする。特定の個人や法人に所有されていないこと、実装が従うべき標準規格があること、独立した実装が複数あること、言語に利害関係を持つ関係者が議論して投票で変更を可決すること、これがC++が長期に渡って使われてきた理由でもある。</p>
<p>委員会方式の規格制定では、下位互換性の破壊は忌避される。なぜならば、既存の動いているコードを壊すということは、それまで存在していた資産の価値を毀損することであり、利害関係を持つ委員が反対するからだ。</p>
<p>下位互換性を壊した結果何が起こるかと言うと、単に言語が新旧2つに分断される。Python 2とPython 3がその最たる例だ。</p>
<p>C++には今日の最新で高級な言語からみれば古風な制約が数多く残っているが、いずれも理由がある。下位互換性を壊すことができないという理由。効率的な実装方法が存在しないという理由。仮に効率的な実装が存在するにしても、様々な環境で実装可能でなければ規格化はできないという理由。</p>
<p>C++には良し悪しがある。Bjarne StroustrupはC++への批判にこう答えている。</p>
<blockquote>
<p>言語には2種類ある。文句を言われる言語と、誰も使わない言語。</p>
</blockquote>
<p>C++は文句を言われる方の言語だ。</p>
<h1 id="cの実行">C++の実行</h1>
<p>プログラミング言語を学ぶには、まず書いたソースコードをプログラムとして実行できるようになることが重要だ。自分が正しく理解しているかどうかを確認するために書いたコードが期待通りに動くことを確かめてこそ、正しい理解が確認できる。</p>
<h2 id="cの実行の仕組み">C++の実行の仕組み</h2>
<p>C++は慣習的に、ソースファイルをコンパイルしてオブジェクトファイルを生成し、オブジェクトファイルをリンクして実行可能ファイルを生成し、実行可能ファイルを直接実行することで実行する言語だ。</p>
<p>他の言語では、ソースファイルをそのままパースし、解釈して実行するインタープリター形式の言語が多い。もっとも、今となってはソースファイルから中間言語に変換してVMで実行するとか、JITコンパイルしてネイティブコードを生成して実行するといった実装もあるため、昔のように単純にインタープリター型の言語ということはできなくなっている事情はある。ただし、最終的にJITコンパイルされてネイティブコードが実行される言語でも、コンパイルやコード生成はプログラマーが意識しない形で行われるため、プログラマーはコンパイラーを直接使う必要のない言語も多い。</p>
<p>C++はプログラマーが直接コンパイラーを使い、ソースファイルをプログラムに変換する言語だ。</p>
<h2 id="簡単な一つのソースファイルからなるプログラムの実行">簡単な一つのソースファイルからなるプログラムの実行</h2>
<p>ここでは、典型的なC++のソースファイルをどのようにコンパイルし実行するか、一連の流れを学ぶ。</p>
<h3 id="サンプルコード">サンプルコード</h3>
<p>以下のC++のソースファイルは標準出力にhelloと出力するものだ。</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1-4" data-line-number="4">{</a>
<a class="sourceLine" id="cb1-5" data-line-number="5">    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;hello&quot;</span> ;</a>
<a class="sourceLine" id="cb1-6" data-line-number="6">}</a></code></pre></div>
<p>コードの詳細な意味はさておくとして、このサンプルコードを使ってC++の実行までの流れを見ていこう。</p>
<p>まずは端末から作業用の適当な名前のディレクトリーを作る。ここでは<code>cpp</code>としておこう。ディレクトリーの作成は<code>mkdir</code>コマンドで行える。</p>
<pre><code>$ mkdir cpp
$ cd cpp</code></pre>
<p>好きなテキストエディターを使って上のサンプルコードをテキストファイルとして記述する。ファイル名は<code>hello.cpp</code>としておこう。</p>
<pre><code>$ vim hello.cpp</code></pre>
<p>C++のソースファイルの名前は何でもよいが、慣習で使われている拡張子がいくつかある。本書では<code>.cpp</code>を使う。</p>
<p>無事にソースファイルが作成できたかどうか確認してみよう。現在のカレントディレクトリー下のファイルの一覧を表示するには<code>ls</code>、ファイルの内容を表示するには<code>cat</code>を使う。</p>
<pre><code>$ ls
hello.cpp
$ cat hello.cpp
#include &lt;iostream&gt;

int main()
{
    std::cout &lt;&lt; &quot;hello&quot; ;
}</code></pre>
<h3 id="コンパイル">コンパイル</h3>
<p>さて、ソースファイルが用意できたならば、いよいよコンパイルだ。</p>
<p>C++のソースファイルから、実行可能ファイルを生成するソフトウェアをC++コンパイラーという。C++コンパイラーとしては、GCC(GNU Compiler Collection)とClang(クラン)がある。使い方はどちらもほぼ同じだ。</p>
<p>GCCを使って先程の<code>hello.cpp</code>をコンパイルするには以下のようにする。</p>
<pre><code>$ g++ -o hello hello.cpp</code></pre>
<p>GCCという名前のC++コンパイラーなのに<code>g++</code>なのは、<code>gcc</code>はC言語コンパイラーの名前としてすでに使われているからだ。この慣習はClangも引き継いでいて、ClangのC++コンパイラーは<code>clang++</code>だ。</p>
<p>サンプルコードを間違いなくタイプしていれば、カレントディレクトリに<code>hello</code>とぃう実行可能ファイルが作成されるはずだ。確認してみよう。</p>
<pre><code>$ ls
hello hello.cpp</code></pre>
<h3 id="実行">実行</h3>
<p>さて、いよいよ実行だ。通常のOSではカレントディレクトリがPATHに含まれていないため、実行するにはカレントディレクトリからパスを指定する必要がある。</p>
<pre><code>$ ./hello
hello</code></pre>
<p>上出来だ。初めてのC++プログラムが実行できた。さっそくC++を学んでいきたいところだが、その前にC++プログラミングに必要なツールの使い方を学ぶ必要がある。</p>
<h2 id="gcc-cコンパイラー">GCC: C++コンパイラー</h2>
<p>GCCはC++のソースファイルからプログラムを生成するC++コンパイラーだ。</p>
<p>GCCの基本的な使い方は以下の通り。</p>
<pre><code>g++ その他のオプション -o 出力するファイル名 ソースファイル名</code></pre>
<p>ソースファイル名は複数指定することができる。</p>
<pre><code>g++ -o abc a.cpp b.cpp c.cpp</code></pre>
<p>これについては分割コンパイルの章で詳しく解説する。</p>
<p>コンパイラーはメッセージを出力することがある。コンパイルメッセージには、エラーメッセージと警告メッセージとがある。</p>
<p>エラーメッセージというのは、ソースコードに文法上、意味上の誤りがあるため、コンパイルできない場合に生成される。エラーメッセージはエラーの箇所も教えてくれる。ただし、文法エラーは往々にして適切な誤りの箇所を指摘できないこともある。これは、C++の文法としては正しくないテキストファイルから、妥当なC++であればどういう間違いなのかを推測する必要があるためだ。</p>
<p>警告メッセージというのは、ソースコードにコンパイルを妨げる文法上、意味上の誤りは存在しないが、誤りの可能性が疑われる場合に出力される。</p>
<h3 id="コンパイラーオプション">コンパイラーオプション</h3>
<p>GCCのコンパイラーオプションをいくつか学んでいこう。</p>
<p><code>-std=</code>はC++の規格を選択するオプションだ。C++17に準拠したいのであれば<code>-std=c++17</code>を指定する。読者が本書を読む頃には、C++20や、あるいはもっと未来の規格が発行されているかもしれない。常に最新のC++規格を選択するオプションを指定するべきだ。</p>
<p><code>-Wall</code>はコンパイラーの便利な警告メッセージのほとんどすべてを有効にするオプションだ。コンパイラーによる警告メッセージはプログラムの不具合を未然に発見できるので、このオプションは指定すべきだ。</p>
<p><code>--pedantic-errors</code>はC++の規格を厳格に守るオプションだ。規格に違反しているコードがコンパイルエラー扱いになる。</p>
<p>これをまとめると、GCCは以下のように使う。</p>
<pre><code>g++ -std=c++17 -Wall --pedantic-errors -o 出力ファイル名 入力ファイル名</code></pre>
<p>ところで、GCCのオプションはとても多い。すべてを知りたい読者は、gccのマニュアルを読むとよい。</p>
<pre><code>$ man gcc</code></pre>
<h3 id="ヘッダーファイルの省略">ヘッダーファイルの省略</h3>
<p>先程のソースコードをもう一度見てみよう。冒頭に以下のような行がある。</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></a></code></pre></div>
<p>これは<code>#includeディレクティブ</code>(#include directive)といい、プリプロセッサー(preprocessor)の一部だ。プリプロセッサーについて詳しくは煩雑になるので巻末資料を参照してもらうとして、このコードは<code>iostream</code>ライブラリを使うために必要で、その意味としてはヘッダーファイル<code>iostream</code>の取り込みだ。</p>
<p>C++の標準ライブラリを使うには、ライブラリごとに対応した<code>#includeディレクティブ</code>を書かなければならない。それはあまりにも煩雑なので、本書では標準ライブラリのヘッダーファイルをすべて<code>#include</code>した<code>ヘッダーファイル</code>(header file)を作成し、それを<code>#include</code>することで、<code>#include</code>を書かなくてすむようにする。</p>
<p>そのためにはまず標準ライブラリのヘッダーファイルのほとんどすべてを<code>#include</code>したヘッダーファイル、<code>all.h</code>を作成する。</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="pp">#include </span><span class="im">&lt;cstddef&gt;</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2"><span class="pp">#include </span><span class="im">&lt;limits&gt;</span></a>
<a class="sourceLine" id="cb13-3" data-line-number="3"><span class="pp">#include </span><span class="im">&lt;climits&gt;</span></a>
<a class="sourceLine" id="cb13-4" data-line-number="4"><span class="pp">#include </span><span class="im">&lt;cfloat&gt;</span></a>
<a class="sourceLine" id="cb13-5" data-line-number="5"><span class="pp">#include </span><span class="im">&lt;cstdint&gt;</span></a>
<a class="sourceLine" id="cb13-6" data-line-number="6"><span class="pp">#include </span><span class="im">&lt;cstdlib&gt;</span></a>
<a class="sourceLine" id="cb13-7" data-line-number="7"><span class="pp">#include </span><span class="im">&lt;new&gt;</span></a>
<a class="sourceLine" id="cb13-8" data-line-number="8"><span class="pp">#include </span><span class="im">&lt;typeinfo&gt;</span></a>
<a class="sourceLine" id="cb13-9" data-line-number="9"><span class="pp">#include </span><span class="im">&lt;exception&gt;</span></a>
<a class="sourceLine" id="cb13-10" data-line-number="10"><span class="pp">#include </span><span class="im">&lt;initializer_list&gt;</span></a>
<a class="sourceLine" id="cb13-11" data-line-number="11"><span class="pp">#include </span><span class="im">&lt;cstdalign&gt;</span></a>
<a class="sourceLine" id="cb13-12" data-line-number="12"><span class="pp">#include </span><span class="im">&lt;stdexcept&gt;</span></a>
<a class="sourceLine" id="cb13-13" data-line-number="13"><span class="pp">#include </span><span class="im">&lt;cassert&gt;</span></a>
<a class="sourceLine" id="cb13-14" data-line-number="14"><span class="pp">#include </span><span class="im">&lt;cerrno&gt;</span></a>
<a class="sourceLine" id="cb13-15" data-line-number="15"><span class="pp">#include </span><span class="im">&lt;system_error&gt;</span></a>
<a class="sourceLine" id="cb13-16" data-line-number="16"><span class="pp">#include </span><span class="im">&lt;string&gt;</span></a>
<a class="sourceLine" id="cb13-17" data-line-number="17"></a>
<a class="sourceLine" id="cb13-18" data-line-number="18"><span class="pp">#if __has_include(&lt;string_view&gt;)</span></a>
<a class="sourceLine" id="cb13-19" data-line-number="19"><span class="pp">#   include </span><span class="im">&lt;string_view&gt;</span></a>
<a class="sourceLine" id="cb13-20" data-line-number="20"><span class="pp">#endif</span></a>
<a class="sourceLine" id="cb13-21" data-line-number="21"></a>
<a class="sourceLine" id="cb13-22" data-line-number="22"><span class="pp">#include </span><span class="im">&lt;array&gt;</span></a>
<a class="sourceLine" id="cb13-23" data-line-number="23"><span class="pp">#include </span><span class="im">&lt;deque&gt;</span></a>
<a class="sourceLine" id="cb13-24" data-line-number="24"><span class="pp">#include </span><span class="im">&lt;forward_list&gt;</span></a>
<a class="sourceLine" id="cb13-25" data-line-number="25"><span class="pp">#include </span><span class="im">&lt;list&gt;</span></a>
<a class="sourceLine" id="cb13-26" data-line-number="26"><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></a>
<a class="sourceLine" id="cb13-27" data-line-number="27"><span class="pp">#include </span><span class="im">&lt;map&gt;</span></a>
<a class="sourceLine" id="cb13-28" data-line-number="28"><span class="pp">#include </span><span class="im">&lt;set&gt;</span></a>
<a class="sourceLine" id="cb13-29" data-line-number="29"><span class="pp">#include </span><span class="im">&lt;unordered_map&gt;</span></a>
<a class="sourceLine" id="cb13-30" data-line-number="30"><span class="pp">#include </span><span class="im">&lt;unordered_set&gt;</span></a>
<a class="sourceLine" id="cb13-31" data-line-number="31"><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></a>
<a class="sourceLine" id="cb13-32" data-line-number="32"><span class="pp">#include </span><span class="im">&lt;stack&gt;</span></a>
<a class="sourceLine" id="cb13-33" data-line-number="33"><span class="pp">#include </span><span class="im">&lt;iterator&gt;</span></a>
<a class="sourceLine" id="cb13-34" data-line-number="34"><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></a>
<a class="sourceLine" id="cb13-35" data-line-number="35"><span class="pp">#include </span><span class="im">&lt;cfenv&gt;</span></a>
<a class="sourceLine" id="cb13-36" data-line-number="36"><span class="pp">#include </span><span class="im">&lt;random&gt;</span></a>
<a class="sourceLine" id="cb13-37" data-line-number="37"><span class="pp">#include </span><span class="im">&lt;numeric&gt;</span></a>
<a class="sourceLine" id="cb13-38" data-line-number="38"><span class="pp">#include </span><span class="im">&lt;cmath&gt;</span></a>
<a class="sourceLine" id="cb13-39" data-line-number="39"><span class="pp">#include </span><span class="im">&lt;iosfwd&gt;</span></a>
<a class="sourceLine" id="cb13-40" data-line-number="40"><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></a>
<a class="sourceLine" id="cb13-41" data-line-number="41"><span class="pp">#include </span><span class="im">&lt;ios&gt;</span></a>
<a class="sourceLine" id="cb13-42" data-line-number="42"><span class="pp">#include </span><span class="im">&lt;streambuf&gt;</span></a>
<a class="sourceLine" id="cb13-43" data-line-number="43"><span class="pp">#include </span><span class="im">&lt;istream&gt;</span></a>
<a class="sourceLine" id="cb13-44" data-line-number="44"><span class="pp">#include </span><span class="im">&lt;ostream&gt;</span></a>
<a class="sourceLine" id="cb13-45" data-line-number="45"><span class="pp">#include </span><span class="im">&lt;iomanip&gt;</span></a>
<a class="sourceLine" id="cb13-46" data-line-number="46"><span class="pp">#include </span><span class="im">&lt;sstream&gt;</span></a>
<a class="sourceLine" id="cb13-47" data-line-number="47"><span class="pp">#include </span><span class="im">&lt;fstream&gt;</span></a>
<a class="sourceLine" id="cb13-48" data-line-number="48"></a>
<a class="sourceLine" id="cb13-49" data-line-number="49"><span class="pp">#if __has_include(&lt;filesystem&gt;)</span></a>
<a class="sourceLine" id="cb13-50" data-line-number="50"><span class="pp">#   include </span><span class="im">&lt;filesystem&gt;</span></a>
<a class="sourceLine" id="cb13-51" data-line-number="51"><span class="pp">#endif</span></a>
<a class="sourceLine" id="cb13-52" data-line-number="52"></a>
<a class="sourceLine" id="cb13-53" data-line-number="53"><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></a>
<a class="sourceLine" id="cb13-54" data-line-number="54"><span class="pp">#include </span><span class="im">&lt;cinttypes&gt;</span></a>
<a class="sourceLine" id="cb13-55" data-line-number="55"></a>
<a class="sourceLine" id="cb13-56" data-line-number="56"></a>
<a class="sourceLine" id="cb13-57" data-line-number="57"><span class="pp">#include </span><span class="im">&lt;regex&gt;</span></a>
<a class="sourceLine" id="cb13-58" data-line-number="58"><span class="pp">#include </span><span class="im">&lt;atomic&gt;</span></a>
<a class="sourceLine" id="cb13-59" data-line-number="59"><span class="pp">#include </span><span class="im">&lt;thread&gt;</span></a>
<a class="sourceLine" id="cb13-60" data-line-number="60"><span class="pp">#include </span><span class="im">&lt;mutex&gt;</span></a>
<a class="sourceLine" id="cb13-61" data-line-number="61"><span class="pp">#include </span><span class="im">&lt;shared_mutex&gt;</span></a>
<a class="sourceLine" id="cb13-62" data-line-number="62"><span class="pp">#include </span><span class="im">&lt;condition_variable&gt;</span></a>
<a class="sourceLine" id="cb13-63" data-line-number="63"><span class="pp">#include </span><span class="im">&lt;future&gt;</span></a>
<a class="sourceLine" id="cb13-64" data-line-number="64"></a>
<a class="sourceLine" id="cb13-65" data-line-number="65"><span class="kw">using</span> <span class="kw">namespace</span> <span class="bu">std::</span>literals ;</a></code></pre></div>
<p>このようなヘッダーファイル<code>all.h</code>を作成した後に、ソースファイルで以下のように書けば、他のヘッダーファイルを<code>#include</code>する必要がなくなる。</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="pp">#include </span><span class="im">&quot;all.h&quot;</span></a>
<a class="sourceLine" id="cb14-2" data-line-number="2"></a>
<a class="sourceLine" id="cb14-3" data-line-number="3"><span class="co">// その他のコード</span></a></code></pre></div>
<p><code>//</code>から行末まではコメントで、好きなテキストを書くことができる。</p>
<p>しかし、この最初の一行の<code>#include</code>も面倒だ。そこでGCCのオプション<code>-include</code>を使い、<code>all.h</code>を常に<code>#include</code>した扱いにする。</p>
<pre><code>$ g++ -include all.h -o program main.cpp</code></pre>
<p>このようにすると、<code>main.cpp</code>が以下のコードでもコンパイルできるようになる。</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="co">// main.cpp</span></a>
<a class="sourceLine" id="cb16-2" data-line-number="2"><span class="co">// 面倒な#includeなどなし</span></a>
<a class="sourceLine" id="cb16-3" data-line-number="3"></a>
<a class="sourceLine" id="cb16-4" data-line-number="4"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb16-5" data-line-number="5">{</a>
<a class="sourceLine" id="cb16-6" data-line-number="6">    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;hello&quot;</span> ;</a>
<a class="sourceLine" id="cb16-7" data-line-number="7">}</a></code></pre></div>
<p>これでヘッダーファイルが省略できるようになった。</p>
<h3 id="コンパイル済みヘッダーprecompiled-header">コンパイル済みヘッダー(precompiled header)</h3>
<p>C++はソースファイルをコンパイルする必要がある言語だ。コンパイルには時間がかかる。コンパイルにどれだけ時間がかかっているかを計測するには、以下のようにするとよい。</p>
<pre><code>$ time g++ -std=c++17 -Wall --pedantic-errors -include all.h -o program main.cpp</code></pre>
<p>どうだろうか。読者の環境にもよるが、知覚できるぐらいの時間がかかっているのではないだろうか。プログラミングの習得にはコードを書いてから実行までの時間が短い方がよい。そこで本格的にC++を学ぶ前に、コンパイル時間を短縮する方法を学ぶ。</p>
<p>プログラムで変更しないファイルを事前にコンパイルしておくと、変更した部分だけコンパイルすれば良いので、コンパイル時間の短縮になる。GCCでは、ヘッダーファイルを事前にコンパイルする特別な機能がある。標準ライブラリのヘッダーファイルは変更しないので、事前にコンパイルしておけばコンパイル時間の短縮になる。</p>
<p>事前にコンパイルしたヘッダーファイルのことをコンパイル済みヘッダー(precompiled header)という。</p>
<p>すでに作成した<code>all.h</code>はコンパイル済みヘッダーとするのに適切なヘッダーファイルだ。</p>
<p>コンパイル済みヘッダーファイルを作成するには、ヘッダーファイル単体をGCCに与え、出力するファイルを<code>ヘッダーファイル名.gch</code>とする。ヘッダーファイル名が<code>all.h</code>の場合、<code>all.h.gch</code>となる。</p>
<p>GCCのオプションには他のソースファイルをコンパイルするときと同じオプションを与えるほか、ヘッダーファイルがC++で書かれていることを示すオプション<code>-x c++-header</code>を与える。</p>
<pre><code>g++ -std=c++17 -Wall --pedantic-errors -x c++-header -o all.h.gch all.h</code></pre>
<p>こうすると、コンパイル済みヘッダーファイル<code>all.h.gch</code>が生成できる。</p>
<p>GCCはヘッダーファイルを使うときに、同名の.gchファイルが存在する場合は、そちらをコンパイル済みヘッダーファイルとして使うことで、ヘッダーファイルの処理を省略する。</p>
<pre><code>g++ -std=c++17 -Wall --pedantic-errors -include all.h -o program main.cpp</code></pre>
<p>コンパイル済みヘッダーは一回のコンパイルにつき一つしか使うことができない。そのため、コンパイル済みヘッダーとするヘッダーファイルを定め、そのヘッダーファイル内に他のヘッダーをすべて記述する。本書ではコンパイル済みヘッダーファイルとする元のヘッダーファイルの名前を<code>all.h</code>とする。</p>
<p>さっそくコンパイル時間の短縮効果を確かめてみよう。</p>
<pre><code>$ ls
all.h main.cpp
$ g++ -std=c++17 -Wall --pedantic-errors -x c++-header -o all.h.gch all.h
$ ls
all.h all.h.gch main.cpp
$ time g++ -std=c++17 -Wall --pedantic-errors -include all.h -o program main.cpp</code></pre>
<h2 id="make-ビルドシステム">Make: ビルドシステム</h2>
<h3 id="コンパイルと実行のまとめ">コンパイルと実行のまとめ</h3>
<p>ここまで、我々はソースファイルをコンパイルして実行可能ファイルを生成し、プログラムを実行する方法について学んできた。これまでに学んできたことを一連のコマンドで振り返ってみよう。</p>
<pre><code>$ ls
all.h main.cpp
$ cat all.h
#include &lt;iostream&gt;
$ cat main.cpp
int main() { std::cout &lt;&lt; &quot;hello&quot;s ; }</code></pre>
<p>まず、カレントディレクトリには<code>all.h</code>と<code>main.cpp</code>がある。この2つのファイルは実行可能ファイルを生成するために必要なファイルだ。今回、その中身は最小限にしてある。本当の<code>all.h</code>は、実際には前回書いたように長い内容になる。</p>
<pre><code>$ g++ -std=c++17 -Wall --pedantic-errors -x c++-header -o all.h.gch all.h
$ ls
all.h all.h.gch main.cpp</code></pre>
<p>次に、ソースファイルのコンパイルを高速化するために、ヘッダーファイル<code>all.h</code>から、コンパイル済みヘッダーファイル<code>all.h.gch</code>を生成する。</p>
<pre><code>$ g++ -std=c++17 -Wall --pedantic-errors -include all.h -o program main.cpp
$ ls
all.h all.h.gch main.cpp program</code></pre>
<p>プリコンパイル済みヘッダーファイル<code>all.h.gch</code>とC++ソースファイル<code>main.cpp</code>から、実行可能ファイル<code>program</code>を生成する。</p>
<pre><code>$ ./program
hello</code></pre>
<p>実行可能ファイル<code>program</code>を実行する。</p>
<p>これで読者はC++のプログラミングを学び始めるに当たって必要なことは全て学んだ。さっそくC++を学んでいきたいところだが、その前にもう一つ、ビルドシステムを学ぶ必要がある。</p>
<h3 id="依存関係を解決するビルドシステム">依存関係を解決するビルドシステム</h3>
<p>以上のC++のソースファイルからプログラムを実行するまでの流れは、C++のプログラムとしてはとても単純なものだが、それでも依存関係が複雑だ。</p>
<p>プログラムの実行にあたって最終的に必要なのはファイル<code>program</code>だが、このファイルはGCCで生成しなければならない。ところでGCCでファイル<code>program</code>を生成するには、事前に<code>all.h</code>, <code>all.h.gch</code>, <code>main.cpp</code>が必要だ。<code>all.h.gch</code>は<code>all.h</code>からGCCで生成しなければならない。</p>
<p>一度コンパイルしたプログラムのソースファイルを書き換えて再びコンパイルする場合はどうすればいいだろう。<code>main.cpp</code>だけを書き換えた場合、<code>all.h</code>は何も変更されていないので、コンパイル済みヘッダーファイル<code>all.h.gch</code>の再生成は必要ない。<code>all.h</code>だけを書き換えた場合は、<code>all.h.gch</code>を生成するだけでなく、<code>program</code>も再生成しなければならない。</p>
<p>プログラムのコンパイルには、このような複雑な依存関係の解決が必要になる。依存関係の解決を人間の手で行うのは大変だ。例えば読者が他人によって書かれた何千ものソースファイルと、プログラムをコンパイルする手順書だけを渡されたとしよう。手順書に従ってコンパイルをしたとして、ソースファイルの一部だけを変更した場合、一体どの手順は省略できるのか、手順書から導き出すのは難しい。するとコンパイルを最初からやり直すべきだろうか。しかし、一つのソースファイルのコンパイルに1秒かかるとして、何千ものソースファイルがある場合、何千秒もかかってしまう。たった一つのソースファイルを変更しただけですべてをコンパイルし直すのは時間と計算資源の無駄だ。</p>
<p>この依存関係の問題は、ビルドシステムによって解決できる。本書ではGNU Makeというビルドシステムを学ぶ。読者がこれから学ぶビルドシステムによって、以下のような簡単なコマンドだけで、他人の書いた何千ものソースファイルからなるプログラムがコンパイル可能になる。</p>
<p>何千ものソースファイルから実行可能ファイルを生成したい。</p>
<pre><code>$ make</code></pre>
<p>これだけだ。<code>make</code>というコマンド一つでプログラムのコンパイルは自動的に行われる。</p>
<p>何千ものソースファイルのうち、一つのソースファイルだけを変更し、必要な部分だけを効率よく再コンパイルしたい。</p>
<pre><code>$ make</code></pre>
<p>これだけだ。<code>make</code>というコマンド一つでプログラムの再コンパイルは自動的に行われる。</p>
<p>ところで、生成される実行可能ファイルの名前はプログラムごとに様々だ。プログラムの開発中は、共通の方法でプログラムを実行したい。</p>
<pre><code>$ make run</code></pre>
<p>これでどんなプログラム名でも共通の方法で実行できる。</p>
<p>ソースファイルから生成されたプログラムなどのファイルをすべて削除したい。</p>
<pre><code>$ make clean</code></pre>
<p>これで生成されたファイルをすべて削除できる</p>
<p>テキストエディターにはVimを使っているがわざわざVimからターミナルに戻るのが面倒だ。</p>
<pre><code>:make</code></pre>
<p>VimはノーマルモードからMakeを呼び出すことができる。もちろん、<code>:make run</code>や<code>:make clean</code>もできる</p>
<h3 id="依存関係を記述するルール">依存関係を記述するルール</h3>
<p>依存関係はどのように表現したらいいのだろうか。GNU makeでは<code>Makefile</code>という名前のファイルの中に、<code>ターゲット</code>(targets)、<code>事前要件</code>(prerequisites)、<code>レシピ</code>(recipes)という3つの概念で依存関係を<code>ルール</code>(rules)として記述する。<code>ルール</code>は以下の文法だ。</p>
<pre><code>ターゲット : 事前要件
[TAB文字]レシピ</code></pre>
<p>レシピは必ず<code>TAB文字</code>を直前に書かなければならない。スペース文字ではだめだ。これは<code>make</code>の初心者を混乱させる落とし穴の一つとなっている。忘れずに<code>TAB文字</code>を打とう。</p>
<p>問題を簡単に理解するために、以下のような状況を考えよう。</p>
<pre><code>$ ls
source
$ cat source &gt; program</code></pre>
<p>この例では、ファイル<code>program</code>を生成するためにはファイル<code>source</code>が必要だ。ファイル<code>source</code>はすでに存在している。</p>
<p><code>ターゲット</code>は生成されるファイル名だ。この場合<code>program</code>となる。</p>
<pre><code>program : 事前要件
    レシピ</code></pre>
<p><code>事前要件</code>は<code>ターゲット</code>を生成するために必要なファイル名だ。この場合<code>source</code>となる。</p>
<pre><code>program : source
    レシピ</code></pre>
<p><code>レシピ</code>は<code>ターゲット</code>を生成するために必要な動作だ。この場合、<code>cat source &gt; program</code>となる</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode makefile"><code class="sourceCode makefile"><a class="sourceLine" id="cb34-1" data-line-number="1"><span class="dv">program :</span><span class="dt"> source</span></a>
<a class="sourceLine" id="cb34-2" data-line-number="2">    cat source &gt; program</a></code></pre></div>
<p>さっそくこのルールを、ファイル<code>Makefile</code>に書き込み、makeを呼び出してみよう。</p>
<pre><code>$ ls
Makefile source 
$ cat Makefile
program : source
    cat source &gt; program
$ make
cat source &gt; program
$ ls
Makefile program source</code></pre>
<p>これがMakeの仕組みだ。<code>ターゲット</code>の生成に必要な<code>事前要件</code>と、<code>ターゲット</code>を生成する<code>レシピ</code>を組み合わせた<code>ルール</code>で依存関係を記述する。makeを実行すると、実行した<code>レシピ</code>が表示される。</p>
<p>もうすこしMakeの<code>ルール</code>を追加してみよう。例えばファイル<code>source</code>は予め存在するのではなく、ファイル<code>source01</code>, <code>source02</code>, <code>source03</code>の中身をこの順番で連結して生成するとしよう。以下のように書ける。</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode makefile"><code class="sourceCode makefile"><a class="sourceLine" id="cb36-1" data-line-number="1"><span class="dv">program :</span><span class="dt"> source</span></a>
<a class="sourceLine" id="cb36-2" data-line-number="2">    cat source &gt; program</a>
<a class="sourceLine" id="cb36-3" data-line-number="3"></a>
<a class="sourceLine" id="cb36-4" data-line-number="4"><span class="dv">source :</span><span class="dt"> source01 source02 source03</span></a>
<a class="sourceLine" id="cb36-5" data-line-number="5">    cat source01 source02 source03 &gt; source</a></code></pre></div>
<p>GNU Makeはカレントディレクトリにあるファイル<code>Makefile</code>の一番上に書かれたルールを実行しようとする。<code>program</code>を生成するには<code>source</code>が必要だが、<code>source</code>の生成には別のルールの実行が必要だ。Makefileはこの依存関係を自動で解決してくれる。</p>
<pre><code>$ touch source01 source02 source03
$ ls
Makefile source01 source03 source03
$ make
cat source01 source02 source03 &gt; source
cat source &gt; program
$ ls
Makefile program source source01 source02 source03</code></pre>
<p>すでに<code>make</code>を実行した後で、もう一度<code>make</code>を実行するとどうなるだろうか。</p>
<pre><code>$ make
make: &#39;program&#39; is up to date.</code></pre>
<p>このメッセージの意味は「programは最新だ」という意味だ。<code>make</code>はファイルのタイムスタンプを調べ、もしファイル<code>program</code>より<code>source</code>のタイムスタンプの方が若い場合、つまり<code>program</code>が変更されたよりも後に<code>source</code>が変更された場合、<code>ルール</code>を実行する。</p>
<p>ためしにファイル<code>source02</code>のタイムスタンプを更新してみよう。</p>
<pre><code>$ touch source02
$ make
cat source01 source02 source03 &gt; source
cat source &gt; program</code></pre>
<p>ファイル<code>source</code>は<code>事前要件</code>に<code>source02</code>を含む。<code>source02</code>のタイムスタンプが<code>source</code>より若いので、<code>source</code>が再び生成される。すると、<code>source</code>のタイムスタンプが<code>program</code>のタイムスタンプよりも若くなったので、<code>program</code>も生成される。</p>
<p>もう一つ例を見てみよう。</p>
<pre><code>$ touch a b c
$ ls
a b c Makefile</code></pre>
<p>あるディレクトリにファイル<code>a</code>, <code>b</code>, <code>c</code>がある。</p>
<p><code>Makefile</code>は以下の内容になっている。</p>
<pre><code>D : A B C
    cat A B C &gt; D

A : a
    cat a &gt; A

B : b
    cat b &gt; B

C : c
    cat c &gt; C</code></pre>
<p>この<code>Makefile</code>を呼び出したときに作られるのはファイル<code>D</code>だ。ファイル<code>D</code>を作るにはファイル<code>A</code>, <code>B</code>, <code>C</code>が必要だ。このファイルはそれぞれファイル<code>a</code>, <code>b</code>, <code>c</code>から生成されるルールが記述してある。</p>
<p>これを<code>make</code>すると以下のようにファイル<code>A</code>, <code>B</code>, <code>C</code>, <code>D</code>が作られる。</p>
<pre><code>$ ls
a b c Makefile
$ make
cat a &gt; A
cat b &gt; B
cat c &gt; C
cat A B C &gt; D</code></pre>
<p>ここで、ファイル<code>b</code>のタイムスタンプだけを更新して<code>make</code>してみよう。</p>
<pre><code>$ touch b
$ make
cat b &gt; B
cat A B C &gt; D</code></pre>
<p>ファイル<code>b</code>のタイムスタンプがファイル<code>B</code>より若くなったので、ファイル<code>B</code>がターゲットとなったルールが再び実行される。ファイル<code>A</code>, <code>C</code>のルールは実行されない。そしてファイル<code>B</code>のタイムスタンプがファイル<code>D</code>より若くなったので、ファイル<code>D</code>がターゲットとなったルールが再び実行される。</p>
<p><code>make</code>により、処理する必要のあるルールだけが部分的に処理されていることがわかる。</p>
<p><code>make</code>は適切な<code>ルール</code>さえ書けば、依存関係の解決を自動的に行ってくれる。</p>
<h3 id="コメント">コメント</h3>
<p><code>Makefile</code>にはコメントを書くことができる。<code>#</code>で始まる行はコメント扱いされる。</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode makefile"><code class="sourceCode makefile"><a class="sourceLine" id="cb44-1" data-line-number="1"><span class="co"># programを生成するルール</span></a>
<a class="sourceLine" id="cb44-2" data-line-number="2"><span class="dv">program :</span><span class="dt"> source</span></a>
<a class="sourceLine" id="cb44-3" data-line-number="3">    cat source &gt; program</a>
<a class="sourceLine" id="cb44-4" data-line-number="4"></a>
<a class="sourceLine" id="cb44-5" data-line-number="5"><span class="co"># sourceを生成するルール</span></a>
<a class="sourceLine" id="cb44-6" data-line-number="6"><span class="dv">source :</span><span class="dt"> source01 source02 source03</span></a>
<a class="sourceLine" id="cb44-7" data-line-number="7">    cat source01 source02 source03 &gt; source</a></code></pre></div>
<h3 id="変数">変数</h3>
<p><code>Makefile</code>には<code>変数</code>を書くことができる。</p>
<p>変数の文法は以下の通り</p>
<pre><code>variable = foobar

target : $(variable)</code></pre>
<p>これは、</p>
<pre><code>target : foobar</code></pre>
<p>と書いたものと同じように扱われる。</p>
<p>変数は<code>=</code>の左側に変数名、右側に変数の内容を書く。</p>
<p>変数を使うときは、<code>$(変数名)</code>のように、<code>$()</code>で変数名を包む。</p>
<h3 id="自動変数">自動変数</h3>
<p>GNU Makeは便利なことに、いくつかの変数を自動で作ってくれる。</p>
<h4 id="ターゲット"><code>$@</code> ターゲット</h4>
<p><code>$@</code>はルールのターゲットのファイル名になる。</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode makefile"><code class="sourceCode makefile"><a class="sourceLine" id="cb47-1" data-line-number="1"><span class="dv">target :</span></a>
<a class="sourceLine" id="cb47-2" data-line-number="2">    echo <span class="ch">$@</span></a></code></pre></div>
<p>このMakefileを実行すると以下のように出力される。</p>
<pre><code>$ make
echo target</code></pre>
<h4 id="最初の事前要件"><code>$&lt;</code> 最初の事前要件</h4>
<p><code>$&lt;</code>はルールの最初の事前要件のファイル名になる。</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode makefile"><code class="sourceCode makefile"><a class="sourceLine" id="cb49-1" data-line-number="1"><span class="dv">target :</span><span class="dt"> A B C</span></a>
<a class="sourceLine" id="cb49-2" data-line-number="2">    echo <span class="ch">$&lt;</span></a></code></pre></div>
<p>このMakefileを実行すると以下のように出力される。</p>
<pre><code>$ make
echo A</code></pre>
<h4 id="すべての事前要件"><code>$^</code> すべての事前要件</h4>
<p><code>$^</code>はすべての事前要件のファイル名が空白区切りされたものになる</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode makefile"><code class="sourceCode makefile"><a class="sourceLine" id="cb51-1" data-line-number="1"><span class="dv">target :</span><span class="dt"> A B C</span></a>
<a class="sourceLine" id="cb51-2" data-line-number="2">    echo <span class="ch">$^</span></a></code></pre></div>
<p>このMakefileを実行すると以下のように出力される。</p>
<pre><code>$ make
echo A B C</code></pre>
<h4 id="自動変数の組み合わせ">自動変数の組み合わせ</h4>
<p>例えば<code>ターゲット</code>を生成するために<code>事前要件</code>と<code>ターゲット</code>のファイル名をレシピに書く場合、</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode makefile"><code class="sourceCode makefile"><a class="sourceLine" id="cb53-1" data-line-number="1"><span class="dv">target :</span><span class="dt"> prerequisite</span></a>
<a class="sourceLine" id="cb53-2" data-line-number="2">    cat prerequisite &gt; target</a></code></pre></div>
<p>と書く代わりに、</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode makefile"><code class="sourceCode makefile"><a class="sourceLine" id="cb54-1" data-line-number="1"><span class="dv">target :</span><span class="dt"> prerequisite</span></a>
<a class="sourceLine" id="cb54-2" data-line-number="2">    cat <span class="ch">$&lt;</span> &gt; <span class="ch">$@</span></a></code></pre></div>
<p>と書ける。</p>
<h3 id="phonyターゲット">PHONYターゲット</h3>
<p>PHONYターゲットとは、ファイル名を意味せず、単にレシピを実行するターゲット名としてのみ機能するターゲットのことだ。</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode makefile"><code class="sourceCode makefile"><a class="sourceLine" id="cb55-1" data-line-number="1"><span class="dv">hi :</span></a>
<a class="sourceLine" id="cb55-2" data-line-number="2">    echo hi</a>
<a class="sourceLine" id="cb55-3" data-line-number="3"></a>
<a class="sourceLine" id="cb55-4" data-line-number="4"><span class="dv">hello :</span></a>
<a class="sourceLine" id="cb55-5" data-line-number="5">    echo hello</a></code></pre></div>
<p>これを実行すると以下のようになる。</p>
<pre><code>$ make
echo hi
hi
$ make hi
echo hi
hi
$ make hello
echo hello
hello</code></pre>
<p><code>make</code>を引数を付けずに実行すると、一番上に書かれたルールが実行される。引数としてターゲットを指定すると、そのターゲットのルールと、依存するルールが実行される。</p>
<p>ただし、ターゲットと同じファイル名が存在すると、ルールは実行されない。</p>
<pre><code>$ touch hello
$ make hello
make: &#39;hello&#39; is up to date.</code></pre>
<p>GNU makeはこの問題に対処するため、<code>.PHONY</code>ターゲットという特殊な機能がある。これはPHONYターゲットを<code>.PHONY</code>ターゲットの事前要件とすることで、ターゲットと同じファイル名の存在の有無にかかわらずルールを実行させられる。</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode makefile"><code class="sourceCode makefile"><a class="sourceLine" id="cb58-1" data-line-number="1"><span class="dv">hello :</span></a>
<a class="sourceLine" id="cb58-2" data-line-number="2">    echo hello</a>
<a class="sourceLine" id="cb58-3" data-line-number="3"></a>
<a class="sourceLine" id="cb58-4" data-line-number="4"><span class="ot">.PHONY</span> <span class="ot">:</span><span class="dt"> hello</span></a></code></pre></div>
<p>PHONYターゲットはコンパイルしたプログラムの実行や削除に使うことができる。</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode makefile"><code class="sourceCode makefile"><a class="sourceLine" id="cb59-1" data-line-number="1"><span class="dv">hello :</span><span class="dt"> hello.cpp</span></a>
<a class="sourceLine" id="cb59-2" data-line-number="2">    g++ -o <span class="ch">$@</span> <span class="ch">$&lt;</span></a>
<a class="sourceLine" id="cb59-3" data-line-number="3"></a>
<a class="sourceLine" id="cb59-4" data-line-number="4"><span class="dv">run :</span><span class="dt"> hello</span></a>
<a class="sourceLine" id="cb59-5" data-line-number="5">    ./hello</a>
<a class="sourceLine" id="cb59-6" data-line-number="6"></a>
<a class="sourceLine" id="cb59-7" data-line-number="7"><span class="dv">clean :</span></a>
<a class="sourceLine" id="cb59-8" data-line-number="8">    rm -rf ./hello</a>
<a class="sourceLine" id="cb59-9" data-line-number="9"></a>
<a class="sourceLine" id="cb59-10" data-line-number="10"><span class="ot">.PHONY</span> <span class="ot">:</span><span class="dt"> run clean</span></a></code></pre></div>
<h2 id="入門用の環境構築">入門用の環境構築</h2>
<p>以上を踏まえて、C++入門用の環境構築をしてこの章のまとめとする。</p>
<p>今回構築する環境のファイル名とその意味は以下の通り。</p>
<dl>
<dt>main.cpp</dt>
<dd>C++のコードを書く all.h
</dd>
<dd>標準ライブラリのヘッダーファイルを書く all.h.gch
</dd>
<dd>コンパイル済みヘッダー program
</dd>
<dd>実行可能ファイル Makefile
</dd>
<dd>GNU makeのルールを書く
</dd>
</dl>
<p>使い方は以下の通り。</p>
<dl>
<dt>make</dt>
<dd>コンパイルする make run
</dd>
<dd>コンパイルして実行 make clean
</dd>
<dd>コンパイル結果を削除
</dd>
</dl>
<p>GCCに与えるコンパイラーオプションを変数にまとめる。</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode makefile"><code class="sourceCode makefile"><a class="sourceLine" id="cb60-1" data-line-number="1"><span class="dt">gcc_options </span><span class="ch">=</span><span class="st"> -std=c++17 -Wall --pedantic-error</span></a></code></pre></div>
<p>言語はC++17、すべての警告を有効にし、規格準拠ではないコードはエラーとする。</p>
<p>プログラムをコンパイルする部分は以下の通り。</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode makefile"><code class="sourceCode makefile"><a class="sourceLine" id="cb61-1" data-line-number="1"><span class="dv">program :</span><span class="dt"> main.cpp all.h all.h.gch</span></a>
<a class="sourceLine" id="cb61-2" data-line-number="2">    g++ <span class="ch">$(</span><span class="dt">gcc_options</span><span class="ch">)</span> -include all.h <span class="ch">$&lt;</span> -o <span class="ch">$@</span></a>
<a class="sourceLine" id="cb61-3" data-line-number="3"></a>
<a class="sourceLine" id="cb61-4" data-line-number="4"><span class="dv">all.h.gch :</span><span class="dt"> all.h</span></a>
<a class="sourceLine" id="cb61-5" data-line-number="5">    g++ <span class="ch">$(</span><span class="dt">gcc_options</span><span class="ch">)</span> -x c++-header -o <span class="ch">$@</span> <span class="ch">$&lt;</span></a></code></pre></div>
<p>実行可能ファイル<code>program</code>と、コンパイル済みヘッダー<code>all.h.gch</code>をコンパイルするルールだ。</p>
<p>PHONYターゲットは以下の通り。</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode makefile"><code class="sourceCode makefile"><a class="sourceLine" id="cb62-1" data-line-number="1"><span class="dv">run :</span><span class="dt"> program</span></a>
<a class="sourceLine" id="cb62-2" data-line-number="2">    ./program</a>
<a class="sourceLine" id="cb62-3" data-line-number="3"></a>
<a class="sourceLine" id="cb62-4" data-line-number="4"><span class="dv">clean :</span></a>
<a class="sourceLine" id="cb62-5" data-line-number="5">    rm -f ./program</a>
<a class="sourceLine" id="cb62-6" data-line-number="6">    rm -f ./all.h.gch</a>
<a class="sourceLine" id="cb62-7" data-line-number="7"></a>
<a class="sourceLine" id="cb62-8" data-line-number="8"><span class="ot">.PHONY</span> <span class="ot">:</span><span class="dt"> run clean</span></a></code></pre></div>
<p><code>make</code>でコンパイル。<code>make run</code>で実行。<code>make clean</code>でコンパイル結果の削除。</p>
<p>Makefile全体は以下のようになる。</p>
<div class="sourceCode" id="cb63"><pre class="sourceCode makefile"><code class="sourceCode makefile"><a class="sourceLine" id="cb63-1" data-line-number="1"><span class="dt">gcc_options </span><span class="ch">=</span><span class="st"> -std=c++17 -Wall --pedantic-error</span></a>
<a class="sourceLine" id="cb63-2" data-line-number="2"></a>
<a class="sourceLine" id="cb63-3" data-line-number="3"><span class="dv">program :</span><span class="dt"> main.cpp all.h all.h.gch</span></a>
<a class="sourceLine" id="cb63-4" data-line-number="4">    g++ <span class="ch">$(</span><span class="dt">gcc_options</span><span class="ch">)</span> -include all.h <span class="ch">$&lt;</span> -o <span class="ch">$@</span></a>
<a class="sourceLine" id="cb63-5" data-line-number="5"></a>
<a class="sourceLine" id="cb63-6" data-line-number="6"><span class="dv">all.h.gch :</span><span class="dt"> all.h</span></a>
<a class="sourceLine" id="cb63-7" data-line-number="7">    g++ <span class="ch">$(</span><span class="dt">gcc_options</span><span class="ch">)</span> -x c++-header -o <span class="ch">$@</span> <span class="ch">$&lt;</span></a>
<a class="sourceLine" id="cb63-8" data-line-number="8"></a>
<a class="sourceLine" id="cb63-9" data-line-number="9"><span class="dv">run :</span><span class="dt"> program</span></a>
<a class="sourceLine" id="cb63-10" data-line-number="10">    ./program</a>
<a class="sourceLine" id="cb63-11" data-line-number="11"></a>
<a class="sourceLine" id="cb63-12" data-line-number="12"><span class="dv">clean :</span></a>
<a class="sourceLine" id="cb63-13" data-line-number="13">    rm -f ./program</a>
<a class="sourceLine" id="cb63-14" data-line-number="14">    rm -f ./all.h.gch</a>
<a class="sourceLine" id="cb63-15" data-line-number="15"></a>
<a class="sourceLine" id="cb63-16" data-line-number="16"><span class="ot">.PHONY</span> <span class="ot">:</span><span class="dt"> run clean</span></a></code></pre></div>
<h1 id="cヒッチハイクガイド">C++ヒッチハイクガイド</h1>
<p>プログラミング言語の個々の機能の解説を理解するためには、まず言語の全体像を掴まなければならない。この章ではC++の様々なコードを一通り観光していく。ここではコードの詳細な解説はしない。</p>
<h2 id="最小のコード">最小のコード</h2>
<p>以下はC++の最小のコードだ。</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb64-1" data-line-number="1"><span class="dt">int</span> main(){}</a></code></pre></div>
<p>暗号のようなコードで訳がわからないが、これが最小のコードだ。<code>main</code>というのは<code>main関数</code>のことだ。C++ではプログラムの実行はmain関数から始まる。</p>
<p>ソースコードにコメントを記述して、もう少しわかりやすく書いてみよう。</p>
<pre><code>int     // 関数の戻り値の型
main    // 関数名
()      // 関数の引数
{       // 関数の始まり
        // 実行される処理
}       // 関数の終わり</code></pre>
<p><code>//</code>から行末まではコメントだ。コメントには好きなことを書くことができる。</p>
<p>このコードと一つ前のコードは、コメントの有無を別にすれば何の違いもない。このコードで使っている、<code>int</code>とか<code>main</code>とか記号文字の一つ一つをトークン(token)と呼ぶ。C++ではトークンの間に空白文字や改行文字をいくら使ってもよい。</p>
<p>なので、</p>
<div class="sourceCode" id="cb66"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb66-1" data-line-number="1"><span class="dt">int</span> main(){ }</a></code></pre></div>
<p>と書くこともできるし、</p>
<div class="sourceCode" id="cb67"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb67-1" data-line-number="1"><span class="dt">int</span>    main    (    )    {   }</a></code></pre></div>
<p>と書くこともできるし、紙に印刷する都合上とても読みづらくなるかもしれないが</p>
<div class="sourceCode" id="cb68"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb68-1" data-line-number="1"><span class="dt">int</span></a>
<a class="sourceLine" id="cb68-2" data-line-number="2">main</a>
<a class="sourceLine" id="cb68-3" data-line-number="3">(</a>
<a class="sourceLine" id="cb68-4" data-line-number="4">)</a>
<a class="sourceLine" id="cb68-5" data-line-number="5">{</a>
<a class="sourceLine" id="cb68-6" data-line-number="6">}</a></code></pre></div>
<p>と書くこともできる。</p>
<p>ただし、トークンの途中で空白文字や改行文字を使うことはできない。以下のコードは間違っている。</p>
<div class="sourceCode" id="cb69"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb69-1" data-line-number="1">i</a>
<a class="sourceLine" id="cb69-2" data-line-number="2">nt ma in(){}</a></code></pre></div>
<h2 id="標準出力">標準出力</h2>
<div class="sourceCode" id="cb70"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb70-1" data-line-number="1"><span class="co">// helloと改行を出力するプログラム</span></a>
<a class="sourceLine" id="cb70-2" data-line-number="2"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb70-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb70-4" data-line-number="4">    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;hello&quot;</span>s ;</a>
<a class="sourceLine" id="cb70-5" data-line-number="5">}</a></code></pre></div>
<p>標準出力はプログラムの基本だ。C++で標準出力する方法はいくつもあるが、&lt;iostream&gt;ライブラリを利用するものが最も簡単だ。</p>
<p><code>std::cout</code>は標準出力を使うためのライブラリだ。</p>
<p><code>&lt;&lt;</code>は<code>operator &lt;&lt;</code>という演算子だ。C++では演算子にも名前がついていて、例えば<code>+</code>は<code>operator +</code>となる。<code>&lt;&lt;</code>も演算子の一種だ。</p>
<p><code>&quot;hello&quot;s</code>というのは文字列で、二重引用符で囲まれた中の文字列が標準出力に出力される。</p>
<p>セミコロン<code>;</code>は文の区切り文字だ。C++では文の区切りは明示的にセミコロンを書く必要がある。他の言語では改行文字を文脈から判断して文の区切りとみなすこともあるが、C++では明示的に文の区切り文字としてセミコロンを書かなければならない。</p>
<p>セミコロンを書き忘れるとエラーとなる。</p>
<div class="sourceCode" id="cb71"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb71-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb71-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb71-3" data-line-number="3">    <span class="co">// エラー！　セミコロンがない</span></a>
<a class="sourceLine" id="cb71-4" data-line-number="4">    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;error&quot;</span>s</a>
<a class="sourceLine" id="cb71-5" data-line-number="5">}</a></code></pre></div>
<p>複数の文を書いてみよう。</p>
<div class="sourceCode" id="cb72"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb72-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb72-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb72-3" data-line-number="3">    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;one &quot;</span>s ;</a>
<a class="sourceLine" id="cb72-4" data-line-number="4">    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;two &quot;</span>s ;</a>
<a class="sourceLine" id="cb72-5" data-line-number="5">    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;three &quot;</span>s ;</a>
<a class="sourceLine" id="cb72-6" data-line-number="6">}</a></code></pre></div>
<p>C++は他の多くの言語と同じように、逐次実行される。つまり、コードは書いた順番に実行される。そして標準出力のような外部への副作用は、実行された順番で出力される。このコードを実行した結果は以下の通り。</p>
<pre><code>one two three </code></pre>
<p>“three two one”や“two one three”のような出力結果にはならない。</p>
<p>C++を含む多くの言語で<code>a + b + c</code>と書けるように、<code>operator &lt;&lt;</code>も<code>a &lt;&lt; b &lt;&lt; c</code>と書ける。<code>operator &lt;&lt;</code>で標準出力をするには、左端は<code>std::cout</code>でなければならない。</p>
<div class="sourceCode" id="cb74"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb74-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb74-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb74-3" data-line-number="3">    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;aaa&quot;</span>s &lt;&lt; <span class="st">&quot;bbb&quot;</span>s &lt;&lt; <span class="st">&quot;ccc&quot;</span>s ;</a>
<a class="sourceLine" id="cb74-4" data-line-number="4">}</a></code></pre></div>
<p>出力は<code>aaabbbccc</code>となる。</p>
<h2 id="文字列">文字列</h2>
<p>二重引用符で囲まれた文字列を、文字通り<code>文字列</code>という。文字列には末尾にsがつくものとつかないものがある。これには違いがあるのだが、わからないうちはsを付けておいたほうが便利だ。</p>
<div class="sourceCode" id="cb75"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb75-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb75-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb75-3" data-line-number="3">    <span class="co">// これは文字列</span></a>
<a class="sourceLine" id="cb75-4" data-line-number="4">    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;hello&quot;</span>s ;</a>
<a class="sourceLine" id="cb75-5" data-line-number="5">    <span class="co">// これも文字列、ただし不便</span></a>
<a class="sourceLine" id="cb75-6" data-line-number="6">    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;hello&quot;</span> ;</a>
<a class="sourceLine" id="cb75-7" data-line-number="7">}</a></code></pre></div>
<p>文字列リテラルの中にバックスラッシュを書くと、エスケープシーケンスとして扱われる。最もよく使われるのは改行文字を表す<code>\n</code>だ。</p>
<div class="sourceCode" id="cb76"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb76-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb76-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb76-3" data-line-number="3">    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;aaa</span><span class="sc">\n</span><span class="st">bbb</span><span class="sc">\n</span><span class="st">ccc&quot;</span>s ;</a>
<a class="sourceLine" id="cb76-4" data-line-number="4">}</a></code></pre></div>
<p>これは以下のように出力される。</p>
<pre><code>aaa
bbb
ccc</code></pre>
<p>バックスラッシュを文字列で使いたい場合は<code>\\</code>と書かなければならない。</p>
<div class="sourceCode" id="cb78"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb78-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb78-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb78-3" data-line-number="3">    <span class="co">// </span></a>
<a class="sourceLine" id="cb78-4" data-line-number="4">    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;</span><span class="sc">\\</span><span class="st">n is a new-line.</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb78-5" data-line-number="5">}</a></code></pre></div>
<p>文字列は演算子<code>operator +</code>で「足す」ことができる。「文字列を足す」というのは、「文字列を結合する」という意味だ。</p>
<div class="sourceCode" id="cb79"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb79-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb79-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb79-3" data-line-number="3">    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;hello&quot;</span>s + <span class="st">&quot;world&quot;</span>s ;</a>
<a class="sourceLine" id="cb79-4" data-line-number="4">}</a></code></pre></div>
<h2 id="整数と浮動小数点数">整数と浮動小数点数</h2>
<p>iostreamは文字列の他にも、整数や浮動小数点数を出力できる。早速試してみよう。</p>
<div class="sourceCode" id="cb80"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb80-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb80-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb80-3" data-line-number="3">    <span class="bu">std::</span>cout</a>
<a class="sourceLine" id="cb80-4" data-line-number="4">        &lt;&lt; <span class="st">&quot;Integer: &quot;</span>s &lt;&lt; <span class="dv">42</span> &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s</a>
<a class="sourceLine" id="cb80-5" data-line-number="5">        &lt;&lt; <span class="st">&quot;Floating Point: &quot;</span>s &lt;&lt; <span class="fl">3.14</span> ;</a>
<a class="sourceLine" id="cb80-6" data-line-number="6">}</a></code></pre></div>
<p><code>-123</code>や<code>0</code>や<code>123</code>といった数値を整数という。<code>3.14</code>のような数値を浮動小数点数という。</p>
<p>数値を扱えるのだから、計算をしてみたいところだ。C++は整数同士の演算子として、四則演算(<code>+-*/</code>)や剰余(<code>%</code>)をサポートしている</p>
<div class="sourceCode" id="cb81"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb81-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb81-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb81-3" data-line-number="3">    <span class="bu">std::</span>cout</a>
<a class="sourceLine" id="cb81-4" data-line-number="4">        &lt;&lt; <span class="dv">3</span> + <span class="dv">5</span> &lt;&lt; <span class="st">&quot; &quot;</span>s &lt;&lt; <span class="dv">3</span> - <span class="dv">5</span> &lt;&lt; <span class="st">&quot; &quot;</span>s</a>
<a class="sourceLine" id="cb81-5" data-line-number="5">        &lt;&lt; <span class="dv">3</span> * <span class="dv">5</span> &lt;&lt; <span class="st">&quot; &quot;</span>s &lt;&lt; <span class="dv">3</span> / <span class="dv">5</span> &lt;&lt; <span class="st">&quot; &quot;</span>s</a>
<a class="sourceLine" id="cb81-6" data-line-number="6">        &lt;&lt; <span class="dv">3</span> % <span class="dv">5</span> ;</a>
<a class="sourceLine" id="cb81-7" data-line-number="7">}</a></code></pre></div>
<p>演算子は組み合わせて使うこともできる。その場合、演算子<code>*/%</code>は演算子<code>+-</code>よりも優先される。</p>
<div class="sourceCode" id="cb82"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb82-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb82-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb82-3" data-line-number="3">    <span class="co">// 7</span></a>
<a class="sourceLine" id="cb82-4" data-line-number="4">    <span class="bu">std::</span>cout &lt;&lt; <span class="dv">1</span> + <span class="dv">2</span> * <span class="dv">3</span> ;</a>
<a class="sourceLine" id="cb82-5" data-line-number="5">}</a></code></pre></div>
<p>この場合、まず<code>2*3</code>が計算され6となり、<code>1+6</code>が計算され<code>7</code>となる。</p>
<p><code>1+2</code>の法を先に計算したい場合、括弧<code>()</code>で囲むことにより、計算の優先度を変えることができる。</p>
<div class="sourceCode" id="cb83"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb83-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb83-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb83-3" data-line-number="3">    <span class="co">// 9</span></a>
<a class="sourceLine" id="cb83-4" data-line-number="4">    <span class="bu">std::</span>cout &lt;&lt; (<span class="dv">1</span> + <span class="dv">2</span>) * <span class="dv">3</span> ;</a>
<a class="sourceLine" id="cb83-5" data-line-number="5">}</a></code></pre></div>
<p>これは<code>1+2</code>が先に計算され<code>3</code>となり、<code>3*3</code>が計算され<code>9</code>となる。</p>
<p>浮動小数点数同士でも四則演算ができる。剰余はできない。</p>
<div class="sourceCode" id="cb84"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb84-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb84-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb84-3" data-line-number="3">    <span class="bu">std::</span>cout</a>
<a class="sourceLine" id="cb84-4" data-line-number="4">        &lt;&lt; <span class="fl">3.5</span> + <span class="fl">7.11</span> &lt;&lt; <span class="st">&quot; &quot;</span>s &lt;&lt; <span class="fl">3.5</span> - <span class="fl">7.11</span> &lt;&lt; <span class="st">&quot; &quot;</span>s</a>
<a class="sourceLine" id="cb84-5" data-line-number="5">        &lt;&lt; <span class="fl">3.5</span> * <span class="fl">7.11</span> &lt;&lt; <span class="st">&quot; &quot;</span>s &lt;&lt; <span class="fl">3.5</span> / <span class="fl">7.11</span> ;</a>
<a class="sourceLine" id="cb84-6" data-line-number="6">}</a></code></pre></div>
<p>では整数と浮動小数点数を演算した場合どうなるのだろう。さっそく試してみよう。</p>
<div class="sourceCode" id="cb85"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb85-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb85-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb85-3" data-line-number="3">    <span class="bu">std::</span>cout &lt;&lt; <span class="dv">1</span> + <span class="fl">0.1</span> ;</a>
<a class="sourceLine" id="cb85-4" data-line-number="4">}</a></code></pre></div>
<p>結果は<code>1.1</code>だ。整数と浮動小数点数を演算した結果は浮動小数点数になる。</p>
<p>そういえばC++には文字列もあるのだった。文字列と文字列は足すことができる。数値と数値も足すことができる。では数値と文字列を足すとどうなるのだろう。</p>
<div class="sourceCode" id="cb86"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb86-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb86-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb86-3" data-line-number="3">    <span class="bu">std::</span>cout &lt;&lt; <span class="dv">1</span> + <span class="st">&quot;234&quot;</span>s ;</a>
<a class="sourceLine" id="cb86-4" data-line-number="4">}</a></code></pre></div>
<p>この結果はエラーになる。</p>
<p>いやまて、C++には末尾にsをつけない文字列もあるのだった。これも試してみよう。</p>
<div class="sourceCode" id="cb87"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb87-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb87-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb87-3" data-line-number="3">    <span class="bu">std::</span>cout &lt;&lt; <span class="dv">1</span> + <span class="st">&quot;234&quot;</span> ;</a>
<a class="sourceLine" id="cb87-4" data-line-number="4">}</a></code></pre></div>
<p>結果はなんと<code>34</code>になるではないか。C++では謎の数学により<code>1 + &quot;234&quot; = &quot;34&quot;</code>であることが判明した。この謎はいずれ解き明かすとして、今は文字列には必ず末尾にsをつけることにしよう。そのほうが安全だ。</p>
<h2 id="変数variable">変数(variable)</h2>
<p>さあどんどんプログラミング言語によくある機能を見ていこう。次は変数だ。</p>
<div class="sourceCode" id="cb88"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb88-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb88-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb88-3" data-line-number="3">    <span class="co">// 整数の変数</span></a>
<a class="sourceLine" id="cb88-4" data-line-number="4">    <span class="kw">auto</span> answer = <span class="dv">42</span> ;</a>
<a class="sourceLine" id="cb88-5" data-line-number="5">    <span class="bu">std::</span>cout &lt;&lt; answer &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb88-6" data-line-number="6">    <span class="co">// 浮動小数点数の変数</span></a>
<a class="sourceLine" id="cb88-7" data-line-number="7">    <span class="kw">auto</span> pi = <span class="fl">3.14</span> ;</a>
<a class="sourceLine" id="cb88-8" data-line-number="8">    <span class="bu">std::</span>cout &lt;&lt; pi &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb88-9" data-line-number="9"></a>
<a class="sourceLine" id="cb88-10" data-line-number="10">    <span class="co">// 文字列の変数</span></a>
<a class="sourceLine" id="cb88-11" data-line-number="11">    <span class="kw">auto</span> question = <span class="st">&quot;Life, The Universe, and Everything.&quot;</span>s ;</a>
<a class="sourceLine" id="cb88-12" data-line-number="12">    <span class="bu">std::</span>cout &lt;&lt; question ;</a>
<a class="sourceLine" id="cb88-13" data-line-number="13">}</a></code></pre></div>
<p>変数はキーワード<code>auto</code>に続いて変数名を書き、<code>=</code>に続いて値を書くことで宣言できる。変数の宣言は文なので、文末にはセミコロンが必要だ。</p>
<pre><code>auto 変数名 = 値 ;</code></pre>
<p><code>変数名</code>はキーワード、アンダースコア(_)で始まる名前、アンダースコア2つ(__)を含む名前以外は自由に名付けることができる。</p>
<p>変数の最初の値は、<code>= 値</code>のかわりに<code>(値)</code>や<code>{値}</code>と書いてもよい。</p>
<div class="sourceCode" id="cb90"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb90-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb90-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb90-3" data-line-number="3">    <span class="kw">auto</span> a = <span class="dv">1</span> ;</a>
<a class="sourceLine" id="cb90-4" data-line-number="4">    <span class="kw">auto</span> b(<span class="dv">2</span>) ;</a>
<a class="sourceLine" id="cb90-5" data-line-number="5">    <span class="kw">auto</span> c{<span class="dv">3</span>} ;</a>
<a class="sourceLine" id="cb90-6" data-line-number="6">}</a></code></pre></div>
<p>この<code>=</code>, <code>()</code>, <code>{}</code>による変数の初期値の指定を、<code>初期化</code>という。</p>
<p>変数は使う前に宣言しなければならない。</p>
<div class="sourceCode" id="cb91"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb91-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb91-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb91-3" data-line-number="3">    <span class="co">// エラー、名前xは宣言されていない</span></a>
<a class="sourceLine" id="cb91-4" data-line-number="4">    <span class="bu">std::</span>cout &lt;&lt; x ;</a>
<a class="sourceLine" id="cb91-5" data-line-number="5">    <span class="kw">auto</span> x = <span class="dv">123</span> ;</a>
<a class="sourceLine" id="cb91-6" data-line-number="6">}</a></code></pre></div>
<p>変数の値は初期化した後にも演算子<code>=</code>で変更できる。これを<code>代入</code>という。</p>
<div class="sourceCode" id="cb92"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb92-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb92-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb92-3" data-line-number="3">    <span class="co">// 変数の宣言</span></a>
<a class="sourceLine" id="cb92-4" data-line-number="4">    <span class="kw">auto</span> x</a>
<a class="sourceLine" id="cb92-5" data-line-number="5">    <span class="co">// 初期化</span></a>
<a class="sourceLine" id="cb92-6" data-line-number="6">    = <span class="dv">123</span> ;</a>
<a class="sourceLine" id="cb92-7" data-line-number="7"></a>
<a class="sourceLine" id="cb92-8" data-line-number="8">    <span class="co">// 123</span></a>
<a class="sourceLine" id="cb92-9" data-line-number="9">    <span class="bu">std::</span>cout &lt;&lt; x ;</a>
<a class="sourceLine" id="cb92-10" data-line-number="10"></a>
<a class="sourceLine" id="cb92-11" data-line-number="11">    <span class="co">// 代入</span></a>
<a class="sourceLine" id="cb92-12" data-line-number="12">    x = <span class="dv">456</span> ;</a>
<a class="sourceLine" id="cb92-13" data-line-number="13"></a>
<a class="sourceLine" id="cb92-14" data-line-number="14">    <span class="co">// 456</span></a>
<a class="sourceLine" id="cb92-15" data-line-number="15">    <span class="bu">std::</span>cout &lt;&lt; x ;</a>
<a class="sourceLine" id="cb92-16" data-line-number="16"></a>
<a class="sourceLine" id="cb92-17" data-line-number="17">    <span class="co">// もう一度代入</span></a>
<a class="sourceLine" id="cb92-18" data-line-number="18">    x = <span class="dv">789</span> ;</a>
<a class="sourceLine" id="cb92-19" data-line-number="19">    <span class="co">// 789</span></a>
<a class="sourceLine" id="cb92-20" data-line-number="20">    <span class="bu">std::</span>cout &lt;&lt; x ;</a>
<a class="sourceLine" id="cb92-21" data-line-number="21">}</a></code></pre></div>
<p>代入演算子<code>operator =</code>は左辺に変数名を、右辺に代入する値を書く。面白いこととして、右辺には代入する変数名そのものを書ける。</p>
<div class="sourceCode" id="cb93"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb93-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb93-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb93-3" data-line-number="3">    <span class="kw">auto</span> x = <span class="dv">10</span> ;</a>
<a class="sourceLine" id="cb93-4" data-line-number="4">    x = x + <span class="dv">5</span> ;</a>
<a class="sourceLine" id="cb93-5" data-line-number="5"></a>
<a class="sourceLine" id="cb93-6" data-line-number="6">    <span class="co">// 15</span></a>
<a class="sourceLine" id="cb93-7" data-line-number="7">    <span class="bu">std::</span>cout &lt;&lt; x ;</a>
<a class="sourceLine" id="cb93-8" data-line-number="8">}</a></code></pre></div>
<p><code>operator =</code>は「代入」という意味で、「等号」という意味ではないからだ。<code>x=x+5</code>は、「<code>x</code>と<code>x+5</code>は等しい」という独創的な数学上の定義ではなく、「変数xに代入前の変数xの値に5を加えた数を代入する」という意味だ。</p>
<p>変数の今の値に対して演算した結果を変数に代入するという処理はとても良く使うので、C++には<code>x = x + a</code>と同じ意味で使える演算子、<code>operator +=</code>もある。</p>
<div class="sourceCode" id="cb94"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb94-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb94-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb94-3" data-line-number="3">    <span class="kw">auto</span> x = <span class="dv">1</span> ;</a>
<a class="sourceLine" id="cb94-4" data-line-number="4">    <span class="co">// x = x + 5と同じ</span></a>
<a class="sourceLine" id="cb94-5" data-line-number="5">    x += <span class="dv">5</span> ;</a>
<a class="sourceLine" id="cb94-6" data-line-number="6">}</a></code></pre></div>
<p><code>operator +=</code>と同様に、<code>operator -=</code>, <code>operator *=</code>, <code>operator /=</code>, <code>operator %=</code>もある。</p>
<p>C++の変数は、専門用語を使うと「静的型付け」になる。静的型付けと対比されるのが「動的型付け」だ。もっと難しく書くと、動的型付け言語の変数は、C++で言えば型情報付きの<code>void *</code>型の変数のような扱いを受ける。</p>
<p>C++の変数には<code>型</code>がある。<code>型</code>というのは値の種類を表す情報のことだ。</p>
<p>例えば、以下は変数が動的型付けの言語JavaScriptのコードだ。</p>
<div class="sourceCode" id="cb95"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb95-1" data-line-number="1"><span class="kw">var</span> x <span class="op">=</span> <span class="dv">1</span> <span class="op">;</span></a>
<a class="sourceLine" id="cb95-2" data-line-number="2">x <span class="op">=</span> <span class="st">&quot;hello&quot;</span> <span class="op">;</span></a>
<a class="sourceLine" id="cb95-3" data-line-number="3">x <span class="op">=</span> <span class="dv">2</span> <span class="op">;</span></a></code></pre></div>
<p>JavaScriptではこのコードは正しい。変数<code>x</code>は数値型であり、文字列型に代わり、また数値型に戻る。</p>
<p>C++ではこのようなコードは書けない。</p>
<div class="sourceCode" id="cb96"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb96-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb96-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb96-3" data-line-number="3">    <span class="kw">auto</span> x = <span class="dv">1</span> ;</a>
<a class="sourceLine" id="cb96-4" data-line-number="4">    <span class="co">// エラー</span></a>
<a class="sourceLine" id="cb96-5" data-line-number="5">    x = <span class="st">&quot;hello&quot;</span>s ;</a>
<a class="sourceLine" id="cb96-6" data-line-number="6">    x = <span class="dv">2</span> ;</a>
<a class="sourceLine" id="cb96-7" data-line-number="7">}</a></code></pre></div>
<p>C++では、変数<code>x</code>は整数型であり、文字列型に変わることはない。整数型の変数に文字列型を代入しようとするとエラーとなる。</p>
<p>C++では型に名前がついている。整数型はint、浮動小数点数型はdouble、文字列型はstd::stringだ。</p>
<div class="sourceCode" id="cb97"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb97-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb97-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb97-3" data-line-number="3">    <span class="co">// iはint型</span></a>
<a class="sourceLine" id="cb97-4" data-line-number="4">    <span class="kw">auto</span> i = <span class="dv">123</span> ;</a>
<a class="sourceLine" id="cb97-5" data-line-number="5">    <span class="co">// dはdouble型</span></a>
<a class="sourceLine" id="cb97-6" data-line-number="6">    <span class="kw">auto</span> d = <span class="fl">1.23</span> ;</a>
<a class="sourceLine" id="cb97-7" data-line-number="7">    <span class="co">// sはstd::string型</span></a>
<a class="sourceLine" id="cb97-8" data-line-number="8">    <span class="kw">auto</span> s = <span class="st">&quot;123&quot;</span>s ;</a>
<a class="sourceLine" id="cb97-9" data-line-number="9">}</a></code></pre></div>
<p>実は変数の宣言で<code>auto</code>と書くかわりに、具体的な型を書いてもよい。</p>
<div class="sourceCode" id="cb98"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb98-1" data-line-number="1"></a>
<a class="sourceLine" id="cb98-2" data-line-number="2"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb98-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb98-4" data-line-number="4">    <span class="dt">int</span> i           = <span class="dv">123</span> ;</a>
<a class="sourceLine" id="cb98-5" data-line-number="5">    <span class="dt">double</span> d        = <span class="fl">1.23</span> ;</a>
<a class="sourceLine" id="cb98-6" data-line-number="6">    <span class="bu">std::</span>string s   = <span class="st">&quot;123&quot;</span>s ;</a>
<a class="sourceLine" id="cb98-7" data-line-number="7">}</a></code></pre></div>
<p>整数型(int)と浮動小数点数型(double)はそれぞれお互いの型の変数に代入できる。ただし、変数の型は変わらない。単に一方の型の値がもう一方の型の値に変換されるだけだ。</p>
<div class="sourceCode" id="cb99"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb99-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb99-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb99-3" data-line-number="3">    <span class="co">// 浮動小数点数型を整数型に変換</span></a>
<a class="sourceLine" id="cb99-4" data-line-number="4">    <span class="dt">int</span> a = <span class="fl">3.14</span> ;</a>
<a class="sourceLine" id="cb99-5" data-line-number="5">    <span class="co">// 3</span></a>
<a class="sourceLine" id="cb99-6" data-line-number="6">    <span class="bu">std::</span>cout &lt;&lt; a &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb99-7" data-line-number="7"></a>
<a class="sourceLine" id="cb99-8" data-line-number="8">    <span class="co">// 整数型を浮動小数点数型に変換</span></a>
<a class="sourceLine" id="cb99-9" data-line-number="9">    <span class="dt">double</span> d = <span class="dv">123</span> ;</a>
<a class="sourceLine" id="cb99-10" data-line-number="10">    <span class="co">// 123</span></a>
<a class="sourceLine" id="cb99-11" data-line-number="11">    <span class="bu">std::</span>cout &lt;&lt; d ;</a>
<a class="sourceLine" id="cb99-12" data-line-number="12">}</a></code></pre></div>
<p>浮動小数点数型を整数型に変換すると、小数部が切り捨てられる。この場合、<code>3.14</code>の小数部<code>0.14</code>が切り捨てられ<code>3</code>となる。<code>0.9999</code>も小数部が切り捨てられ<code>0</code>になる。</p>
<div class="sourceCode" id="cb100"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb100-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb100-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb100-3" data-line-number="3">    <span class="dt">int</span> i = <span class="fl">0.9999</span> ;</a>
<a class="sourceLine" id="cb100-4" data-line-number="4">    <span class="co">// 0</span></a>
<a class="sourceLine" id="cb100-5" data-line-number="5">    <span class="bu">std::</span>cout &lt;&lt; i ;</a>
<a class="sourceLine" id="cb100-6" data-line-number="6">}</a></code></pre></div>
<p>整数型を浮動小数点数型に変換すると、値を正確に表現できる場合はその値になる。正確に表現できない場合は近い値になる。</p>
<div class="sourceCode" id="cb101"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb101-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb101-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb101-3" data-line-number="3">    <span class="dt">double</span> d = <span class="dv">1234567890</span> ;</a>
<a class="sourceLine" id="cb101-4" data-line-number="4">    <span class="co">// 正確に表現できるかどうかわからない</span></a>
<a class="sourceLine" id="cb101-5" data-line-number="5">    <span class="bu">std::</span>cout &lt;&lt; d ;</a>
<a class="sourceLine" id="cb101-6" data-line-number="6">}</a></code></pre></div>
<p>整数型と浮動小数点数型の挙動については後の章で詳しく解説する。また、これ以外にも型はいくらでもあるし、読者が新しい型を作り出すこともできる。これも後の章で詳しく解説する。</p>
<h2 id="関数function">関数(function)</h2>
<p>「変数ぐらい知っている。さっさと教えてもらいたい。どうせC++の関数は書きづらいのだろう」と考える読者の皆さん、おまたせしました。こちらがC++の関数でございます。</p>
<div class="sourceCode" id="cb102"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb102-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb102-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb102-3" data-line-number="3">    <span class="co">// 関数</span></a>
<a class="sourceLine" id="cb102-4" data-line-number="4">    <span class="kw">auto</span> print = [](<span class="kw">auto</span> x)</a>
<a class="sourceLine" id="cb102-5" data-line-number="5">    {</a>
<a class="sourceLine" id="cb102-6" data-line-number="6">        <span class="bu">std::</span>cout &lt;&lt; x &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb102-7" data-line-number="7">    } ;</a>
<a class="sourceLine" id="cb102-8" data-line-number="8"></a>
<a class="sourceLine" id="cb102-9" data-line-number="9">    <span class="co">// 関数呼び出し</span></a>
<a class="sourceLine" id="cb102-10" data-line-number="10">    print(<span class="dv">123</span>) ;</a>
<a class="sourceLine" id="cb102-11" data-line-number="11">    print(<span class="fl">3.14</span>) ;</a>
<a class="sourceLine" id="cb102-12" data-line-number="12">    print(<span class="st">&quot;hello&quot;</span>) ;</a>
<a class="sourceLine" id="cb102-13" data-line-number="13">}</a></code></pre></div>
<p>C++では関数も変数として扱える。<code>auto print =</code>までは変数だ。変数の初期化として関数を書いている。より正確にはラムダ式と呼ばれる関数を値として書くための文法だ。</p>
<p>ラムダ式は以下のような文法を持つ。</p>
<div class="sourceCode" id="cb103"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb103-1" data-line-number="1">[] <span class="co">// ラムダ式導入部</span></a>
<a class="sourceLine" id="cb103-2" data-line-number="2">() <span class="co">// 引数</span></a>
<a class="sourceLine" id="cb103-3" data-line-number="3">{} <span class="co">// 本体</span></a></code></pre></div>
<p>ラムダ式は<code>[]</code>で始まり、<code>()</code>の中に引数を書き、<code>{}</code>の中の文が実行される。</p>
<p>例えば以下は引数を2回標準出力する関数だ。</p>
<div class="sourceCode" id="cb104"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb104-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb104-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb104-3" data-line-number="3">    <span class="kw">auto</span> twice = [](<span class="kw">auto</span> x)</a>
<a class="sourceLine" id="cb104-4" data-line-number="4">    {</a>
<a class="sourceLine" id="cb104-5" data-line-number="5">        <span class="bu">std::</span>cout &lt;&lt; x &lt;&lt; <span class="st">&quot; &quot;</span>s &lt;&lt; x &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb104-6" data-line-number="6">    } ;</a>
<a class="sourceLine" id="cb104-7" data-line-number="7"></a>
<a class="sourceLine" id="cb104-8" data-line-number="8">    twice(<span class="dv">5</span>) ;</a>
<a class="sourceLine" id="cb104-9" data-line-number="9">}</a></code></pre></div>
<p>引数は<code>auto 引数名</code>で受け取れる。引数を複数取る場合は、カンマ<code>,</code>で区切る。</p>
<div class="sourceCode" id="cb105"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb105-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb105-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb105-3" data-line-number="3">    <span class="kw">auto</span> print_two = []( <span class="kw">auto</span> x, <span class="kw">auto</span> y )</a>
<a class="sourceLine" id="cb105-4" data-line-number="4">    {</a>
<a class="sourceLine" id="cb105-5" data-line-number="5">        <span class="bu">std::</span>cout &lt;&lt; x &lt;&lt; <span class="st">&quot; &quot;</span>s &lt;&lt; y &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb105-6" data-line-number="6">    } ;</a>
<a class="sourceLine" id="cb105-7" data-line-number="7"></a>
<a class="sourceLine" id="cb105-8" data-line-number="8">    print_two( <span class="dv">1</span>, <span class="dv">2</span> ) ;</a>
<a class="sourceLine" id="cb105-9" data-line-number="9">    print_two( <span class="st">&quot;Pi is&quot;</span>, <span class="fl">3.14</span> ) ;</a>
<a class="sourceLine" id="cb105-10" data-line-number="10">}</a></code></pre></div>
<p>引数を取らないラムダ式を書く場合は、単に<code>()</code>と書く。</p>
<div class="sourceCode" id="cb106"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb106-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb106-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb106-3" data-line-number="3">    <span class="kw">auto</span> no_args = []()</a>
<a class="sourceLine" id="cb106-4" data-line-number="4">    {</a>
<a class="sourceLine" id="cb106-5" data-line-number="5">        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Nothing.</span><span class="sc">\n</span><span class="st">&quot;</span> ;</a>
<a class="sourceLine" id="cb106-6" data-line-number="6">    } ;</a>
<a class="sourceLine" id="cb106-7" data-line-number="7"></a>
<a class="sourceLine" id="cb106-8" data-line-number="8">    no_args() ;</a>
<a class="sourceLine" id="cb106-9" data-line-number="9">}</a></code></pre></div>
<p>関数は演算子<code>operator ()</code>を関数の直後に書いて呼び出す。これが演算子であるというのは少し不思議な感じがするが、C++では紛れもなく演算子だ。<code>operator +</code>とか<code>operator -</code>などと同じ演算子だ。</p>
<div class="sourceCode" id="cb107"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb107-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb107-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb107-3" data-line-number="3">    <span class="co">// 何もしない関数</span></a>
<a class="sourceLine" id="cb107-4" data-line-number="4">    <span class="kw">auto</span> func = [](){} ;</a>
<a class="sourceLine" id="cb107-5" data-line-number="5"></a>
<a class="sourceLine" id="cb107-6" data-line-number="6">    <span class="co">// operator ()の適用</span></a>
<a class="sourceLine" id="cb107-7" data-line-number="7">    func() ;</a>
<a class="sourceLine" id="cb107-8" data-line-number="8">    <span class="co">// これもoperator ()</span></a>
<a class="sourceLine" id="cb107-9" data-line-number="9">    func    (   ) ;</a>
<a class="sourceLine" id="cb107-10" data-line-number="10">}</a></code></pre></div>
<p>演算子<code>operator ()</code>は、ラムダ式そのものに対して適用することもできる。</p>
<div class="sourceCode" id="cb108"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb108-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb108-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb108-3" data-line-number="3">    <span class="co">// 変数fをラムダ式で初期化</span></a>
<a class="sourceLine" id="cb108-4" data-line-number="4">    <span class="kw">auto</span> f = [](){} ;</a>
<a class="sourceLine" id="cb108-5" data-line-number="5">    <span class="co">// 変数fを関数呼び出し</span></a>
<a class="sourceLine" id="cb108-6" data-line-number="6">    f() ;</a>
<a class="sourceLine" id="cb108-7" data-line-number="7"></a>
<a class="sourceLine" id="cb108-8" data-line-number="8">    <span class="co">// ラムダ式を関数呼び出し</span></a>
<a class="sourceLine" id="cb108-9" data-line-number="9">    [](){}() ;</a>
<a class="sourceLine" id="cb108-10" data-line-number="10">}</a></code></pre></div>
<p>このコードを見ると、<code>operator ()</code>が単なる演算子であることがよくわかるだろう。<code>[](){}</code>がラムダ式でその直後の<code>()</code>が関数呼び出し演算子だ。</p>
<p>関数は値を返すことができる。関数から値を返すには、<code>return文</code>を使う。</p>
<div class="sourceCode" id="cb109"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb109-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb109-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb109-3" data-line-number="3">    <span class="kw">auto</span> plus = []( <span class="kw">auto</span> x, <span class="kw">auto</span> y )</a>
<a class="sourceLine" id="cb109-4" data-line-number="4">        { <span class="cf">return</span> x + y ; } ;</a>
<a class="sourceLine" id="cb109-5" data-line-number="5"></a>
<a class="sourceLine" id="cb109-6" data-line-number="6">    <span class="bu">std::</span>cout</a>
<a class="sourceLine" id="cb109-7" data-line-number="7">        &lt;&lt; plus( <span class="dv">1</span>, <span class="dv">2</span> ) &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s</a>
<a class="sourceLine" id="cb109-8" data-line-number="8">        &lt;&lt; plus( <span class="fl">1.5</span>, <span class="fl">0.5</span> ) &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s</a>
<a class="sourceLine" id="cb109-9" data-line-number="9">        &lt;&lt; plus( <span class="st">&quot;123&quot;</span>s, <span class="st">&quot;456&quot;</span>s) ;</a>
<a class="sourceLine" id="cb109-10" data-line-number="10">}</a></code></pre></div>
<p>関数はreturn文を実行すると処理を関数の呼び出し元に返す。</p>
<div class="sourceCode" id="cb110"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb110-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb110-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb110-3" data-line-number="3">    <span class="kw">auto</span> f = []()</a>
<a class="sourceLine" id="cb110-4" data-line-number="4">    {</a>
<a class="sourceLine" id="cb110-5" data-line-number="5">        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;f is called.</span><span class="sc">\n</span><span class="st">&quot;</span> ;</a>
<a class="sourceLine" id="cb110-6" data-line-number="6">        <span class="cf">return</span> <span class="dv">0</span> ; <span class="co">// ここで処理が戻る</span></a>
<a class="sourceLine" id="cb110-7" data-line-number="7">        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;f returned zero.</span><span class="sc">\n</span><span class="st">&quot;</span> ;</a>
<a class="sourceLine" id="cb110-8" data-line-number="8">    } ;</a>
<a class="sourceLine" id="cb110-9" data-line-number="9"></a>
<a class="sourceLine" id="cb110-10" data-line-number="10">    <span class="kw">auto</span> result = f() ;</a>
<a class="sourceLine" id="cb110-11" data-line-number="11">}</a></code></pre></div>
<p>これを実行すると以下のようになる。</p>
<pre><code>$ make
f is called.</code></pre>
<p>return文以降の文が実行されていないことがわかる。</p>
<h2 id="本当の関数">本当の関数</h2>
<p>実はラムダ式は本当のC++の<code>関数</code>ではない。本当の<code>関数</code>はとても書きづらいので心して読むべきだ。</p>
<p>読者は本書の冒頭で使った<code>main関数</code>という言葉を覚えているだろうか。覚えていないとしても、サンプルコードに必ずと行っていいほど出てくる<code>main</code>という名前は気になっていたことだろう。</p>
<div class="sourceCode" id="cb112"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb112-1" data-line-number="1"><span class="dt">int</span> main(){}</a></code></pre></div>
<p>これをみると、聡明な読者はラムダ式と似通ったところがあることに気づくだろう。</p>
<div class="sourceCode" id="cb113"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb113-1" data-line-number="1">[](){}</a></code></pre></div>
<p>末尾の<code>(){}</code>が同じだ。これは同じ意味だ。<code>()</code>は関数の引数で、<code>{}</code>は関数の本体だ。</p>
<p>では残りの部分はどうだろうか。<code>int</code>は関数の戻り値の型、<code>main</code>は関数の名前だ。</p>
<p>C++の本当の関数は以下のような文法で定義される。</p>
<div class="sourceCode" id="cb114"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb114-1" data-line-number="1"><span class="dt">int</span>     <span class="co">// 戻り値の型</span></a>
<a class="sourceLine" id="cb114-2" data-line-number="2">main    <span class="co">// 関数名</span></a>
<a class="sourceLine" id="cb114-3" data-line-number="3">()      <span class="co">// 関数の引数</span></a>
<a class="sourceLine" id="cb114-4" data-line-number="4">{}      <span class="co">// 関数の本体</span></a></code></pre></div>
<p>ためしに、int型の引数を2つ取り足して返す関数<code>plus</code>を書いてみよう。</p>
<div class="sourceCode" id="cb115"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb115-1" data-line-number="1"><span class="dt">int</span> plus( <span class="dt">int</span> x, <span class="dt">int</span> y )</a>
<a class="sourceLine" id="cb115-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb115-3" data-line-number="3">    <span class="cf">return</span> x + y ;</a>
<a class="sourceLine" id="cb115-4" data-line-number="4">}</a>
<a class="sourceLine" id="cb115-5" data-line-number="5"></a>
<a class="sourceLine" id="cb115-6" data-line-number="6"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb115-7" data-line-number="7">{</a>
<a class="sourceLine" id="cb115-8" data-line-number="8">    <span class="kw">auto</span> x = plus( <span class="dv">1</span>, <span class="dv">2</span> ) ;</a>
<a class="sourceLine" id="cb115-9" data-line-number="9">}</a></code></pre></div>
<p>では次に、double型の引数を2つ取り足して返す関数<code>plus</code>を書いてみよう。</p>
<div class="sourceCode" id="cb116"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb116-1" data-line-number="1"><span class="dt">double</span> plus( <span class="dt">double</span> x, <span class="dt">double</span> y )</a>
<a class="sourceLine" id="cb116-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb116-3" data-line-number="3">    <span class="cf">return</span> x + y ;</a>
<a class="sourceLine" id="cb116-4" data-line-number="4">}</a>
<a class="sourceLine" id="cb116-5" data-line-number="5"></a>
<a class="sourceLine" id="cb116-6" data-line-number="6"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb116-7" data-line-number="7">{</a>
<a class="sourceLine" id="cb116-8" data-line-number="8">    <span class="kw">auto</span> x = plus( <span class="fl">1.0</span>, <span class="fl">2.0</span> ) ;</a>
<a class="sourceLine" id="cb116-9" data-line-number="9">}</a></code></pre></div>
<p>最後のstd::string型の引数を2つ取り足して返す関数<code>plus</code>は読者への課題とする。</p>
<p>これがC++の本当の関数だ。C++の関数では、型をすべて明示的に書かなければならない。型を間違えるとエラーだ。</p>
<p>しかも、C++の関数は、戻り値の型を正しく返さなければならない。</p>
<div class="sourceCode" id="cb117"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb117-1" data-line-number="1"><span class="dt">int</span> f()</a>
<a class="sourceLine" id="cb117-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb117-3" data-line-number="3">    <span class="co">// エラー、return文がない</span></a>
<a class="sourceLine" id="cb117-4" data-line-number="4">}</a></code></pre></div>
<p>もし、何も値を返さない関数を書く場合は、どの値でもないという特別な型、<code>void</code>型を関数の戻り値の型として書かなければならないという特別なルールまである。</p>
<div class="sourceCode" id="cb118"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb118-1" data-line-number="1"><span class="dt">void</span> f()</a>
<a class="sourceLine" id="cb118-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb118-3" data-line-number="3">    <span class="co">// OK</span></a>
<a class="sourceLine" id="cb118-4" data-line-number="4">}</a></code></pre></div>
<p>ただし、戻り値の型については、具体的な型の代わりに<code>auto</code>を書くこともできる。その場合、return文で同じ型さえ返していれば、気にする必要はない。</p>
<div class="sourceCode" id="cb119"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb119-1" data-line-number="1"><span class="co">// void</span></a>
<a class="sourceLine" id="cb119-2" data-line-number="2"><span class="kw">auto</span> a() { }</a>
<a class="sourceLine" id="cb119-3" data-line-number="3"><span class="co">// int</span></a>
<a class="sourceLine" id="cb119-4" data-line-number="4"><span class="kw">auto</span> b() { <span class="cf">return</span> <span class="dv">0</span> ; }</a>
<a class="sourceLine" id="cb119-5" data-line-number="5"><span class="co">// double</span></a>
<a class="sourceLine" id="cb119-6" data-line-number="6"><span class="kw">auto</span> c() { <span class="cf">return</span> <span class="fl">0.0</span> ; }</a>
<a class="sourceLine" id="cb119-7" data-line-number="7"><span class="co">// std::string</span></a>
<a class="sourceLine" id="cb119-8" data-line-number="8"><span class="kw">auto</span> d() { <span class="cf">return</span> <span class="st">&quot;&quot;</span>s ; }</a>
<a class="sourceLine" id="cb119-9" data-line-number="9"></a>
<a class="sourceLine" id="cb119-10" data-line-number="10"><span class="co">// エラー</span></a>
<a class="sourceLine" id="cb119-11" data-line-number="11"><span class="co">// return文の型が一致しない。</span></a>
<a class="sourceLine" id="cb119-12" data-line-number="12"><span class="kw">auto</span> e()</a>
<a class="sourceLine" id="cb119-13" data-line-number="13">{</a>
<a class="sourceLine" id="cb119-14" data-line-number="14">    <span class="cf">return</span> <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb119-15" data-line-number="15">    <span class="cf">return</span> <span class="fl">0.0</span> ;</a>
<a class="sourceLine" id="cb119-16" data-line-number="16">}</a></code></pre></div>
<h1 id="デバッグコンパイルエラーメッセージの読み方">デバッグ：コンパイルエラーメッセージの読み方</h1>
<p>やれやれ疲れた。この辺で一休みして、デバッグについて考えよう。まずはコンパイルエラーについてだ。</p>
<p>プログラムには様々なバグがあるが、コンパイルエラーは最も簡単なバグだ。というのも、プログラムのバグの存在が実行前に発覚したわけだから、手間が省ける。もしコンパイルエラーにならない場合、実行した結果から、バグがあるかどうかを判断しなければならない。</p>
<p>読者の中には、せっかく書いたソースコードをコンパイルしたらコンパイルエラーが出たので、運が悪かったとか、失敗したとか、怒られてつらい気持ちになったなどと感じることがあるかもしれない。しかしそれは大違いだ。コンパイラーによって読者はプログラムを実行することなくバグが発見できたのだから、読者は運が良かった、大成功した、褒められて最高の気持ちになったと感じるべきなのだ。</p>
<p>さあ皆さんご一緒に、</p>
<ul>
<li>コンパイルエラーは普通</li>
<li>コンパイルエラーが出たらありがとう</li>
<li>コンパイルエラーがでたら大喜び</li>
</ul>
<p>熟練のプログラマーは自分の書いたコードがコンパイルエラーを出さずに一発でコンパイルが通った場合、逆に不安になるくらいだ。</p>
<p>もしバグがあるのにコンパイルエラーが出なければ、バグの存在に気が付かないまま、読者の書いたソフトウェアは広く世の中に使われ、10年後、20年後に最もバグが発見されてほしくない方法で発見されてしまうかもしれない。すなわち、セキュリティ上問題となる脆弱性という形での発覚だ。しかし安心してほしい。今読者が出したコンパイルエラーによって、そのような悲しい未来の可能性は永久に排除されたのだ。コンパイルエラーはどんどん出すとよい。</p>
<p>コンパイルエラーの原因は2つ。</p>
<ol type="1">
<li>文法エラー</li>
<li>意味エラー</li>
<li>コンパイラーのバグ</li>
</ol>
<p>3つだった。コンパイルエラーの原因は3つ。</p>
<ol type="1">
<li>文法エラー</li>
<li>意味エラー</li>
<li>コンパイラーのバグ</li>
<li>コンピューターの故障</li>
</ol>
<p>4つだった。ただ、3.と4.はめったにないから無視してよい。</p>
<h2 id="文法エラー">文法エラー</h2>
<p>文法エラーとは、C++というプログラミング言語の文法に従っていないエラーのことだ。これはC++として解釈できないので、当然エラーになる。</p>
<p>よくある文法エラーとしては、文末のセミコロンを打ち忘れたものがある。例えば以下のコードには間違いがある。</p>
<div class="sourceCode" id="cb120"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb120-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb120-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb120-3" data-line-number="3">    <span class="kw">auto</span> x = <span class="dv">1</span> + <span class="dv">1</span> </a>
<a class="sourceLine" id="cb120-4" data-line-number="4">    <span class="kw">auto</span> y = x + <span class="dv">1</span> ;</a>
<a class="sourceLine" id="cb120-5" data-line-number="5">}</a></code></pre></div>
<p>これをコンパイルすると以下のようにコンパイルエラーメッセージが出力される。</p>
<pre><code>$ make
g++ -std=c++17 -Wall --pedantic-error -include all.h main.cpp -o program
main.cpp: In function ‘int main()’:
main.cpp:4:5: error: expected ‘,’ or ‘;’ before ‘auto’
     auto y = x + 1 ;
     ^~~~
main.cpp:3:10: warning: unused variable ‘x’ [-Wunused-variable]
     auto x = 1 + 1
          ^
Makefile:4: recipe for target &#39;program&#39; failed
make: *** [program] Error 1</code></pre>
<p>コンパイラーのメッセージを読み慣れていない読者はここで考えることを放棄してコンピューターの電源を落とし家を出て街を徘徊し夕日を見つめて人生、宇宙、すべてについての究極の質問への答えを模索してしまうことだろう。</p>
<p>しかし恐れるなかれ。コンパイラーのエラーメッセージを読み解くのは難しくない。</p>
<p>まず最初の2行を見てみよう。</p>
<pre><code>$ make
g++ -std=c++17 -Wall --pedantic-error -include all.h main.cpp -o program</code></pre>
<p>1行目はシェルにmakeを実行させるためのコマンド、二行目はmakeが実行したレシピの中身だ。これはコンパイラーによるメッセージではない。</p>
<p>3行目からはコンパイラーによる出力だ。</p>
<pre><code>main.cpp: In function ‘int main()’:</code></pre>
<p>コンパイラーはソースファイル<code>main.cpp</code>の中の、<code>int main()</code>という関数について、特に言うべきことがあると主張している。</p>
<p>言うべきこととは以下だ。</p>
<pre><code>main.cpp:4:5: error: expected ‘,’ or ‘;’ before ‘auto’
     auto y = x + 1 ;
     ^~~~</code></pre>
<p>GCCというコンパイラーのエラーメッセージは、以下のフォーマットを採用している。</p>
<pre><code>ソースファイル名:行番号:列番号: メッセージの種類: メッセージの内容</code></pre>
<p>ここでのメッセージの種類は<code>error</code>、つまりこのメッセージはエラーを伝えるものだ。</p>
<p>ソースファイル名は<code>main.cpp</code>、つまりエラーは<code>main.cpp</code>の中にあるということだ。</p>
<p>行番号というのは、最初の行を1行目とし、改行ごとにインクリメントされていく。今回のソースファイルの場合、以下のようになる。</p>
<pre><code>1 int main()
2 {
3     auto x = 1 + 1 
4     auto y = x + 1 ;
5 }</code></pre>
<p>もし読者が素晴らしいテキストエディターであるVimを使っている場合、<code>:set nu</code>すると行番号を表示できる。</p>
<p>その上でエラーメッセージの行番号を確認すると<code>4</code>とある。つまりコンパイラーは4行目に問題があると考えているわけだ。</p>
<p>4行目を確認してみよう。</p>
<pre><code>    auto y = x + 1 ;</code></pre>
<p>何の問題もないように見える。更にエラーメッセージを読んでみよう。</p>
<p>列番号が<code>5</code>となっている。列番号というのは、行頭からの文字数だ。最初の文字を1文字目とし、文字ごとにインクリメントされていく。</p>
<pre><code>123456789...
    auto y = x + 1 ;</code></pre>
<p>4行目は空白文字を4つ使ってインデントしているので、autoのaの列番号は5だ。ここに問題があるのだろうか。何も問題がないように見える。</p>
<p>この謎を解くためには、メッセージの内容を読まなければならない。</p>
<pre><code>expected ‘,’ or ‘;’ before ‘auto’
     auto y = x + 1 ;
     ^~~</code></pre>
<p>これは日本語に翻訳すると以下のようになる。</p>
<pre><code>‘auto’の前に&#39;,&#39;か&#39;;&#39;があるべき
     auto y = x + 1 ;
     ^~~</code></pre>
<p>1行目はエラー内容をテキストで表現したものだ。これによると、‘auto’の前に’,‘か’;’があるべきとあるが、やはりまだわからない。</p>
<p>2行目は問題のある箇所のソースコードを部分的に抜粋したもので、3行目はそのソースコードの問題のある文字を視覚的にわかりやすく示しているものだ。</p>
<p>ともかく、コンパイラーの指示に従って’auto’の前に’,’を付けてみよう。</p>
<pre><code>    ,auto y = x + 1 ;</code></pre>
<p>これをコンパイルすると、また違ったエラーメッセージが表示される。</p>
<pre><code>main.cpp: In function ‘int main()’:
main.cpp:4:6: error: expected unqualified-id before ‘auto’
     ,auto y = x + 1 ;
      ^~~~</code></pre>
<p>では’;’ならばどうか。</p>
<pre><code>    ;auto y = x + 1 ;</code></pre>
<p>これはコンパイルが通るようだ。</p>
<p>しかしなぜこれでコンパイルが通るのだろう。そのためには、コンパイラーが問題だとした行の一つ上の行を見る必要がある。</p>
<pre><code>    auto x = 1 + 1
    auto y = x + 1 ;</code></pre>
<p>コンパイラーにとって、改行は空白文字と同じくソースファイル中の意味のあるトークン(キーワードや名前や記号)を区切る文字でしかない。コンパイラーにとって、このコードは実質以下のように見えてる。</p>
<pre><code>auto x=1+1 auto y=x+1;</code></pre>
<p>“1 auto”というのは文法エラーだ。なのでコンパイラーは文法エラーが発覚する最初の文字である’auto’の’a’を指摘したのだ。</p>
<p>人間にとって自然になるように修正すると、コンパイラーが指摘した行の一つ上の行の行末に’;’を追加すべきだ。</p>
<pre><code>    auto x = 1 + 1 ;
    auto y = x + 1 ;</code></pre>
<p>さて、問題自体は解決したわけだが、残りのメッセージも見ていこう。</p>
<pre><code>main.cpp:3:10: warning: unused variable ‘x’ [-Wunused-variable]
     auto x = 1 + 1</code></pre>
<p>これはコンパイラーによる警告メッセージだ。警告メッセージについて詳しくは、デバッグ：警告メッセージの章で解説する。</p>
<pre><code>Makefile:4: recipe for target &#39;program&#39; failed
make: *** [program] Error 1</code></pre>
<p>これはGNU makeによるメッセージだ。GCCがソースファイルを正しくコンパイルできず、実行が失敗したとエラーを返したので、レシピの実行が失敗したことを伝えるメッセージだ。</p>
<p>プログラムはどうやってエラーを通知するのか。main関数の戻り値によってだ。main関数は関数であるので、戻り値がある。main関数の戻り値はint型だ。</p>
<div class="sourceCode" id="cb139"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb139-1" data-line-number="1"><span class="co">// 戻り値の型</span></a>
<a class="sourceLine" id="cb139-2" data-line-number="2"><span class="dt">int</span></a>
<a class="sourceLine" id="cb139-3" data-line-number="3"><span class="co">// main関数の残りの部分</span></a>
<a class="sourceLine" id="cb139-4" data-line-number="4">main() { }</a></code></pre></div>
<p>main関数が何も値を返さない場合、<code>return 0</code>したものとみなされる。main関数が<code>0</code>もしくは<code>EXIT_SUCCESS</code>を返した場合、プログラムの実行の成功を通知したことになる。</p>
<div class="sourceCode" id="cb140"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb140-1" data-line-number="1"><span class="co">// 必ず実行が成功したと通知するプログラム</span></a>
<a class="sourceLine" id="cb140-2" data-line-number="2"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb140-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb140-4" data-line-number="4">    <span class="cf">return</span> <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb140-5" data-line-number="5">}</a></code></pre></div>
<p>プログラムの実行が失敗した場合、main関数は<code>EXIT_FAILURE</code>を返すことでエラーを通知できる。</p>
<div class="sourceCode" id="cb141"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb141-1" data-line-number="1"><span class="co">// 必ず実行が失敗したと通知するプログラム</span></a>
<a class="sourceLine" id="cb141-2" data-line-number="2"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb141-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb141-4" data-line-number="4">    <span class="cf">return</span> EXIT_FAILURE ;</a>
<a class="sourceLine" id="cb141-5" data-line-number="5">}</a></code></pre></div>
<p><code>EXIT_SUCCESS</code>と<code>EXIT_FAILURE</code>はマクロだ。</p>
<div class="sourceCode" id="cb142"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb142-1" data-line-number="1"><span class="pp">#define EXIT_SUCCESS</span></a>
<a class="sourceLine" id="cb142-2" data-line-number="2"><span class="pp">#define EXIT_FAILURE</span></a></code></pre></div>
<p>その中身はC++標準規格では規定されていない。どうしても値を知りたい場合は以下のプログラムを実行してみるとよい。</p>
<div class="sourceCode" id="cb143"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb143-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb143-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb143-3" data-line-number="3">    <span class="bu">std::</span>cout</a>
<a class="sourceLine" id="cb143-4" data-line-number="4">        &lt;&lt; <span class="st">&quot;EXIT_SUCCESS: &quot;</span>s &lt;&lt; EXIT_SUCCESS &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s</a>
<a class="sourceLine" id="cb143-5" data-line-number="5">        &lt;&lt; <span class="st">&quot;EXIT_FAILURE: &quot;</span>s   &lt;&lt; EXIT_FAILURE ;  </a>
<a class="sourceLine" id="cb143-6" data-line-number="6">}</a></code></pre></div>
<p>文法エラーというのは厄介なバグだ。というのも、コンパイラーというのは正しい文法のソースファイルを処理するように作られている。文法を間違えた場合、ソースファイル全体が正しくないということになる。コンパイラーは文法違反に遭遇した場合、なるべく人間がよく間違えそうなパターンをヒューリスティックに指摘することもしている。そのため、エラーメッセージに指摘された行番号と列番号は、必ずしも人間にとっての問題の箇所と一致しない。</p>
<p>もうひとつ例を見てみよう。</p>
<div class="sourceCode" id="cb144"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb144-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb144-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb144-3" data-line-number="3">    <span class="co">// 引数を3つとって足して返す関数</span></a>
<a class="sourceLine" id="cb144-4" data-line-number="4">    <span class="kw">auto</span> f = [](<span class="kw">auto</span> a, <span class="kw">auto</span> b, <span class="kw">auto</span> c)</a>
<a class="sourceLine" id="cb144-5" data-line-number="5">    { <span class="cf">return</span> a + b + c ; } ;</a>
<a class="sourceLine" id="cb144-6" data-line-number="6"></a>
<a class="sourceLine" id="cb144-7" data-line-number="7">    <span class="bu">std::</span>cout &lt;&lt; f(<span class="dv">1</span>+(<span class="dv">2</span>*<span class="dv">3</span>),<span class="dv">4-5</span>,<span class="dv">6</span>/(<span class="dv">7-8</span>))) ;</a>
<a class="sourceLine" id="cb144-8" data-line-number="8">}</a></code></pre></div>
<p>GCCによるコンパイルエラーメッセージだけ抜粋すると以下の通り、</p>
<pre><code>main.cpp: In function ‘int main()’:
main.cpp:7:40: error: expected ‘;’ before ‘)’ token
     std::cout &lt;&lt; f(1+(2*3),4-5,6/(7-8))) ;
                                        ^</code></pre>
<p>さて早速読んでみよう。すでに学んだように、GCCのメッセージのフォーマットは以下の通りだ。</p>
<pre><code>ソースファイル名:行番号:列番号: メッセージの種類: メッセージの内容</code></pre>
<p>これに当てはめると、問題はソースファイル<code>main.cpp</code>の7行目の40列目にある。</p>
<p>エラーメッセージは、「‘;’か’)’がトークンの前にあるべき」だ。</p>
<p>トークン(token)というのは’std’とか’::’とか’cout’といったソースファイルの空白文字で区切られた最小の文字列の単位のことだ。</p>
<p>抜粋されたソースコードに示された問題の箇所、つまり7行目40列目にあるトークンは’)‘だ。この前に’;’が必要とはどういうことだろう。</p>
<p>問題を探るため、7行目のトークンを詳しく分解してみよう。以下は7行目と同じソースコードだが、トークンをわかりやすく分解してある</p>
<pre><code>std::cout &lt;&lt; // 標準出力
f // 関数名
    ( // 空き括弧
        1+(2*3),    // 第1引数
        4-5,        // 第2引数
        6/(7-8)     // 第3引数
    ) // 空き括弧に対応する閉じ括弧
    ) // ???
    ; // 終端文字</code></pre>
<p>これを見ると、閉じ括弧が一つ多いことがわかる。</p>
<h2 id="意味エラー">意味エラー</h2>
<p>意味エラーとは、ソースファイルは文法的に正しいが、意味的に間違っているコンパイルエラーのことだ。</p>
<p>早速例を見ていこう。</p>
<div class="sourceCode" id="cb148"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb148-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb148-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb148-3" data-line-number="3">    <span class="kw">auto</span> x = <span class="fl">1.0</span> % <span class="fl">1.0</span> ;</a>
<a class="sourceLine" id="cb148-4" data-line-number="4">}</a></code></pre></div>
<p>このコードをコンパイルすると出力されるエラーメッセージは以下の通り。</p>
<pre><code>main.cpp: In function ‘int main()’:
main.cpp:3:18: error: invalid operands of types ‘double’ and ‘double’ to binary ‘operator%’
     auto x = 1.0 % 1.0 ;
              ~~~~^~~~~</code></pre>
<p>問題の箇所は3行目の18列目、’%’だ。</p>
<p>エラーメッセージは、「二項 ‘operator%’に対して不適切なオペランドである型’double’と’double’」とある。</p>
<p>前の章を読み直すとわかるとおり、<code>operator %</code>は剰余を計算する演算子だが、この演算子には<code>double</code>型を渡すことはできない。</p>
<p>このコードはどうだろう。</p>
<div class="sourceCode" id="cb150"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb150-1" data-line-number="1"><span class="co">// 引数を一つ取る関数</span></a>
<a class="sourceLine" id="cb150-2" data-line-number="2"><span class="dt">void</span> f( <span class="dt">int</span> x ) { }</a>
<a class="sourceLine" id="cb150-3" data-line-number="3"></a>
<a class="sourceLine" id="cb150-4" data-line-number="4"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb150-5" data-line-number="5">{</a>
<a class="sourceLine" id="cb150-6" data-line-number="6">    <span class="co">// 引数を2つ渡す</span></a>
<a class="sourceLine" id="cb150-7" data-line-number="7">    f( <span class="dv">1</span>, <span class="dv">2</span> ) ;</a>
<a class="sourceLine" id="cb150-8" data-line-number="8">}</a></code></pre></div>
<p>このようなエラーメッセージになる。</p>
<pre><code>
main.cpp: In function ‘int main()’:
main.cpp:7:13: error: too many arguments to function ‘void f(int)’
     f( 1, 2 ) ;
             ^
main.cpp:2:6: note: declared here
 void f( int x ) { }
      ^</code></pre>
<p>問題の箇所は7行目。「関数’void f(int)’に対して実引数が多すぎる」とある。<code>関数f</code>は引数を一つしか取らないのに、2つの引数を渡しているのがエラーの原因だ。</p>
<p>2つめのメッセージはエラーではなくて、エラーを補足説明するための注記(note)メッセージだ。ここで言及している<code>関数f</code>とは、2行目に宣言されていることを説明してくれている。</p>
<p>意味エラーは時としておぞましいほどのエラーメッセージを生成することがある。例えば以下の一件無害そうなコードだ。</p>
<div class="sourceCode" id="cb152"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb152-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb152-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb152-3" data-line-number="3">    <span class="st">&quot;hello&quot;</span>s &lt;&lt; <span class="dv">1</span> ;</a>
<a class="sourceLine" id="cb152-4" data-line-number="4">}</a></code></pre></div>
<p>このコードは文法的に正しいが、意味的に間違っているコードだ。このコードをコンパイルすると膨大なエラーメッセージが出力される。しかも問題の行番号特定以外、大して役に立たない。</p>
<h2 id="コンパイラーのバグ">コンパイラーのバグ</h2>
<p>C++コンパイラーもソフトウェアであり、バグがある。コンパイラーにバグがある場合、正しいC++のソースファイルがコンパイルできないことがある。</p>
<p>読者がそのようなコンパイラーの秘孔を突くコードを書くことはまれだ。しかし、もしそのようなコードを偶然にも書いてしまった場合、GCCは、</p>
<pre><code>gcc: internal compiler error: エラー内容
Please submit a full bug report,
with preprocessed source if appropriate.
See &lt;ドキュメントへのファイルパス&gt; for instructions.</code></pre>
<p>のようなメッセージを出力する。</p>
<p>これはGCCのバグなので、見つけた読者は適切な方法でバグ報告をしよう。</p>
<h1 id="条件分岐の果てのレストラン">条件分岐の果てのレストラン</h1>
<p>さてC++の勉強に戻ろう。この章では条件分岐について学ぶ。</p>
<h2 id="複合文">複合文</h2>
<p>条件分岐とループについて学ぶ前に、まず<code>複合文(compound statement)</code>や<code>ブロック(block)</code>と呼ばれている、複数の文をひとまとめにする文について学ばなければならない。</p>
<p>C++では<code>文(statement)</code>が実行される。<code>文</code>については詳しく説明すると長くなるが、’;’で区切られたものが<code>文</code>だ。</p>
<div class="sourceCode" id="cb154"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb154-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb154-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb154-3" data-line-number="3">    <span class="co">// 文</span></a>
<a class="sourceLine" id="cb154-4" data-line-number="4">    <span class="kw">auto</span> x = <span class="dv">1</span> + <span class="dv">1</span> ;</a>
<a class="sourceLine" id="cb154-5" data-line-number="5">    <span class="co">// 文</span></a>
<a class="sourceLine" id="cb154-6" data-line-number="6">    <span class="bu">std::</span>cout &lt;&lt; x ;</a>
<a class="sourceLine" id="cb154-7" data-line-number="7"></a>
<a class="sourceLine" id="cb154-8" data-line-number="8">    <span class="co">// 空文</span></a>
<a class="sourceLine" id="cb154-9" data-line-number="9">    <span class="co">// 実は空っぽの文も書ける。</span></a>
<a class="sourceLine" id="cb154-10" data-line-number="10">    ;</a>
<a class="sourceLine" id="cb154-11" data-line-number="11">}</a></code></pre></div>
<p>複数の<code>文</code>を<code>{}</code>で囲むことで、一つの文として扱うことができる。これを<code>複合文</code>という</p>
<div class="sourceCode" id="cb155"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb155-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb155-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb155-3" data-line-number="3">    <span class="co">// 複合文開始</span></a>
<a class="sourceLine" id="cb155-4" data-line-number="4">    {</a>
<a class="sourceLine" id="cb155-5" data-line-number="5">        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;hello</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb155-6" data-line-number="6">        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;hello</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb155-7" data-line-number="7">    } <span class="co">// 複合文終了</span></a>
<a class="sourceLine" id="cb155-8" data-line-number="8"></a>
<a class="sourceLine" id="cb155-9" data-line-number="9">    <span class="co">// 別の複合文</span></a>
<a class="sourceLine" id="cb155-10" data-line-number="10">    { <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;world</span><span class="sc">\n</span><span class="st">&quot;</span>s ; }</a>
<a class="sourceLine" id="cb155-11" data-line-number="11"></a>
<a class="sourceLine" id="cb155-12" data-line-number="12">    <span class="co">// 空の複合文</span></a>
<a class="sourceLine" id="cb155-13" data-line-number="13">    { }</a>
<a class="sourceLine" id="cb155-14" data-line-number="14">}</a></code></pre></div>
<p><code>複合文</code>には’;’はいらない。</p>
<div class="sourceCode" id="cb156"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb156-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb156-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb156-3" data-line-number="3">    <span class="co">// ;はいらない</span></a>
<a class="sourceLine" id="cb156-4" data-line-number="4">    { }</a>
<a class="sourceLine" id="cb156-5" data-line-number="5"></a>
<a class="sourceLine" id="cb156-6" data-line-number="6">    <span class="co">// これは空の複合文に続いて</span></a>
<a class="sourceLine" id="cb156-7" data-line-number="7">    <span class="co">// 空文があるだけのコード</span></a>
<a class="sourceLine" id="cb156-8" data-line-number="8">    { } ;</a>
<a class="sourceLine" id="cb156-9" data-line-number="9">}</a></code></pre></div>
<p><code>複合文</code>の中に<code>複合文</code>を書くこともできる。</p>
<div class="sourceCode" id="cb157"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb157-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb157-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb157-3" data-line-number="3">    {{{}}} ;</a>
<a class="sourceLine" id="cb157-4" data-line-number="4">}</a></code></pre></div>
<p><code>関数の本体</code>としての一番外側’{}’はこの<code>複合文</code>とは別のものだが、読者はまだ気にする必要はない。</p>
<p><code>複合文</code>は複数の<code>文</code>をひとまとめにして、ひとつの<code>文</code>として扱えるようにするぐらいの意味しか持っていない。ただし、変数の見え方に影響する。変数は宣言された最も内側の複合文の中でしか使えない。</p>
<div class="sourceCode" id="cb158"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb158-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb158-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb158-3" data-line-number="3">    <span class="kw">auto</span> a = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb158-4" data-line-number="4"></a>
<a class="sourceLine" id="cb158-5" data-line-number="5">    {</a>
<a class="sourceLine" id="cb158-6" data-line-number="6">        <span class="kw">auto</span> b = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb158-7" data-line-number="7">        {</a>
<a class="sourceLine" id="cb158-8" data-line-number="8">            <span class="kw">auto</span> c = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb158-9" data-line-number="9">            <span class="co">// cはここまで使える</span></a>
<a class="sourceLine" id="cb158-10" data-line-number="10">        }</a>
<a class="sourceLine" id="cb158-11" data-line-number="11">        <span class="co">// bはここまで使える</span></a>
<a class="sourceLine" id="cb158-12" data-line-number="12">    }</a>
<a class="sourceLine" id="cb158-13" data-line-number="13">    <span class="co">// aはここまで使える</span></a>
<a class="sourceLine" id="cb158-14" data-line-number="14">}</a></code></pre></div>
<p>これを専門用語では<code>変数</code>の<code>寿命</code>とか<code>ブロックスコープ(block-scope)</code>という。</p>
<p>内側のブロックスコープの変数が、外側のブロックスコープの変数と同じ名前を持っていた場合はエラーではない。外側の変数が内側の変数で隠される。</p>
<div class="sourceCode" id="cb159"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb159-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb159-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb159-3" data-line-number="3">    <span class="kw">auto</span> x = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb159-4" data-line-number="4">    {</a>
<a class="sourceLine" id="cb159-5" data-line-number="5">        <span class="kw">auto</span> x = <span class="dv">1</span> ;</a>
<a class="sourceLine" id="cb159-6" data-line-number="6">        {</a>
<a class="sourceLine" id="cb159-7" data-line-number="7">            <span class="kw">auto</span> x = <span class="dv">2</span> ;</a>
<a class="sourceLine" id="cb159-8" data-line-number="8">            <span class="co">// 2</span></a>
<a class="sourceLine" id="cb159-9" data-line-number="9">            <span class="bu">std::</span>cout &lt;&lt; x ;</a>
<a class="sourceLine" id="cb159-10" data-line-number="10">        }</a>
<a class="sourceLine" id="cb159-11" data-line-number="11">        <span class="co">// 1</span></a>
<a class="sourceLine" id="cb159-12" data-line-number="12">        <span class="bu">std::</span>cout &lt;&lt; x ;</a>
<a class="sourceLine" id="cb159-13" data-line-number="13">        x = <span class="dv">42</span> ;</a>
<a class="sourceLine" id="cb159-14" data-line-number="14">        <span class="co">// 42</span></a>
<a class="sourceLine" id="cb159-15" data-line-number="15">        <span class="bu">std::</span>cout &lt;&lt; x ;</a>
<a class="sourceLine" id="cb159-16" data-line-number="16">    }</a>
<a class="sourceLine" id="cb159-17" data-line-number="17">    <span class="co">// 0</span></a>
<a class="sourceLine" id="cb159-18" data-line-number="18">    <span class="bu">std::</span>cout &lt;&lt; x ;</a>
<a class="sourceLine" id="cb159-19" data-line-number="19">}</a></code></pre></div>
<p>なれないうちは驚くかもしれないが、多くのプログラミング言語はこのような挙動になっているものだ。</p>
<h2 id="条件分岐">条件分岐</h2>
<p>すでに読者は様々な数値計算を学んだ。読者は<code>12345 + 6789</code>の答えや、<code>8073 * 132 / 5</code>の答えを計算できる上、この2つの答えをさらにかけ合わせた結果だって計算できる。</p>
<div class="sourceCode" id="cb160"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb160-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb160-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb160-3" data-line-number="3">    <span class="kw">auto</span> a = <span class="dv">12345</span> + <span class="dv">6789</span> ;</a>
<a class="sourceLine" id="cb160-4" data-line-number="4">    <span class="kw">auto</span> b = <span class="dv">8073</span> * <span class="dv">132</span> / <span class="dv">5</span> ;</a>
<a class="sourceLine" id="cb160-5" data-line-number="5">    <span class="kw">auto</span> sum = a + b ;</a>
<a class="sourceLine" id="cb160-6" data-line-number="6"></a>
<a class="sourceLine" id="cb160-7" data-line-number="7">    <span class="bu">std::</span>cout</a>
<a class="sourceLine" id="cb160-8" data-line-number="8">        &lt;&lt; <span class="st">&quot;a=12345 + 6789=&quot;</span> &lt;&lt; a &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s</a>
<a class="sourceLine" id="cb160-9" data-line-number="9">        &lt;&lt; <span class="st">&quot;b=8073 * 132 / 5=&quot;</span> &lt;&lt; b &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s</a>
<a class="sourceLine" id="cb160-10" data-line-number="10">        &lt;&lt; <span class="st">&quot;a+b=&quot;</span> &lt;&lt; sum &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb160-11" data-line-number="11">}</a></code></pre></div>
<p>なるほど、答えがわかった。ところで変数<code>a</code>と変数<code>b</code>はどちらが大きいのだろうか。大きい変数だけ出力したい。この場合は条件分岐を使う。</p>
<p>C++では条件分岐に<code>if文</code>を使う。</p>
<div class="sourceCode" id="cb161"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb161-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb161-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb161-3" data-line-number="3">    <span class="kw">auto</span> a = <span class="dv">12345</span> + <span class="dv">6789</span> ;</a>
<a class="sourceLine" id="cb161-4" data-line-number="4">    <span class="kw">auto</span> b = <span class="dv">8073</span> * <span class="dv">132</span> / <span class="dv">5</span> ;</a>
<a class="sourceLine" id="cb161-5" data-line-number="5"></a>
<a class="sourceLine" id="cb161-6" data-line-number="6"></a>
<a class="sourceLine" id="cb161-7" data-line-number="7">    <span class="cf">if</span> ( a &lt; b )</a>
<a class="sourceLine" id="cb161-8" data-line-number="8">    {</a>
<a class="sourceLine" id="cb161-9" data-line-number="9">        <span class="co">// bが大きい</span></a>
<a class="sourceLine" id="cb161-10" data-line-number="10">        <span class="bu">std::</span>cout &lt;&lt; b ;</a>
<a class="sourceLine" id="cb161-11" data-line-number="11">    }</a>
<a class="sourceLine" id="cb161-12" data-line-number="12">    <span class="cf">else</span></a>
<a class="sourceLine" id="cb161-13" data-line-number="13">    {</a>
<a class="sourceLine" id="cb161-14" data-line-number="14">        <span class="co">// aが大きい</span></a>
<a class="sourceLine" id="cb161-15" data-line-number="15">        <span class="bu">std::</span>cout &lt;&lt; a ;</a>
<a class="sourceLine" id="cb161-16" data-line-number="16">    }</a>
<a class="sourceLine" id="cb161-17" data-line-number="17">}</a></code></pre></div>
<p><code>if文</code>は以下のように書く。</p>
<pre><code>if ( 条件 )
文1
else
文2</code></pre>
<p><code>条件</code>が真(true)のときは<code>文1</code>が実行され、偽(false)のときは<code>文2</code>が実行される。</p>
<p>elseの部分は書かなくてもよい。</p>
<pre><code>if ( 条件 )
文1
文2</code></pre>
<p>その場合、<code>条件</code>が真の時だけ<code>文1</code>が実行される。条件の真偽にかかわらず<code>文2</code>は実行される。</p>
<div class="sourceCode" id="cb164"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb164-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb164-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb164-3" data-line-number="3">    <span class="cf">if</span> ( <span class="dv">2</span> &lt; <span class="dv">1</span> )</a>
<a class="sourceLine" id="cb164-4" data-line-number="4">        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;sentence 1.</span><span class="sc">\n</span><span class="st">&quot;</span> ; <span class="co">// 文1</span></a>
<a class="sourceLine" id="cb164-5" data-line-number="5">    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;sentence 2.</span><span class="sc">\n</span><span class="st">&quot;</span> ; <span class="co">// 文2</span></a>
<a class="sourceLine" id="cb164-6" data-line-number="6">}</a></code></pre></div>
<p>この例では、2が1より小さい場合は<code>文1</code>が実行される。<code>文2</code>は必ず実行される。</p>
<p>条件次第で複数の文を実行したい場合、<code>複合文</code>を使う。</p>
<div class="sourceCode" id="cb165"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb165-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb165-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb165-3" data-line-number="3">    <span class="cf">if</span> ( <span class="dv">1</span> &lt; <span class="dv">2</span> )</a>
<a class="sourceLine" id="cb165-4" data-line-number="4">    {</a>
<a class="sourceLine" id="cb165-5" data-line-number="5">        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;yes!</span><span class="sc">\n</span><span class="st">&quot;</span> ;</a>
<a class="sourceLine" id="cb165-6" data-line-number="6">        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;yes!</span><span class="sc">\n</span><span class="st">&quot;</span> ;</a>
<a class="sourceLine" id="cb165-7" data-line-number="7">    }</a>
<a class="sourceLine" id="cb165-8" data-line-number="8">}</a></code></pre></div>
<p><code>条件</code>とか<code>真偽</code>についてはとてもとても深い話があるのだが、その解説は後の章に回すとして、まずは以下の比較演算子を覚えよう。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">演算子</th>
<th style="text-align: left;">意味</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">a == b</td>
<td style="text-align: left;">aはbと等しい</td>
</tr>
<tr class="even">
<td style="text-align: left;">a != b</td>
<td style="text-align: left;">aはbと等しくない</td>
</tr>
<tr class="odd">
<td style="text-align: left;">a &lt; b</td>
<td style="text-align: left;">aはbより小さい</td>
</tr>
<tr class="even">
<td style="text-align: left;">a &lt;= b</td>
<td style="text-align: left;">aはbより小さい、もしくは等しい</td>
</tr>
<tr class="odd">
<td style="text-align: left;">a &gt; b</td>
<td style="text-align: left;">aはbより大きい</td>
</tr>
<tr class="even">
<td style="text-align: left;">a &gt;= b</td>
<td style="text-align: left;">aはbより大きい、もしくは等しい</td>
</tr>
</tbody>
</table>
<p>真(true)というのは、意味が真であるときだ。正しい、成り立つ、正解などと言い換えてもよい。それ以外の場合はすべて偽(false)だ。正しくない、成り立たない、不正解などと言い換えてもいい。</p>
<p>整数や浮動小数点数の場合、話は簡単だ。</p>
<div class="sourceCode" id="cb166"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb166-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb166-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb166-3" data-line-number="3">    <span class="co">// 1は2より小さいか？</span></a>
<a class="sourceLine" id="cb166-4" data-line-number="4">    <span class="cf">if</span> ( <span class="dv">1</span> &lt; <span class="dv">2</span> )</a>
<a class="sourceLine" id="cb166-5" data-line-number="5">    {   <span class="co">// 真、お使いのコンピューターは正常です</span></a>
<a class="sourceLine" id="cb166-6" data-line-number="6">        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Your computer works just fine.</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb166-7" data-line-number="7">    }</a>
<a class="sourceLine" id="cb166-8" data-line-number="8">    <span class="cf">else</span></a>
<a class="sourceLine" id="cb166-9" data-line-number="9">    {</a>
<a class="sourceLine" id="cb166-10" data-line-number="10">        <span class="co">// 偽、お使いのコンピューターには深刻な問題があります</span></a>
<a class="sourceLine" id="cb166-11" data-line-number="11">        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Your computer has serious issues.</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb166-12" data-line-number="12">    }</a>
<a class="sourceLine" id="cb166-13" data-line-number="13">}</a></code></pre></div>
<p>文字列の場合、内容が同じであれば等しい。違うのであれば等しくない。</p>
<div class="sourceCode" id="cb167"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb167-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb167-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb167-3" data-line-number="3">    <span class="kw">auto</span> a = <span class="st">&quot;dog&quot;</span>s ;</a>
<a class="sourceLine" id="cb167-4" data-line-number="4">    <span class="kw">auto</span> b = <span class="st">&quot;dog&quot;</span>s ;</a>
<a class="sourceLine" id="cb167-5" data-line-number="5">    <span class="kw">auto</span> c = <span class="st">&quot;cat&quot;</span>s ;</a>
<a class="sourceLine" id="cb167-6" data-line-number="6"></a>
<a class="sourceLine" id="cb167-7" data-line-number="7">    <span class="cf">if</span> ( a == b )</a>
<a class="sourceLine" id="cb167-8" data-line-number="8">    {</a>
<a class="sourceLine" id="cb167-9" data-line-number="9">        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;a == b</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb167-10" data-line-number="10">    }</a>
<a class="sourceLine" id="cb167-11" data-line-number="11">    <span class="cf">else</span></a>
<a class="sourceLine" id="cb167-12" data-line-number="12">    {</a>
<a class="sourceLine" id="cb167-13" data-line-number="13">        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;a != b</span><span class="sc">\n</span><span class="st">&quot;</span> ;</a>
<a class="sourceLine" id="cb167-14" data-line-number="14">    }</a>
<a class="sourceLine" id="cb167-15" data-line-number="15"></a>
<a class="sourceLine" id="cb167-16" data-line-number="16">    <span class="cf">if</span> ( a == c )</a>
<a class="sourceLine" id="cb167-17" data-line-number="17">    {</a>
<a class="sourceLine" id="cb167-18" data-line-number="18">        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;a == c</span><span class="sc">\n</span><span class="st">&quot;</span> ;</a>
<a class="sourceLine" id="cb167-19" data-line-number="19">    }</a>
<a class="sourceLine" id="cb167-20" data-line-number="20">    <span class="cf">else</span></a>
<a class="sourceLine" id="cb167-21" data-line-number="21">    {</a>
<a class="sourceLine" id="cb167-22" data-line-number="22">        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;a != c</span><span class="sc">\n</span><span class="st">&quot;</span> ;</a>
<a class="sourceLine" id="cb167-23" data-line-number="23">    }</a>
<a class="sourceLine" id="cb167-24" data-line-number="24">}</a></code></pre></div>
<p>では文字列に大小はあるのだろうか。文字列に大小はある。</p>
<div class="sourceCode" id="cb168"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb168-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb168-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb168-3" data-line-number="3">    <span class="kw">auto</span> cat = <span class="st">&quot;cat&quot;</span>s ;</a>
<a class="sourceLine" id="cb168-4" data-line-number="4">    <span class="kw">auto</span> dog = <span class="st">&quot;dog&quot;</span>s ;</a>
<a class="sourceLine" id="cb168-5" data-line-number="5"></a>
<a class="sourceLine" id="cb168-6" data-line-number="6">    <span class="cf">if</span> ( cat &lt; dog )</a>
<a class="sourceLine" id="cb168-7" data-line-number="7">    {   <span class="co">// 猫は小さい</span></a>
<a class="sourceLine" id="cb168-8" data-line-number="8">        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;cat is smaller.</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb168-9" data-line-number="9">    }</a>
<a class="sourceLine" id="cb168-10" data-line-number="10">    <span class="cf">else</span></a>
<a class="sourceLine" id="cb168-11" data-line-number="11">    {   <span class="co">// 犬は小さい</span></a>
<a class="sourceLine" id="cb168-12" data-line-number="12">        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;dog is smaller.</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb168-13" data-line-number="13">    }</a>
<a class="sourceLine" id="cb168-14" data-line-number="14"></a>
<a class="sourceLine" id="cb168-15" data-line-number="15">    <span class="kw">auto</span> longcat = <span class="st">&quot;longcat&quot;</span>s ;</a>
<a class="sourceLine" id="cb168-16" data-line-number="16"></a>
<a class="sourceLine" id="cb168-17" data-line-number="17">    <span class="cf">if</span> ( longcat &gt; cat )</a>
<a class="sourceLine" id="cb168-18" data-line-number="18">    {   <span class="co">// longcatは長い</span></a>
<a class="sourceLine" id="cb168-19" data-line-number="19">        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Longcat is Looong.</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb168-20" data-line-number="20">    }</a>
<a class="sourceLine" id="cb168-21" data-line-number="21">    <span class="cf">else</span></a>
<a class="sourceLine" id="cb168-22" data-line-number="22">    {</a>
<a class="sourceLine" id="cb168-23" data-line-number="23">        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Longcat isn&#39;t that long. Sigh.</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb168-24" data-line-number="24">    }</a>
<a class="sourceLine" id="cb168-25" data-line-number="25">}</a></code></pre></div>
<p>実行して確かめてみよう。ほとんどの読者の実行環境では以下のようになるはずだ。ほとんどの、というのは、そうではない環境も存在するからだ。読者がそのような稀有な環境を使っている可能性はまずないだろうが。</p>
<pre><code>cat is smaller.
Longcat is Looong.</code></pre>
<p>なるほど。“cat”sは“dog”sよりも小さく(？)、“longcat”sは“cat”sよりも長い(大きい？)ようだ。なんだかよくわからない結果になった。</p>
<p>これはどういうことなのか。もっと簡単な文字列で試してみよう。</p>
<div class="sourceCode" id="cb170"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb170-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb170-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb170-3" data-line-number="3">    <span class="kw">auto</span> x = <span class="st">&quot;&quot;</span>s ;</a>
<a class="sourceLine" id="cb170-4" data-line-number="4"></a>
<a class="sourceLine" id="cb170-5" data-line-number="5">    <span class="co">// aとbはどちらが小さいのだろうか？</span></a>
<a class="sourceLine" id="cb170-6" data-line-number="6">    <span class="cf">if</span> ( <span class="st">&quot;a&quot;</span>s &lt; <span class="st">&quot;b&quot;</span>s )</a>
<a class="sourceLine" id="cb170-7" data-line-number="7">    {   x = <span class="st">&quot;a&quot;</span>s ; }</a>
<a class="sourceLine" id="cb170-8" data-line-number="8">    <span class="cf">else</span></a>
<a class="sourceLine" id="cb170-9" data-line-number="9">    {   x = <span class="st">&quot;b&quot;</span>s ; }</a>
<a class="sourceLine" id="cb170-10" data-line-number="10"> </a>
<a class="sourceLine" id="cb170-11" data-line-number="11">    <span class="co">// 小さい方の文字が出力される</span></a>
<a class="sourceLine" id="cb170-12" data-line-number="12">    <span class="bu">std::</span>cout &lt;&lt; x ;</a>
<a class="sourceLine" id="cb170-13" data-line-number="13">}</a></code></pre></div>
<p>これを実行するとaと出力される。すると“a”sは“b”sより小さいようだ。</p>
<p>もっと試してみよう。</p>
<div class="sourceCode" id="cb171"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb171-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb171-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb171-3" data-line-number="3">    <span class="kw">auto</span> x = <span class="st">&quot;&quot;</span>s ;</a>
<a class="sourceLine" id="cb171-4" data-line-number="4">    <span class="cf">if</span> ( <span class="st">&quot;aa&quot;</span>s &lt; <span class="st">&quot;ab&quot;</span>s )</a>
<a class="sourceLine" id="cb171-5" data-line-number="5">    { x = <span class="st">&quot;aa&quot;</span>s ; }</a>
<a class="sourceLine" id="cb171-6" data-line-number="6">    <span class="cf">else</span></a>
<a class="sourceLine" id="cb171-7" data-line-number="7">    { x = <span class="st">&quot;ab&quot;</span>s ; }</a>
<a class="sourceLine" id="cb171-8" data-line-number="8"></a>
<a class="sourceLine" id="cb171-9" data-line-number="9">    <span class="co">// 小さい文字列が出力される</span></a>
<a class="sourceLine" id="cb171-10" data-line-number="10">    <span class="bu">std::</span>cout &lt;&lt; x ;</a>
<a class="sourceLine" id="cb171-11" data-line-number="11">}</a></code></pre></div>
<p>これを実行すると、aaと出力される。すると“aa”sは“ab”sより小さいことになる。</p>
<p>文字列の大小比較は文字単位で行われる。まず最初の文字が大小比較される。もし等しい場合は、次の文字が大小比較される。等しくない最初の文字の結果が、文字列の大小比較の結果となる。</p>
<h2 id="条件式">条件式</h2>
<h3 id="条件とは何だろう">条件とは何だろう</h3>
<p><code>if文</code>の中で書く<code>条件(condition)</code>は、<code>条件式(conditional expression)</code>とも呼ばれている<code>式(expression)</code>の一種だ。<code>式</code>というのは例えば“1+1”のようなものだ。<code>式</code>は<code>文</code>の中に書くことができ、これを<code>式文(expression statement)</code>という。</p>
<div class="sourceCode" id="cb172"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb172-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb172-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb172-3" data-line-number="3">    <span class="dv">1</span> + <span class="dv">1</span> ; <span class="co">// 式文</span></a>
<a class="sourceLine" id="cb172-4" data-line-number="4">}</a></code></pre></div>
<p>“a==b”や“a&lt;b”のような<code>条件</code>も<code>式</code>なので、<code>文</code>として書くことができる。</p>
<div class="sourceCode" id="cb173"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb173-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb173-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb173-3" data-line-number="3">    <span class="dv">1</span> == <span class="dv">1</span> ;</a>
<a class="sourceLine" id="cb173-4" data-line-number="4">    <span class="dv">1</span> &lt; <span class="dv">2</span> ;</a>
<a class="sourceLine" id="cb173-5" data-line-number="5">}</a></code></pre></div>
<p>C++では多くの式には型がある。たとえば“123”はint型で、“123+4”もint型だ。</p>
<div class="sourceCode" id="cb174"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb174-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb174-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb174-3" data-line-number="3">    <span class="kw">auto</span> a = <span class="dv">123</span> ; <span class="co">// int</span></a>
<a class="sourceLine" id="cb174-4" data-line-number="4">    <span class="kw">auto</span> b = a + <span class="dv">4</span> ; <span class="co">// int</span></a>
<a class="sourceLine" id="cb174-5" data-line-number="5">    <span class="kw">auto</span> c = <span class="fl">1.0</span> ; <span class="co">// double</span></a>
<a class="sourceLine" id="cb174-6" data-line-number="6">    <span class="kw">auto</span> d = <span class="st">&quot;hello&quot;</span>s ; <span class="co">// std::string</span></a>
<a class="sourceLine" id="cb174-7" data-line-number="7">}</a></code></pre></div>
<p>とすると、“1==2”や“3!=3”のような条件式にも型があるのではないか。型があるのであれば変数に入れられるはずだ。試してみよう。</p>
<div class="sourceCode" id="cb175"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb175-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb175-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb175-3" data-line-number="3">    <span class="cf">if</span> (  <span class="dv">1</span> == <span class="dv">1</span> )</a>
<a class="sourceLine" id="cb175-4" data-line-number="4">    { <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;1 == 1 is true.</span><span class="sc">\n</span><span class="st">&quot;</span>s ; }</a>
<a class="sourceLine" id="cb175-5" data-line-number="5">    <span class="cf">else</span></a>
<a class="sourceLine" id="cb175-6" data-line-number="6">    { <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;1 == 1 is false.</span><span class="sc">\n</span><span class="st">&quot;</span>s ; }</a>
<a class="sourceLine" id="cb175-7" data-line-number="7"></a>
<a class="sourceLine" id="cb175-8" data-line-number="8">    <span class="kw">auto</span> x = <span class="dv">1</span> == <span class="dv">1</span> ;</a>
<a class="sourceLine" id="cb175-9" data-line-number="9">    <span class="cf">if</span> ( x )</a>
<a class="sourceLine" id="cb175-10" data-line-number="10">    { <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;1 == 1 is true.</span><span class="sc">\n</span><span class="st">&quot;</span>s ; }</a>
<a class="sourceLine" id="cb175-11" data-line-number="11">    <span class="cf">else</span></a>
<a class="sourceLine" id="cb175-12" data-line-number="12">    { <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;1 == 1 is false.</span><span class="sc">\n</span><span class="st">&quot;</span>s ; }</a>
<a class="sourceLine" id="cb175-13" data-line-number="13">}</a></code></pre></div>
<p>“if(x)”は“if(1==1)”と書いた場合と同じように動く。</p>
<p>変数に入れられるのであれば出力もできるのではないだろうか。試してみよう。</p>
<div class="sourceCode" id="cb176"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb176-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb176-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb176-3" data-line-number="3">    <span class="kw">auto</span> a = <span class="dv">1</span> == <span class="dv">1</span> ; <span class="co">// 正しい</span></a>
<a class="sourceLine" id="cb176-4" data-line-number="4">    <span class="kw">auto</span> b = <span class="dv">1</span> != <span class="dv">1</span> ; <span class="co">// 間違い</span></a>
<a class="sourceLine" id="cb176-5" data-line-number="5">    <span class="bu">std::</span>cout &lt;&lt; a &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s &lt;&lt; b ;</a>
<a class="sourceLine" id="cb176-6" data-line-number="6">}</a></code></pre></div>
<pre><code>1
0</code></pre>
<p>なるほど、条件が正しい場合“1”になり、条件が間違っている場合“0”になるようだ。</p>
<p>では<code>if文</code>の中に1や0を入れたらどうなるのだろうか。</p>
<div class="sourceCode" id="cb178"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb178-1" data-line-number="1"><span class="co">// 条件が正しい値だけ出力される。</span></a>
<a class="sourceLine" id="cb178-2" data-line-number="2"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb178-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb178-4" data-line-number="4">    <span class="cf">if</span> ( <span class="dv">1</span> ) <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;1</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb178-5" data-line-number="5">    <span class="cf">if</span> ( <span class="dv">0</span> ) <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;0</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb178-6" data-line-number="6">    <span class="cf">if</span> ( <span class="dv">123</span> ) <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;123</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb178-7" data-line-number="7">    <span class="cf">if</span> ( <span class="dv">-1</span> ) <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;-1</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb178-8" data-line-number="8">}</a></code></pre></div>
<p>実行結果は以下のようになる。</p>
<pre><code>1
123
-1</code></pre>
<p>この結果を見ると、条件として1, 123, -1は正しく、0は間違っているということになる。ますます訳がわからなくなってきた。</p>
<h2 id="bool型">bool型</h2>
<p>そろそろ種明かしをしよう。条件式の結果は、<code>bool型</code>という特別な型を持っている。</p>
<div class="sourceCode" id="cb180"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb180-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb180-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb180-3" data-line-number="3">    <span class="kw">auto</span> a = <span class="dv">1</span> == <span class="dv">1</span> ; <span class="co">// bool型</span></a>
<a class="sourceLine" id="cb180-4" data-line-number="4">    <span class="dt">bool</span> A = <span class="dv">1</span> == <span class="dv">1</span> ; <span class="co">// 型を書いてもよい</span></a>
<a class="sourceLine" id="cb180-5" data-line-number="5">}</a></code></pre></div>
<p>int型の変数には整数の値が入る。double型の変数には浮動小数点数の値が入る。std::string型の変数には文字列の値が入る。</p>
<p>すると、bool型の変数にはbool型の値が入る。</p>
<p>bool型には2つの値がある。条件が正しいことを意味する<code>true</code>と、条件が間違っていることを意味する<code>false</code>だ。</p>
<div class="sourceCode" id="cb181"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb181-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb181-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb181-3" data-line-number="3">    <span class="dt">bool</span> correct = <span class="kw">true</span> ;</a>
<a class="sourceLine" id="cb181-4" data-line-number="4">    <span class="dt">bool</span> wrong = <span class="kw">false</span> ;</a>
<a class="sourceLine" id="cb181-5" data-line-number="5">}</a></code></pre></div>
<p>bool型にこれ以外の値は存在しない。</p>
<p>bool型の値を正しく出力するには、std::boolalphaを出力する。</p>
<div class="sourceCode" id="cb182"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb182-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb182-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb182-3" data-line-number="3">    <span class="bu">std::</span>cout &lt;&lt; <span class="bu">std::</span>boolalpha ;</a>
<a class="sourceLine" id="cb182-4" data-line-number="4">    <span class="bu">std::</span>cout &lt;&lt; <span class="kw">true</span> &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s &lt;&lt; <span class="kw">false</span> ;</a>
<a class="sourceLine" id="cb182-5" data-line-number="5">}</a></code></pre></div>
<pre><code>true
false</code></pre>
<p>std::boolalpha自体は何も出力をしない。一度std::boolalphaを出力すると、それ以降のbool値がtrue/falseで出力されるようになる。</p>
<p>元に戻すにはstd::noboolalphaを使う。</p>
<div class="sourceCode" id="cb184"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb184-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb184-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb184-3" data-line-number="3">    <span class="bu">std::</span>cout &lt;&lt; <span class="bu">std::</span>boolalpha ;</a>
<a class="sourceLine" id="cb184-4" data-line-number="4">    <span class="bu">std::</span>cout &lt;&lt; <span class="kw">true</span> &lt;&lt; <span class="kw">false</span> ;</a>
<a class="sourceLine" id="cb184-5" data-line-number="5">    <span class="bu">std::</span>cout &lt;&lt; <span class="bu">std::</span>noboolalpha ;</a>
<a class="sourceLine" id="cb184-6" data-line-number="6">    <span class="bu">std::</span>cout &lt;&lt; <span class="kw">true</span> &lt;&lt; <span class="kw">false</span> ;</a>
<a class="sourceLine" id="cb184-7" data-line-number="7">}</a></code></pre></div>
<p>以下のように出力される。</p>
<pre><code>truefalse10</code></pre>
<p>すでに学んだ比較演算子は、正しい場合に<code>bool</code>型の値<code>true</code>を、間違っている場合に<code>bool</code>型の値<code>false</code>を返す。</p>
<div class="sourceCode" id="cb186"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb186-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb186-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb186-3" data-line-number="3">    <span class="co">// true</span></a>
<a class="sourceLine" id="cb186-4" data-line-number="4">    <span class="dt">bool</span> a = <span class="dv">1</span> == <span class="dv">1</span> ;</a>
<a class="sourceLine" id="cb186-5" data-line-number="5">    <span class="co">// false</span></a>
<a class="sourceLine" id="cb186-6" data-line-number="6">    <span class="dt">bool</span> b = <span class="dv">1</span> != <span class="dv">1</span> ;</a>
<a class="sourceLine" id="cb186-7" data-line-number="7"></a>
<a class="sourceLine" id="cb186-8" data-line-number="8">    <span class="co">// true</span></a>
<a class="sourceLine" id="cb186-9" data-line-number="9">    <span class="dt">bool</span> c = <span class="dv">1</span> &lt; <span class="dv">2</span> ;</a>
<a class="sourceLine" id="cb186-10" data-line-number="10">    <span class="co">// false</span></a>
<a class="sourceLine" id="cb186-11" data-line-number="11">    <span class="dt">bool</span> d = <span class="dv">1</span> &gt; <span class="dv">2</span> ;</a>
<a class="sourceLine" id="cb186-12" data-line-number="12">}</a></code></pre></div>
<p>先に説明した<code>if文</code>の<code>条件</code>が「正しい」というのは<code>true</code>のことで、「間違っている」というのは<code>false</code>のことだ。</p>
<div class="sourceCode" id="cb187"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb187-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb187-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb187-3" data-line-number="3">    <span class="co">// 出力される</span></a>
<a class="sourceLine" id="cb187-4" data-line-number="4">    <span class="cf">if</span> ( <span class="kw">true</span> )</a>
<a class="sourceLine" id="cb187-5" data-line-number="5">        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;true</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb187-6" data-line-number="6"></a>
<a class="sourceLine" id="cb187-7" data-line-number="7">    <span class="co">// 出力されない。</span></a>
<a class="sourceLine" id="cb187-8" data-line-number="8">    <span class="cf">if</span> ( <span class="kw">false</span> )</a>
<a class="sourceLine" id="cb187-9" data-line-number="9">        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;false</span><span class="sc">\n</span><span class="st">&quot;</span>s ; </a>
<a class="sourceLine" id="cb187-10" data-line-number="10">}</a></code></pre></div>
<h2 id="bool型の演算">bool型の演算</h2>
<p>bool型にはいくつかの演算が用意されている。</p>
<h3 id="論理否定-operator">論理否定: operator !</h3>
<p>“!a”はaが<code>true</code>の場合<code>false</code>に、<code>false</code>の場合<code>true</code>になる。</p>
<div class="sourceCode" id="cb188"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb188-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb188-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb188-3" data-line-number="3">    <span class="bu">std::</span>cout &lt;&lt; <span class="bu">std::</span>boolalpha ;</a>
<a class="sourceLine" id="cb188-4" data-line-number="4"></a>
<a class="sourceLine" id="cb188-5" data-line-number="5">    <span class="co">// false</span></a>
<a class="sourceLine" id="cb188-6" data-line-number="6">    <span class="bu">std::</span>cout &lt;&lt; !<span class="kw">true</span> &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb188-7" data-line-number="7"></a>
<a class="sourceLine" id="cb188-8" data-line-number="8">    <span class="co">// true</span></a>
<a class="sourceLine" id="cb188-9" data-line-number="9">    <span class="bu">std::</span>cout &lt;&lt; !<span class="kw">false</span> &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb188-10" data-line-number="10">}</a></code></pre></div>
<p>論理否定演算子を使うと、falseのときのみ実行されてほしい条件分岐が書きやすくなる。</p>
<div class="sourceCode" id="cb189"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb189-1" data-line-number="1"><span class="co">// ロケットが発射可能かどうかを返す関数</span></a>
<a class="sourceLine" id="cb189-2" data-line-number="2"><span class="dt">bool</span> is_rocket_ready_to_launch()</a>
<a class="sourceLine" id="cb189-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb189-4" data-line-number="4">    <span class="co">// まだだよ</span></a>
<a class="sourceLine" id="cb189-5" data-line-number="5">    <span class="cf">return</span> <span class="kw">false</span> ;</a>
<a class="sourceLine" id="cb189-6" data-line-number="6">}</a>
<a class="sourceLine" id="cb189-7" data-line-number="7"></a>
<a class="sourceLine" id="cb189-8" data-line-number="8"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb189-9" data-line-number="9">{</a>
<a class="sourceLine" id="cb189-10" data-line-number="10"></a>
<a class="sourceLine" id="cb189-11" data-line-number="11">    <span class="co">// ロケットが発射可能ではないときに実行される</span></a>
<a class="sourceLine" id="cb189-12" data-line-number="12">    <span class="cf">if</span> ( !is_rocket_ready_to_launch() )</a>
<a class="sourceLine" id="cb189-13" data-line-number="13">    {   <span class="co">// もうしばらくそのままでお待ちください</span></a>
<a class="sourceLine" id="cb189-14" data-line-number="14">        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Standby...</span><span class="sc">\n</span><span class="st">&quot;</span> ;</a>
<a class="sourceLine" id="cb189-15" data-line-number="15">    }</a>
<a class="sourceLine" id="cb189-16" data-line-number="16">}</a></code></pre></div>
<p>この例では、ロケットが発射可能でない場合のみ、待つようにアナウンスする。</p>
<p>同じように、trueのときに実行されてほしくない条件分岐も書ける。</p>
<div class="sourceCode" id="cb190"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb190-1" data-line-number="1"><span class="co">// ロケットが発射可能かどうかを返す関数</span></a>
<a class="sourceLine" id="cb190-2" data-line-number="2"><span class="dt">bool</span> is_rocket_ready_to_launch()</a>
<a class="sourceLine" id="cb190-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb190-4" data-line-number="4">    <span class="co">// もういいよ</span></a>
<a class="sourceLine" id="cb190-5" data-line-number="5">    <span class="cf">return</span> <span class="kw">true</span> ;</a>
<a class="sourceLine" id="cb190-6" data-line-number="6">}</a>
<a class="sourceLine" id="cb190-7" data-line-number="7"></a>
<a class="sourceLine" id="cb190-8" data-line-number="8"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb190-9" data-line-number="9">{</a>
<a class="sourceLine" id="cb190-10" data-line-number="10">    <span class="co">// ロケットが発射可能なときに実行される</span></a>
<a class="sourceLine" id="cb190-11" data-line-number="11">    <span class="cf">if</span> ( !is_rocket_ready_to_launch() )</a>
<a class="sourceLine" id="cb190-12" data-line-number="12">    {   <span class="co">// カウントダウン</span></a>
<a class="sourceLine" id="cb190-13" data-line-number="13">        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;3...2...1...Hallelujah!</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb190-14" data-line-number="14">    }</a>
<a class="sourceLine" id="cb190-15" data-line-number="15"></a>
<a class="sourceLine" id="cb190-16" data-line-number="16">}</a></code></pre></div>
<p>この2つの例では、ロケットの状態が実行すべき条件ではないので、正しく何も出力されない。</p>
<h3 id="同値比較-operator">同値比較: operator ==, !=</h3>
<p>bool型の値の同値比較はわかりやすい。<code>true</code>は<code>true</code>と等しく、<code>false</code>は<code>false</code>と等しく、<code>true</code>と<code>false</code>は等しくない。</p>
<div class="sourceCode" id="cb191"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb191-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb191-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb191-3" data-line-number="3">    <span class="bu">std::</span>cout &lt;&lt; <span class="bu">std::</span>boolalpha ;</a>
<a class="sourceLine" id="cb191-4" data-line-number="4">    <span class="kw">auto</span> print = [](<span class="kw">auto</span> b)</a>
<a class="sourceLine" id="cb191-5" data-line-number="5">    { <span class="bu">std::</span>cout &lt;&lt; b &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ; } ;</a>
<a class="sourceLine" id="cb191-6" data-line-number="6"></a>
<a class="sourceLine" id="cb191-7" data-line-number="7">    print( <span class="kw">true</span>  == <span class="kw">true</span>  ) ; <span class="co">// true</span></a>
<a class="sourceLine" id="cb191-8" data-line-number="8">    print( <span class="kw">true</span>  == <span class="kw">false</span> ) ; <span class="co">// false</span></a>
<a class="sourceLine" id="cb191-9" data-line-number="9">    print( <span class="kw">false</span> == <span class="kw">true</span>  ) ; <span class="co">// false</span></a>
<a class="sourceLine" id="cb191-10" data-line-number="10">    print( <span class="kw">false</span> == <span class="kw">false</span> ) ; <span class="co">// true</span></a>
<a class="sourceLine" id="cb191-11" data-line-number="11"></a>
<a class="sourceLine" id="cb191-12" data-line-number="12">    print( <span class="kw">true</span>  != <span class="kw">true</span>  ) ; <span class="co">// false</span></a>
<a class="sourceLine" id="cb191-13" data-line-number="13">    print( <span class="kw">true</span>  != <span class="kw">false</span> ) ; <span class="co">// true</span></a>
<a class="sourceLine" id="cb191-14" data-line-number="14">    print( <span class="kw">false</span> != <span class="kw">true</span>  ) ; <span class="co">// true</span></a>
<a class="sourceLine" id="cb191-15" data-line-number="15">    print( <span class="kw">false</span> != <span class="kw">false</span> ) ; <span class="co">// false</span></a>
<a class="sourceLine" id="cb191-16" data-line-number="16">}</a></code></pre></div>
<p>比較演算子の結果はbool値になるということを覚えてるだろうか。“1 &lt; 2”は<code>true</code>になり、“1 &gt; 2”は<code>false</code>になる。</p>
<p>bool値同士も同値比較ができるということは、“(1 &lt; 2) == true”のように書くことも可能だということだ。</p>
<div class="sourceCode" id="cb192"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb192-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb192-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb192-3" data-line-number="3">    <span class="dt">bool</span> b = (<span class="dv">1</span> &lt; <span class="dv">2</span>) == <span class="kw">true</span> ;</a>
<a class="sourceLine" id="cb192-4" data-line-number="4">}</a></code></pre></div>
<p>“(1&lt;2)”はtrueなので、“(1&lt;2)==true”は“true==true”と同じ意味になる。この結果はもちろん“true”だ。</p>
<h3 id="論理積-operator">論理積: operator &amp;&amp;</h3>
<p>“a &amp;&amp; b”は<code>a</code>と<code>b</code>がともに<code>true</code>のときに<code>true</code>となる。それ以外の場合は<code>false</code>となる。これを論理積という。</p>
<p>表にまとめると以下のようになる。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">式</th>
<th style="text-align: left;">結果</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">false &amp;&amp; false</td>
<td style="text-align: left;">false</td>
</tr>
<tr class="even">
<td style="text-align: left;">false &amp;&amp; true</td>
<td style="text-align: left;">false</td>
</tr>
<tr class="odd">
<td style="text-align: left;">true &amp;&amp; false</td>
<td style="text-align: left;">false</td>
</tr>
<tr class="even">
<td style="text-align: left;">true &amp;&amp; true</td>
<td style="text-align: left;">true</td>
</tr>
</tbody>
</table>
<p>早速確かめてみよう。</p>
<div class="sourceCode" id="cb193"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb193-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb193-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb193-3" data-line-number="3">    <span class="bu">std::</span>cout &lt;&lt; <span class="bu">std::</span>boolalpha ;</a>
<a class="sourceLine" id="cb193-4" data-line-number="4">    <span class="kw">auto</span> print = []( <span class="kw">auto</span> b )</a>
<a class="sourceLine" id="cb193-5" data-line-number="5">    { <span class="bu">std::</span>cout &lt;&lt; b &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ; } ;</a>
<a class="sourceLine" id="cb193-6" data-line-number="6"></a>
<a class="sourceLine" id="cb193-7" data-line-number="7">    print( <span class="kw">false</span> &amp;&amp; <span class="kw">false</span> ) ; <span class="co">// false</span></a>
<a class="sourceLine" id="cb193-8" data-line-number="8">    print( <span class="kw">false</span> &amp;&amp; <span class="kw">true</span>  ) ; <span class="co">// false</span></a>
<a class="sourceLine" id="cb193-9" data-line-number="9">    print( <span class="kw">true</span>  &amp;&amp; <span class="kw">false</span> ) ; <span class="co">// false</span></a>
<a class="sourceLine" id="cb193-10" data-line-number="10">    print( <span class="kw">true</span>  &amp;&amp; <span class="kw">true</span>  ) ; <span class="co">// true</span></a>
<a class="sourceLine" id="cb193-11" data-line-number="11">}</a></code></pre></div>
<p>論理積は、「AかつB」を表現するのに使える。</p>
<p>例えば、人間の体温が平熱かどうかを判断するプログラムを書くとする。36.1℃以上、37.2℃以下を平熱とすると、if文を使って以下のように書くことができる。</p>
<div class="sourceCode" id="cb194"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb194-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb194-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb194-3" data-line-number="3">    <span class="co">// 体温</span></a>
<a class="sourceLine" id="cb194-4" data-line-number="4">    <span class="dt">double</span> temperature = <span class="fl">36.6</span> ;</a>
<a class="sourceLine" id="cb194-5" data-line-number="5"></a>
<a class="sourceLine" id="cb194-6" data-line-number="6">    <span class="co">// 36.1度以上</span></a>
<a class="sourceLine" id="cb194-7" data-line-number="7">    <span class="cf">if</span> ( temperature &gt;= <span class="fl">36.1</span> )</a>
<a class="sourceLine" id="cb194-8" data-line-number="8">        <span class="cf">if</span> ( temperature &lt;= <span class="fl">37.2</span> )</a>
<a class="sourceLine" id="cb194-9" data-line-number="9">        { <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Good.</span><span class="sc">\n</span><span class="st">&quot;</span>s ; }</a>
<a class="sourceLine" id="cb194-10" data-line-number="10">        <span class="cf">else</span></a>
<a class="sourceLine" id="cb194-11" data-line-number="11">        { <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Bad.</span><span class="sc">\n</span><span class="st">&quot;</span>s ; }</a>
<a class="sourceLine" id="cb194-12" data-line-number="12">    <span class="cf">else</span></a>
<a class="sourceLine" id="cb194-13" data-line-number="13">    { <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Bad.</span><span class="sc">\n</span><span class="st">&quot;</span>s ; }</a>
<a class="sourceLine" id="cb194-14" data-line-number="14">}</a></code></pre></div>
<p>このコードは、<code>operator &amp;&amp;</code>を使えば簡潔に書ける。</p>
<div class="sourceCode" id="cb195"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb195-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb195-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb195-3" data-line-number="3">    <span class="dt">double</span> temperature = <span class="fl">36.6</span> ;</a>
<a class="sourceLine" id="cb195-4" data-line-number="4"></a>
<a class="sourceLine" id="cb195-5" data-line-number="5">    <span class="cf">if</span> ( ( temperature &gt;= <span class="fl">36.1</span> ) &amp;&amp; ( temperature &lt;= <span class="fl">37.2</span> ) )</a>
<a class="sourceLine" id="cb195-6" data-line-number="6">    { <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Good.</span><span class="sc">\n</span><span class="st">&quot;</span>s ; }</a>
<a class="sourceLine" id="cb195-7" data-line-number="7">    <span class="cf">else</span></a>
<a class="sourceLine" id="cb195-8" data-line-number="8">    { <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Bad.</span><span class="sc">\n</span><span class="st">&quot;</span>s ; }</a>
<a class="sourceLine" id="cb195-9" data-line-number="9">}</a></code></pre></div>
<h3 id="論理和-operator">論理和: operator ||</h3>
<p>“a || b”は<code>a</code>と<code>b</code>がともにfalseのときに<code>false</code>となる。それ以外の場合は<code>true</code>となる。これを論理和という。</p>
<p>表にまとめると以下のようになる。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">式</th>
<th style="text-align: left;">結果</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">false || false</td>
<td style="text-align: left;">false</td>
</tr>
<tr class="even">
<td style="text-align: left;">false || true</td>
<td style="text-align: left;">true</td>
</tr>
<tr class="odd">
<td style="text-align: left;">true || false</td>
<td style="text-align: left;">true</td>
</tr>
<tr class="even">
<td style="text-align: left;">true || true</td>
<td style="text-align: left;">true</td>
</tr>
</tbody>
</table>
<p>早速確かめてみよう。</p>
<div class="sourceCode" id="cb196"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb196-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb196-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb196-3" data-line-number="3">    <span class="bu">std::</span>cout &lt;&lt; <span class="bu">std::</span>boolalpha ;</a>
<a class="sourceLine" id="cb196-4" data-line-number="4">    <span class="kw">auto</span> print = []( <span class="kw">auto</span> b )</a>
<a class="sourceLine" id="cb196-5" data-line-number="5">    { <span class="bu">std::</span>cout &lt;&lt; b &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ; } ;</a>
<a class="sourceLine" id="cb196-6" data-line-number="6"></a>
<a class="sourceLine" id="cb196-7" data-line-number="7">    print( <span class="kw">false</span> || <span class="kw">false</span> ) ; <span class="co">// false</span></a>
<a class="sourceLine" id="cb196-8" data-line-number="8">    print( <span class="kw">false</span> || <span class="kw">true</span>  ) ; <span class="co">// true</span></a>
<a class="sourceLine" id="cb196-9" data-line-number="9">    print( <span class="kw">true</span>  || <span class="kw">false</span> ) ; <span class="co">// true</span></a>
<a class="sourceLine" id="cb196-10" data-line-number="10">    print( <span class="kw">true</span>  || <span class="kw">true</span>  ) ; <span class="co">// true</span></a>
<a class="sourceLine" id="cb196-11" data-line-number="11">}</a></code></pre></div>
<p>論理和は、「AもしくはB」を表現するのに使える。</p>
<p>例えば、ある遊園地の乗り物には安全上の理由で身長が1.1m未満、あるいは1.9mを超える人は乗れないものとする。この場合、乗り物に乗れる身長かどうかを確かめるコードは、<code>if文</code>を使うと以下のようになる。</p>
<div class="sourceCode" id="cb197"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb197-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb197-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb197-3" data-line-number="3">    <span class="dt">double</span> height = <span class="fl">1.3</span> ;</a>
<a class="sourceLine" id="cb197-4" data-line-number="4"></a>
<a class="sourceLine" id="cb197-5" data-line-number="5">    <span class="cf">if</span> ( height &lt; <span class="fl">1.1</span> )</a>
<a class="sourceLine" id="cb197-6" data-line-number="6">    { <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;No.&quot;</span>s ; }</a>
<a class="sourceLine" id="cb197-7" data-line-number="7">    <span class="cf">else</span> <span class="cf">if</span> ( height &gt; <span class="fl">1.9</span> )</a>
<a class="sourceLine" id="cb197-8" data-line-number="8">    { <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;No.&quot;</span>s ; }</a>
<a class="sourceLine" id="cb197-9" data-line-number="9">    <span class="cf">else</span></a>
<a class="sourceLine" id="cb197-10" data-line-number="10">    { <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Yes.&quot;</span>s ; }</a>
<a class="sourceLine" id="cb197-11" data-line-number="11">}</a></code></pre></div>
<p>論理和を使うと以下のように簡潔に書ける。</p>
<div class="sourceCode" id="cb198"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb198-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb198-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb198-3" data-line-number="3">    <span class="dt">double</span> height = <span class="fl">1.3</span> ;</a>
<a class="sourceLine" id="cb198-4" data-line-number="4"></a>
<a class="sourceLine" id="cb198-5" data-line-number="5">    <span class="cf">if</span> ( ( height &lt; <span class="fl">1.1</span> ) || ( height &gt; <span class="fl">1.9</span> ) )</a>
<a class="sourceLine" id="cb198-6" data-line-number="6">    { <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;No.&quot;</span>s ; }</a>
<a class="sourceLine" id="cb198-7" data-line-number="7">    <span class="cf">else</span></a>
<a class="sourceLine" id="cb198-8" data-line-number="8">    { <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Yes.&quot;</span>s ; }</a>
<a class="sourceLine" id="cb198-9" data-line-number="9">}</a></code></pre></div>
<h3 id="短絡評価">短絡評価</h3>
<p>論理積と論理和は短絡評価と呼ばれる特殊な評価が行われる。これは、左から右に最小限の評価をするという意味だ。</p>
<p>論理積では、“a &amp;&amp; b”とある場合、<code>a</code>と<code>b</code>が共に<code>true</code>である場合のみ、結果は<code>true</code>になる。もし、<code>a</code>が<code>false</code>であった場合、<code>b</code>の結果如何にかかわらず結果は<code>false</code>となるので、<code>b</code>は評価されない。</p>
<div class="sourceCode" id="cb199"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb199-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb199-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb199-3" data-line-number="3">    <span class="kw">auto</span> a = []()</a>
<a class="sourceLine" id="cb199-4" data-line-number="4">    {</a>
<a class="sourceLine" id="cb199-5" data-line-number="5">        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;a</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb199-6" data-line-number="6">        <span class="cf">return</span> <span class="kw">false</span> ;</a>
<a class="sourceLine" id="cb199-7" data-line-number="7">    } ;</a>
<a class="sourceLine" id="cb199-8" data-line-number="8">    <span class="kw">auto</span> b = []()</a>
<a class="sourceLine" id="cb199-9" data-line-number="9">    {</a>
<a class="sourceLine" id="cb199-10" data-line-number="10">        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;b</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb199-11" data-line-number="11">        <span class="cf">return</span> <span class="kw">true</span> ;</a>
<a class="sourceLine" id="cb199-12" data-line-number="12">    } ;</a>
<a class="sourceLine" id="cb199-13" data-line-number="13"></a>
<a class="sourceLine" id="cb199-14" data-line-number="14">    <span class="dt">bool</span> c = a() &amp;&amp; b() ;</a>
<a class="sourceLine" id="cb199-15" data-line-number="15">    <span class="bu">std::</span>cout &lt;&lt; <span class="bu">std::</span>boolalpha &lt;&lt; c ; </a>
<a class="sourceLine" id="cb199-16" data-line-number="16">}</a></code></pre></div>
<p>これを実行すると以下のようになる。</p>
<pre><code>a
false</code></pre>
<p>関数呼び出し“a()”の結果は<code>false</code>なので、“b()”は評価されない。評価されないということは関数呼び出しが行われず、当然標準出力も行われない。</p>
<p>同様に、論理和では、“a || b”とある場合、<code>a</code>と<code>b</code>のどちらか片方でも<code>true</code>であれば、結果は<code>true</code>となる。もし、<code>a</code>が<code>true</code>であった場合、<code>b</code>の結果如何にかかわらず結果は<code>true</code>となるので、<code>b</code>は評価されない。</p>
<div class="sourceCode" id="cb201"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb201-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb201-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb201-3" data-line-number="3">    <span class="kw">auto</span> a = []()</a>
<a class="sourceLine" id="cb201-4" data-line-number="4">    {</a>
<a class="sourceLine" id="cb201-5" data-line-number="5">        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;a</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb201-6" data-line-number="6">        <span class="cf">return</span> <span class="kw">true</span> ;</a>
<a class="sourceLine" id="cb201-7" data-line-number="7">    } ;</a>
<a class="sourceLine" id="cb201-8" data-line-number="8">    <span class="kw">auto</span> b = []()</a>
<a class="sourceLine" id="cb201-9" data-line-number="9">    {</a>
<a class="sourceLine" id="cb201-10" data-line-number="10">        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;b</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb201-11" data-line-number="11">        <span class="cf">return</span> <span class="kw">false</span> ;</a>
<a class="sourceLine" id="cb201-12" data-line-number="12">    } ;</a>
<a class="sourceLine" id="cb201-13" data-line-number="13"></a>
<a class="sourceLine" id="cb201-14" data-line-number="14">    <span class="dt">bool</span> c = a() &amp;&amp; b() ;</a>
<a class="sourceLine" id="cb201-15" data-line-number="15">    <span class="bu">std::</span>cout &lt;&lt; <span class="bu">std::</span>boolalpha &lt;&lt; c ; </a>
<a class="sourceLine" id="cb201-16" data-line-number="16">}</a></code></pre></div>
<p>結果、</p>
<pre><code>a
true</code></pre>
<p>“b()”が評価されていないことがわかる。</p>
<h2 id="boolの変換">boolの変換</h2>
<p><code>bool</code>型の値と演算はこれで全部だ。値は<code>true</code>/<code>false</code>の2つのみ。演算は==, !=, !と&amp;&amp;と||の5つだけだ。</p>
<p>読者の中には納得の行かないものもいるだろう。ちょっとまってもらいたい。boolの大小比較できないのだろうか。boolの四則演算はできないのか。“if(123)”などと書けてしまうのはなんなのか。</p>
<p>好奇心旺盛な読者は本書の解説を待たずしてすでに自分で色々とコードを書いて試してしまっていることだろう。</p>
<p>boolの大小比較はどうなるのだろうか。</p>
<div class="sourceCode" id="cb203"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb203-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb203-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb203-3" data-line-number="3">    <span class="bu">std::</span>cout &lt;&lt; <span class="bu">std::</span>boolalpha ;</a>
<a class="sourceLine" id="cb203-4" data-line-number="4"></a>
<a class="sourceLine" id="cb203-5" data-line-number="5">    <span class="dt">bool</span> b = <span class="kw">true</span> &lt; <span class="kw">false</span> ;</a>
<a class="sourceLine" id="cb203-6" data-line-number="6">    <span class="bu">std::</span>cout &lt;&lt; b ;</a>
<a class="sourceLine" id="cb203-7" data-line-number="7">}</a></code></pre></div>
<p>このコードを実行すると、出力は“false”だ。“true &lt; false”の結果が“false”だということは、<code>true</code>は<code>false</code>より大きいということになる</p>
<p>四則演算はどうか？</p>
<div class="sourceCode" id="cb204"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb204-1" data-line-number="1"></a>
<a class="sourceLine" id="cb204-2" data-line-number="2"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb204-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb204-4" data-line-number="4">    <span class="kw">auto</span> print = [](<span class="kw">auto</span> x)</a>
<a class="sourceLine" id="cb204-5" data-line-number="5">    { <span class="bu">std::</span>cout &lt;&lt; x &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ; } ;</a>
<a class="sourceLine" id="cb204-6" data-line-number="6"></a>
<a class="sourceLine" id="cb204-7" data-line-number="7">    print( <span class="kw">true</span>  + <span class="kw">true</span>  ) ;</a>
<a class="sourceLine" id="cb204-8" data-line-number="8">    print( <span class="kw">true</span>  + <span class="kw">false</span> ) ;</a>
<a class="sourceLine" id="cb204-9" data-line-number="9">    print( <span class="kw">false</span> + <span class="kw">true</span>  ) ;</a>
<a class="sourceLine" id="cb204-10" data-line-number="10">    print( <span class="kw">false</span> + <span class="kw">false</span> ) ;</a>
<a class="sourceLine" id="cb204-11" data-line-number="11">}</a></code></pre></div>
<p>結果、</p>
<pre><code>2
1
1
0</code></pre>
<p>不思議な結果だ。“true+true”は“2”、“true+false”は“1”、“false+false”は“0”。これは<code>true</code>が1で<code>false</code>が0ならば納得の行く結果だ。大小比較の結果としても矛盾していない。</p>
<p>すでに見たように、std::boolalphaを出力していない状態でboolを出力すると<code>true</code>が1、<code>false</code>が0となる。</p>
<div class="sourceCode" id="cb206"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb206-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb206-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb206-3" data-line-number="3">    <span class="bu">std::</span>cout &lt;&lt; <span class="kw">true</span> &lt;&lt; <span class="kw">false</span> ;</a>
<a class="sourceLine" id="cb206-4" data-line-number="4">}</a></code></pre></div>
<p>結果、</p>
<pre><code>10</code></pre>
<p>これは<code>bool型</code>と<code>整数型</code>が変換されているのだ。</p>
<p>ことなる型の値が変換されるというのは、すでに例がある。<code>整数型</code>と<code>浮動小数点数型</code>だ。</p>
<div class="sourceCode" id="cb208"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb208-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb208-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb208-3" data-line-number="3">    <span class="co">// 3</span></a>
<a class="sourceLine" id="cb208-4" data-line-number="4">    <span class="dt">int</span> i = <span class="fl">3.14</span> ;</a>
<a class="sourceLine" id="cb208-5" data-line-number="5">    <span class="bu">std::</span>cout &lt;&lt; i &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb208-6" data-line-number="6"></a>
<a class="sourceLine" id="cb208-7" data-line-number="7">    <span class="co">// 123.0</span></a>
<a class="sourceLine" id="cb208-8" data-line-number="8">    <span class="dt">double</span> d = <span class="dv">123</span> ;</a>
<a class="sourceLine" id="cb208-9" data-line-number="9">    <span class="bu">std::</span>cout &lt;&lt; d &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb208-10" data-line-number="10">}</a></code></pre></div>
<p><code>浮動小数点数型</code>は<code>整数型</code>に変換できる。その際に小数部は切り捨てられる。<code>整数型</code>は<code>浮動小数点数型</code>に変換できる。小数部はない。</p>
<p>これと同じように、<code>bool型</code>も<code>整数型</code>と変換ができる。</p>
<p>bool型の<code>true</code>を<code>整数型</code>に変換すると1になる。<code>false</code>は0になる。</p>
<pre><code>int main()
{
    // 1
    int True = true ;
    // 0
    int False = false ;
}</code></pre>
<p>同様に、<code>整数型</code>のゼロを<code>bool型</code>に変換すると<code>false</code>になる。非ゼロは<code>true</code>になる。</p>
<div class="sourceCode" id="cb210"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb210-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb210-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb210-3" data-line-number="3">    <span class="co">// false</span></a>
<a class="sourceLine" id="cb210-4" data-line-number="4">    <span class="dt">bool</span> Zero = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb210-5" data-line-number="5"></a>
<a class="sourceLine" id="cb210-6" data-line-number="6">    <span class="co">// すべてtrue</span></a>
<a class="sourceLine" id="cb210-7" data-line-number="7">    <span class="dt">bool</span> One = <span class="dv">1</span> ;</a>
<a class="sourceLine" id="cb210-8" data-line-number="8">    <span class="dt">bool</span> minus_one = <span class="dv">-1</span> ;</a>
<a class="sourceLine" id="cb210-9" data-line-number="9">    <span class="dt">bool</span> OneTwoThree = <span class="dv">123</span> ;  </a>
<a class="sourceLine" id="cb210-10" data-line-number="10">}</a></code></pre></div>
<p>したがって、“if (0)”は“if (false)”と等しく、“if (1)”や“if(-1)”など非ゼロな値は“if (true)”と等しい。</p>
<div class="sourceCode" id="cb211"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb211-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb211-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb211-3" data-line-number="3">    <span class="co">// 出力されない</span></a>
<a class="sourceLine" id="cb211-4" data-line-number="4">    <span class="cf">if</span> ( <span class="dv">0</span> )</a>
<a class="sourceLine" id="cb211-5" data-line-number="5">        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;No output.</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb211-6" data-line-number="6"></a>
<a class="sourceLine" id="cb211-7" data-line-number="7">    <span class="co">// 出力される</span></a>
<a class="sourceLine" id="cb211-8" data-line-number="8">    <span class="cf">if</span> ( <span class="dv">1</span> )</a>
<a class="sourceLine" id="cb211-9" data-line-number="9">        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Output.</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb211-10" data-line-number="10">}</a></code></pre></div>
<p>大小比較は単にboolを整数に変換した結果を比較しているだけだ。“true &lt; false”は“1 &lt; 0”と書くのと同じだ。</p>
<div class="sourceCode" id="cb212"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb212-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb212-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb212-3" data-line-number="3">    <span class="bu">std::</span>cout &lt;&lt; <span class="bu">std::</span>boolalpha ;</a>
<a class="sourceLine" id="cb212-4" data-line-number="4"></a>
<a class="sourceLine" id="cb212-5" data-line-number="5">    <span class="co">// 1 &lt; 0</span></a>
<a class="sourceLine" id="cb212-6" data-line-number="6">    <span class="bu">std::</span>cout &lt;&lt; (<span class="kw">true</span> &lt; <span class="kw">false</span>) ;</a>
<a class="sourceLine" id="cb212-7" data-line-number="7">}</a></code></pre></div>
<p>同様に四則演算もbool型を整数型に変換した上で計算をしているだけだ。“true + true”は“1 + 1”と書くのと同じだ。</p>
<div class="sourceCode" id="cb213"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb213-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb213-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb213-3" data-line-number="3">    <span class="co">// 1 + 1</span></a>
<a class="sourceLine" id="cb213-4" data-line-number="4">    <span class="bu">std::</span>cout &lt;&lt; (<span class="kw">true</span> + <span class="kw">true</span>) ;</a>
<a class="sourceLine" id="cb213-5" data-line-number="5">}</a></code></pre></div>
<p>C++では、<code>bool型</code>と<code>整数型</code>の変換は暗黙に行われてしまうので注意が必要だ。</p>
<h1 id="デバッグ-コンパイル警告メッセージ">デバッグ: コンパイル警告メッセージ</h1>
<p>やれやれ、条件分岐は難しかった。この辺でもう一度一休みして、息抜きとしてデバッグの話をしよう。今回はコンパイラーの警告メッセージ(warning messages)についてだ。</p>
<p>コンパイラーはソースコードに文法エラーや意味エラーがあると、エラーメッセージを出すことはすでに学んだ。</p>
<p>コンパイラーがエラーメッセージを出さなかったとき、コンパイラーはソースコードには文法エラーや意味エラーを発見できず、コンパイラーは意味のあるプログラムを生成することができたということを意味する。しかし、コンパイルが通って実行可能なプログラムが生成できたからと行って、プログラムにバグがないことは保証できない。</p>
<p>たとえば、変数xとyを足して出力するプログラムを考える。</p>
<div class="sourceCode" id="cb214"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb214-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb214-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb214-3" data-line-number="3">    <span class="kw">auto</span> x = <span class="dv">1</span> ;</a>
<a class="sourceLine" id="cb214-4" data-line-number="4">    <span class="kw">auto</span> y = <span class="dv">2</span> ;</a>
<a class="sourceLine" id="cb214-5" data-line-number="5"></a>
<a class="sourceLine" id="cb214-6" data-line-number="6">    <span class="bu">std::</span>cout &lt;&lt; x + x ;</a>
<a class="sourceLine" id="cb214-7" data-line-number="7">}</a></code></pre></div>
<p>このプログラムにはバグがある。プログラムの仕様は変数xとyを足すはずだったが変数xとxを足してしまっている。</p>
<p>コンパイラーはこのソースコードをコンパイルエラーにはしない。なぜならば上のコードは文法的に正しく、意味的にも正しいコードだからだ。</p>
<p>警告メッセージはこのような疑わしいコードについて、エラーとまでは行かないまでも、文字通り警告を出す機能だ。例えば上のコードをGCCでコンパイルすると以下のような警告メッセージを出す</p>
<pre><code>$ make
g++ -std=c++17 -Wall --pedantic-error -include all.h main.cpp -o program
main.cpp: In function ‘int main()’:
main.cpp:5:10: warning: unused variable ‘y’ [-Wunused-variable]
     auto y = 2 ;
          ^</code></pre>
<p>すでに説明したように、GCCのメッセージは</p>
<pre><code>ソースファイル名:行番号:列番号:メッセージの種類:メッセージの内容</code></pre>
<p>というフォーマットを取る。</p>
<p>このメッセージのフォーマットに照らし合わせると、このメッセージはソースファイルmain.cppの5行目の10列目について何かを警告している。警告はメッセージの種類として<code>warning</code>が使われる。</p>
<p>警告メッセージの内容は、「未使用の変数’y’ [-Wunused-variable]」だ。コード中で’y’という名前の変数を宣言しているにもかかわらず、使っている場所がない。使わない変数を宣言するのはバグの可能性が高いので警告しているのだ。</p>
<p>[-Wunused-variable]というのはGCCに与えるこの警告を有効にするためのオプション名だ。GCCに-Wunused-variableというオプションを与えると、未使用の変数を警告するようになる。</p>
<pre><code>$ g++ -Wunused-variable その他のオプション</code></pre>
<p>今回は-Wallというすべての警告を有効にするオプションを使っているので、このオプションを使う必要はない。</p>
<p>もう一つ例を出そう。以下のソースコードは変数xの値が123と等しいかどうかを調べるものだ。</p>
<div class="sourceCode" id="cb218"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb218-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb218-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb218-3" data-line-number="3">    <span class="co">// xの値は0</span></a>
<a class="sourceLine" id="cb218-4" data-line-number="4">    <span class="kw">auto</span> x = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb218-5" data-line-number="5"></a>
<a class="sourceLine" id="cb218-6" data-line-number="6">    <span class="co">// xが123と等しいかどうか比較する</span></a>
<a class="sourceLine" id="cb218-7" data-line-number="7">    <span class="cf">if</span> ( x = <span class="dv">123</span> )</a>
<a class="sourceLine" id="cb218-8" data-line-number="8">        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;x is 123.</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb218-9" data-line-number="9">    <span class="cf">else</span></a>
<a class="sourceLine" id="cb218-10" data-line-number="10">        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;x is NOT 123.</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb218-11" data-line-number="11">}</a></code></pre></div>
<p>これを実行すると、“x is 123.”と出力される。しかし、変数xの値は0のはずだ。なぜか0と123は等しいと判断されてしまった。一体どういうことだろう。</p>
<p>この謎は警告メッセージを読むと解ける。</p>
<pre><code>g++ -std=c++17 -Wall --pedantic-error -include all.h main.cpp -o program
main.cpp: In function ‘int main()’:
main.cpp:5:12: warning: suggest parentheses around assignment used as truth value [-Wparentheses]
     if ( x = 123 )
          ~~^~~~~</code></pre>
<p>main.cppの5行目の12列目、「真偽値として使われている代入は括弧で囲むべき」とある。これは一体どういうことか。よく見てみると、演算子が同値比較につかう==ではなく、=だ。=は代入演算子だ。</p>
<div class="sourceCode" id="cb220"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb220-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb220-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb220-3" data-line-number="3">    <span class="kw">auto</span> x = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb220-4" data-line-number="4"></a>
<a class="sourceLine" id="cb220-5" data-line-number="5">    <span class="co">// 代入</span></a>
<a class="sourceLine" id="cb220-6" data-line-number="6">    <span class="co">// xの値は1</span></a>
<a class="sourceLine" id="cb220-7" data-line-number="7">    x = <span class="dv">1</span> ;</a>
<a class="sourceLine" id="cb220-8" data-line-number="8"></a>
<a class="sourceLine" id="cb220-9" data-line-number="9">    <span class="co">// 同値比較</span></a>
<a class="sourceLine" id="cb220-10" data-line-number="10">    x == <span class="dv">1</span> ;</a>
<a class="sourceLine" id="cb220-11" data-line-number="11">}</a></code></pre></div>
<p>実は<code>if文</code>の<code>条件</code>にはあらゆる<code>式</code>を書くことができる。代入というのは、実は<code>代入式</code>という式なので、<code>if文</code>の中にも書くことができる。その場合、式の結果の値は代入される変数の値になる。</p>
<p>そして思い出してほしいのは、整数型はbool型に変換されるということだ。0は<code>false</code>、非ゼロは<code>true</code>だ。</p>
<div class="sourceCode" id="cb221"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb221-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb221-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb221-3" data-line-number="3">    <span class="kw">auto</span> x = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb221-4" data-line-number="4">    <span class="co">// 1はtrue</span></a>
<a class="sourceLine" id="cb221-5" data-line-number="5">    <span class="dt">bool</span> b1 = x = <span class="dv">1</span> ;</a>
<a class="sourceLine" id="cb221-6" data-line-number="6">    <span class="cf">if</span> ( x = <span class="dv">1</span> ) ;</a>
<a class="sourceLine" id="cb221-7" data-line-number="7"></a>
<a class="sourceLine" id="cb221-8" data-line-number="8">    <span class="co">// 0はfalse</span></a>
<a class="sourceLine" id="cb221-9" data-line-number="9">    <span class="dt">bool</span> b0 = x = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb221-10" data-line-number="10">    <span class="cf">if</span> ( x = <span class="dv">0</span> ) ;</a>
<a class="sourceLine" id="cb221-11" data-line-number="11">}</a></code></pre></div>
<p>つまり、“if(x=1)”というのは、“if(1)”と書くのと同じで、これは最終的に、“if(true)”と同じ意味になる。</p>
<p>警告メッセージの「括弧で囲むべき」というのは、括弧で囲んだ場合、この警告メッセージはでなくなるからだ。</p>
<div class="sourceCode" id="cb222"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb222-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb222-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb222-3" data-line-number="3">    <span class="kw">auto</span> x = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb222-4" data-line-number="4"></a>
<a class="sourceLine" id="cb222-5" data-line-number="5">    <span class="cf">if</span> ( (x = <span class="dv">0</span>) )</a>
<a class="sourceLine" id="cb222-6" data-line-number="6">        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;x is 123.</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb222-7" data-line-number="7">    <span class="cf">else</span></a>
<a class="sourceLine" id="cb222-8" data-line-number="8">        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;x is NOT 123.</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb222-9" data-line-number="9">}</a></code></pre></div>
<p>このコードをコンパイルしても警告メッセージはでない。</p>
<p>わざわざ括弧で囲むということは、ちゃんと代入を意図して使っていることがわかっていると意思表示したことになり、結果として警告メッセージはなくなる。</p>
<p>この警告メッセージ単体を有効にするオプションは<code>-Wparentheses</code>だ。</p>
<p>警告メッセージは万能ではない。時には全く問題ないコードに対して警告メッセージがでたりする。これは仕方がないことだ。というのもコンパイラーはソースコード中に表現されていない、人間の脳内にある意図を読むことはできないからだ。ただし、警告メッセージには一通り目を通して、それが問題ない誤検知であるかどうかを確認することは重要だ。</p>
<h1 id="最近体重が気になるあなたのための標準入力">最近体重が気になるあなたのための標準入力</h1>
<h2 id="これまでのおさらい">これまでのおさらい</h2>
<p>ここまで学んできた範囲でも、かなりのプログラムが書けるようになってきた。試しにちょっとプログラムを書いてみよう。</p>
<p>最近肥満が気になる読者は、肥満度を把握するためにBMI(Body Mass Index)を計算して出力するプログラムを書くことにした。</p>
<p>BMIの計算は以下の通り。</p>
<p><span class="math display">\[
BMI = \frac{体重_{kg}}{身長^2_{m}}
\]</span></p>
<p>本書をここまで読み進めた読者ならば、このようなプログラムは簡単に書けるだろう。計算は小数点以下の値を扱う必要があるために、変数は浮動小数点数型(double)にする。掛け算は<code>operator *</code>で、割り算は<code>operator /</code>だ。出力にはstd::coutを使う。</p>
<div class="sourceCode" id="cb223"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb223-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb223-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb223-3" data-line-number="3">    <span class="co">// 身長1.63m</span></a>
<a class="sourceLine" id="cb223-4" data-line-number="4">    <span class="dt">double</span> height = <span class="fl">1.63</span> ;</a>
<a class="sourceLine" id="cb223-5" data-line-number="5">    <span class="co">// 体重73kg</span></a>
<a class="sourceLine" id="cb223-6" data-line-number="6">    <span class="dt">double</span> mass = <span class="fl">73.0</span> ;</a>
<a class="sourceLine" id="cb223-7" data-line-number="7"></a>
<a class="sourceLine" id="cb223-8" data-line-number="8">    <span class="co">// BMIの計算</span></a>
<a class="sourceLine" id="cb223-9" data-line-number="9">    <span class="dt">double</span> bmi = mass / (height*height) ;</a>
<a class="sourceLine" id="cb223-10" data-line-number="10"></a>
<a class="sourceLine" id="cb223-11" data-line-number="11">    <span class="co">// BMIの出力</span></a>
<a class="sourceLine" id="cb223-12" data-line-number="12">    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;BMI=&quot;</span> &lt;&lt; bmi &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb223-13" data-line-number="13">}</a></code></pre></div>
<p>結果は“27.4756”となった。これだけでは太っているのか痩せているのかよくわからない。調べてみると、BMIの数値と肥満との関係は以下の表のとおりになるそうだ。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">BMI</th>
<th style="text-align: left;">状態</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">18.5未満</td>
<td style="text-align: left;">痩せすぎ(Underweight)</td>
</tr>
<tr class="even">
<td style="text-align: left;">18.5以上、25未満</td>
<td style="text-align: left;">普通(Normal)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">25以上、30未満</td>
<td style="text-align: left;">太り気味(Overweight)</td>
</tr>
<tr class="even">
<td style="text-align: left;">30以上</td>
<td style="text-align: left;">肥満(Obese)</td>
</tr>
</tbody>
</table>
<p>では早速、この表のようにBMIから肥満状態も出力してくれるように、プログラムを書き換えよう。</p>
<div class="sourceCode" id="cb224"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb224-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb224-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb224-3" data-line-number="3">    <span class="co">// 身長1.6m</span></a>
<a class="sourceLine" id="cb224-4" data-line-number="4">    <span class="dt">double</span> height = <span class="fl">1.63</span> ;</a>
<a class="sourceLine" id="cb224-5" data-line-number="5">    <span class="co">// 体重73kg</span></a>
<a class="sourceLine" id="cb224-6" data-line-number="6">    <span class="dt">double</span> mass = <span class="fl">73.0</span> ;</a>
<a class="sourceLine" id="cb224-7" data-line-number="7"></a>
<a class="sourceLine" id="cb224-8" data-line-number="8">    <span class="co">// BMIの計算</span></a>
<a class="sourceLine" id="cb224-9" data-line-number="9">    <span class="dt">double</span> bmi = mass / (height*height) ;</a>
<a class="sourceLine" id="cb224-10" data-line-number="10"></a>
<a class="sourceLine" id="cb224-11" data-line-number="11">    <span class="co">// BMIの出力</span></a>
<a class="sourceLine" id="cb224-12" data-line-number="12">    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;BMI=&quot;</span> &lt;&lt; bmi &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb224-13" data-line-number="13"></a>
<a class="sourceLine" id="cb224-14" data-line-number="14">    <span class="co">// 状態の判定をする関数</span></a>
<a class="sourceLine" id="cb224-15" data-line-number="15">    <span class="kw">auto</span> status = []( <span class="dt">double</span> bmi )</a>
<a class="sourceLine" id="cb224-16" data-line-number="16">    {</a>
<a class="sourceLine" id="cb224-17" data-line-number="17">        <span class="cf">if</span> ( bmi &lt; <span class="fl">18.5</span> )</a>
<a class="sourceLine" id="cb224-18" data-line-number="18">            <span class="cf">return</span> <span class="st">&quot;Underweight.</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb224-19" data-line-number="19">        <span class="cf">else</span> <span class="cf">if</span> ( bmi &lt; <span class="fl">25.0</span> )</a>
<a class="sourceLine" id="cb224-20" data-line-number="20">            <span class="cf">return</span> <span class="st">&quot;Normal.</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb224-21" data-line-number="21">        <span class="cf">else</span> <span class="cf">if</span> ( bmi &lt; <span class="fl">30.0</span> )</a>
<a class="sourceLine" id="cb224-22" data-line-number="22">            <span class="cf">return</span> <span class="st">&quot;Overweight.</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb224-23" data-line-number="23">        <span class="cf">else</span></a>
<a class="sourceLine" id="cb224-24" data-line-number="24">            <span class="cf">return</span> <span class="st">&quot;Obese.&quot;</span>s ;</a>
<a class="sourceLine" id="cb224-25" data-line-number="25">    } ;</a>
<a class="sourceLine" id="cb224-26" data-line-number="26"></a>
<a class="sourceLine" id="cb224-27" data-line-number="27">    <span class="co">// 状態の出力</span></a>
<a class="sourceLine" id="cb224-28" data-line-number="28">    <span class="bu">std::</span>cout &lt;&lt; status(bmi) ;</a>
<a class="sourceLine" id="cb224-29" data-line-number="29">}</a></code></pre></div>
<p>ここまで問題なく読むことができただろうか。ここまでのコードはすべて、本書をはじめからから読めば理解できる機能しか使っていない。わからない場合、この先に進む前に本書をもう一度はじめから読みなすべきだろう。</p>
<h2 id="標準入力">標準入力</h2>
<p>上のプログラムには実用にする上で一つ問題がある。身長と体重の値を変えたい場合、ソースコードを書き換えてコンパイルしなければならないのだ。</p>
<p>例えば読者の身長が1.8mで体重が80kgの場合、以下のように書き換えなければならない。</p>
<div class="sourceCode" id="cb225"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb225-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb225-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb225-3" data-line-number="3">    <span class="co">// 身長1.63m</span></a>
<a class="sourceLine" id="cb225-4" data-line-number="4">    <span class="dt">double</span> height = <span class="fl">1.80</span> ;</a>
<a class="sourceLine" id="cb225-5" data-line-number="5">    <span class="co">// 体重73kg</span></a>
<a class="sourceLine" id="cb225-6" data-line-number="6">    <span class="dt">double</span> mass = <span class="fl">80.0</span> ;</a>
<a class="sourceLine" id="cb225-7" data-line-number="7"></a>
<a class="sourceLine" id="cb225-8" data-line-number="8">    <span class="co">// BMIの計算</span></a>
<a class="sourceLine" id="cb225-9" data-line-number="9">    <span class="dt">double</span> bmi = mass / (height*height) ;</a>
<a class="sourceLine" id="cb225-10" data-line-number="10"></a>
<a class="sourceLine" id="cb225-11" data-line-number="11">    <span class="co">// BMIの出力</span></a>
<a class="sourceLine" id="cb225-12" data-line-number="12">    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;BMI=&quot;</span> &lt;&lt; bmi &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb225-13" data-line-number="13">}</a></code></pre></div>
<p>すると今度は身長が1.48mで体重が48kgの人がやってきて私のBMIも計測しろとうるさい。しかも昨日と今日で体重が変わったからどちらも計測したいと言い出す始末。</p>
<p>こういうとき、プログラムのコンパイル時ではなく、実行時に値を入力できたならば、いちいちプログラムをコンパイルし直す必要がなくなる。</p>
<p>入力には<code>std::cin</code>を使う。<code>std::cout</code>は標準出力を扱うのに対し、<code>std::cin</code>は標準入力を扱う。<code>std::cout</code>が<code>operator &lt;&lt;</code>を使って値を出力したのに対し、<code>std::cin</code>は<code>operator &gt;&gt;</code>を使って値を変数に入れる。</p>
<div class="sourceCode" id="cb226"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb226-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb226-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb226-3" data-line-number="3">    <span class="co">// 入力を受け取るための変数</span></a>
<a class="sourceLine" id="cb226-4" data-line-number="4">    <span class="bu">std::</span>string x{} ;</a>
<a class="sourceLine" id="cb226-5" data-line-number="5">    <span class="co">// 変数に入力を受け取る</span></a>
<a class="sourceLine" id="cb226-6" data-line-number="6">    <span class="bu">std::</span>cin &gt;&gt; x ;</a>
<a class="sourceLine" id="cb226-7" data-line-number="7">    <span class="co">// 入力された値を出力</span></a>
<a class="sourceLine" id="cb226-8" data-line-number="8">    <span class="bu">std::</span>cout &lt;&lt; x ;</a>
<a class="sourceLine" id="cb226-9" data-line-number="9">}</a></code></pre></div>
<p>実行結果、</p>
<pre><code>$ make run
hello
hello</code></pre>
<p>標準入力はデフォルトでは、プログラムを実行したユーザーがターミナルから入力する。上の実行結果の2行目は、ユーザーの入力だ。</p>
<p><code>std::cin</code>は入力された文字列を変数に入れる。入力は空白文字や改行で区切られる。そのため、空白で区切られた文字列を渡すと、以下のようになる。</p>
<pre><code>$ make run
hello world
hello</code></pre>
<p>入力は複数取ることができる。</p>
<div class="sourceCode" id="cb229"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb229-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb229-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb229-3" data-line-number="3">    <span class="bu">std::</span>string x{} ;</a>
<a class="sourceLine" id="cb229-4" data-line-number="4">    <span class="bu">std::</span>string y{} ;</a>
<a class="sourceLine" id="cb229-5" data-line-number="5">    <span class="bu">std::</span>cin &gt;&gt;  x &gt;&gt; y ;</a>
<a class="sourceLine" id="cb229-6" data-line-number="6">    <span class="bu">std::</span>cout &lt;&lt; x &lt;&lt; y ;</a>
<a class="sourceLine" id="cb229-7" data-line-number="7">}</a></code></pre></div>
<p>実行結果、</p>
<pre><code>$ make run
hello world
helloworld</code></pre>
<p>空白文字は文字列の区切り文字として認識されるので変数x, yには入らない。</p>
<p><code>std::cin</code>では文字列の他にも整数や浮動小数点数、boolを入力として得ることができる。</p>
<div class="sourceCode" id="cb231"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb231-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb231-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb231-3" data-line-number="3">    <span class="co">// 整数</span></a>
<a class="sourceLine" id="cb231-4" data-line-number="4">    <span class="dt">int</span> i{} ;</a>
<a class="sourceLine" id="cb231-5" data-line-number="5">    <span class="bu">std::</span>cin &gt;&gt; i ;</a>
<a class="sourceLine" id="cb231-6" data-line-number="6">    <span class="co">// 浮動小数点数</span></a>
<a class="sourceLine" id="cb231-7" data-line-number="7">    <span class="dt">double</span> d{} ;</a>
<a class="sourceLine" id="cb231-8" data-line-number="8">    <span class="bu">std::</span>cin &gt;&gt; d ;</a>
<a class="sourceLine" id="cb231-9" data-line-number="9">}</a></code></pre></div>
<p>実行結果、</p>
<pre><code>$ make run
123 1.23</code></pre>
<p>数値はデフォルトで10進数として扱われる。</p>
<p>boolの入力には注意が必要だ。普通に書くと、ゼロが<code>false</code>, 非ゼロが<code>true</code>として扱われる。</p>
<div class="sourceCode" id="cb233"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb233-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb233-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb233-3" data-line-number="3">    <span class="dt">bool</span> b{} ;</a>
<a class="sourceLine" id="cb233-4" data-line-number="4">    <span class="bu">std::</span>cin &gt;&gt; b ;</a>
<a class="sourceLine" id="cb233-5" data-line-number="5"></a>
<a class="sourceLine" id="cb233-6" data-line-number="6">    <span class="bu">std::</span>cout &lt;&lt; <span class="bu">std::</span>boolalpha &lt;&lt; b &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb233-7" data-line-number="7">}</a></code></pre></div>
<p>実行結果、</p>
<pre><code>$ make run
1
true
$ make run
0
false
$ make run
123
true
$ make run
-1
true</code></pre>
<p>“true”, “false”という文字列で<code>true</code>, <code>false</code>の入力をしたい場合、<code>std::cin</code>に<code>std::boolalpha</code>を「入力」させる。</p>
<div class="sourceCode" id="cb235"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb235-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb235-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb235-3" data-line-number="3">    <span class="co">// bool型</span></a>
<a class="sourceLine" id="cb235-4" data-line-number="4">    <span class="dt">bool</span> b{} ;</a>
<a class="sourceLine" id="cb235-5" data-line-number="5">    <span class="bu">std::</span>cin &gt;&gt; <span class="bu">std::</span>boolalpha &gt;&gt; b ;</a>
<a class="sourceLine" id="cb235-6" data-line-number="6"></a>
<a class="sourceLine" id="cb235-7" data-line-number="7">    <span class="bu">std::</span>cout &lt;&lt; <span class="bu">std::</span>boolalpha &lt;&lt; b ;</a>
<a class="sourceLine" id="cb235-8" data-line-number="8">}</a></code></pre></div>
<p>実行結果</p>
<pre><code>$ make run
true
true
$ make run
false
false</code></pre>
<p>std::boolalphaを入出力するというのは、実際には何も入出力しないので奇妙に見えるが、そういう設計になっているので仕方がない。</p>
<p>では標準入力を学んだので、さっそくBMIを計算するプログラムを標準入力に対応させよう。</p>
<div class="sourceCode" id="cb237"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb237-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb237-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb237-3" data-line-number="3">    <span class="co">// 身長の入力</span></a>
<a class="sourceLine" id="cb237-4" data-line-number="4">    <span class="dt">double</span> height{} ;</a>
<a class="sourceLine" id="cb237-5" data-line-number="5">    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;height(m)&gt;&quot;</span> ;</a>
<a class="sourceLine" id="cb237-6" data-line-number="6">    <span class="bu">std::</span>cin &gt;&gt; height ;</a>
<a class="sourceLine" id="cb237-7" data-line-number="7"></a>
<a class="sourceLine" id="cb237-8" data-line-number="8">    <span class="co">// 体重の入力</span></a>
<a class="sourceLine" id="cb237-9" data-line-number="9">    <span class="dt">double</span> mass{} ;</a>
<a class="sourceLine" id="cb237-10" data-line-number="10">    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;mass(kg)&gt;&quot;</span> ;</a>
<a class="sourceLine" id="cb237-11" data-line-number="11">    <span class="bu">std::</span>cin &gt;&gt; mass ;</a>
<a class="sourceLine" id="cb237-12" data-line-number="12"></a>
<a class="sourceLine" id="cb237-13" data-line-number="13">    <span class="dt">double</span> bmi = mass / (height*height) ;</a>
<a class="sourceLine" id="cb237-14" data-line-number="14"></a>
<a class="sourceLine" id="cb237-15" data-line-number="15">    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;BMI=&quot;</span> &lt;&lt; bmi &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb237-16" data-line-number="16">}</a></code></pre></div>
<p>上出来だ。</p>
<h2 id="リダイレクト">リダイレクト</h2>
<p>標準入出力が扱えるようになれば、もう自分の好きなプログラムを書くことができる。プログラムというのは結局、入力を得て、処理して、出力するだけのものだからだ。入力はテキストだったりグラフィックだったり何らかの特殊なデバイスだったりするが、基本は変わらない。</p>
<p>たとえば読者はまだC++でファイルを読み書きする方法を知らないが、標準入出力さえ使えれば、ファイルの読み書きはリダイレクトを使うだけでできるのだ。</p>
<div class="sourceCode" id="cb238"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb238-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb238-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb238-3" data-line-number="3">    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;hello&quot;</span> ;</a>
<a class="sourceLine" id="cb238-4" data-line-number="4">}</a></code></pre></div>
<p>これは“hello”と標準出力するだけの簡単なプログラムだ。このプログラムをコンパイルしたプログラム名を<code>program</code>としよう。標準出力の出力先はデフォルトで、ユーザーのターミナルになる。</p>
<pre><code>$ ./program
hello</code></pre>
<p>リダイレクトを使えば、この出力先をファイルにできる。リダイレクトを使うには“プログラム &gt; ファイル名”とする</p>
<pre><code>$ ./program &gt; hello.txt
$ cat hello.txt
hello</code></pre>
<p>ファイルへの簡単な書き込みは、リダイレクトを使うことで後から簡単に実現可能だ。</p>
<p>リダイレクトはファイルの読み込みにも使える。例えば先程のBMIを計算するプログラムを用意しよう。</p>
<div class="sourceCode" id="cb241"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb241-1" data-line-number="1"><span class="co">// bmi</span></a>
<a class="sourceLine" id="cb241-2" data-line-number="2"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb241-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb241-4" data-line-number="4">    <span class="dt">double</span> height{ } ;</a>
<a class="sourceLine" id="cb241-5" data-line-number="5">    <span class="dt">double</span> mass { } ;</a>
<a class="sourceLine" id="cb241-6" data-line-number="6"></a>
<a class="sourceLine" id="cb241-7" data-line-number="7">    <span class="bu">std::</span>cin &gt;&gt; height &gt;&gt; mass ;</a>
<a class="sourceLine" id="cb241-8" data-line-number="8"></a>
<a class="sourceLine" id="cb241-9" data-line-number="9">    <span class="bu">std::</span>cout &lt;&lt; mass / (height*height) ;</a>
<a class="sourceLine" id="cb241-10" data-line-number="10">}</a></code></pre></div>
<p>このプログラム名を<code>bmi</code>として、通常通り実行すると以下のようになる。</p>
<pre><code>$　./bmi
1.63
73
27.4756</code></pre>
<p>このうち、1.63と73はユーザーによる入力だ。これを毎回手で入力するのではなく、ファイルから入力することができる。つまり以下のようなファイルを用意して、</p>
<pre><code>1.63
73</code></pre>
<p>このファイルを例えば、“bodymass.txt”とする。手で入力する代わりに、このファイルを入力として使いたい。これにはリダイレクトとして“プログラム名 &lt; ファイル名”とする。</p>
<pre><code>$ ./bmi &lt; bodymass.txt
27.4756</code></pre>
<p>リダイレクトの入出力を組み合わせることも可能だ。</p>
<pre><code>$ cat bodymass.txt
1.63
73
$ ./bmi &lt; bodymass.txt &gt; index.txt
$ cat index.text
27.4756</code></pre>
<p>もちろん、このようなファイルの読み書きは簡易的なものだが、かなりの処理がこの程度のファイル操作でも行えるのだ。</p>
<h2 id="パイプ">パイプ</h2>
<p>プログラムが出力した結果をさらに入力にすることだってできる。</p>
<p>例えば、先程のプログラム<code>bmi</code>に入力するファイル<code>bodymass.txt</code>の身長の単位がメートルではなくセンチメートルだったとしよう。</p>
<pre><code>163
73</code></pre>
<p>この場合、プログラム<code>bmi</code>を書き換えて対処することもできるが、プログラムに入力させる前にファイルを読み込み、書き換えて出力し、その出力を入力とすることもできる。</p>
<p>まず、身長の単位をセンチメートルからメートルに直すプログラムを書く。</p>
<div class="sourceCode" id="cb247"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb247-1" data-line-number="1"><span class="co">// convert</span></a>
<a class="sourceLine" id="cb247-2" data-line-number="2"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb247-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb247-4" data-line-number="4">    <span class="dt">double</span> height{} ;</a>
<a class="sourceLine" id="cb247-5" data-line-number="5">    <span class="dt">double</span> mass{} ;</a>
<a class="sourceLine" id="cb247-6" data-line-number="6"></a>
<a class="sourceLine" id="cb247-7" data-line-number="7">    <span class="bu">std::</span>cin &gt;&gt; height &gt;&gt; mass ;</a>
<a class="sourceLine" id="cb247-8" data-line-number="8"></a>
<a class="sourceLine" id="cb247-9" data-line-number="9">    <span class="co">// 身長をセンチメートルからメートルに直す</span></a>
<a class="sourceLine" id="cb247-10" data-line-number="10">    <span class="co">// 体重はそのままでよい</span></a>
<a class="sourceLine" id="cb247-11" data-line-number="11">    <span class="bu">std::</span>cout &lt;&lt; height/<span class="fl">100.0</span> &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s &lt;&lt; mass ;</a>
<a class="sourceLine" id="cb247-12" data-line-number="12">}</a></code></pre></div>
<p>このプログラムを<code>convert</code>と名付け、さっそく使ってみよう。</p>
<pre><code>$ ./convert
163
73
1.63
73</code></pre>
<p>身長の単位がセンチメートルからメートルに正しく直されている。</p>
<p>これをリダイレクトで使うとこうなる。</p>
<pre><code>$ ./convert &lt; bodymass.txt &gt; fixed_bodymass.txt
$ ./bmi &lt; fixed_bodymass.txt
27.4756</code></pre>
<p>しかしこれではファイルが増えて面倒だ。この場合、パイプを使うとスッキリと書ける。</p>
<p>パイプはプログラムの標準出力をプログラムの標準入力とするの使い方は、“プログラム名 | プログラム名”だ。</p>
<pre><code>$ ./convert &lt; bodymass.txt | ./bmi
27.4756</code></pre>
<p>ところで、すでに何度か説明無しで使っているが、POSIX規格を満たすOSには<code>cat</code>というプログラムが標準で入っている。<code>cat ファイル名</code>は指定したファイル名の内容を標準出力する。標準出力はパイプで標準入力にできる。</p>
<pre><code>$ cat bodymass.txt | ./convert | ./bmi
27.4756</code></pre>
<h2 id="プログラムの組み合わせ">プログラムの組み合わせ</h2>
<p>現代のプログラミングというのは、すでに存在するプログラムを組み合わせて作るものだ。もし、自分の必要とする処理がすでに実装されているのであれば、自分で書く必要はない。</p>
<p>例えば、読者はまだカレントディレクトリー下のファイルの一覧を列挙する方法を知らない。しかしPOSIX規格を満たすOSには<code>ls</code>というカレントディレクトリー下のファイルの一覧を列挙するプログラムが存在する。これを先程までBMIの計算などの作業をしていたディレクトリ下で実行してみよう。</p>
<pre><code>$ ls
all.h  all.h.gch  bmi  bodymass.txt  convert  data  main.cpp  Makefile  program</code></pre>
<p>ファイルの一覧が列挙される。そしてこれはプログラム<code>ls</code>による標準出力だ。標準出力ということは、リダイレクトしてファイルに書き込んだり、パイプで別のプログラムに渡したりできるということだ。</p>
<pre><code>$ ls &gt; files.txt
$ ls | ./program</code></pre>
<p>標準入出力が扱えれば、ネットワークごしにWebサイトをダウンロードすることもできる。これにはほとんどのGNU/LinuxベースのOSに入っている<code>curl</code>というプログラムを使う。</p>
<pre><code>$ curl https://example.com</code></pre>
<p>プログラム<code>curl</code>は指定されたURLからデータをダウンロードして、標準出力する。標準出力するということは、パイプによって標準入力にできるということだ。</p>
<pre><code>$ curl https://example.com | ./program</code></pre>
<p>読者はC++でネットワークアクセスする方法を知らないが、すでにネットワークアクセスは可能になった。</p>
<p>他にも便利なプログラムはたくさんある。プログラミングの学び始めはできることが少なくて退屈になりがちだが、読者はもうファイルの読み書きやネットワークアクセスまでできるようになったのだから、退屈はしないはずだ。</p>
<h1 id="ループ">ループ</h1>
<p>さて、ここまでで変数や関数、標準入出力といったプログラミングの基礎的な概念を教えてきた。あと一つでプログラミングに必要な基礎的な概念はすべて説明し終わる。ループだ。</p>
<h2 id="これまでのおさらい-1">これまでのおさらい</h2>
<p>C++では、プログラムは書いた順番に実行される。これを<code>逐次実行</code>という。</p>
<div class="sourceCode" id="cb256"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb256-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb256-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb256-3" data-line-number="3">    <span class="bu">std::</span>cout &lt;&lt; <span class="dv">1</span> ;</a>
<a class="sourceLine" id="cb256-4" data-line-number="4">    <span class="bu">std::</span>cout &lt;&lt; <span class="dv">2</span> ;</a>
<a class="sourceLine" id="cb256-5" data-line-number="5">    <span class="bu">std::</span>cout &lt;&lt; <span class="dv">3</span> ;</a>
<a class="sourceLine" id="cb256-6" data-line-number="6">}</a></code></pre></div>
<p>実行結果、</p>
<pre><code>123</code></pre>
<p>この実行結果が“123”以外の結果になることはない。C++ではプログラムは書かれた順番に実行されるからだ。</p>
<p>条件分岐は、プログラムの実行を条件付きで行うことができる。</p>
<div class="sourceCode" id="cb258"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb258-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb258-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb258-3" data-line-number="3">    <span class="bu">std::</span>cout &lt;&lt; <span class="dv">1</span> ;</a>
<a class="sourceLine" id="cb258-4" data-line-number="4"></a>
<a class="sourceLine" id="cb258-5" data-line-number="5">    <span class="cf">if</span> ( <span class="kw">false</span> )</a>
<a class="sourceLine" id="cb258-6" data-line-number="6">        <span class="bu">std::</span>cout &lt;&lt; <span class="dv">2</span> ;</a>
<a class="sourceLine" id="cb258-7" data-line-number="7"></a>
<a class="sourceLine" id="cb258-8" data-line-number="8">    <span class="bu">std::</span>cout &lt;&lt; <span class="dv">3</span> ;</a>
<a class="sourceLine" id="cb258-9" data-line-number="9"></a>
<a class="sourceLine" id="cb258-10" data-line-number="10">    <span class="cf">if</span> ( <span class="kw">true</span> )</a>
<a class="sourceLine" id="cb258-11" data-line-number="11">        <span class="bu">std::</span>cout &lt;&lt; <span class="dv">4</span> ;</a>
<a class="sourceLine" id="cb258-12" data-line-number="12">    <span class="cf">else</span></a>
<a class="sourceLine" id="cb258-13" data-line-number="13">        <span class="bu">std::</span>cout &lt;&lt; <span class="dv">5</span> ;</a>
<a class="sourceLine" id="cb258-14" data-line-number="14">}</a></code></pre></div>
<p>実行結果、</p>
<pre><code>134</code></pre>
<p>条件分岐によって、プログラムの一部を実行しないということが可能になる。</p>
<h2 id="goto文">goto文</h2>
<p>ここでは繰り返し(ループ)の基礎的な仕組みを理解するために、最も原始的で最も使いづらい繰り返しの機能である<code>goto文</code>を学ぶ。<code>goto文</code>で実用的な繰り返し処理をするのは面倒だが、恐れることはない。より簡単な方法もすぐに説明するからだ。なぜ本書で<code>goto文</code>を先に教えるかと言うと、あらゆる繰り返しは、結局のところ<code>if文</code>と<code>goto文</code>へのシンタックスシュガーにすぎないからだ。<code>goto文</code>を学ぶことにより、繰り返しを恐れることなく使う本物のプログラマーになれる。</p>
<h3 id="無限ループ">無限ループ</h3>
<p>“hello”と3回出力するプログラムはどうやって書くのだろうか。“hello”を1回出力するプログラムの書き方はすでにわかっているので、同じ文を3回書けばよい。</p>
<pre><code>// 1回&quot;hello\n&quot;を出力する関数
void hello()
{
    std::cout &lt;&lt; &quot;hello\n&quot;s ;
}

int main()
{
    hello() ;
    hello() ;
    hello() ;
}</code></pre>
<p>10回出力する場合はどうするのだろう。10回書けばよい。コードは省略する。</p>
<p>では100回出力する場合はどうするのだろう。100回書くのだろうか。100回も同じコードを書くのはとても面倒だ。読者がVimのような優秀なテキストエディターを使っていない限り100回も同じコードを間違えずに書くことは不可能だろう。Vimならば1回書いた後にノーマルモードで“100.”するだけで100回書ける。</p>
<p>実際のところ、100回だろうが、1000回だろうが、あらかじめ回数がコンパイル時に決まっているのであれば、その回数だけ同じ処理を書くことで実現可能だ。</p>
<p>しかし、プログラムを外部から強制的に停止させるまで、無限に出力し続けるプログラムはどう書けばいいのだろうか。そういった停止しないプログラムを外部から強制的に停止させるには<code>Ctrl-C</code>を使う。</p>
<p>以下はそのようなプログラムの実行例だ。</p>
<pre><code>$ make run
hello
hello
hello
hello
...
[Ctrl-Cを押す]</code></pre>
<p><code>goto文</code>は指定したラベルに実行を移す機能だ。</p>
<pre><code>ラベル名 : 文

goto ラベル名 ;</code></pre>
<div class="sourceCode" id="cb263"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb263-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb263-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb263-3" data-line-number="3">    <span class="bu">std::</span>cout &lt;&lt; <span class="dv">1</span> ;</a>
<a class="sourceLine" id="cb263-4" data-line-number="4"></a>
<a class="sourceLine" id="cb263-5" data-line-number="5">    <span class="co">// ラベルskipまで飛ぶ</span></a>
<a class="sourceLine" id="cb263-6" data-line-number="6">    <span class="cf">goto</span> skip ;</a>
<a class="sourceLine" id="cb263-7" data-line-number="7"></a>
<a class="sourceLine" id="cb263-8" data-line-number="8">    <span class="bu">std::</span>cout &lt;&lt; <span class="dv">2</span> ;</a>
<a class="sourceLine" id="cb263-9" data-line-number="9"></a>
<a class="sourceLine" id="cb263-10" data-line-number="10"><span class="co">// ラベルskip</span></a>
<a class="sourceLine" id="cb263-11" data-line-number="11">skip :</a>
<a class="sourceLine" id="cb263-12" data-line-number="12">    <span class="bu">std::</span>cout &lt;&lt; <span class="dv">3</span> ;</a>
<a class="sourceLine" id="cb263-13" data-line-number="13">}</a></code></pre></div>
<p>これを実行すると以下のようになる。</p>
<pre><code>13</code></pre>
<p><code>2</code>を出力すべき文の実行が飛ばされていることがわかる。</p>
<p>これだけみると“if (false)”と同じように見えるが、<code>goto文</code>はソースコードの上に飛ぶこともできるのだ。</p>
<div class="sourceCode" id="cb265"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb265-1" data-line-number="1"><span class="dt">void</span> hello()</a>
<a class="sourceLine" id="cb265-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb265-3" data-line-number="3">    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;hello</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb265-4" data-line-number="4">}</a>
<a class="sourceLine" id="cb265-5" data-line-number="5"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb265-6" data-line-number="6">{</a>
<a class="sourceLine" id="cb265-7" data-line-number="7">loop :</a>
<a class="sourceLine" id="cb265-8" data-line-number="8">    hello() ;</a>
<a class="sourceLine" id="cb265-9" data-line-number="9">    <span class="cf">goto</span> loop ; </a>
<a class="sourceLine" id="cb265-10" data-line-number="10">}</a></code></pre></div>
<p>これは“hello”を無限に出力するプログラムだ。</p>
<p>このプログラムを実行すると、</p>
<ol type="1">
<li>関数helloが呼ばれる</li>
<li>goto文でラベルloopまで飛ぶ</li>
<li>1に戻る</li>
</ol>
<p>という処理を行う。</p>
<h3 id="終了条件付きループ">終了条件付きループ</h3>
<p>ひたすら同じ文字列を出力し続けるだけのプログラムというのも味気ない。もっと面白くてためになるプログラムを作ろう。例えば、ユーザーから入力された数値を合計し続けるプログラムはどうだろう。</p>
<p>今から作るプログラムを実行すると以下のようになる。</p>
<pre><code>$ make run
&gt; 10
10
&gt; 5
15
&gt; 999
1014
&gt; -234
780</code></pre>
<p>このプログラムは、</p>
<ol type="1">
<li>“&gt;”と表示してユーザーから整数値を入力</li>
<li>これまでの入力との合計値を出力</li>
<li>1.に戻る</li>
</ol>
<p>という動作を繰り返す。先程学んだ無限ループと同じだ。</p>
<p>さっそく作っていこう。</p>
<div class="sourceCode" id="cb267"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb267-1" data-line-number="1"><span class="dt">int</span> input()</a>
<a class="sourceLine" id="cb267-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb267-3" data-line-number="3">    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;&gt;&quot;</span>s ;</a>
<a class="sourceLine" id="cb267-4" data-line-number="4">    <span class="dt">int</span> x {} ;</a>
<a class="sourceLine" id="cb267-5" data-line-number="5">    <span class="bu">std::</span>cin &gt;&gt; x ;</a>
<a class="sourceLine" id="cb267-6" data-line-number="6">    <span class="cf">return</span> x ;</a>
<a class="sourceLine" id="cb267-7" data-line-number="7">}</a>
<a class="sourceLine" id="cb267-8" data-line-number="8"></a>
<a class="sourceLine" id="cb267-9" data-line-number="9"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb267-10" data-line-number="10">{</a>
<a class="sourceLine" id="cb267-11" data-line-number="11">    <span class="dt">int</span> sum = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb267-12" data-line-number="12">loop :</a>
<a class="sourceLine" id="cb267-13" data-line-number="13">    sum = sum + input() ;</a>
<a class="sourceLine" id="cb267-14" data-line-number="14">    <span class="bu">std::</span>cout &lt;&lt; sum &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb267-15" data-line-number="15">    <span class="cf">goto</span> loop ;</a>
<a class="sourceLine" id="cb267-16" data-line-number="16">}</a></code></pre></div>
<p>関数inputは“&gt;”を表示してユーザーからの入力を得て戻り値として返すだけの関数だ。</p>
<p>“sum = sum + input()”は、変数sumに新しい値を代入するもので、その代入する値というのは、代入する前の変数sumの値と関数inputの戻り値を足した値だ。</p>
<p>このような変数xに何らかの値nを足した結果を元の変数xに代入するという処理はとても多く使われるので、C++では“x = x + n”を意味する省略記法“x += n”がある。</p>
<div class="sourceCode" id="cb268"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb268-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb268-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb268-3" data-line-number="3">    <span class="dt">int</span> x = <span class="dv">1</span> ;</a>
<a class="sourceLine" id="cb268-4" data-line-number="4">    <span class="dt">int</span> n = <span class="dv">5</span> ;</a>
<a class="sourceLine" id="cb268-5" data-line-number="5"></a>
<a class="sourceLine" id="cb268-6" data-line-number="6">    x = x + n ; <span class="co">// 6</span></a>
<a class="sourceLine" id="cb268-7" data-line-number="7">    x += n ; <span class="co">// 11</span></a>
<a class="sourceLine" id="cb268-8" data-line-number="8">}</a></code></pre></div>
<p>さて、本題に戻ろう。上のプログラムは動く。しかし、プログラムを停止するにはCtrl-Cを押すしかない。できればプログラム自ら終了してもらいたいものだ。</p>
<p>そこで、ユーザーが0を入力したときはプログラムを終了するようにしよう。</p>
<div class="sourceCode" id="cb269"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb269-1" data-line-number="1"><span class="dt">int</span> input()</a>
<a class="sourceLine" id="cb269-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb269-3" data-line-number="3">    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;&gt;&quot;</span>s ;</a>
<a class="sourceLine" id="cb269-4" data-line-number="4">    <span class="dt">int</span> x {} ;</a>
<a class="sourceLine" id="cb269-5" data-line-number="5">    <span class="bu">std::</span>cin &gt;&gt; x ;</a>
<a class="sourceLine" id="cb269-6" data-line-number="6">    <span class="cf">return</span> x ;</a>
<a class="sourceLine" id="cb269-7" data-line-number="7">}</a>
<a class="sourceLine" id="cb269-8" data-line-number="8"></a>
<a class="sourceLine" id="cb269-9" data-line-number="9"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb269-10" data-line-number="10">{</a>
<a class="sourceLine" id="cb269-11" data-line-number="11">    <span class="dt">int</span> sum = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb269-12" data-line-number="12">loop :</a>
<a class="sourceLine" id="cb269-13" data-line-number="13">    <span class="co">// 一度入力を変数に代入</span></a>
<a class="sourceLine" id="cb269-14" data-line-number="14">    <span class="dt">int</span> x = input() ;</a>
<a class="sourceLine" id="cb269-15" data-line-number="15">    <span class="co">// 変数xが0でない場合</span></a>
<a class="sourceLine" id="cb269-16" data-line-number="16">    <span class="cf">if</span> ( x != <span class="dv">0</span> )</a>
<a class="sourceLine" id="cb269-17" data-line-number="17">    {<span class="co">// 実行</span></a>
<a class="sourceLine" id="cb269-18" data-line-number="18">        sum = sum + x ;</a>
<a class="sourceLine" id="cb269-19" data-line-number="19">        <span class="bu">std::</span>cout &lt;&lt; sum &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb269-20" data-line-number="20">        <span class="cf">goto</span> loop ;</a>
<a class="sourceLine" id="cb269-21" data-line-number="21">    }</a>
<a class="sourceLine" id="cb269-22" data-line-number="22">    <span class="co">// x == 0の場合、ここに実行が移る</span></a>
<a class="sourceLine" id="cb269-23" data-line-number="23">    <span class="co">// main関数の最後なのでプログラムが終了</span></a>
<a class="sourceLine" id="cb269-24" data-line-number="24">}</a></code></pre></div>
<p>うまくいった。このループは、ユーザーが0を入力した場合に繰り返しを終了する、条件付きのループだ。</p>
<h3 id="インデックスループ">インデックスループ</h3>
<p>最後に紹介するループは、インデックスループだ。n回“hello”sを出力するプログラムを書こう。問題は、このnはコンパイル時には与えられず、実行時にユーザーからの入力で与えられる。</p>
<div class="sourceCode" id="cb270"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb270-1" data-line-number="1"><span class="co">// n回出力する関数の宣言</span></a>
<a class="sourceLine" id="cb270-2" data-line-number="2"><span class="dt">void</span> hello_n( <span class="dt">int</span> n ) ;</a>
<a class="sourceLine" id="cb270-3" data-line-number="3"></a>
<a class="sourceLine" id="cb270-4" data-line-number="4"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb270-5" data-line-number="5">{</a>
<a class="sourceLine" id="cb270-6" data-line-number="6">    <span class="co">// ユーザーからの入力</span></a>
<a class="sourceLine" id="cb270-7" data-line-number="7">    <span class="dt">int</span> n {} ;</a>
<a class="sourceLine" id="cb270-8" data-line-number="8">    <span class="bu">std::</span>cin &gt;&gt; n ;</a>
<a class="sourceLine" id="cb270-9" data-line-number="9">    <span class="co">// n回出力</span></a>
<a class="sourceLine" id="cb270-10" data-line-number="10">    hello_n( n ) ;</a>
<a class="sourceLine" id="cb270-11" data-line-number="11">}</a></code></pre></div>
<p>このコードをコンパイルしようとするとエラーになる。これは実はコンパイルエラーではなくてリンクエラーという種類のエラーだ。その理由は、関数hello_nに対する関数の定義が存在しないからだ。</p>
<p>関数というのは宣言と定義に分かれている。</p>
<div class="sourceCode" id="cb271"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb271-1" data-line-number="1"><span class="co">// 関数の宣言</span></a>
<a class="sourceLine" id="cb271-2" data-line-number="2"><span class="dt">void</span> f( ) ;</a>
<a class="sourceLine" id="cb271-3" data-line-number="3"></a>
<a class="sourceLine" id="cb271-4" data-line-number="4"><span class="co">// 宣言</span></a>
<a class="sourceLine" id="cb271-5" data-line-number="5"><span class="dt">void</span> f( )</a>
<a class="sourceLine" id="cb271-6" data-line-number="6"><span class="co">// 定義</span></a>
<a class="sourceLine" id="cb271-7" data-line-number="7">{ }</a></code></pre></div>
<p>関数の宣言というのは何度書いても大丈夫だ。</p>
<div class="sourceCode" id="cb272"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb272-1" data-line-number="1"><span class="co">// 宣言</span></a>
<a class="sourceLine" id="cb272-2" data-line-number="2"><span class="dt">int</span> f( <span class="dt">int</span> x ) ;</a>
<a class="sourceLine" id="cb272-3" data-line-number="3"></a>
<a class="sourceLine" id="cb272-4" data-line-number="4"><span class="co">// 再宣言</span></a>
<a class="sourceLine" id="cb272-5" data-line-number="5"><span class="dt">int</span> f( <span class="dt">int</span> x ) ;</a>
<a class="sourceLine" id="cb272-6" data-line-number="6"></a>
<a class="sourceLine" id="cb272-7" data-line-number="7"><span class="co">// 再宣言</span></a>
<a class="sourceLine" id="cb272-8" data-line-number="8"><span class="dt">int</span> f( <span class="dt">int</span> x ) ;</a></code></pre></div>
<p>関数の宣言というのは戻り値の型や関数名や引数リストだけで、“;”で終わる。</p>
<p>関数の定義とは、関数の宣言の後の“{}”だ。この場合、宣言のあとに“;”は書かない。</p>
<div class="sourceCode" id="cb273"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb273-1" data-line-number="1"><span class="dt">int</span> f( <span class="dt">int</span> x ) { <span class="cf">return</span> x ; }</a></code></pre></div>
<p>関数の定義は一度しか書けない。</p>
<div class="sourceCode" id="cb274"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb274-1" data-line-number="1"><span class="co">// 定義</span></a>
<a class="sourceLine" id="cb274-2" data-line-number="2"><span class="dt">void</span> f() {}</a>
<a class="sourceLine" id="cb274-3" data-line-number="3"><span class="co">// エラー、再定義</span></a>
<a class="sourceLine" id="cb274-4" data-line-number="4"><span class="dt">void</span> f() {}</a></code></pre></div>
<p>なぜ関数は宣言と定義とに別れているかというと、C++では名前は宣言しないと使えないためだ。</p>
<div class="sourceCode" id="cb275"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb275-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb275-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb275-3" data-line-number="3">    <span class="co">// エラー</span></a>
<a class="sourceLine" id="cb275-4" data-line-number="4">    <span class="co">// 名前fは宣言されていない</span></a>
<a class="sourceLine" id="cb275-5" data-line-number="5">    f() ;</a>
<a class="sourceLine" id="cb275-6" data-line-number="6">}</a>
<a class="sourceLine" id="cb275-7" data-line-number="7"></a>
<a class="sourceLine" id="cb275-8" data-line-number="8"><span class="co">// 定義</span></a>
<a class="sourceLine" id="cb275-9" data-line-number="9"><span class="dt">void</span> f() { }</a></code></pre></div>
<p>なので、必ず名前は使う前に宣言しなければならない。</p>
<div class="sourceCode" id="cb276"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb276-1" data-line-number="1"><span class="co">// 名前fの宣言</span></a>
<a class="sourceLine" id="cb276-2" data-line-number="2"><span class="dt">void</span> f() ;</a>
<a class="sourceLine" id="cb276-3" data-line-number="3"></a>
<a class="sourceLine" id="cb276-4" data-line-number="4"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb276-5" data-line-number="5">{</a>
<a class="sourceLine" id="cb276-6" data-line-number="6">    <span class="co">// OK、名前fは関数</span></a>
<a class="sourceLine" id="cb276-7" data-line-number="7">    f() ;</a>
<a class="sourceLine" id="cb276-8" data-line-number="8">}</a>
<a class="sourceLine" id="cb276-9" data-line-number="9"></a>
<a class="sourceLine" id="cb276-10" data-line-number="10"><span class="co">// 名前fの定義</span></a>
<a class="sourceLine" id="cb276-11" data-line-number="11"><span class="dt">void</span> f() { }</a></code></pre></div>
<p>さて、話をもとに戻そう。これから学ぶのはn回“hello”sと出力するプログラムの書き方だ。ただしnはユーザーが入力するので実行時にしかわからない。すでに我々はユーザーからnの入力を受け取る部分のプログラムは書いた。</p>
<div class="sourceCode" id="cb277"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb277-1" data-line-number="1"><span class="co">// n回出力する関数の宣言</span></a>
<a class="sourceLine" id="cb277-2" data-line-number="2"><span class="dt">void</span> hello_n( <span class="dt">int</span> n ) ;</a>
<a class="sourceLine" id="cb277-3" data-line-number="3"></a>
<a class="sourceLine" id="cb277-4" data-line-number="4"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb277-5" data-line-number="5">{</a>
<a class="sourceLine" id="cb277-6" data-line-number="6">    <span class="co">// ユーザーからの入力</span></a>
<a class="sourceLine" id="cb277-7" data-line-number="7">    <span class="dt">int</span> n {} ;</a>
<a class="sourceLine" id="cb277-8" data-line-number="8">    <span class="bu">std::</span>cin &gt;&gt; n ;</a>
<a class="sourceLine" id="cb277-9" data-line-number="9">    <span class="co">// n回出力</span></a>
<a class="sourceLine" id="cb277-10" data-line-number="10">    hello_n( n ) ;</a>
<a class="sourceLine" id="cb277-11" data-line-number="11">}</a></code></pre></div>
<p>あとは関数<code>hello_n(n)</code>がn回“hello”sと出力するようなループを実行すればいいのだ。</p>
<p>すでに我々は無限回“hello”sと出力する方法を知っている。まずは無限回ループを書こう。</p>
<div class="sourceCode" id="cb278"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb278-1" data-line-number="1"><span class="dt">void</span> hello_n( <span class="dt">int</span> n )</a>
<a class="sourceLine" id="cb278-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb278-3" data-line-number="3">loop :</a>
<a class="sourceLine" id="cb278-4" data-line-number="4">    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;hello</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb278-5" data-line-number="5">    <span class="cf">goto</span> loop ;</a>
<a class="sourceLine" id="cb278-6" data-line-number="6">}</a></code></pre></div>
<p>終了条件付きループで学んだように、このループをn回繰り返した場合に終了させるには、<code>if文</code>を使って、終了条件に達したかどうかで実行を分岐させればよい。</p>
<div class="sourceCode" id="cb279"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb279-1" data-line-number="1"><span class="dt">void</span> hello_n( <span class="dt">int</span> n )</a>
<a class="sourceLine" id="cb279-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb279-3" data-line-number="3">loop :</a>
<a class="sourceLine" id="cb279-4" data-line-number="4">    <span class="co">// まだn回繰り返していない場合</span></a>
<a class="sourceLine" id="cb279-5" data-line-number="5">    <span class="cf">if</span> ( ??? )</a>
<a class="sourceLine" id="cb279-6" data-line-number="6">    { <span class="co">// 以下を実行</span></a>
<a class="sourceLine" id="cb279-7" data-line-number="7">        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;hello</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb279-8" data-line-number="8">        <span class="cf">goto</span> loop ;</a>
<a class="sourceLine" id="cb279-9" data-line-number="9">    }</a>
<a class="sourceLine" id="cb279-10" data-line-number="10">}</a></code></pre></div>
<p>このコードを完成させるにはどうすればいいのか。まず、現在何回繰り返しを行ったのか記録する必要がある。このために変数を作る。</p>
<div class="sourceCode" id="cb280"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb280-1" data-line-number="1"><span class="dt">int</span> i = <span class="dv">0</span> ;</a></code></pre></div>
<p>変数iの初期値は0だ。まだ繰り返し実行を1回も行っていないということは、つまり0回繰り返し実行をしたということだ。</p>
<p>1回繰り返し実行をするたびに、変数iの値を1増やす。</p>
<div class="sourceCode" id="cb281"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb281-1" data-line-number="1">i = i + <span class="dv">1</span> ;</a></code></pre></div>
<p>これはすでに学んだように、もっと簡単に書ける。</p>
<div class="sourceCode" id="cb282"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb282-1" data-line-number="1">i += <span class="dv">1</span> ;</a></code></pre></div>
<p>実は、更に簡単に書くこともできる。変数の代入前の値に1を足した値を代入する、つまり変数の値を1増やすというのはとてもよく書くコードなので、とても簡単な演算子が用意されている。<code>operator ++</code>だ。</p>
<div class="sourceCode" id="cb283"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb283-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb283-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb283-3" data-line-number="3">    <span class="dt">int</span> i = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb283-4" data-line-number="4">    ++i ; <span class="co">// 1</span></a>
<a class="sourceLine" id="cb283-5" data-line-number="5">    ++i ; <span class="co">// 2</span></a>
<a class="sourceLine" id="cb283-6" data-line-number="6">    ++i ; <span class="co">// 3</span></a>
<a class="sourceLine" id="cb283-7" data-line-number="7">}</a></code></pre></div>
<p>これで変数iの値は1増える。これをインクリメント(increment)という。</p>
<p>インクリメントと対になるのがデクリメント(decrement)だ。これは変数の値を1減らす。演算子は<code>operator --</code>だ。</p>
<div class="sourceCode" id="cb284"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb284-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb284-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb284-3" data-line-number="3">    <span class="dt">int</span> i = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb284-4" data-line-number="4">    --i ; <span class="co">// -1</span></a>
<a class="sourceLine" id="cb284-5" data-line-number="5">    --i ; <span class="co">// -2</span></a>
<a class="sourceLine" id="cb284-6" data-line-number="6">    --i ; <span class="co">// -3</span></a>
<a class="sourceLine" id="cb284-7" data-line-number="7">}</a></code></pre></div>
<p>さて、必要な知識は学び終えたので本題に戻ろう。n回の繰り返しをした後にループを終了するには、まず今何回繰り返し実行しているのかを記録する必要がある。その方法を学ぶために、0, 1, 2, 3, 4…と無限に出力されるプログラムを書いてみよう。</p>
<p>このプログラムを実行すると以下のように表示される。</p>
<pre><code>$ make run
1, 2, 3, 4, 5, 6, [Ctrl-C]</code></pre>
<p>Ctrl-Cを押すまでプログラムは無限に実行される。</p>
<p>ではどうやって書くのか。以下のようにする。</p>
<ol type="1">
<li>変数iを作り、値を0にする</li>
<li>変数iと“,”sを出力する</li>
<li>変数iをインクリメントする</li>
<li>goto 2</li>
</ol>
<p>この処理を素直に書くと以下のコードになる。</p>
<div class="sourceCode" id="cb286"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb286-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb286-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb286-3" data-line-number="3">    <span class="co">// 1. 変数iを作り、値を0にする</span></a>
<a class="sourceLine" id="cb286-4" data-line-number="4">    <span class="dt">int</span> i = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb286-5" data-line-number="5">loop :</a>
<a class="sourceLine" id="cb286-6" data-line-number="6">    <span class="co">// 2. 変数iと&quot;, &quot;sを出力する</span></a>
<a class="sourceLine" id="cb286-7" data-line-number="7">    <span class="bu">std::</span>cout &lt;&lt; i &lt;&lt; <span class="st">&quot;, &quot;</span>s ;</a>
<a class="sourceLine" id="cb286-8" data-line-number="8">    <span class="co">// 3. 変数iをインクリメントする</span></a>
<a class="sourceLine" id="cb286-9" data-line-number="9">    ++i ;</a>
<a class="sourceLine" id="cb286-10" data-line-number="10">    <span class="co">// 4. goto 2</span></a>
<a class="sourceLine" id="cb286-11" data-line-number="11">    <span class="cf">goto</span> loop ;</a>
<a class="sourceLine" id="cb286-12" data-line-number="12">}</a></code></pre></div>
<p>どうやら、いま何回繰り返し実行しているか記録することはできるようになったようだ。</p>
<p>ここまでくればしめたもの。あとは<code>goto文</code>を実行するかどうかを<code>if文</code>で条件分岐すればよい。しかし、<code>if文</code>の中にどんな条件を書けばいいのだろうか。</p>
<div class="sourceCode" id="cb287"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb287-1" data-line-number="1"><span class="dt">void</span> hello_n( <span class="dt">int</span> n )</a>
<a class="sourceLine" id="cb287-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb287-3" data-line-number="3">    <span class="dt">int</span> i = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb287-4" data-line-number="4">loop :</a>
<a class="sourceLine" id="cb287-5" data-line-number="5">    <span class="co">// まだn回繰り返し実行をしていなければ実行</span></a>
<a class="sourceLine" id="cb287-6" data-line-number="6">    <span class="cf">if</span> ( ??? )</a>
<a class="sourceLine" id="cb287-7" data-line-number="7">    {</a>
<a class="sourceLine" id="cb287-8" data-line-number="8">        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;hello</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb287-9" data-line-number="9">        ++i ;</a>
<a class="sourceLine" id="cb287-10" data-line-number="10">        <span class="cf">goto</span> loop ;</a>
<a class="sourceLine" id="cb287-11" data-line-number="11">    }</a>
<a class="sourceLine" id="cb287-12" data-line-number="12">}</a></code></pre></div>
<p>具体的に考えてみよう。n == 3のとき、つまり3回繰り返すときを考えよう。</p>
<ol type="1">
<li>1回目のif文実行の時、i == 0</li>
<li>2回目のif文実行の時、i == 1</li>
<li>3回目のif文実行の時、i == 2</li>
<li>4回目のif文実行の時、i == 3</li>
</ol>
<p>ここではn == 3なので、3回まで実行してほしい。つまり3回目まではtrueになり、4回目のif文実行のときにはfalseになるような式を書く。そのような式とは、ズバリ“i != n”だ。</p>
<div class="sourceCode" id="cb288"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb288-1" data-line-number="1"><span class="dt">void</span> hello_n( <span class="dt">int</span> n )</a>
<a class="sourceLine" id="cb288-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb288-3" data-line-number="3">    <span class="dt">int</span> i = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb288-4" data-line-number="4">loop :</a>
<a class="sourceLine" id="cb288-5" data-line-number="5">    <span class="cf">if</span> ( i != n )</a>
<a class="sourceLine" id="cb288-6" data-line-number="6">    {</a>
<a class="sourceLine" id="cb288-7" data-line-number="7">        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;hello</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb288-8" data-line-number="8">        ++i ;</a>
<a class="sourceLine" id="cb288-9" data-line-number="9">        <span class="cf">goto</span> loop ;</a>
<a class="sourceLine" id="cb288-10" data-line-number="10">    }</a>
<a class="sourceLine" id="cb288-11" data-line-number="11">}</a></code></pre></div>
<p>早速実行してみよう。</p>
<pre><code>$ make run
3
hello
hello
hello
$ make run
2
hello
hello</code></pre>
<p>なるほど、動くようだ。しかしこのプログラムにはバグがある。-1を入力すると、何故か大量のhelloが出力されてしまうのだ。</p>
<pre><code>$ make run
-1
hello
hello
hello
hello
[Ctrl-C]</code></pre>
<p>この原因はまだ現時点の読者には難しい。この謎はいずれ明らかにするとして、今はnが負数の場合にプログラムを0回の繰り返し分の実行で終了するように書き換えよう。</p>
<div class="sourceCode" id="cb291"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb291-1" data-line-number="1"><span class="dt">void</span> hello_n( <span class="dt">int</span> n )</a>
<a class="sourceLine" id="cb291-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb291-3" data-line-number="3">    <span class="co">// nが負数ならば</span></a>
<a class="sourceLine" id="cb291-4" data-line-number="4">    <span class="cf">if</span> ( n &lt; <span class="dv">0</span> )</a>
<a class="sourceLine" id="cb291-5" data-line-number="5">        <span class="co">// 関数の実行を終了</span></a>
<a class="sourceLine" id="cb291-6" data-line-number="6">        <span class="cf">return</span> ;</a>
<a class="sourceLine" id="cb291-7" data-line-number="7"></a>
<a class="sourceLine" id="cb291-8" data-line-number="8">    <span class="dt">int</span> i = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb291-9" data-line-number="9">loop :</a>
<a class="sourceLine" id="cb291-10" data-line-number="10">    <span class="cf">if</span> ( i != n )</a>
<a class="sourceLine" id="cb291-11" data-line-number="11">    {</a>
<a class="sourceLine" id="cb291-12" data-line-number="12">        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;hello</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb291-13" data-line-number="13">        ++i ;</a>
<a class="sourceLine" id="cb291-14" data-line-number="14">        <span class="cf">goto</span> loop ;</a>
<a class="sourceLine" id="cb291-15" data-line-number="15">    }</a>
<a class="sourceLine" id="cb291-16" data-line-number="16">}</a></code></pre></div>
<h2 id="while文">while文</h2>
<p><code>goto文</code>は極めて原始的で使いづらい機能だ。現実のC++プログラムでは<code>goto文</code>はめったに使われない。もっと簡単な機能を使う。ではなぜ<code>goto文</code>が存在するかというと、<code>goto文</code>は最も原始的で基礎的で、他の繰り返し機能は<code>if文</code>と<code>goto文</code>に変換することで実現できるからだ。</p>
<p><code>goto文</code>より簡単な繰り返し文に、<code>while文</code>がある。ここでは<code>goto文</code>と<code>while文</code>を比較することで、<code>while文</code>を学んでいこう。</p>
<h3 id="無限ループ-1">無限ループ</h3>
<p>無限ループを<code>goto文</code>で書く方法を思い出してみよう。</p>
<div class="sourceCode" id="cb292"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb292-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb292-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb292-3" data-line-number="3">    <span class="kw">auto</span> hello = []()</a>
<a class="sourceLine" id="cb292-4" data-line-number="4">    { <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;hello</span><span class="sc">\n</span><span class="st">&quot;</span>s ; } ;</a>
<a class="sourceLine" id="cb292-5" data-line-number="5"></a>
<a class="sourceLine" id="cb292-6" data-line-number="6">loop :</a>
<a class="sourceLine" id="cb292-7" data-line-number="7">    <span class="co">// 繰り返し実行される文</span></a>
<a class="sourceLine" id="cb292-8" data-line-number="8">    hello() ;</a>
<a class="sourceLine" id="cb292-9" data-line-number="9">    <span class="cf">goto</span> loop ;</a>
<a class="sourceLine" id="cb292-10" data-line-number="10">}</a></code></pre></div>
<p>このコードで本当に重要なのは関数helloを呼び出している部分だ。ここが繰り返し実行される文で、<code>ラベル文</code>と<code>goto文</code>は、繰り返し実行を実現するために必要な記述でしかない。</p>
<p>そこで<code>while(true)</code>だ。<code>while(true)</code>は<code>goto文</code>と<code>ラベル文</code>よりも簡単に無限ループを実現できる。</p>
<pre><code>while (true) 文</code></pre>
<p><code>while文</code>は文を無限に繰り返して実行してくれる。試してみよう。</p>
<div class="sourceCode" id="cb294"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb294-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb294-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb294-3" data-line-number="3">    <span class="kw">auto</span> hello = []()</a>
<a class="sourceLine" id="cb294-4" data-line-number="4">    { <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;hello</span><span class="sc">\n</span><span class="st">&quot;</span>s ; } ;</a>
<a class="sourceLine" id="cb294-5" data-line-number="5"></a>
<a class="sourceLine" id="cb294-6" data-line-number="6">    <span class="cf">while</span> (<span class="kw">true</span>)</a>
<a class="sourceLine" id="cb294-7" data-line-number="7">        hello() ;</a>
<a class="sourceLine" id="cb294-8" data-line-number="8">}</a></code></pre></div>
<p>このコードの重要な部分は以下の2行。</p>
<div class="sourceCode" id="cb295"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb295-1" data-line-number="1"><span class="cf">while</span> (<span class="kw">true</span>)</a>
<a class="sourceLine" id="cb295-2" data-line-number="2">    hello() ;</a></code></pre></div>
<p>これを<code>goto文</code>と<code>ラベル文</code>を使った無限ループと比べてみよう。</p>
<pre><code>loop:
    hello() ;
    goto loop ;</code></pre>
<p>どちらも同じ意味のコードだが、<code>while文</code>の方が明らかに書きやすくなっているのがわかる。</p>
<p><code>goto文</code>で学んだ、ユーザーからの整数値の入力の合計の計算を繰り返すプログラムを<code>while(true)</code>で書いてみよう。</p>
<div class="sourceCode" id="cb297"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb297-1" data-line-number="1"><span class="dt">int</span> input()</a>
<a class="sourceLine" id="cb297-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb297-3" data-line-number="3">    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;&gt;&quot;</span>s ;</a>
<a class="sourceLine" id="cb297-4" data-line-number="4">    <span class="dt">int</span> x {} ;</a>
<a class="sourceLine" id="cb297-5" data-line-number="5">    <span class="bu">std::</span>cin &gt;&gt; x ;</a>
<a class="sourceLine" id="cb297-6" data-line-number="6">    <span class="cf">return</span> x ;</a>
<a class="sourceLine" id="cb297-7" data-line-number="7">}</a>
<a class="sourceLine" id="cb297-8" data-line-number="8"></a>
<a class="sourceLine" id="cb297-9" data-line-number="9"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb297-10" data-line-number="10">{</a>
<a class="sourceLine" id="cb297-11" data-line-number="11">    <span class="dt">int</span> sum = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb297-12" data-line-number="12"></a>
<a class="sourceLine" id="cb297-13" data-line-number="13">    <span class="cf">while</span>( <span class="kw">true</span> )</a>
<a class="sourceLine" id="cb297-14" data-line-number="14">    {</a>
<a class="sourceLine" id="cb297-15" data-line-number="15">        sum += input() ;</a>
<a class="sourceLine" id="cb297-16" data-line-number="16">        <span class="bu">std::</span>cout &lt;&lt; sum &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb297-17" data-line-number="17">    }</a>
<a class="sourceLine" id="cb297-18" data-line-number="18">}</a></code></pre></div>
<p>重要なのは以下の4行だ。</p>
<div class="sourceCode" id="cb298"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb298-1" data-line-number="1"><span class="cf">while</span>( <span class="kw">true</span> )</a>
<a class="sourceLine" id="cb298-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb298-3" data-line-number="3">    sum += input() ;</a>
<a class="sourceLine" id="cb298-4" data-line-number="4">    <span class="bu">std::</span>cout &lt;&lt; sum &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb298-5" data-line-number="5">}</a></code></pre></div>
<p>これを<code>goto文</code>で書いた場合と比べてみよう。</p>
<div class="sourceCode" id="cb299"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb299-1" data-line-number="1">loop :</a>
<a class="sourceLine" id="cb299-2" data-line-number="2">    sum += input() ;</a>
<a class="sourceLine" id="cb299-3" data-line-number="3">    <span class="bu">std::</span>cout &lt;&lt; sum &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb299-4" data-line-number="4">    <span class="cf">goto</span> loop ;</a></code></pre></div>
<p>本当に重要で本質的な、繰り返し実行をする部分の2行のコードは全く変わっていない。それでいて<code>while(true)</code>の方が圧倒的に簡単に書ける。</p>
<h2 id="終了条件付きループ-1">終了条件付きループ</h2>
<p>なるほど、無限ループを書くのに、<code>goto文</code>を使うより<code>while(true)</code>を使ったほうがいいことがわかった。では他のループの場合でも、<code>while文</code>の方が使いやすいだろうか。</p>
<p>本書を先頭から読んでいる優秀な読者は<code>while(true)</code>の<code>true</code>はbool型の値であることに気がついているだろう。実は<code>while(E)</code>の括弧の中Eは、<code>if(E)</code>と書くのと全く同じ<code>条件</code>なのだ。<code>条件</code>が<code>true</code>であれば繰り返し実行される。<code>false</code>なら繰り返し実行されない。</p>
<pre><code>while ( 条件 ) 文</code></pre>
<div class="sourceCode" id="cb301"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb301-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb301-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb301-3" data-line-number="3">    <span class="co">// 実行されない</span></a>
<a class="sourceLine" id="cb301-4" data-line-number="4">    <span class="cf">while</span> ( <span class="kw">false</span> )</a>
<a class="sourceLine" id="cb301-5" data-line-number="5">        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;No&quot;</span>s ;</a>
<a class="sourceLine" id="cb301-6" data-line-number="6"></a>
<a class="sourceLine" id="cb301-7" data-line-number="7">    <span class="co">// 実行されない</span></a>
<a class="sourceLine" id="cb301-8" data-line-number="8">    <span class="cf">while</span> ( <span class="dv">1</span> &gt; <span class="dv">2</span> )</a>
<a class="sourceLine" id="cb301-9" data-line-number="9">        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;No&quot;</span>s ;</a>
<a class="sourceLine" id="cb301-10" data-line-number="10"></a>
<a class="sourceLine" id="cb301-11" data-line-number="11">    <span class="co">// 実行される</span></a>
<a class="sourceLine" id="cb301-12" data-line-number="12">    <span class="co">// 無限ループ</span></a>
<a class="sourceLine" id="cb301-13" data-line-number="13">    <span class="cf">while</span> ( <span class="dv">1</span> &lt; <span class="dv">2</span> )</a>
<a class="sourceLine" id="cb301-14" data-line-number="14">        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Yes&quot;</span>s ;</a>
<a class="sourceLine" id="cb301-15" data-line-number="15">}</a></code></pre></div>
<p><code>while文</code>を使って、0が入力されたら終了する合計値計算プログラムを書いてみよう。</p>
<div class="sourceCode" id="cb302"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb302-1" data-line-number="1"><span class="dt">int</span> input()</a>
<a class="sourceLine" id="cb302-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb302-3" data-line-number="3">    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;&gt;&quot;</span>s ;</a>
<a class="sourceLine" id="cb302-4" data-line-number="4">    <span class="dt">int</span> x {} ;</a>
<a class="sourceLine" id="cb302-5" data-line-number="5">    <span class="bu">std::</span>cin &gt;&gt; x ;</a>
<a class="sourceLine" id="cb302-6" data-line-number="6">    <span class="cf">return</span> x ;</a>
<a class="sourceLine" id="cb302-7" data-line-number="7">}</a>
<a class="sourceLine" id="cb302-8" data-line-number="8"></a>
<a class="sourceLine" id="cb302-9" data-line-number="9"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb302-10" data-line-number="10">{</a>
<a class="sourceLine" id="cb302-11" data-line-number="11">    <span class="dt">int</span> sum = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb302-12" data-line-number="12">    <span class="dt">int</span> x {} ;</a>
<a class="sourceLine" id="cb302-13" data-line-number="13"></a>
<a class="sourceLine" id="cb302-14" data-line-number="14">    <span class="cf">while</span>( ( x = input() ) != <span class="dv">0</span> )</a>
<a class="sourceLine" id="cb302-15" data-line-number="15">    {</a>
<a class="sourceLine" id="cb302-16" data-line-number="16">        sum += x ;</a>
<a class="sourceLine" id="cb302-17" data-line-number="17">        <span class="bu">std::</span>cout &lt;&lt; sum &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb302-18" data-line-number="18">    }</a>
<a class="sourceLine" id="cb302-19" data-line-number="19">}</a></code></pre></div>
<p>重要なのはこの5行。</p>
<div class="sourceCode" id="cb303"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb303-1" data-line-number="1"><span class="cf">while</span>( ( x = input() ) != <span class="dv">0</span> )</a>
<a class="sourceLine" id="cb303-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb303-3" data-line-number="3">    sum += x ;</a>
<a class="sourceLine" id="cb303-4" data-line-number="4">    <span class="bu">std::</span>cout &lt;&lt; sum &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb303-5" data-line-number="5">}</a></code></pre></div>
<p>ここではちょっとむずかしいコードが出てくる。<code>while</code>の中の<code>条件</code>が、“( x = input() ) != 0”になっている。これはどういうことか。</p>
<p>実は<code>条件</code>は<code>bool型</code>に変換さえできればどんな式でも書ける。</p>
<div class="sourceCode" id="cb304"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb304-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb304-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb304-3" data-line-number="3">    <span class="dt">int</span> x { } ;</a>
<a class="sourceLine" id="cb304-4" data-line-number="4"></a>
<a class="sourceLine" id="cb304-5" data-line-number="5">    <span class="cf">if</span> ( (x = <span class="dv">1</span>) == <span class="dv">1</span> )</a>
<a class="sourceLine" id="cb304-6" data-line-number="6">        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;(x = 1) is 1.</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb304-7" data-line-number="7">}</a></code></pre></div>
<p>このコードでは、“(x=1)”と“1”が等しいか“==”どうかを判断している。“(x=1)”という式は変数xに1を代入する式だ。<code>代入式</code>の値は、代入された変数の値になる。この場合変数xの値だ。変数xには1が代入されているので、その値は1、つまり“(x=1) == 1”は“1 == 1”と書くのと同じ意味になる。この結果は<code>true</code>だ。</p>
<p>さて、このことを踏まえて、“( x = input() ) != 0”を考えてみよう。</p>
<p>“( x = input() )”は変数xに関数inputを呼び出した結果を代入している。関数inputはユーザーから入力を得て、その入力をそのまま返す。つまり変数xにはユーザーの入力した値が代入される。その結果が0と等しくないか“!=”どうかを判断している。つまり、ユーザーが0を入力した場合はfalse、非ゼロを入力した場合はtrueとなる。</p>
<p><code>while(条件)</code>は<code>条件</code>が<code>true</code>となる場合に繰り返し実行をする。結果として、ユーザーが0を入力するまで繰り返し実行をするコードになる。</p>
<p><code>goto文</code>を使った終了条件付きループと比較してみよう。</p>
<div class="sourceCode" id="cb305"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb305-1" data-line-number="1">loop:</a>
<a class="sourceLine" id="cb305-2" data-line-number="2">    <span class="cf">if</span> ( (x = input() ) != <span class="dv">0</span> )</a>
<a class="sourceLine" id="cb305-3" data-line-number="3">    {</a>
<a class="sourceLine" id="cb305-4" data-line-number="4">        sum += x ;</a>
<a class="sourceLine" id="cb305-5" data-line-number="5">        <span class="bu">std::</span>cout &lt;&lt; sum &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb305-6" data-line-number="6">        <span class="cf">goto</span> loop ;</a>
<a class="sourceLine" id="cb305-7" data-line-number="7">    }</a></code></pre></div>
<p><code>while文</code>の方が圧倒的に書きやすいことがわかる。</p>
<h3 id="インデックスループ-1">インデックスループ</h3>
<p>n回“hello”sと出力するプログラムを<code>while文</code>で書いてみよう。ただしnはユーザーが入力するものとする。</p>
<p>まずは<code>goto文</code>でも使ったループ以外の処理をするコードから。</p>
<div class="sourceCode" id="cb306"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb306-1" data-line-number="1"><span class="dt">void</span> hello_n( <span class="dt">int</span> n ) ;</a>
<a class="sourceLine" id="cb306-2" data-line-number="2"></a>
<a class="sourceLine" id="cb306-3" data-line-number="3"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb306-4" data-line-number="4">{</a>
<a class="sourceLine" id="cb306-5" data-line-number="5">    <span class="dt">int</span> n {} ;</a>
<a class="sourceLine" id="cb306-6" data-line-number="6">    <span class="bu">std::</span>cin &gt;&gt; n ;</a>
<a class="sourceLine" id="cb306-7" data-line-number="7">    hello_n( n ) ;</a>
<a class="sourceLine" id="cb306-8" data-line-number="8">}</a></code></pre></div>
<p>後は関数hello_n(n)がインデックスループを実装するだけだ。ただしnが負数ならば何も実行しないように仕様。</p>
<p><code>goto文</code>でインデックスループを書くときに学んだように、</p>
<ol type="1">
<li>n &lt; 0ならば関数を終了</li>
<li>変数iを作り値を0にする</li>
<li>i != nならば繰り返し実行</li>
<li>出力</li>
<li>++i</li>
<li>goto 3.</li>
</ol>
<p>を<code>while文</code>で書くだけだ。</p>
<div class="sourceCode" id="cb307"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb307-1" data-line-number="1"><span class="dt">void</span> hello_n( <span class="dt">int</span> n )</a>
<a class="sourceLine" id="cb307-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb307-3" data-line-number="3">    <span class="co">// 1. n &lt; 0ならば関数を終了</span></a>
<a class="sourceLine" id="cb307-4" data-line-number="4">    <span class="cf">if</span> ( n &lt; <span class="dv">0</span> )</a>
<a class="sourceLine" id="cb307-5" data-line-number="5">        <span class="cf">return</span> ;</a>
<a class="sourceLine" id="cb307-6" data-line-number="6"></a>
<a class="sourceLine" id="cb307-7" data-line-number="7">    <span class="co">// 2. 変数iを作り値を0にする</span></a>
<a class="sourceLine" id="cb307-8" data-line-number="8">    <span class="dt">int</span> i = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb307-9" data-line-number="9"></a>
<a class="sourceLine" id="cb307-10" data-line-number="10">    <span class="co">//3. i != nならば繰り返し実行</span></a>
<a class="sourceLine" id="cb307-11" data-line-number="11">    <span class="cf">while</span>( i != n )</a>
<a class="sourceLine" id="cb307-12" data-line-number="12">    {   <span class="co">// 4. 出力</span></a>
<a class="sourceLine" id="cb307-13" data-line-number="13">        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;hello</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb307-14" data-line-number="14">        <span class="co">// 5. ++i</span></a>
<a class="sourceLine" id="cb307-15" data-line-number="15">        ++i ;</a>
<a class="sourceLine" id="cb307-16" data-line-number="16">    } <span class="co">// 6. goto 3</span></a>
<a class="sourceLine" id="cb307-17" data-line-number="17">}</a></code></pre></div>
<p>重要な部分だけ抜き出すと以下の通り。</p>
<div class="sourceCode" id="cb308"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb308-1" data-line-number="1"><span class="cf">while</span>( i != n )</a>
<a class="sourceLine" id="cb308-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb308-3" data-line-number="3">    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;hello</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb308-4" data-line-number="4">    ++i ;</a>
<a class="sourceLine" id="cb308-5" data-line-number="5">}</a></code></pre></div>
<p><code>goto文</code>を使ったインデックスループと比較してみよう。</p>
<div class="sourceCode" id="cb309"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb309-1" data-line-number="1">loop :</a>
<a class="sourceLine" id="cb309-2" data-line-number="2">    <span class="cf">if</span> ( i != n )</a>
<a class="sourceLine" id="cb309-3" data-line-number="3">    {</a>
<a class="sourceLine" id="cb309-4" data-line-number="4">        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;hello</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb309-5" data-line-number="5">        ++i ;</a>
<a class="sourceLine" id="cb309-6" data-line-number="6">        <span class="cf">goto</span> loop ;</a>
<a class="sourceLine" id="cb309-7" data-line-number="7">    }</a></code></pre></div>
<p>読者の中にはあまり変わらないのではないかと思う人もいるかもしれない。しかし、次の問題を解くプログラムを書くと、<code>while文</code>がいかに楽に書けるかを実感するだろう。</p>
<p>問題：以下のような九九の表を出力するプログラムを書きなさい</p>
<pre><code>1   2   3   4   5   6   7   8   9   
2   4   6   8   10  12  14  16  18  
3   6   9   12  15  18  21  24  27  
4   8   12  16  20  24  28  32  36  
5   10  15  20  25  30  35  40  45  
6   12  18  24  30  36  42  48  54  
7   14  21  28  35  42  49  56  63  
8   16  24  32  40  48  56  64  72  
9   18  27  36  45  54  63  72  81</code></pre>
<p>もちろん、このような文字列を愚直に出力しろという問題ではない。</p>
<div class="sourceCode" id="cb311"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb311-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb311-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb311-3" data-line-number="3">    <span class="co">// 違う！</span></a>
<a class="sourceLine" id="cb311-4" data-line-number="4">    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;1 2 3 4 5...&quot;</span>s ;</a>
<a class="sourceLine" id="cb311-5" data-line-number="5">}</a></code></pre></div>
<p>逐次実行、条件分岐、ループまでを習得した誇りある本物のプログラマーである我々は、もちろん九九の表はループを書いて出力する。</p>
<p>まず出力すべき表をみると、数値が左揃えになっていることに気がつくだろう。</p>
<pre><code>4   8   12
5   10  15</code></pre>
<p>8は1文字、10は2文字にもかかわらず、12と15は同じ列目から始まっている。これは出力するスペース文字を調整することでも実現できるが、ここでは単にタブ文字を使っている。</p>
<p>タブ文字はMakefileを書くのにも使った文字で、C++の文字列中に直接書くこともできるが、エスケープ文字<code>\t</code>を使ってもよい。</p>
<div class="sourceCode" id="cb313"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb313-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb313-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb313-3" data-line-number="3">    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;4</span><span class="sc">\t</span><span class="st">8</span><span class="sc">\t</span><span class="st">12</span><span class="sc">\n</span><span class="st">5</span><span class="sc">\t</span><span class="st">10</span><span class="sc">\t</span><span class="st">15&quot;</span>s ;</a>
<a class="sourceLine" id="cb313-4" data-line-number="4">}</a></code></pre></div>
<p>エスケープ文字<code>\n</code>が改行文字に置き換わるように、エスケープ文字<code>\t</code>はタブ文字に置き換わる。</p>
<p>九九の表はどうやって出力すればよいだろうか。計算自体はC++では&quot;a*b&quot;でできる。上の表がどのように計算されているかを考えてみよう。</p>
<pre><code>1*1 1*2 1*3 1*4 1*5 1*6 1*7 1*8 1*9 
2*1 2*2 2*3 2*4 2*5 2*6 2*7 2*8 2*9 
3*1 3*2 3*3 3*4 3*5 3*6 3*7 3*8 3*9 
4*1 4*2 4*3 4*4 4*5 4*6 4*7 4*8 4*9 
5*1 5*2 5*3 5*4 5*5 5*6 5*7 5*8 5*9 
6*1 6*2 6*3 6*4 6*5 6*6 6*7 6*8 6*9 
7*1 7*2 7*3 7*4 7*5 7*6 7*7 7*8 7*9 
8*1 8*2 8*3 8*4 8*5 8*6 8*7 8*8 8*9 
9*1 9*2 9*3 9*4 9*5 9*6 9*7 9*8 9*9</code></pre>
<p>これをみると、&quot;a*b&quot;のうちのaを1から9までインクリメントし、それに対してbを1から9までインクリメントさせればよい。つまり、9回のインデックスループの中で9回のインデックスループを実行することになる。ループの中のループだ。</p>
<div class="sourceCode" id="cb315"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb315-1" data-line-number="1"><span class="cf">while</span> ( 条件 )</a>
<a class="sourceLine" id="cb315-2" data-line-number="2">    <span class="cf">while</span> ( 条件 )</a>
<a class="sourceLine" id="cb315-3" data-line-number="3">        文</a></code></pre></div>
<p>早速そのようなコードを書いてみよう。</p>
<div class="sourceCode" id="cb316"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb316-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb316-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb316-3" data-line-number="3">    <span class="co">// 1から9まで</span></a>
<a class="sourceLine" id="cb316-4" data-line-number="4">    <span class="dt">int</span> a = <span class="dv">1</span> ;</a>
<a class="sourceLine" id="cb316-5" data-line-number="5">    <span class="cf">while</span> ( a &lt;= <span class="dv">9</span> )</a>
<a class="sourceLine" id="cb316-6" data-line-number="6">    {</a>
<a class="sourceLine" id="cb316-7" data-line-number="7">        <span class="co">// 1から9まで</span></a>
<a class="sourceLine" id="cb316-8" data-line-number="8">        <span class="dt">int</span> b = <span class="dv">1</span> ;</a>
<a class="sourceLine" id="cb316-9" data-line-number="9">        <span class="cf">while</span> ( b &lt;= <span class="dv">9</span> )</a>
<a class="sourceLine" id="cb316-10" data-line-number="10">        {</a>
<a class="sourceLine" id="cb316-11" data-line-number="11">            <span class="co">// 計算結果を出力</span></a>
<a class="sourceLine" id="cb316-12" data-line-number="12">            <span class="bu">std::</span>cout &lt;&lt; a * b &lt;&lt; <span class="st">&quot;</span><span class="sc">\t</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb316-13" data-line-number="13">            ++b ;</a>
<a class="sourceLine" id="cb316-14" data-line-number="14">        }</a>
<a class="sourceLine" id="cb316-15" data-line-number="15">        <span class="co">// 段の終わりに改行</span></a>
<a class="sourceLine" id="cb316-16" data-line-number="16">        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb316-17" data-line-number="17">        ++a ;</a>
<a class="sourceLine" id="cb316-18" data-line-number="18">    }</a>
<a class="sourceLine" id="cb316-19" data-line-number="19">}</a></code></pre></div>
<p>うまくいった。</p>
<p>ところで、このコードを<code>goto文</code>で書くとどうなるだろうか。</p>
<div class="sourceCode" id="cb317"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb317-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb317-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb317-3" data-line-number="3">    <span class="dt">int</span> a = <span class="dv">1</span> ;</a>
<a class="sourceLine" id="cb317-4" data-line-number="4">loop_outer :</a>
<a class="sourceLine" id="cb317-5" data-line-number="5">    <span class="cf">if</span> ( a &lt;= <span class="dv">9</span> )</a>
<a class="sourceLine" id="cb317-6" data-line-number="6">    {</a>
<a class="sourceLine" id="cb317-7" data-line-number="7">        <span class="dt">int</span> b = <span class="dv">1</span> ;</a>
<a class="sourceLine" id="cb317-8" data-line-number="8">loop_inner :</a>
<a class="sourceLine" id="cb317-9" data-line-number="9">        <span class="cf">if</span> ( b &lt;= <span class="dv">9</span> )</a>
<a class="sourceLine" id="cb317-10" data-line-number="10">        {</a>
<a class="sourceLine" id="cb317-11" data-line-number="11">            <span class="bu">std::</span>cout &lt;&lt; a * b &lt;&lt; <span class="st">&quot;</span><span class="sc">\t</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb317-12" data-line-number="12">            ++b ;</a>
<a class="sourceLine" id="cb317-13" data-line-number="13">            <span class="cf">goto</span> loop_inner ;</a>
<a class="sourceLine" id="cb317-14" data-line-number="14">        }</a>
<a class="sourceLine" id="cb317-15" data-line-number="15">        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb317-16" data-line-number="16">        ++a ;</a>
<a class="sourceLine" id="cb317-17" data-line-number="17">        <span class="cf">goto</span> loop_outer ;</a>
<a class="sourceLine" id="cb317-18" data-line-number="18">    }</a>
<a class="sourceLine" id="cb317-19" data-line-number="19">}</a></code></pre></div>
<p>とてつもなく読みにくい。</p>
<h2 id="for文">for文</h2>
<p>ところで今まで<code>while文</code>で書いてきたインデックスループには特徴がある。</p>
<p>試しに1から100までの整数を出力するコードを見てみよう。</p>
<div class="sourceCode" id="cb318"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb318-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb318-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb318-3" data-line-number="3">    <span class="dt">int</span> i = <span class="dv">1</span> ;</a>
<a class="sourceLine" id="cb318-4" data-line-number="4">    <span class="cf">while</span> ( i &lt;= <span class="dv">100</span> )</a>
<a class="sourceLine" id="cb318-5" data-line-number="5">    {</a>
<a class="sourceLine" id="cb318-6" data-line-number="6">        <span class="bu">std::</span>cout &lt;&lt; i &lt;&lt; <span class="st">&quot; &quot;</span>s ;</a>
<a class="sourceLine" id="cb318-7" data-line-number="7">        ++i ;</a>
<a class="sourceLine" id="cb318-8" data-line-number="8">    }</a>
<a class="sourceLine" id="cb318-9" data-line-number="9">}</a></code></pre></div>
<p>このコードを読むと、以下のようなパターンがあることがわかる。</p>
<div class="sourceCode" id="cb319"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb319-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb319-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb319-3" data-line-number="3">    <span class="co">// ループ実行前の変数の宣言と初期化</span></a>
<a class="sourceLine" id="cb319-4" data-line-number="4">    <span class="dt">int</span> i = <span class="dv">1</span> ;</a>
<a class="sourceLine" id="cb319-5" data-line-number="5">    <span class="co">// ループ中の終了条件の確認</span></a>
<a class="sourceLine" id="cb319-6" data-line-number="6">    <span class="cf">while</span> ( i &lt;= <span class="dv">100</span> )</a>
<a class="sourceLine" id="cb319-7" data-line-number="7">    {</a>
<a class="sourceLine" id="cb319-8" data-line-number="8">        <span class="co">// 実際に繰り返したい文</span></a>
<a class="sourceLine" id="cb319-9" data-line-number="9">        <span class="bu">std::</span>cout &lt;&lt; i &lt;&lt; <span class="st">&quot; &quot;</span>s ;</a>
<a class="sourceLine" id="cb319-10" data-line-number="10">        <span class="co">// 各ループの最後に必ず行う処理</span></a>
<a class="sourceLine" id="cb319-11" data-line-number="11">        ++i ;</a>
<a class="sourceLine" id="cb319-12" data-line-number="12">    }</a>
<a class="sourceLine" id="cb319-13" data-line-number="13">}</a></code></pre></div>
<p>ここで真に必要なのは、「実際に繰り返したい文」だ。その他の処理は、ループを実現するために必要なコードだ。ループの実現に必要な処理が飛び飛びの場所にあるのは甚だわかりにくい。</p>
<p><code>for文</code>はそのような問題を解決するための機能だ。</p>
<pre><code>for ( 変数の宣言 ; 終了条件の確認 ; 各ループの最後に必ず行う処理 ) 文</code></pre>
<p><code>for文</code>を使うと、上のコードは以下のように書ける。</p>
<div class="sourceCode" id="cb321"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb321-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb321-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb321-3" data-line-number="3">    <span class="cf">for</span> ( <span class="dt">int</span> i = <span class="dv">1</span> ; i &lt;= <span class="dv">100</span> ; ++i )</a>
<a class="sourceLine" id="cb321-4" data-line-number="4">    {</a>
<a class="sourceLine" id="cb321-5" data-line-number="5">        <span class="bu">std::</span>cout &lt;&lt; i &lt;&lt; <span class="st">&quot; &quot;</span>s ;</a>
<a class="sourceLine" id="cb321-6" data-line-number="6">    } </a>
<a class="sourceLine" id="cb321-7" data-line-number="7">}</a></code></pre></div>
<p>ループの実現に必要な部分だけ抜き出すと以下のようになる。</p>
<div class="sourceCode" id="cb322"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb322-1" data-line-number="1"><span class="co">// for文の開始</span></a>
<a class="sourceLine" id="cb322-2" data-line-number="2"><span class="cf">for</span> (</a>
<a class="sourceLine" id="cb322-3" data-line-number="3"><span class="co">// 変数の宣言と初期化</span></a>
<a class="sourceLine" id="cb322-4" data-line-number="4"><span class="dt">int</span> i = <span class="dv">1</span> ;</a>
<a class="sourceLine" id="cb322-5" data-line-number="5"><span class="co">// 終了条件の確認</span></a>
<a class="sourceLine" id="cb322-6" data-line-number="6">i &lt;= <span class="dv">100</span> ;</a>
<a class="sourceLine" id="cb322-7" data-line-number="7"><span class="co">// 各ループの最後に必ず行う処理</span></a>
<a class="sourceLine" id="cb322-8" data-line-number="8">++i )</a></code></pre></div>
<p><code>for文</code>はインデックスループによくあるパターンをわかりやすく書くための機能だ。例えば<code>while文</code>のときに書いた九九の表を出力するプログラムは、<code>for文</code>ならばこんなに簡潔に書ける。</p>
<div class="sourceCode" id="cb323"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb323-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb323-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb323-3" data-line-number="3">    <span class="cf">for</span> ( <span class="dt">int</span> a = <span class="dv">1</span> ; a &lt;= <span class="dv">9</span> ; ++a )</a>
<a class="sourceLine" id="cb323-4" data-line-number="4">    {</a>
<a class="sourceLine" id="cb323-5" data-line-number="5">        <span class="cf">for</span> ( <span class="dt">int</span> b = <span class="dv">1</span> ; b &lt;= <span class="dv">9</span> ; ++b )</a>
<a class="sourceLine" id="cb323-6" data-line-number="6">        { <span class="bu">std::</span>cout &lt;&lt; a*b &lt;&lt; <span class="st">&quot;</span><span class="sc">\t</span><span class="st">&quot;</span>s ; }</a>
<a class="sourceLine" id="cb323-7" data-line-number="7"></a>
<a class="sourceLine" id="cb323-8" data-line-number="8">        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb323-9" data-line-number="9">    }</a>
<a class="sourceLine" id="cb323-10" data-line-number="10">}</a></code></pre></div>
<p><code>while文</code>を使ったコードと比べてみよう。</p>
<div class="sourceCode" id="cb324"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb324-1" data-line-number="1"></a>
<a class="sourceLine" id="cb324-2" data-line-number="2"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb324-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb324-4" data-line-number="4">    <span class="dt">int</span> a = <span class="dv">1</span> ;</a>
<a class="sourceLine" id="cb324-5" data-line-number="5">    <span class="cf">while</span> ( a &lt;= <span class="dv">9</span> )</a>
<a class="sourceLine" id="cb324-6" data-line-number="6">    {</a>
<a class="sourceLine" id="cb324-7" data-line-number="7">        <span class="dt">int</span> b = <span class="dv">1</span> ;</a>
<a class="sourceLine" id="cb324-8" data-line-number="8">        <span class="cf">while</span> ( b &lt;= <span class="dv">9</span> )</a>
<a class="sourceLine" id="cb324-9" data-line-number="9">        {</a>
<a class="sourceLine" id="cb324-10" data-line-number="10">            <span class="bu">std::</span>cout &lt;&lt; a * b &lt;&lt; <span class="st">&quot;</span><span class="sc">\t</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb324-11" data-line-number="11">            ++b ;</a>
<a class="sourceLine" id="cb324-12" data-line-number="12">        }</a>
<a class="sourceLine" id="cb324-13" data-line-number="13">        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb324-14" data-line-number="14">        ++a ;</a>
<a class="sourceLine" id="cb324-15" data-line-number="15">    }</a>
<a class="sourceLine" id="cb324-16" data-line-number="16">}</a></code></pre></div>
<p>格段に読みやすくなっていることがわかる。</p>
<p>C++ではカンマ’,’を使うことで、複数の<code>式</code>をひとつの<code>文</code>に書くことができる。</p>
<div class="sourceCode" id="cb325"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb325-1" data-line-number="1"></a>
<a class="sourceLine" id="cb325-2" data-line-number="2"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb325-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb325-4" data-line-number="4">    <span class="dt">int</span> a = <span class="dv">0</span>, b = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb325-5" data-line-number="5">    ++a, ++b ;</a>
<a class="sourceLine" id="cb325-6" data-line-number="6">}</a></code></pre></div>
<p><code>for文</code>でもカンマが使える。九九の表を出力するプログラムは、以下のように書くこともできる。</p>
<div class="sourceCode" id="cb326"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb326-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb326-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb326-3" data-line-number="3">    <span class="cf">for</span> ( <span class="dt">int</span> a = <span class="dv">1</span> ; a &lt;= <span class="dv">9</span> ; ++a, <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s )</a>
<a class="sourceLine" id="cb326-4" data-line-number="4">        <span class="cf">for</span> ( <span class="dt">int</span> b = <span class="dv">1</span> ; b &lt;= <span class="dv">9</span> ; ++b )</a>
<a class="sourceLine" id="cb326-5" data-line-number="5">            <span class="bu">std::</span>cout &lt;&lt; a*b &lt;&lt; <span class="st">&quot;</span><span class="sc">\t</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb326-6" data-line-number="6">}</a></code></pre></div>
<p>変数もカンマで複数宣言できると知った読者は、以下のように書きたくなるだろう。</p>
<div class="sourceCode" id="cb327"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb327-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb327-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb327-3" data-line-number="3">    <span class="cf">for</span> (   <span class="dt">int</span> a = <span class="dv">1</span>, b = <span class="dv">1</span> ;</a>
<a class="sourceLine" id="cb327-4" data-line-number="4">            a &lt;= <span class="dv">9</span> ;</a>
<a class="sourceLine" id="cb327-5" data-line-number="5">            ++a, ++b,</a>
<a class="sourceLine" id="cb327-6" data-line-number="6">            <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s</a>
<a class="sourceLine" id="cb327-7" data-line-number="7">        )</a>
<a class="sourceLine" id="cb327-8" data-line-number="8">            <span class="bu">std::</span>cout &lt;&lt; a*b &lt;&lt; <span class="st">&quot;</span><span class="sc">\t</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb327-9" data-line-number="9">}</a></code></pre></div>
<p>これは動かない。なぜならば、<code>for文</code>を2つネストさせたループは、<span class="math inline">\(a \times b\)</span>回のループで、変数aが1から9まで変化するそれぞれに対して、変数bが1から9まで変化する。しかし、上の<code>for文</code>ひとつのコードは、変数a, bともに同時に1から9まで変化する。したがって、これは単にa回のループでしかない。a回のループの中でb回のループをすることで<span class="math inline">\(a \times b\)</span>回のループを実現できる。</p>
<p><code>for文</code>では使わない部分を省略することができる。</p>
<div class="sourceCode" id="cb328"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb328-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb328-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb328-3" data-line-number="3">    <span class="dt">bool</span> b = <span class="kw">true</span> ;</a>
<a class="sourceLine" id="cb328-4" data-line-number="4">    <span class="co">// for文による変数宣言は使わない</span></a>
<a class="sourceLine" id="cb328-5" data-line-number="5">    <span class="cf">for</span> ( ; b ; b = <span class="kw">false</span> )</a>
<a class="sourceLine" id="cb328-6" data-line-number="6">        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;hello&quot;</span>s ;</a>
<a class="sourceLine" id="cb328-7" data-line-number="7">}</a></code></pre></div>
<p><code>for文</code>で終了条件を省略した場合、<code>true</code>と同じになる。</p>
<div class="sourceCode" id="cb329"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb329-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb329-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb329-3" data-line-number="3">    <span class="cf">for</span> (;;)</a>
<a class="sourceLine" id="cb329-4" data-line-number="4">        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;hello</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb329-5" data-line-number="5">}</a></code></pre></div>
<p>このプログラムは“hello”sと無限に出力し続けるプログラムだ。“for(;;)”は“for(;true;)”と同じ意味であり、“while(true)”とも同じ意味だ。</p>
<h2 id="do文">do文</h2>
<p><code>do文</code>は<code>while文</code>に似ている。</p>
<pre><code>do 文 while ( 条件 ) ;</code></pre>
<p>比較のために<code>while文</code>の文法も書いてみると以下のようになる。</p>
<pre><code>while ( 条件 ) 文</code></pre>
<p><code>while文</code>はまず<code>条件</code>を確認し<code>true</code>の場合<code>文</code>を実行する。これを繰り返す。</p>
<div class="sourceCode" id="cb332"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb332-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb332-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb332-3" data-line-number="3">    <span class="cf">while</span> ( <span class="kw">false</span> )</a>
<a class="sourceLine" id="cb332-4" data-line-number="4">    {</a>
<a class="sourceLine" id="cb332-5" data-line-number="5">        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;hello</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb332-6" data-line-number="6">    }</a>
<a class="sourceLine" id="cb332-7" data-line-number="7">}</a></code></pre></div>
<p><code>do文</code>はまず<code>文</code>を実行する。しかる後に<code>条件</code>を確認し<code>true</code>の場合繰り返しを行う。</p>
<div class="sourceCode" id="cb333"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb333-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb333-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb333-3" data-line-number="3">    <span class="cf">do</span> {</a>
<a class="sourceLine" id="cb333-4" data-line-number="4">        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;hello</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb333-5" data-line-number="5">    } <span class="cf">while</span> ( <span class="kw">false</span> ) ;</a>
<a class="sourceLine" id="cb333-6" data-line-number="6">}</a></code></pre></div>
<p>違いがわかっただろうか。<code>do文</code>は繰り返し実行する<code>文</code>を、<code>条件</code>がなんであれ、最初に一度実行する。</p>
<p><code>do文</code>を使うと条件にかかわらず文を1回は実行するコードが、文の重複なく書けるようになる。</p>
<h2 id="break文">break文</h2>
<p>ループの実行の途中で、ループの中から外に脱出したくなった場合、どうすればいいのだろうか。例えばループを実行中に何らかのエラーを検出したので処理を中止したい場合などだ</p>
<div class="sourceCode" id="cb334"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb334-1" data-line-number="1"><span class="cf">while</span> ( <span class="kw">true</span> )</a>
<a class="sourceLine" id="cb334-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb334-3" data-line-number="3">    <span class="co">// 処理</span></a>
<a class="sourceLine" id="cb334-4" data-line-number="4"></a>
<a class="sourceLine" id="cb334-5" data-line-number="5">    <span class="cf">if</span> ( is_error() )</a>
<a class="sourceLine" id="cb334-6" data-line-number="6">        <span class="co">// エラーのため脱出したくなった</span></a>
<a class="sourceLine" id="cb334-7" data-line-number="7"></a>
<a class="sourceLine" id="cb334-8" data-line-number="8">    <span class="co">// 処理</span></a>
<a class="sourceLine" id="cb334-9" data-line-number="9">}</a></code></pre></div>
<p><code>break文</code>はループの途中から脱出するための文だ。</p>
<pre><code>break ;</code></pre>
<p><code>break文</code>は<code>for文</code>、<code>while文</code>、<code>do文</code>の中でしか使えない。</p>
<p><code>break文</code>は<code>for文</code>、<code>while文</code>、<code>do文</code>の外側に脱出する。</p>
<div class="sourceCode" id="cb336"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb336-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb336-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb336-3" data-line-number="3">    <span class="cf">while</span> ( <span class="kw">true</span> )</a>
<a class="sourceLine" id="cb336-4" data-line-number="4">    {</a>
<a class="sourceLine" id="cb336-5" data-line-number="5">        <span class="co">// 処理</span></a>
<a class="sourceLine" id="cb336-6" data-line-number="6"></a>
<a class="sourceLine" id="cb336-7" data-line-number="7">        <span class="cf">break</span> ;</a>
<a class="sourceLine" id="cb336-8" data-line-number="8"></a>
<a class="sourceLine" id="cb336-9" data-line-number="9">        <span class="co">// 処理</span></a>
<a class="sourceLine" id="cb336-10" data-line-number="10">    }</a>
<a class="sourceLine" id="cb336-11" data-line-number="11">}</a></code></pre></div>
<p>これは以下のようなコードと同じだ。</p>
<div class="sourceCode" id="cb337"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb337-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb337-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb337-3" data-line-number="3">    <span class="cf">while</span> ( <span class="kw">true</span> )</a>
<a class="sourceLine" id="cb337-4" data-line-number="4">    {</a>
<a class="sourceLine" id="cb337-5" data-line-number="5">        <span class="co">// 処理</span></a>
<a class="sourceLine" id="cb337-6" data-line-number="6"></a>
<a class="sourceLine" id="cb337-7" data-line-number="7">        <span class="cf">goto</span> break_while ;</a>
<a class="sourceLine" id="cb337-8" data-line-number="8"></a>
<a class="sourceLine" id="cb337-9" data-line-number="9">        <span class="co">// 処理</span></a>
<a class="sourceLine" id="cb337-10" data-line-number="10">    }</a>
<a class="sourceLine" id="cb337-11" data-line-number="11">break_while : ;</a>
<a class="sourceLine" id="cb337-12" data-line-number="12">}</a></code></pre></div>
<p><code>break文</code>は最も内側の<code>繰り返し文</code>から脱出する</p>
<div class="sourceCode" id="cb338"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb338-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb338-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb338-3" data-line-number="3">    <span class="cf">while</span> ( <span class="kw">true</span> ) <span class="co">// 外側</span></a>
<a class="sourceLine" id="cb338-4" data-line-number="4">    {</a>
<a class="sourceLine" id="cb338-5" data-line-number="5">        <span class="cf">while</span> ( <span class="kw">true</span> ) <span class="co">// 内側</span></a>
<a class="sourceLine" id="cb338-6" data-line-number="6">        {</a>
<a class="sourceLine" id="cb338-7" data-line-number="7">            <span class="cf">break</span> ;</a>
<a class="sourceLine" id="cb338-8" data-line-number="8">        }</a>
<a class="sourceLine" id="cb338-9" data-line-number="9">        <span class="co">// ここに脱出</span></a>
<a class="sourceLine" id="cb338-10" data-line-number="10">    }</a>
<a class="sourceLine" id="cb338-11" data-line-number="11">}</a></code></pre></div>
<h2 id="continue文">continue文</h2>
<p>ループの途中で、今のループを打ち切って次のループに進みたい場合はどうすればいいのだろう。例えば、ループの途中でエラーを検出したので、そのループについては処理を打ち切りたい場合だ。</p>
<div class="sourceCode" id="cb339"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb339-1" data-line-number="1"><span class="cf">while</span> ( <span class="kw">true</span> )</a>
<a class="sourceLine" id="cb339-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb339-3" data-line-number="3">    <span class="co">// 処理</span></a>
<a class="sourceLine" id="cb339-4" data-line-number="4"></a>
<a class="sourceLine" id="cb339-5" data-line-number="5">    <span class="cf">if</span> ( is_error() )</a>
<a class="sourceLine" id="cb339-6" data-line-number="6">        <span class="co">// このループは打ち切りたい</span></a>
<a class="sourceLine" id="cb339-7" data-line-number="7"></a>
<a class="sourceLine" id="cb339-8" data-line-number="8">    <span class="co">// 処理</span></a>
<a class="sourceLine" id="cb339-9" data-line-number="9">}</a></code></pre></div>
<p><code>continue文</code>はループを打ち切って次のループに行くための文だ。</p>
<pre><code>continue ;</code></pre>
<p><code>continue文</code>は<code>for文</code>、<code>while文</code>、<code>do</code>文の中でしか使えない。</p>
<div class="sourceCode" id="cb341"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb341-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb341-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb341-3" data-line-number="3">    <span class="cf">while</span> ( <span class="kw">true</span> )</a>
<a class="sourceLine" id="cb341-4" data-line-number="4">    {</a>
<a class="sourceLine" id="cb341-5" data-line-number="5">        <span class="co">// 処理</span></a>
<a class="sourceLine" id="cb341-6" data-line-number="6"></a>
<a class="sourceLine" id="cb341-7" data-line-number="7">        <span class="cf">continue</span> ;</a>
<a class="sourceLine" id="cb341-8" data-line-number="8"></a>
<a class="sourceLine" id="cb341-9" data-line-number="9">        <span class="co">// 処理</span></a>
<a class="sourceLine" id="cb341-10" data-line-number="10">    }</a>
<a class="sourceLine" id="cb341-11" data-line-number="11">}</a></code></pre></div>
<p>これは以下のようなコードと同じだ。</p>
<div class="sourceCode" id="cb342"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb342-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb342-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb342-3" data-line-number="3">    <span class="cf">while</span> ( <span class="kw">true</span> )</a>
<a class="sourceLine" id="cb342-4" data-line-number="4">    {</a>
<a class="sourceLine" id="cb342-5" data-line-number="5">        <span class="co">// 処理</span></a>
<a class="sourceLine" id="cb342-6" data-line-number="6"></a>
<a class="sourceLine" id="cb342-7" data-line-number="7">        <span class="cf">goto</span> continue_while ;</a>
<a class="sourceLine" id="cb342-8" data-line-number="8"></a>
<a class="sourceLine" id="cb342-9" data-line-number="9">        <span class="co">// 処理</span></a>
<a class="sourceLine" id="cb342-10" data-line-number="10"></a>
<a class="sourceLine" id="cb342-11" data-line-number="11">continue_while : ;</a>
<a class="sourceLine" id="cb342-12" data-line-number="12">    }</a>
<a class="sourceLine" id="cb342-13" data-line-number="13">}</a></code></pre></div>
<p><code>continue</code>文はループの最後に処理を移す。その結果、次のループを実行するかどうかの<code>条件</code>を評価することになる。</p>
<p><code>continue文</code>は最も内側のループに対応する。</p>
<div class="sourceCode" id="cb343"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb343-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb343-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb343-3" data-line-number="3">    <span class="cf">while</span> ( <span class="kw">true</span> ) <span class="co">// 外側</span></a>
<a class="sourceLine" id="cb343-4" data-line-number="4">    {</a>
<a class="sourceLine" id="cb343-5" data-line-number="5">        <span class="cf">while</span> ( <span class="kw">true</span> ) <span class="co">// 内側</span></a>
<a class="sourceLine" id="cb343-6" data-line-number="6">        {</a>
<a class="sourceLine" id="cb343-7" data-line-number="7">            <span class="cf">continue</span> ;</a>
<a class="sourceLine" id="cb343-8" data-line-number="8">            <span class="co">// continueはここに実行を移す</span></a>
<a class="sourceLine" id="cb343-9" data-line-number="9">        }</a>
<a class="sourceLine" id="cb343-10" data-line-number="10">    }</a>
<a class="sourceLine" id="cb343-11" data-line-number="11">}</a></code></pre></div>
<h2 id="再帰関数">再帰関数</h2>
<p>最後に関数でループを実装する方法を示してこの章を終わりにしよう。</p>
<p>関数は関数を呼び出すことができる。</p>
<div class="sourceCode" id="cb344"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb344-1" data-line-number="1"><span class="dt">void</span> f() { }</a>
<a class="sourceLine" id="cb344-2" data-line-number="2"></a>
<a class="sourceLine" id="cb344-3" data-line-number="3"><span class="dt">void</span> g()</a>
<a class="sourceLine" id="cb344-4" data-line-number="4">{</a>
<a class="sourceLine" id="cb344-5" data-line-number="5">    f() ; <span class="co">// 関数fの呼び出し</span></a>
<a class="sourceLine" id="cb344-6" data-line-number="6">}</a>
<a class="sourceLine" id="cb344-7" data-line-number="7"></a>
<a class="sourceLine" id="cb344-8" data-line-number="8"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb344-9" data-line-number="9">{</a>
<a class="sourceLine" id="cb344-10" data-line-number="10">    g() ; <span class="co">// 関数gの呼び出し</span></a>
<a class="sourceLine" id="cb344-11" data-line-number="11">}</a></code></pre></div>
<p>ではもし、関数が自分自身を呼び出したらどうなるだろうか。</p>
<div class="sourceCode" id="cb345"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb345-1" data-line-number="1"><span class="dt">void</span> hello()</a>
<a class="sourceLine" id="cb345-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb345-3" data-line-number="3">    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;hello</span><span class="sc">\n</span><span class="st">&quot;</span> ;</a>
<a class="sourceLine" id="cb345-4" data-line-number="4">    hello() ;</a>
<a class="sourceLine" id="cb345-5" data-line-number="5">}</a>
<a class="sourceLine" id="cb345-6" data-line-number="6"></a>
<a class="sourceLine" id="cb345-7" data-line-number="7"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb345-8" data-line-number="8">{</a>
<a class="sourceLine" id="cb345-9" data-line-number="9">    hello() ;</a>
<a class="sourceLine" id="cb345-10" data-line-number="10">}</a></code></pre></div>
<ol type="1">
<li>関数<code>main</code>は関数<code>hello</code>を呼び出す</li>
<li>関数<code>hello</code>は“hello”と出力して関数<code>hello</code>を呼び出す</li>
</ol>
<p>関数<code>hello</code>は必ず関数<code>hello</code>を呼び出すので、この実行は無限ループする。</p>
<p>関数が自分自身を呼び出すことを、<code>再帰(recursion)</code>という。</p>
<p>なるほど、再帰によって無限ループを実現できることはわかった。では終了条件付きループは書けるだろうか。</p>
<p>関数は<code>return文</code>によって呼び出し元に戻る。単に’return ;’と書けば再帰はしない。そして、<code>if文</code>によって実行は分岐できる。これを使えば再帰で終了条件付きループが実現できる。</p>
<p>試しに、ユーザーが0を入力するまでループし続けるプログラムを書いてみよう。</p>
<div class="sourceCode" id="cb346"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb346-1" data-line-number="1"><span class="co">// ユーザーからの入力を返す</span></a>
<a class="sourceLine" id="cb346-2" data-line-number="2"><span class="dt">int</span> input ()</a>
<a class="sourceLine" id="cb346-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb346-4" data-line-number="4">    <span class="dt">int</span> x { } ;</a>
<a class="sourceLine" id="cb346-5" data-line-number="5">    <span class="bu">std::</span>cin &gt;&gt; x ;</a>
<a class="sourceLine" id="cb346-6" data-line-number="6">    <span class="cf">return</span> x ;</a>
<a class="sourceLine" id="cb346-7" data-line-number="7">}</a>
<a class="sourceLine" id="cb346-8" data-line-number="8"></a>
<a class="sourceLine" id="cb346-9" data-line-number="9"><span class="co">// 0の入力を終了条件としたループ</span></a>
<a class="sourceLine" id="cb346-10" data-line-number="10"><span class="dt">void</span> loop_until_zero()</a>
<a class="sourceLine" id="cb346-11" data-line-number="11">{</a>
<a class="sourceLine" id="cb346-12" data-line-number="12">    <span class="cf">if</span> ( input() == <span class="dv">0</span> )</a>
<a class="sourceLine" id="cb346-13" data-line-number="13">        <span class="cf">return</span> ;</a>
<a class="sourceLine" id="cb346-14" data-line-number="14">    <span class="cf">else</span></a>
<a class="sourceLine" id="cb346-15" data-line-number="15">        loop_until_zero() ;</a>
<a class="sourceLine" id="cb346-16" data-line-number="16">}</a>
<a class="sourceLine" id="cb346-17" data-line-number="17"></a>
<a class="sourceLine" id="cb346-18" data-line-number="18"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb346-19" data-line-number="19">{</a>
<a class="sourceLine" id="cb346-20" data-line-number="20">    loop_until_zero() ;</a>
<a class="sourceLine" id="cb346-21" data-line-number="21">}</a></code></pre></div>
<p>書けた。</p>
<p>ではインデックスループはどうだろうか。1から10までの整数を出力してみよう。</p>
<p>インデックスループを実現するには、書き換えられる変数が必要だ。関数は引数で値を渡すことができる。</p>
<div class="sourceCode" id="cb347"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb347-1" data-line-number="1"><span class="dt">void</span> g( <span class="dt">int</span> x ) { }</a>
<a class="sourceLine" id="cb347-2" data-line-number="2"><span class="dt">void</span> f( <span class="dt">int</span> x ) { g( x<span class="dv">+1</span> ) ; }</a>
<a class="sourceLine" id="cb347-3" data-line-number="3"></a>
<a class="sourceLine" id="cb347-4" data-line-number="4"><span class="dt">int</span> main() { f( <span class="dv">0</span> ) ; }</a></code></pre></div>
<p>これをみると、関数<code>main</code>は関数<code>f</code>に引数0を渡し、関数<code>f</code>は関数<code>g</code>に引数1を渡している。これをもっと再帰的に考えよう。</p>
<div class="sourceCode" id="cb348"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb348-1" data-line-number="1"><span class="dt">void</span> until_ten( <span class="dt">int</span> x )</a>
<a class="sourceLine" id="cb348-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb348-3" data-line-number="3">    <span class="cf">if</span> ( x &gt; <span class="dv">10</span> )</a>
<a class="sourceLine" id="cb348-4" data-line-number="4">        <span class="cf">return</span> ;</a>
<a class="sourceLine" id="cb348-5" data-line-number="5">    <span class="cf">else</span></a>
<a class="sourceLine" id="cb348-6" data-line-number="6">    {</a>
<a class="sourceLine" id="cb348-7" data-line-number="7">        <span class="bu">std::</span>cout &lt;&lt; x &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span> ;</a>
<a class="sourceLine" id="cb348-8" data-line-number="8">        <span class="cf">return</span> until_ten( x + <span class="dv">1</span> ) ;</a>
<a class="sourceLine" id="cb348-9" data-line-number="9">    }</a>
<a class="sourceLine" id="cb348-10" data-line-number="10">}</a>
<a class="sourceLine" id="cb348-11" data-line-number="11"></a>
<a class="sourceLine" id="cb348-12" data-line-number="12"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb348-13" data-line-number="13">{</a>
<a class="sourceLine" id="cb348-14" data-line-number="14">    until_ten(<span class="dv">1</span>) ;</a>
<a class="sourceLine" id="cb348-15" data-line-number="15">}</a></code></pre></div>
<p>関数<code>main</code>は関数<code>until_ten</code>に引数1を渡す。</p>
<p>関数<code>until_ten</code>は引数が10より大きければ何もせず処理を戻し、そうでなければ引数を出力して再帰する。その時引数は+1される。</p>
<p>これによりインデックスループが実現できる。</p>
<p>関数は戻り値を返すことができる。再帰で戻り値を使うことにより面白い問題も解くことができる。</p>
<p>例えば、1と0だけを使った10進数の整数を2進数に変換するプログラムを書いてみよう。</p>
<pre><code>$ make run
&gt; 0
0
&gt; 1
1
&gt; 10
2
&gt; 11
3
&gt; 1010
10
&gt; 1111
15</code></pre>
<p>まず10進数と2進数を確認しよう。数学的に言うと「10を底にする」とか「2を底にする」という言い方をする。</p>
<p>具体的な例を出すと10進数では1,2,3,4,5,6,7,8,9,0の文字を使う。<code>1234</code>は以下のようになる。</p>
<p><span class="math display">\[
1234 = 1 \times 10^3 + 2 \times 10^2 + 3 \times 10^1 + 4 \times 10^0 = 1 \times 1000 + 2 \times 100 + 3 \times 10 + 4 \times 1
\]</span></p>
<p>10進数で<code>1010</code>は以下のようになる。</p>
<p><span class="math display">\[
1010 = 1 \times 10^3 + 0 \times 10^2 + 1 \times 10^1 + 0 \times 10^0 = 1 \times 1000 + 0 \times 100 + 1 \times 10 + 0 \times 1
\]</span></p>
<p>2進数では1,0の文字を使う。<code>1010</code>は以下のようになる。</p>
<p><span class="math display">\[
1010 = 1 \times 2^3 + 0 \times 2^2 + 1 \times 2^1 + 0 \times 2^0 = 1 \times 8 + 0 \times 4 + 1 \times 2 + 0 \times 1
\]</span></p>
<p>2進数の<code>1010</code>は10進数では<code>10</code>になる。</p>
<p>では問題を解いていこう。</p>
<p>問題を難しく考えるとかえって解けなくなる。ここではすでに10進数から2進数への変換は解決したものとして考えよう。関数<code>convert</code>によってその問題は解決した。</p>
<div class="sourceCode" id="cb350"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb350-1" data-line-number="1"><span class="co">// 2進数への変換</span></a>
<a class="sourceLine" id="cb350-2" data-line-number="2"><span class="dt">int</span> convert( <span class="dt">int</span> n ) ;</a></code></pre></div>
<p>まだ我々は関数<code>convert</code>の中身を書いていないが、すでに書き終わったと仮定しよう。するとプログラムの残りの部分は以下のように書ける。</p>
<div class="sourceCode" id="cb351"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb351-1" data-line-number="1"><span class="dt">int</span> convert( <span class="dt">int</span> n ) ;</a>
<a class="sourceLine" id="cb351-2" data-line-number="2"></a>
<a class="sourceLine" id="cb351-3" data-line-number="3"><span class="co">// 入力</span></a>
<a class="sourceLine" id="cb351-4" data-line-number="4"><span class="dt">int</span> input()</a>
<a class="sourceLine" id="cb351-5" data-line-number="5">{</a>
<a class="sourceLine" id="cb351-6" data-line-number="6">    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;&gt; &quot;</span> ;</a>
<a class="sourceLine" id="cb351-7" data-line-number="7">    <span class="dt">int</span> x{} ;</a>
<a class="sourceLine" id="cb351-8" data-line-number="8">    <span class="bu">std::</span>cin &gt;&gt; x ;</a>
<a class="sourceLine" id="cb351-9" data-line-number="9">    <span class="cf">return</span> x ;</a>
<a class="sourceLine" id="cb351-10" data-line-number="10">}</a>
<a class="sourceLine" id="cb351-11" data-line-number="11"></a>
<a class="sourceLine" id="cb351-12" data-line-number="12"><span class="co">// 出力</span></a>
<a class="sourceLine" id="cb351-13" data-line-number="13"><span class="dt">void</span> output( <span class="dt">int</span> binary )</a>
<a class="sourceLine" id="cb351-14" data-line-number="14">{</a>
<a class="sourceLine" id="cb351-15" data-line-number="15">    <span class="bu">std::</span>cout &lt;&lt; binary &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb351-16" data-line-number="16">}</a>
<a class="sourceLine" id="cb351-17" data-line-number="17"></a>
<a class="sourceLine" id="cb351-18" data-line-number="18"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb351-19" data-line-number="19">{</a>
<a class="sourceLine" id="cb351-20" data-line-number="20">    <span class="co">// 入力、変換、出力のループ</span></a>
<a class="sourceLine" id="cb351-21" data-line-number="21">    <span class="cf">while</span>( <span class="kw">true</span> )</a>
<a class="sourceLine" id="cb351-22" data-line-number="22">    {</a>
<a class="sourceLine" id="cb351-23" data-line-number="23">        <span class="kw">auto</span> decimal = input() ;</a>
<a class="sourceLine" id="cb351-24" data-line-number="24">        <span class="kw">auto</span> binary = convert( decimal ) ;</a>
<a class="sourceLine" id="cb351-25" data-line-number="25">        output( binary ) ;</a>
<a class="sourceLine" id="cb351-26" data-line-number="26">    } </a>
<a class="sourceLine" id="cb351-27" data-line-number="27">}</a></code></pre></div>
<p>後は関数<code>convert</code>を実装すればよいだけだ。</p>
<p>関数<code>convert</code>に引数を渡した時の結果を考えてみよう。convert(1010)は10を返し、convert(1111)は15を返す。</p>
<p>ではconvert(-1010)の結果はどうなるだろうか。これは-10になる。</p>
<p>負数と正数の違いを考えるのは面倒だ。ここでは正数を引数として与えると10進数から2進数へ変換した答えを返してくる魔法のような関数<code>solve</code>をすでに書き終えたと仮定しよう。我々はまだ関数<code>solve</code>を書いていないが、その問題は未来の自分に押し付けよう。</p>
<div class="sourceCode" id="cb352"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb352-1" data-line-number="1"><span class="co">// 1,0のみを使った10進数から</span></a>
<a class="sourceLine" id="cb352-2" data-line-number="2"><span class="co">// 2進数へ変換する関数</span></a>
<a class="sourceLine" id="cb352-3" data-line-number="3"><span class="dt">int</span> solve( <span class="dt">int</span> n ) ;</a></code></pre></div>
<p>すると、関数<code>convert</code>がやるのは負数と正数の処理だけでよい。</p>
<ol type="1">
<li>引数が正数の場合はそのまま関数<code>solve</code>に渡してreturn</li>
<li>引数が負数の場合は絶対値を関数<code>solve</code>に渡して負数にしてreturn</li>
</ol>
<div class="sourceCode" id="cb353"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb353-1" data-line-number="1"><span class="dt">int</span> convert( <span class="dt">int</span> n )</a>
<a class="sourceLine" id="cb353-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb353-3" data-line-number="3">    <span class="co">// 引数が正数の場合</span></a>
<a class="sourceLine" id="cb353-4" data-line-number="4">    <span class="cf">if</span> ( n &gt; <span class="dv">0</span> )</a>
<a class="sourceLine" id="cb353-5" data-line-number="5">        <span class="co">// そのまま関数solveに渡してreturn</span></a>
<a class="sourceLine" id="cb353-6" data-line-number="6">        <span class="cf">return</span> solve( n ) ;</a>
<a class="sourceLine" id="cb353-7" data-line-number="7">    <span class="cf">else</span> <span class="co">// 引数が負数の場合</span></a>
<a class="sourceLine" id="cb353-8" data-line-number="8">        <span class="co">// 絶対値を関数solveに渡して負数にしてreturn</span></a>
<a class="sourceLine" id="cb353-9" data-line-number="9">        <span class="cf">return</span> - solve( -n ) ;</a>
<a class="sourceLine" id="cb353-10" data-line-number="10">}</a></code></pre></div>
<p>nが負数の場合の絶対値は-nで得られる。その場合、関数<code>solve</code>の答えは正数なので負数にする。</p>
<p>あとは関数<code>solve</code>を実装するだけだ。</p>
<p>今回、引数の整数を10進数で表現した場合に2,3,4,5,6,7,8,9が使われている場合は考えないものとする。</p>
<div class="sourceCode" id="cb354"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb354-1" data-line-number="1"><span class="co">// OK</span></a>
<a class="sourceLine" id="cb354-2" data-line-number="2">solve(<span class="dv">10111101</span>) ;</a>
<a class="sourceLine" id="cb354-3" data-line-number="3"><span class="co">// ありえない</span></a>
<a class="sourceLine" id="cb354-4" data-line-number="4">solve(<span class="dv">2</span>) ;</a></code></pre></div>
<p>再帰で問題を解くには再帰的な考え方が必要だ。再帰的な考え方では、問題の一部のみを解き、残りは自分自身に丸投げする。</p>
<p>まずとても簡単な1桁の変換を考えよう。</p>
<div class="sourceCode" id="cb355"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb355-1" data-line-number="1">solve(<span class="dv">0</span>) ; <span class="co">// 0</span></a>
<a class="sourceLine" id="cb355-2" data-line-number="2">solve(<span class="dv">1</span>) ; <span class="co">// 1</span></a></code></pre></div>
<p>引数が0か1の場合、単にその値を返すだけだ。関数<code>solve</code>には正数しか渡されないので、負数は考えなくてよい。すると、以下のように書ける。</p>
<div class="sourceCode" id="cb356"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb356-1" data-line-number="1"><span class="dt">int</span> solve( <span class="dt">int</span> n )</a>
<a class="sourceLine" id="cb356-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb356-3" data-line-number="3">    <span class="cf">if</span> ( n &lt; <span class="dv">1</span> )</a>
<a class="sourceLine" id="cb356-4" data-line-number="4">        <span class="cf">return</span> n ;</a>
<a class="sourceLine" id="cb356-5" data-line-number="5">    <span class="cf">else</span></a>
<a class="sourceLine" id="cb356-6" data-line-number="6">        <span class="co">// その他の場合</span></a>
<a class="sourceLine" id="cb356-7" data-line-number="7">}</a></code></pre></div>
<p>その他の場合とは、桁数が多い場合だ。</p>
<div class="sourceCode" id="cb357"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb357-1" data-line-number="1">solve(<span class="dv">10</span>) ;  <span class="co">// 2</span></a>
<a class="sourceLine" id="cb357-2" data-line-number="2">solve(<span class="dv">11</span>) ;  <span class="co">// 3</span></a>
<a class="sourceLine" id="cb357-3" data-line-number="3">solve(<span class="dv">110</span>) ; <span class="co">// 4</span></a>
<a class="sourceLine" id="cb357-4" data-line-number="4">solve(<span class="dv">111</span>) ; <span class="co">// 5</span></a></code></pre></div>
<p>関数<code>solve</code>が解決するのは最下位桁だ。110の場合は0で、111の場合は1となる。最も右側の桁のみを扱う。数値から10進数で表記したときの最下位桁を取り出すには、10で割った余りが使える。覚えているだろうか。剰余演算子のoperator %を。</p>
<div class="sourceCode" id="cb358"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb358-1" data-line-number="1"><span class="dt">int</span> solve( <span class="dt">int</span> n )</a>
<a class="sourceLine" id="cb358-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb358-3" data-line-number="3">    <span class="cf">if</span> ( n &lt; <span class="dv">1</span> )</a>
<a class="sourceLine" id="cb358-4" data-line-number="4">        <span class="cf">return</span> n ;</a>
<a class="sourceLine" id="cb358-5" data-line-number="5">    <span class="cf">else</span> <span class="co">// 未完成</span></a>
<a class="sourceLine" id="cb358-6" data-line-number="6">        <span class="cf">return</span> n%<span class="dv">10</span> ;</a>
<a class="sourceLine" id="cb358-7" data-line-number="7">}</a></code></pre></div>
<p>結果は以下のようになる。</p>
<div class="sourceCode" id="cb359"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb359-1" data-line-number="1">solve(<span class="dv">10</span>) ;  <span class="co">// 0</span></a>
<a class="sourceLine" id="cb359-2" data-line-number="2">solve(<span class="dv">11</span>) ;  <span class="co">// 1</span></a>
<a class="sourceLine" id="cb359-3" data-line-number="3">solve(<span class="dv">110</span>) ; <span class="co">// 0</span></a>
<a class="sourceLine" id="cb359-4" data-line-number="4">solve(<span class="dv">111</span>) ; <span class="co">// 1</span></a></code></pre></div>
<p>これで関数<code>solve</code>は最下位桁に完全に対応した。しかしそれ以外の桁はどうすればいいのだろう。</p>
<p>ここで再帰的な考え方が必要だ。関数<code>solve</code>はすでに最下位桁に完全に対応している。ならば次の桁を最下位桁とした数値で関数<code>solve</code>を再帰的に呼び出せばいいのではないか。</p>
<p>以下はsolve(n)が再帰的に呼び出す関数だ。</p>
<div class="sourceCode" id="cb360"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb360-1" data-line-number="1">solve(<span class="dv">10</span>) ;  <span class="co">// solve(1)</span></a>
<a class="sourceLine" id="cb360-2" data-line-number="2">solve(<span class="dv">11</span>) ;  <span class="co">// solve(1)</span></a>
<a class="sourceLine" id="cb360-3" data-line-number="3">solve(<span class="dv">100</span>) ; <span class="co">// solve(10)→solve(1)</span></a>
<a class="sourceLine" id="cb360-4" data-line-number="4">solve(<span class="dv">110</span>) ; <span class="co">// solve(11)→solve(1)</span></a>
<a class="sourceLine" id="cb360-5" data-line-number="5">solve(<span class="dv">111</span>) ; <span class="co">// solve(11)→solve(1)</span></a></code></pre></div>
<p>10進数表記された数値から最下位桁を取り除いた数値にするというのは、11を1に, 111を11にする処理だ。これは数値を10で割ればよい。</p>
<div class="sourceCode" id="cb361"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb361-1" data-line-number="1"><span class="dv">10</span>  / <span class="dv">10</span> ; <span class="co">// 1</span></a>
<a class="sourceLine" id="cb361-2" data-line-number="2"><span class="dv">11</span>  / <span class="dv">10</span> ; <span class="co">// 1</span></a>
<a class="sourceLine" id="cb361-3" data-line-number="3"><span class="dv">100</span> / <span class="dv">10</span> ; <span class="co">// 10</span></a>
<a class="sourceLine" id="cb361-4" data-line-number="4"><span class="dv">110</span> / <span class="dv">10</span> ; <span class="co">// 11</span></a>
<a class="sourceLine" id="cb361-5" data-line-number="5"><span class="dv">111</span> / <span class="dv">10</span> ; <span class="co">// 11</span></a></code></pre></div>
<p>10進数表記は桁が一つあがると10倍される。だから10で割れば最下位桁が消える。ところで、我々は計算しようとしているのは2進数だ。2進数では桁が一つあがると2倍される。なので、再帰的に関数<code>solve</code>を呼び出して得られた結果は2倍しなければならない。そして足し合わせる。</p>
<div class="sourceCode" id="cb362"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb362-1" data-line-number="1"><span class="dt">int</span> solve( <span class="dt">int</span> n )</a>
<a class="sourceLine" id="cb362-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb362-3" data-line-number="3">    <span class="co">// 1桁の場合</span></a>
<a class="sourceLine" id="cb362-4" data-line-number="4">    <span class="cf">if</span> ( n &lt;= <span class="dv">1</span> )</a>
<a class="sourceLine" id="cb362-5" data-line-number="5">        <span class="cf">return</span> n ; <span class="co">// 単に返す</span></a>
<a class="sourceLine" id="cb362-6" data-line-number="6">    <span class="cf">else</span> <span class="co">// それ以外</span></a>
<a class="sourceLine" id="cb362-7" data-line-number="7">        <span class="cf">return</span></a>
<a class="sourceLine" id="cb362-8" data-line-number="8">            <span class="co">// 最下位桁の計算</span></a>
<a class="sourceLine" id="cb362-9" data-line-number="9">            n%<span class="dv">2</span></a>
<a class="sourceLine" id="cb362-10" data-line-number="10">            <span class="co">// 残りの桁を丸投げする</span></a>
<a class="sourceLine" id="cb362-11" data-line-number="11">            <span class="co">// 次の桁なので2倍する</span></a>
<a class="sourceLine" id="cb362-12" data-line-number="12">            + <span class="dv">2</span> * solve( n/<span class="dv">10</span> ) ;</a>
<a class="sourceLine" id="cb362-13" data-line-number="13">}</a></code></pre></div>
<p>冗長なコメントを除いて短くすると以下の通り</p>
<div class="sourceCode" id="cb363"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb363-1" data-line-number="1"><span class="dt">int</span> solve( <span class="dt">int</span> n )</a>
<a class="sourceLine" id="cb363-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb363-3" data-line-number="3">    <span class="cf">if</span> ( n &lt;= <span class="dv">1</span> )</a>
<a class="sourceLine" id="cb363-4" data-line-number="4">        <span class="cf">return</span> n ;</a>
<a class="sourceLine" id="cb363-5" data-line-number="5">    <span class="cf">else</span></a>
<a class="sourceLine" id="cb363-6" data-line-number="6">        <span class="cf">return</span> n%<span class="dv">2</span> + <span class="dv">2</span> * solve( n/<span class="dv">10</span> ) ;</a>
<a class="sourceLine" id="cb363-7" data-line-number="7">}</a></code></pre></div>
<p>再帰ではないループで関数<code>solve</code>を実装するとどうなるのだろうか。</p>
<p>引数の数値が何桁あっても対応できるよう、ループで1桁づつ処理していくのはかわらない。</p>
<p>もういちど2進数の計算を見てみよう。</p>
<p><span class="math display">\[
1010 = 1 \times 2^3 + 0 \times 2^2 + 1 \times 2^1 + 0 \times 2^0 = 1 \times 8 + 0 \times 4 + 1 \times 2 + 0 \times 1
\]</span></p>
<p>1桁目は0で、この値は<span class="math inline">\(0 \times 2^0\)</span>、2桁目は1で、この値は<span class="math inline">\(1 \times 2^1\)</span>になる。</p>
<p>一般に、i桁目の値は<span class="math inline">\(i桁目の数字 \times 2^{i-1}\)</span>になる。</p>
<p>すると解き方としては、各桁の値を計算した和を返せばよい</p>
<div class="sourceCode" id="cb364"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb364-1" data-line-number="1"><span class="dt">int</span> solve( <span class="dt">int</span> n )</a>
<a class="sourceLine" id="cb364-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb364-3" data-line-number="3">    <span class="co">// 和</span></a>
<a class="sourceLine" id="cb364-4" data-line-number="4">    <span class="dt">int</span> result = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb364-5" data-line-number="5">    <span class="co">// i桁目の数字に乗ずる値</span></a>
<a class="sourceLine" id="cb364-6" data-line-number="6">    <span class="dt">int</span> i = <span class="dv">1</span> ;</a>
<a class="sourceLine" id="cb364-7" data-line-number="7"></a>
<a class="sourceLine" id="cb364-8" data-line-number="8">    <span class="co">// 桁がなくなれば終了</span></a>
<a class="sourceLine" id="cb364-9" data-line-number="9">    <span class="cf">while</span> ( n != <span class="dv">0</span> )</a>
<a class="sourceLine" id="cb364-10" data-line-number="10">    {</a>
<a class="sourceLine" id="cb364-11" data-line-number="11">        <span class="co">// 現在の桁を計算して足す</span></a>
<a class="sourceLine" id="cb364-12" data-line-number="12">        result += n%<span class="dv">10</span> * i ;</a>
<a class="sourceLine" id="cb364-13" data-line-number="13">        <span class="co">// 次の桁に乗ずる値</span></a>
<a class="sourceLine" id="cb364-14" data-line-number="14">        i *= <span class="dv">2</span> ;</a>
<a class="sourceLine" id="cb364-15" data-line-number="15">        <span class="co">// 桁を一つ減らす</span></a>
<a class="sourceLine" id="cb364-16" data-line-number="16">        n /= <span class="dv">10</span> ;</a>
<a class="sourceLine" id="cb364-17" data-line-number="17">    }</a>
<a class="sourceLine" id="cb364-18" data-line-number="18"></a>
<a class="sourceLine" id="cb364-19" data-line-number="19">    <span class="cf">return</span> result ;</a>
<a class="sourceLine" id="cb364-20" data-line-number="20">}</a></code></pre></div>
<p>再帰を使うコードは、再帰を理解できれば短く簡潔でわかりやすい。ただし、再帰を理解するためにはまず再帰を理解しなければならない。</p>
<p>再帰は万能ではない。そもそも関数とは、別の関数から呼ばれるものだ。関数<code>main</code>だけは特別で、関数<code>main</code>を呼び出すことはできない。</p>
<div class="sourceCode" id="cb365"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb365-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb365-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb365-3" data-line-number="3">    main() ; <span class="co">// エラー</span></a>
<a class="sourceLine" id="cb365-4" data-line-number="4">}</a></code></pre></div>
<p>関数の実行が終了した場合、呼び出し元に処理が戻る。そのために関数は呼び出し元を覚えていなければならない。これには通常<code>スタック</code>とよばれるメモリーを消費する。</p>
<div class="sourceCode" id="cb366"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb366-1" data-line-number="1"><span class="dt">void</span> f() { }            <span class="co">// gに戻る</span></a>
<a class="sourceLine" id="cb366-2" data-line-number="2"><span class="dt">void</span> g() { f() ; }      <span class="co">// mainに戻る </span></a>
<a class="sourceLine" id="cb366-3" data-line-number="3"><span class="dt">int</span> main() { g() ; }</a></code></pre></div>
<p>関数の中の変数も通常<code>スタック</code>に確保される。これもメモリーを消費する。</p>
<div class="sourceCode" id="cb367"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb367-1" data-line-number="1"><span class="dt">void</span> f() { }</a>
<a class="sourceLine" id="cb367-2" data-line-number="2"></a>
<a class="sourceLine" id="cb367-3" data-line-number="3"><span class="dt">void</span> g()</a>
<a class="sourceLine" id="cb367-4" data-line-number="4">{</a>
<a class="sourceLine" id="cb367-5" data-line-number="5">    <span class="dt">int</span> x {} ;</a>
<a class="sourceLine" id="cb367-6" data-line-number="6">    <span class="bu">std::</span>cin &gt;&gt; x ;</a>
<a class="sourceLine" id="cb367-7" data-line-number="7">    f() ;   <span class="co">// 関数を呼び出す</span></a>
<a class="sourceLine" id="cb367-8" data-line-number="8">    <span class="co">// 関数を呼び出した後に変数を使う</span></a>
<a class="sourceLine" id="cb367-9" data-line-number="9">    <span class="bu">std::</span>cout &lt;&lt; x ;</a>
<a class="sourceLine" id="cb367-10" data-line-number="10">}</a></code></pre></div>
<p>このコードでは、関数<code>g</code>が変数<code>x</code>を用意し、関数<code>f</code>を呼び出し、処理が戻ったら変数<code>x</code>を使っている。このコードが動くためには、変数<code>x</code>は関数<code>f</code>が実行されている間もスタックメモリーを消費し続けなければならない。</p>
<p>スタックメモリーは有限であるので、以下のような再帰による無限ループは、いつかスタックメモリーを消費し尽して実行が止まるはずだ。</p>
<div class="sourceCode" id="cb368"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb368-1" data-line-number="1"><span class="dt">void</span> hello()</a>
<a class="sourceLine" id="cb368-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb368-3" data-line-number="3">    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;hello</span><span class="sc">\n</span><span class="st">&quot;</span> ;</a>
<a class="sourceLine" id="cb368-4" data-line-number="4">    hello() ;</a>
<a class="sourceLine" id="cb368-5" data-line-number="5">}</a>
<a class="sourceLine" id="cb368-6" data-line-number="6"></a>
<a class="sourceLine" id="cb368-7" data-line-number="7"><span class="dt">int</span> main() { hello() ; }</a></code></pre></div>
<p>しかし、大半の読者の環境ではプログラムの実行が止まらないはずだ。これはコンパイラーの末尾再帰の最適化によるものだ。</p>
<p>末尾再帰とは、関数のすべての条件分岐の末尾が再帰で終わっている再帰のことだ。</p>
<p>例えば以下は階乗を計算する再帰で書かれたループだ。</p>
<div class="sourceCode" id="cb369"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb369-1" data-line-number="1"><span class="dt">int</span> factorial( <span class="dt">int</span> n )</a>
<a class="sourceLine" id="cb369-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb369-3" data-line-number="3">    <span class="cf">if</span> ( n &lt; <span class="dv">1</span> )</a>
<a class="sourceLine" id="cb369-4" data-line-number="4">        <span class="cf">return</span> <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb369-5" data-line-number="5">    <span class="cf">else</span> <span class="cf">if</span> ( n == <span class="dv">1</span> )</a>
<a class="sourceLine" id="cb369-6" data-line-number="6">        <span class="cf">return</span> <span class="dv">1</span> ;</a>
<a class="sourceLine" id="cb369-7" data-line-number="7">    <span class="cf">else</span></a>
<a class="sourceLine" id="cb369-8" data-line-number="8">        <span class="cf">return</span> n * factorial(n<span class="dv">-1</span>) ;</a>
<a class="sourceLine" id="cb369-9" data-line-number="9">}</a></code></pre></div>
<p>factorial(n)は<span class="math inline">\(1 \times 2 \times 3 \times ... \times n\)</span>を計算する。</p>
<p>この関数は、引数<code>n</code>が1未満であれば引数が間違っているので0を返す。そうでない場合でnが1であれば1を返す。それ以外の場合、n * factorial(n-1)を返す。</p>
<p>このコードは末尾再帰になっている。末尾再帰は非再帰のループに機械的に変換できる特徴を持っている。例えば以下のように、</p>
<div class="sourceCode" id="cb370"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb370-1" data-line-number="1"><span class="dt">int</span> factorial( <span class="dt">int</span> n )</a>
<a class="sourceLine" id="cb370-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb370-3" data-line-number="3">    <span class="dt">int</span> temp = n ;</a>
<a class="sourceLine" id="cb370-4" data-line-number="4"></a>
<a class="sourceLine" id="cb370-5" data-line-number="5">loop :</a>
<a class="sourceLine" id="cb370-6" data-line-number="6">    <span class="cf">if</span> ( n &lt; <span class="dv">1</span> )</a>
<a class="sourceLine" id="cb370-7" data-line-number="7">        <span class="cf">return</span> <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb370-8" data-line-number="8">    <span class="cf">else</span> <span class="cf">if</span> ( n == <span class="dv">1</span> )</a>
<a class="sourceLine" id="cb370-9" data-line-number="9">        <span class="cf">return</span> temp * <span class="dv">1</span> ;</a>
<a class="sourceLine" id="cb370-10" data-line-number="10">    <span class="cf">else</span></a>
<a class="sourceLine" id="cb370-11" data-line-number="11">    {</a>
<a class="sourceLine" id="cb370-12" data-line-number="12">        n = n<span class="dv">-1</span> ;</a>
<a class="sourceLine" id="cb370-13" data-line-number="13">        temp *= n ;</a>
<a class="sourceLine" id="cb370-14" data-line-number="14">        <span class="cf">goto</span> loop ;</a>
<a class="sourceLine" id="cb370-15" data-line-number="15">    }</a>
<a class="sourceLine" id="cb370-16" data-line-number="16">}</a></code></pre></div>
<p>関数のすべての条件分岐の末尾が再帰になっているため、機械的に関数呼び出しをgoto文で置き換えることができる。</p>
<p>ただし、プログラミング言語C++の標準規格は、C++の実装に末尾再帰の最適化を義務付けてはいない。そのため、末尾再帰が最適化されるかどうかはC++コンパイラー次第だ。</p>
<p>再帰は強力なループの実現方法で、再帰的な問題を解くのに最適だが、落とし穴もある。</p>
<h1 id="メモリを無限に確保する">メモリを無限に確保する</h1>
<h2 id="これまでのまとめ">これまでのまとめ</h2>
<p>ここまで読み進めてきた読者は、逐次実行、条件分岐、ループに加えて、変数と関数を理解した。これだけの要素を習得したならば、本質的にはプログラミングはほぼできるようになったと言ってよい。ただし、まだできないことがある。動的なメモリ確保だ。</p>
<p>標準入力から0が入力されるまで任意個の整数値を受け取り、小さい値から順に出力するプログラムを実装しよう。以下はそのようなプログラムの実行例だ。</p>
<pre><code>$ make run
100
-100
1
6
3
999
-5000
0
-5000
-100
1
3
6
100
999</code></pre>
<p>0が入力されるまで、1番目に、2番目に小さい値はわからない。そのため、この問題の解決には、入力をすべて保持しておく必要がある。</p>
<p>ここで必要なのは、値をいくらでも保持しておく方法と、値に順番があり、i番目の値を間接的に指定して読み書きできる方法だ。その方法としてC++には標準ライブラリ<code>std::vector</code>がある。</p>
<h2 id="vector">vector</h2>
<p><code>std::vector&lt;T&gt;</code>はT型の値をいくらでも保持できる。<code>T</code>には保持する値の型を指定する。例えばintとかdoubleとかstd::stringだ。</p>
<div class="sourceCode" id="cb372"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb372-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb372-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb372-3" data-line-number="3">    <span class="co">// 整数型intの値を保持するvector</span></a>
<a class="sourceLine" id="cb372-4" data-line-number="4">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; vi ;</a>
<a class="sourceLine" id="cb372-5" data-line-number="5"></a>
<a class="sourceLine" id="cb372-6" data-line-number="6">    <span class="co">// 浮動小数点数型doubleの値を保持するvector</span></a>
<a class="sourceLine" id="cb372-7" data-line-number="7">    <span class="bu">std::</span>vector&lt;<span class="dt">double</span>&gt; vd ;</a>
<a class="sourceLine" id="cb372-8" data-line-number="8"></a>
<a class="sourceLine" id="cb372-9" data-line-number="9">    <span class="co">// 文字列型std::stringの値を保持するvector</span></a>
<a class="sourceLine" id="cb372-10" data-line-number="10">    <span class="bu">std::</span>vector&lt;<span class="bu">std::</span>string&gt; vs ;</a>
<a class="sourceLine" id="cb372-11" data-line-number="11">}</a></code></pre></div>
<p><code>std::vector&lt;T&gt;</code>というのはそれ自体が型になっている。そしてTには型を指定する。ということは、vector型の値を保持するvectorも書けるということだ。</p>
<div class="sourceCode" id="cb373"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb373-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb373-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb373-3" data-line-number="3">    <span class="co">// 整数型intを保持するvectorを保持するvector</span></a>
<a class="sourceLine" id="cb373-4" data-line-number="4">    <span class="bu">std::</span>vector&lt; <span class="bu">std::</span>vector&lt; <span class="dt">int</span> &gt; &gt; vvi ;</a>
<a class="sourceLine" id="cb373-5" data-line-number="5">}</a></code></pre></div>
<p>もちろん、上のvectorを保持するvectorも書ける。その場合、<code>std::vector&lt;std::vector&lt;std::vector&lt;int&gt;&gt;&gt;</code>になる。このvectorを保持するvectorも当然書けるが省略する。</p>
<p><code>std::vector</code>型の変数にはメンバー関数<code>push_back</code>を使うことで値を保持できる。</p>
<div class="sourceCode" id="cb374"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb374-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb374-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb374-3" data-line-number="3">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v  ;</a>
<a class="sourceLine" id="cb374-4" data-line-number="4"></a>
<a class="sourceLine" id="cb374-5" data-line-number="5">    v.push_back(<span class="dv">1</span>) ;</a>
<a class="sourceLine" id="cb374-6" data-line-number="6">    v.push_back(<span class="dv">2</span>) ;</a>
<a class="sourceLine" id="cb374-7" data-line-number="7">    v.push_back(<span class="dv">3</span>) ;</a>
<a class="sourceLine" id="cb374-8" data-line-number="8">}</a></code></pre></div>
<p><code>メンバー関数(member function)</code>というのは特別な関数で、詳細はまだ説明しない。ここで覚えておくべきこととしては、メンバー関数は一部の変数に使うことができること、メンバー関数<code>f</code>を変数<code>x</code>に使うには’x.f(…)’のように書くこと、を覚えておこう。</p>
<p><code>std::vector</code>はメモリの続く限りいくらでも値を保持できる。試しに1000個の整数を保持させてみよう。</p>
<div class="sourceCode" id="cb375"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb375-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb375-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb375-3" data-line-number="3">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v ;</a>
<a class="sourceLine" id="cb375-4" data-line-number="4"></a>
<a class="sourceLine" id="cb375-5" data-line-number="5">    <span class="cf">for</span> ( <span class="dt">int</span> i = <span class="dv">0</span> ; i != <span class="dv">1000</span> ; ++i )</a>
<a class="sourceLine" id="cb375-6" data-line-number="6">    {</a>
<a class="sourceLine" id="cb375-7" data-line-number="7">        v.push_back( i ) ;</a>
<a class="sourceLine" id="cb375-8" data-line-number="8">    }</a>
<a class="sourceLine" id="cb375-9" data-line-number="9">}</a></code></pre></div>
<p>このプログラムは0から999までの1000個の整数を<code>std::vector</code>に保持させている。</p>
<p><code>std::vector</code>では保持する値のことを要素という。要素は順番を持っている。メンバー関数<code>push_back</code>は最後の要素の次に要素を追加する。最初に要素はない。もしくは0個ある空の状態だと言ってもよい。</p>
<div class="sourceCode" id="cb376"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb376-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb376-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb376-3" data-line-number="3">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v ;</a>
<a class="sourceLine" id="cb376-4" data-line-number="4"></a>
<a class="sourceLine" id="cb376-5" data-line-number="5">    <span class="co">// vは空</span></a>
<a class="sourceLine" id="cb376-6" data-line-number="6"></a>
<a class="sourceLine" id="cb376-7" data-line-number="7">    <span class="co">// 要素数1、中身は{1}</span></a>
<a class="sourceLine" id="cb376-8" data-line-number="8">    v.push_back(<span class="dv">1</span>) ;</a>
<a class="sourceLine" id="cb376-9" data-line-number="9">    <span class="co">// 要素数2、中身は{1,2}</span></a>
<a class="sourceLine" id="cb376-10" data-line-number="10">    v.push_back(<span class="dv">2</span>) ;</a>
<a class="sourceLine" id="cb376-11" data-line-number="11">    <span class="co">// 要素数3、中身は{1,2,3}</span></a>
<a class="sourceLine" id="cb376-12" data-line-number="12">    v.push_back(<span class="dv">3</span>) ;</a>
<a class="sourceLine" id="cb376-13" data-line-number="13">}</a></code></pre></div>
<p><code>std::vector</code>はメンバー関数<code>size()</code>で現在の要素数を取得できる。</p>
<div class="sourceCode" id="cb377"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb377-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb377-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb377-3" data-line-number="3">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v ;</a>
<a class="sourceLine" id="cb377-4" data-line-number="4"></a>
<a class="sourceLine" id="cb377-5" data-line-number="5">    <span class="co">// 0</span></a>
<a class="sourceLine" id="cb377-6" data-line-number="6">    <span class="bu">std::</span>cout &lt;&lt; v.size() ;</a>
<a class="sourceLine" id="cb377-7" data-line-number="7">    v.push_back(<span class="dv">1</span>) ;</a>
<a class="sourceLine" id="cb377-8" data-line-number="8">    <span class="co">// 1</span></a>
<a class="sourceLine" id="cb377-9" data-line-number="9">    <span class="bu">std::</span>cout &lt;&lt; v.size() ;</a>
<a class="sourceLine" id="cb377-10" data-line-number="10">    v.push_back(<span class="dv">2</span>) ;</a>
<a class="sourceLine" id="cb377-11" data-line-number="11">    <span class="co">// 2</span></a>
<a class="sourceLine" id="cb377-12" data-line-number="12">    <span class="bu">std::</span>cout &lt;&lt; v.size() ;</a>
<a class="sourceLine" id="cb377-13" data-line-number="13">}</a></code></pre></div>
<p>せっかく値を入れたのだから取り出したいものだ。<code>std::vector</code>ではメンバー関数<code>at(i)</code>を使うことで、i番目の要素を取り出すことができる。このiのことを添字、インデックスと呼ぶ。ここで注意してほしいのは、最初の要素は0番目で、次の要素は1番目だということだ。最後の要素は<code>size()-1</code>番目になる。</p>
<div class="sourceCode" id="cb378"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb378-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb378-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb378-3" data-line-number="3"></a>
<a class="sourceLine" id="cb378-4" data-line-number="4">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v ;</a>
<a class="sourceLine" id="cb378-5" data-line-number="5"></a>
<a class="sourceLine" id="cb378-6" data-line-number="6">    <span class="cf">for</span> ( <span class="dt">int</span> i = <span class="dv">0</span> ; i != <span class="dv">10</span> ; ++i )</a>
<a class="sourceLine" id="cb378-7" data-line-number="7">    {</a>
<a class="sourceLine" id="cb378-8" data-line-number="8">        v.push_back(i) ;</a>
<a class="sourceLine" id="cb378-9" data-line-number="9">    }</a>
<a class="sourceLine" id="cb378-10" data-line-number="10"></a>
<a class="sourceLine" id="cb378-11" data-line-number="11">    <span class="co">// vの中身は{0,1,2,3,4,5,6,7,8,9}</span></a>
<a class="sourceLine" id="cb378-12" data-line-number="12"></a>
<a class="sourceLine" id="cb378-13" data-line-number="13">    <span class="co">// 0, 0番目の最初の要素</span></a>
<a class="sourceLine" id="cb378-14" data-line-number="14">    <span class="bu">std::</span>cout &lt;&lt; v.at(<span class="dv">0</span>) ;</a>
<a class="sourceLine" id="cb378-15" data-line-number="15">    <span class="co">// 4, 5番目の要素</span></a>
<a class="sourceLine" id="cb378-16" data-line-number="16">    <span class="bu">std::</span>cout &lt;&lt; v.at(<span class="dv">4</span>) ;</a>
<a class="sourceLine" id="cb378-17" data-line-number="17">    <span class="co">// 9, 10番目の最後の要素</span></a>
<a class="sourceLine" id="cb378-18" data-line-number="18">    <span class="bu">std::</span>cout &lt;&lt; v.at(<span class="dv">9</span>) ;</a>
<a class="sourceLine" id="cb378-19" data-line-number="19">}</a></code></pre></div>
<p>この例ではループを使っている。読者はすでにループについては理解しているはずだ。上のコードが理解できないのであれば、もう一度ループの章に戻って学び直すべきだ。</p>
<p>もし<code>at(i)</code>に要素数を超えるiを渡してしまった場合どうなるのだろうか。</p>
<div class="sourceCode" id="cb379"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb379-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb379-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb379-3" data-line-number="3">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v { } ;</a>
<a class="sourceLine" id="cb379-4" data-line-number="4">    v.push_back(<span class="dv">0</span>) ;</a>
<a class="sourceLine" id="cb379-5" data-line-number="5">    <span class="co">// vには0番目の要素しかない</span></a>
<a class="sourceLine" id="cb379-6" data-line-number="6">    <span class="co">// 1番目はあやまり</span></a>
<a class="sourceLine" id="cb379-7" data-line-number="7">    <span class="bu">std::</span>cout &lt;&lt; v.at(<span class="dv">1</span>) ;</a>
<a class="sourceLine" id="cb379-8" data-line-number="8">}</a></code></pre></div>
<p>実行して確かめてみよう。</p>
<pre><code>$ ./program
terminate called after throwing an instance of &#39;std::out_of_range&#39;
  what():  vector::_M_range_check: __n (which is 1) &gt;= this-&gt;size() (which is 1)
Aborted (core dumped)</code></pre>
<p>なにやら恐ろしげなメッセージが表示されるではないか。しかし心配することはない。このメッセージはむしろ嬉しいメッセージだ。変数vに1番目の要素がないことを発見してくれたという実行時のエラーメッセージだ。すでに学んだように、エラーメッセージは恐れるものではない。エラーメッセージは嬉しいものだ。エラーメッセージが出たらありがとう。エラーメッセージがあるおかげでバグの存在がわかる。</p>
<p>このメッセージの本当の意味はいずれ例外やデバッガーを解説する章で説明するとして、vectorの要素数を超える指定をしてはいけないことを肝に銘じておこう。もちろん、-1もダメだ。</p>
<p>メンバー関数<code>at(i)</code>に与える引数<code>i</code>の型は整数型ではあるのだが<code>int</code>型ではない。<code>std::size_t</code>型という特殊な型になる。メンバー関数<code>size</code>も同様に<code>std::size_t</code>型を返す。</p>
<div class="sourceCode" id="cb381"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb381-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb381-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb381-3" data-line-number="3">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v ;</a>
<a class="sourceLine" id="cb381-4" data-line-number="4"></a>
<a class="sourceLine" id="cb381-5" data-line-number="5">    <span class="co">// std::size_t型</span></a>
<a class="sourceLine" id="cb381-6" data-line-number="6">    <span class="bu">std::</span>size_t size = v.size() ;</a>
<a class="sourceLine" id="cb381-7" data-line-number="7"></a>
<a class="sourceLine" id="cb381-8" data-line-number="8">    v.push_back(<span class="dv">0</span>) ;</a>
<a class="sourceLine" id="cb381-9" data-line-number="9"></a>
<a class="sourceLine" id="cb381-10" data-line-number="10">    <span class="co">// std::siz_t型</span></a>
<a class="sourceLine" id="cb381-11" data-line-number="11">    <span class="bu">std::</span>size_t index = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb381-12" data-line-number="12">    v.at( index ) ;</a>
<a class="sourceLine" id="cb381-13" data-line-number="13">}</a></code></pre></div>
<p>なぜ<code>int</code>型ではダメなのか。その謎は整数の章で明らかになる。ここでは<code>std::size_t</code>型は負数が使えない整数型だということだけ覚えておこう。<code>std::size_t</code>型に-1はない。vectorの要素指定では負数は使えないので、負数が使えない変数を使うのは理にかなっている。</p>
<p>さて、これまでに学んだ知識だけを使って、<code>std::vector</code>のすべての要素を順番通りに出力するコードが書けるはずだ。</p>
<div class="sourceCode" id="cb382"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb382-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb382-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb382-3" data-line-number="3"></a>
<a class="sourceLine" id="cb382-4" data-line-number="4">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v ;</a>
<a class="sourceLine" id="cb382-5" data-line-number="5"></a>
<a class="sourceLine" id="cb382-6" data-line-number="6">    <span class="cf">for</span> ( <span class="dt">int</span> iota = <span class="dv">0</span> ; iota != <span class="dv">10</span> ; ++iota )</a>
<a class="sourceLine" id="cb382-7" data-line-number="7">    {</a>
<a class="sourceLine" id="cb382-8" data-line-number="8">        v.push_back(iota) ;</a>
<a class="sourceLine" id="cb382-9" data-line-number="9">    }</a>
<a class="sourceLine" id="cb382-10" data-line-number="10"></a>
<a class="sourceLine" id="cb382-11" data-line-number="11">    <span class="cf">for</span> ( <span class="bu">std::</span>size_t index = <span class="dv">0</span> ; index != v.size() ; ++index )</a>
<a class="sourceLine" id="cb382-12" data-line-number="12">    {</a>
<a class="sourceLine" id="cb382-13" data-line-number="13">        <span class="bu">std::</span>cout &lt;&lt; v.at(index) &lt;&lt; <span class="st">&quot; &quot;</span>s ;</a>
<a class="sourceLine" id="cb382-14" data-line-number="14">    }</a>
<a class="sourceLine" id="cb382-15" data-line-number="15">}</a></code></pre></div>
<p>このコードが書けるということは、もう標準入力から0が入力されるまで任意個の値を受け取り、入力された順番で出力するプログラムも書けるということだ。</p>
<div class="sourceCode" id="cb383"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb383-1" data-line-number="1"><span class="dt">int</span> input()</a>
<a class="sourceLine" id="cb383-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb383-3" data-line-number="3">    <span class="dt">int</span> x{} ;</a>
<a class="sourceLine" id="cb383-4" data-line-number="4">    <span class="bu">std::</span>cin &gt;&gt; x ;</a>
<a class="sourceLine" id="cb383-5" data-line-number="5">    <span class="cf">return</span> x ;</a>
<a class="sourceLine" id="cb383-6" data-line-number="6">}</a>
<a class="sourceLine" id="cb383-7" data-line-number="7"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb383-8" data-line-number="8">{</a>
<a class="sourceLine" id="cb383-9" data-line-number="9">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v ;</a>
<a class="sourceLine" id="cb383-10" data-line-number="10">    <span class="dt">int</span> x { } ;</a>
<a class="sourceLine" id="cb383-11" data-line-number="11"></a>
<a class="sourceLine" id="cb383-12" data-line-number="12">    <span class="co">// 入力</span></a>
<a class="sourceLine" id="cb383-13" data-line-number="13">    <span class="cf">while</span> ( ( x = input() ) != <span class="dv">0</span> )</a>
<a class="sourceLine" id="cb383-14" data-line-number="14">    {</a>
<a class="sourceLine" id="cb383-15" data-line-number="15">        v.push_back( x ) ;</a>
<a class="sourceLine" id="cb383-16" data-line-number="16">    }</a>
<a class="sourceLine" id="cb383-17" data-line-number="17"></a>
<a class="sourceLine" id="cb383-18" data-line-number="18">    <span class="co">// 出力</span></a>
<a class="sourceLine" id="cb383-19" data-line-number="19">    <span class="cf">for</span> ( <span class="bu">std::</span>size_t index = <span class="dv">0</span> ; index != v.size() ; ++index )</a>
<a class="sourceLine" id="cb383-20" data-line-number="20">    {</a>
<a class="sourceLine" id="cb383-21" data-line-number="21">        <span class="bu">std::</span>cout &lt;&lt; v.at(index) &lt;&lt; <span class="st">&quot; &quot;</span>s ;</a>
<a class="sourceLine" id="cb383-22" data-line-number="22">    }</a>
<a class="sourceLine" id="cb383-23" data-line-number="23">}</a></code></pre></div>
<p>入力された順番に出力できるということは、その逆順にも出力できるということだ。</p>
<div class="sourceCode" id="cb384"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb384-1" data-line-number="1"><span class="cf">for</span> ( <span class="bu">std::</span>size_t index = v.size()<span class="dv">-1</span> ; index != <span class="dv">0</span> ; --index )</a>
<a class="sourceLine" id="cb384-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb384-3" data-line-number="3">    <span class="bu">std::</span>cout &lt;&lt; v.at(index) &lt;&lt; <span class="st">&quot; &quot;</span>s ;</a>
<a class="sourceLine" id="cb384-4" data-line-number="4">}</a>
<a class="sourceLine" id="cb384-5" data-line-number="5"></a>
<a class="sourceLine" id="cb384-6" data-line-number="6"><span class="bu">std::</span>cout &lt;&lt; v.at(<span class="dv">0</span>) ;</a></code></pre></div>
<p>最後に’v.at(0)’を出力しているのは、ループが’i == 0’のときに終了してしまうからだ。つまり最後に出力すべきvector最初の要素である’v.at(0)’が出力されない。</p>
<p><code>std::size_t</code>型は-1が使えないため、このようなコードになってしまう。<code>int</code>型を使えば負数は使えるのだが、<code>int</code>型と<code>std::size_t</code>型の比較は様々な理由で問題がある。その理由は整数の章で深く学ぶことになるだろう。</p>
<p>ところで、問題は入力された整数を小さい順に出力することだった。この問題を考えるために、まずvectorの中に入っている要素から最も小さい整数の場所を探すプログラムを考えよう。</p>
<p>問題を考えるに当たって、いちいち標準入力から入力を取るのも面倒なので、あらかじめvectorに要素をいれておく方法を学ぶ。実は、vectorの要素は以下のように書けば指定することができる。</p>
<div class="sourceCode" id="cb385"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb385-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb385-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb385-3" data-line-number="3">    <span class="co">// 要素{1, 2, 3}</span></a>
<a class="sourceLine" id="cb385-4" data-line-number="4">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = { <span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span> } ;</a>
<a class="sourceLine" id="cb385-5" data-line-number="5"></a>
<a class="sourceLine" id="cb385-6" data-line-number="6">    <span class="co">// 1</span></a>
<a class="sourceLine" id="cb385-7" data-line-number="7">    <span class="kw">auto</span> x = v.at(<span class="dv">0</span>) ;</a>
<a class="sourceLine" id="cb385-8" data-line-number="8">    <span class="co">// 2</span></a>
<a class="sourceLine" id="cb385-9" data-line-number="9">    <span class="kw">auto</span> y = v.at(<span class="dv">1</span>) ;</a>
<a class="sourceLine" id="cb385-10" data-line-number="10">    <span class="co">// 3</span></a>
<a class="sourceLine" id="cb385-11" data-line-number="11">    <span class="kw">auto</span> z = v.at(<span class="dv">2</span>) ;</a>
<a class="sourceLine" id="cb385-12" data-line-number="12">}</a></code></pre></div>
<p>この例では、1, 2, 3の整数が書かれた順番であらかじめvectorの要素として入った状態になる。</p>
<p>さて、以下のような要素のvectorから最も小さい整数を探すプログラムを考えよう。</p>
<div class="sourceCode" id="cb386"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb386-1" data-line-number="1"><span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = { <span class="dv">8</span>, <span class="dv">3</span>, <span class="dv">7</span>, <span class="dv">4</span>, <span class="dv">2</span>, <span class="dv">9</span>, <span class="dv">3</span> } ;</a></code></pre></div>
<p>これを見ると、最も小さい整数は4番目(最初の要素は0番目なので4番目)にある2だ。ではどうやって探すのだろうか。</p>
<p>解決方法としては先頭から末尾まで要素を一つづつ比較して、最も小さい要素を見つけ出す。まず0番目の8が最も小さいと仮定する。現在わかっている中で最も小さい要素のインデックスを記録するために変数minを作っておこう</p>
<pre><code>min = 0
8 3 7 4 2 9 3
^</code></pre>
<p>次に1番目の3とmin番目を比較する。1番目の方が小さいので変数minに1を代入する。</p>
<pre><code>min = 1
8 3 7 4 2 9 3
  ^</code></pre>
<p>2番目の7とmin番目を比較するとまだ1番目のほうが小さい。3番目の4と比較してもまだmin番目の方が小さい。</p>
<p>4番目の2とmin番目を比較すると、4番目の方が小さい。変数minに4を代入しよう。</p>
<pre><code>min = 4
8 3 7 4 2 9 3
        ^</code></pre>
<p>5番目と6番目もmin番目より大きいので、これで変数minに代入された4番目の要素が最も小さいことがわかる。</p>
<p>vectorの変数をv、要素数をsizeとする。変数minには現在わかっている中で最も小さい要素へのインデックスが代入される。</p>
<ol type="1">
<li>変数minに0を代入する。</li>
<li>size回のループを実行する</li>
<li>変数indexに0からsize-1までの整数を代入する</li>
<li>’v.at(index) &lt; v.at(min)’ならばmin = index</li>
</ol>
<p>さっそく書いてみよう。</p>
<div class="sourceCode" id="cb390"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb390-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb390-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb390-3" data-line-number="3">    <span class="co">// vecotrの変数をv</span></a>
<a class="sourceLine" id="cb390-4" data-line-number="4">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = { <span class="dv">8</span>, <span class="dv">3</span>, <span class="dv">7</span>, <span class="dv">4</span>, <span class="dv">2</span>, <span class="dv">9</span>, <span class="dv">3</span> } ;</a>
<a class="sourceLine" id="cb390-5" data-line-number="5">    <span class="co">// 要素数をsizeとする</span></a>
<a class="sourceLine" id="cb390-6" data-line-number="6">    <span class="bu">std::</span>size_t size = v.size() ;</a>
<a class="sourceLine" id="cb390-7" data-line-number="7"></a>
<a class="sourceLine" id="cb390-8" data-line-number="8">    <span class="co">// 変数minに0を代入する</span></a>
<a class="sourceLine" id="cb390-9" data-line-number="9">    <span class="bu">std::</span>size_t min = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb390-10" data-line-number="10"></a>
<a class="sourceLine" id="cb390-11" data-line-number="11">    <span class="co">// size回のループを実行する</span></a>
<a class="sourceLine" id="cb390-12" data-line-number="12">    <span class="co">// 変数iに0からsize-1までの整数を代入する</span></a>
<a class="sourceLine" id="cb390-13" data-line-number="13">    <span class="cf">for</span> ( <span class="bu">std::</span>size_t index = <span class="dv">1</span> ; index != size ; ++index )</a>
<a class="sourceLine" id="cb390-14" data-line-number="14">    {</a>
<a class="sourceLine" id="cb390-15" data-line-number="15">        <span class="co">// &#39;v.at(index) &lt; v.at(min)&#39;ならばmin = index</span></a>
<a class="sourceLine" id="cb390-16" data-line-number="16">        <span class="cf">if</span> ( v.at(index) &lt; v.at(min) )</a>
<a class="sourceLine" id="cb390-17" data-line-number="17">            min = index ;</a>
<a class="sourceLine" id="cb390-18" data-line-number="18">    }</a>
<a class="sourceLine" id="cb390-19" data-line-number="19"></a>
<a class="sourceLine" id="cb390-20" data-line-number="20">    <span class="co">// 一番小さい値を出力</span></a>
<a class="sourceLine" id="cb390-21" data-line-number="21">    <span class="bu">std::</span>cout &lt;&lt; v.at(min) ;</a>
<a class="sourceLine" id="cb390-22" data-line-number="22">}</a></code></pre></div>
<p>うまくいった。</p>
<p>ところで、最終的に解きたい問題とは、vectorのすべての要素を小さい順に出力するということだ。すると、もっと小さい要素を出力した次に、2番目に小さい要素、3番目に小さい要素・・・と出力していく必要がある。</p>
<p>2番目に小さい要素を見つけるためには、1番目に小さい要素を探さなければよい。そこで、発見した最も小さい要素と先頭の要素を交換してしまい、先頭は無視して最も小さい要素を探すことを繰り返すと実現できる。</p>
<p>例えば以下のような要素があるとして、</p>
<pre><code>8 3 7 4 2 9 3
        ^</code></pre>
<p>最も小さい要素である4番目の2と0番目の8を交換する。</p>
<pre><code>2 3 7 4 8 9 3
^       ^
+-------+</code></pre>
<p>そして、0番目は無視して最も小さい要素を探す。</p>
<pre><code>3 7 4 8 9 3
^</code></pre>
<p>この場合、最も小さいのは0番目と5番目の3だ。どちらも同じだが今回は0番目を選ぶ。もともと0番目にあるので0番目と0番目を交換した結果は変わらない。</p>
<p>そして、新しい0番目は無視して最も小さい要素を探す。</p>
<pre><code>7 4 8 9 3
        ^</code></pre>
<p>こんどは4番目の3だ。これも先頭と交換する</p>
<pre><code>3 4 8 9 7
^       ^
+-------+</code></pre>
<p>これを繰り返していけば、小さい順に要素を探していくことができる。</p>
<p>この処理を行うコードを考えるために、先ほどと似たようなコードを見てみよう。</p>
<div class="sourceCode" id="cb396"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb396-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb396-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb396-3" data-line-number="3">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = { <span class="dv">8</span>, <span class="dv">3</span>, <span class="dv">7</span>, <span class="dv">4</span>, <span class="dv">2</span>, <span class="dv">9</span>, <span class="dv">3</span> } ;</a>
<a class="sourceLine" id="cb396-4" data-line-number="4">    <span class="bu">std::</span>size_t size = v.size() ;</a>
<a class="sourceLine" id="cb396-5" data-line-number="5"></a>
<a class="sourceLine" id="cb396-6" data-line-number="6">    <span class="co">// この部分を繰り返す？ </span></a>
<a class="sourceLine" id="cb396-7" data-line-number="7">    { <span class="co">// これ全体がひとつのブロック文</span></a>
<a class="sourceLine" id="cb396-8" data-line-number="8">        <span class="bu">std::</span>size_t min = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb396-9" data-line-number="9"></a>
<a class="sourceLine" id="cb396-10" data-line-number="10">        <span class="cf">for</span> ( <span class="bu">std::</span>size_t index = <span class="dv">1</span> ; index != size ; ++index )</a>
<a class="sourceLine" id="cb396-11" data-line-number="11">        {</a>
<a class="sourceLine" id="cb396-12" data-line-number="12">            <span class="cf">if</span> ( v.at(index) &lt; v.at(min) )</a>
<a class="sourceLine" id="cb396-13" data-line-number="13">                min = index ;</a>
<a class="sourceLine" id="cb396-14" data-line-number="14">        }</a>
<a class="sourceLine" id="cb396-15" data-line-number="15"></a>
<a class="sourceLine" id="cb396-16" data-line-number="16">        <span class="co">// 出力</span></a>
<a class="sourceLine" id="cb396-17" data-line-number="17">        <span class="bu">std::</span>cout &lt;&lt; v.at(min) &lt;&lt; <span class="st">&quot; &quot;</span>s ;</a>
<a class="sourceLine" id="cb396-18" data-line-number="18"></a>
<a class="sourceLine" id="cb396-19" data-line-number="19">        <span class="co">// 先頭と交換</span></a>
<a class="sourceLine" id="cb396-20" data-line-number="20">    }</a>
<a class="sourceLine" id="cb396-21" data-line-number="21">}</a></code></pre></div>
<p>このコードはそのまま使えない。今回考えた方法では、先頭が一つづつずれていく。そのために、最も小さい要素を探すループを、更にループさせる。</p>
<div class="sourceCode" id="cb397"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb397-1" data-line-number="1"><span class="co">// 現在の先頭</span></a>
<a class="sourceLine" id="cb397-2" data-line-number="2"><span class="cf">for</span> ( <span class="bu">std::</span>size_t head = <span class="dv">0</span> ; head != size ; ++head )</a>
<a class="sourceLine" id="cb397-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb397-4" data-line-number="4">    <span class="co">// 現在の先頭であるmin番目を仮の最小の要素とみなすのでhead</span></a>
<a class="sourceLine" id="cb397-5" data-line-number="5">    <span class="bu">std::</span>size_t min = head ;    </a>
<a class="sourceLine" id="cb397-6" data-line-number="6">    <span class="co">// 現在の先頭の次の要素から探すのでhead + 1</span></a>
<a class="sourceLine" id="cb397-7" data-line-number="7">    <span class="cf">for</span> ( <span class="bu">std::</span>size_t index = head + <span class="dv">1</span> ; index != size ; ++index )</a>
<a class="sourceLine" id="cb397-8" data-line-number="8">    {</a>
<a class="sourceLine" id="cb397-9" data-line-number="9">        <span class="cf">if</span> ( v.at(index) &lt; v.at(min)</a>
<a class="sourceLine" id="cb397-10" data-line-number="10">            min = index ;</a>
<a class="sourceLine" id="cb397-11" data-line-number="11">    }</a>
<a class="sourceLine" id="cb397-12" data-line-number="12"></a>
<a class="sourceLine" id="cb397-13" data-line-number="13">    <span class="bu">std::</span>cout &lt;&lt; v.at(min) &lt;&lt; <span class="st">&quot; &quot;</span>s ;</a>
<a class="sourceLine" id="cb397-14" data-line-number="14"></a>
<a class="sourceLine" id="cb397-15" data-line-number="15">    <span class="co">// 先頭と交換</span></a>
<a class="sourceLine" id="cb397-16" data-line-number="16">}</a></code></pre></div>
<p>次に先頭(0番目)と現在見つけた最小の要素(min番目)を交換する方法を考えよう。</p>
<p>vectorのn番目の要素の値をxに変更するには、単に<code>v.at(n) = x</code>と書けばよい。</p>
<div class="sourceCode" id="cb398"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb398-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb398-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb398-3" data-line-number="3">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>} ;</a>
<a class="sourceLine" id="cb398-4" data-line-number="4"></a>
<a class="sourceLine" id="cb398-5" data-line-number="5">    v.at(<span class="dv">0</span>) = <span class="dv">4</span> ;</a>
<a class="sourceLine" id="cb398-6" data-line-number="6">    <span class="co">// vは{4,2,3}</span></a>
<a class="sourceLine" id="cb398-7" data-line-number="7">}</a></code></pre></div>
<p>すると、vectorのi番目の要素にj番目の要素値を入れるには’v.at(i) = v.at(j)’と書く。</p>
<div class="sourceCode" id="cb399"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb399-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb399-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb399-3" data-line-number="3">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>} ;</a>
<a class="sourceLine" id="cb399-4" data-line-number="4">    v.at(<span class="dv">0</span>) = v.at(<span class="dv">2</span>) ;</a>
<a class="sourceLine" id="cb399-5" data-line-number="5">    <span class="co">// vは{3,2,3}</span></a>
<a class="sourceLine" id="cb399-6" data-line-number="6">}</a></code></pre></div>
<p>変数と全く同じだ。</p>
<p>しかし、変数aに変数bの値を代入すると、変数aの元の値は消えてしまう。</p>
<div class="sourceCode" id="cb400"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb400-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb400-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb400-3" data-line-number="3">    <span class="dt">int</span> a = <span class="dv">1</span> ;</a>
<a class="sourceLine" id="cb400-4" data-line-number="4">    <span class="dt">int</span> b = <span class="dv">2</span> ;</a>
<a class="sourceLine" id="cb400-5" data-line-number="5"></a>
<a class="sourceLine" id="cb400-6" data-line-number="6">    <span class="co">// aの元の値は上書きされる</span></a>
<a class="sourceLine" id="cb400-7" data-line-number="7">    a = b ;</a>
<a class="sourceLine" id="cb400-8" data-line-number="8">    <span class="co">// a == 2</span></a>
<a class="sourceLine" id="cb400-9" data-line-number="9">    b = a ;</a>
<a class="sourceLine" id="cb400-10" data-line-number="10">    <span class="co">// b == 2</span></a>
<a class="sourceLine" id="cb400-11" data-line-number="11">}</a></code></pre></div>
<p>変数a, bの値を交換するためには、変数への代入の前に、別の変数に値を一時退避しておく必要がある。</p>
<div class="sourceCode" id="cb401"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb401-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb401-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb401-3" data-line-number="3">    <span class="dt">int</span> a = <span class="dv">1</span> ;</a>
<a class="sourceLine" id="cb401-4" data-line-number="4">    <span class="dt">int</span> b = <span class="dv">2</span> ;</a>
<a class="sourceLine" id="cb401-5" data-line-number="5"></a>
<a class="sourceLine" id="cb401-6" data-line-number="6">    <span class="co">// 退避</span></a>
<a class="sourceLine" id="cb401-7" data-line-number="7">    <span class="kw">auto</span> temp = a ;</a>
<a class="sourceLine" id="cb401-8" data-line-number="8"></a>
<a class="sourceLine" id="cb401-9" data-line-number="9">    a = b ;</a>
<a class="sourceLine" id="cb401-10" data-line-number="10">    b = temp ;</a>
<a class="sourceLine" id="cb401-11" data-line-number="11"></a>
<a class="sourceLine" id="cb401-12" data-line-number="12">    <span class="co">// a == 2</span></a>
<a class="sourceLine" id="cb401-13" data-line-number="13">    <span class="co">// b == 1</span></a>
<a class="sourceLine" id="cb401-14" data-line-number="14">}</a></code></pre></div>
<p>さて、これで問題を解く準備は全て整った。</p>
<div class="sourceCode" id="cb402"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb402-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb402-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb402-3" data-line-number="3">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = { <span class="dv">8</span>, <span class="dv">3</span>, <span class="dv">7</span>, <span class="dv">4</span>, <span class="dv">2</span>, <span class="dv">9</span>, <span class="dv">3</span> } ;</a>
<a class="sourceLine" id="cb402-4" data-line-number="4">    <span class="bu">std::</span>size_t size = v.size() ;</a>
<a class="sourceLine" id="cb402-5" data-line-number="5">   </a>
<a class="sourceLine" id="cb402-6" data-line-number="6">    <span class="co">// 先頭をずらすループ </span></a>
<a class="sourceLine" id="cb402-7" data-line-number="7">    <span class="cf">for</span> ( <span class="bu">std::</span>size_t head = <span class="dv">0</span> ; head != size ; ++head )</a>
<a class="sourceLine" id="cb402-8" data-line-number="8">    {</a>
<a class="sourceLine" id="cb402-9" data-line-number="9">        <span class="bu">std::</span>size_t min = head ;</a>
<a class="sourceLine" id="cb402-10" data-line-number="10">        <span class="co">// 現在の要素の範囲から最小値を見つけるループ</span></a>
<a class="sourceLine" id="cb402-11" data-line-number="11">        <span class="cf">for</span> ( <span class="bu">std::</span>size_t index = head<span class="dv">+1</span> ; index != size ; ++index )</a>
<a class="sourceLine" id="cb402-12" data-line-number="12">        {</a>
<a class="sourceLine" id="cb402-13" data-line-number="13">            <span class="cf">if</span> ( v.at(index) &lt; v.at(min) )</a>
<a class="sourceLine" id="cb402-14" data-line-number="14">                min = index ;</a>
<a class="sourceLine" id="cb402-15" data-line-number="15">        }</a>
<a class="sourceLine" id="cb402-16" data-line-number="16">        <span class="co">// 出力</span></a>
<a class="sourceLine" id="cb402-17" data-line-number="17">        <span class="bu">std::</span>cout &lt;&lt; v.at(min) &lt;&lt; <span class="st">&quot; &quot;</span>s ;</a>
<a class="sourceLine" id="cb402-18" data-line-number="18"></a>
<a class="sourceLine" id="cb402-19" data-line-number="19">        <span class="co">// 最小値を先頭と交換</span></a>
<a class="sourceLine" id="cb402-20" data-line-number="20">        <span class="kw">auto</span> temp = v.at(head) ;</a>
<a class="sourceLine" id="cb402-21" data-line-number="21">        v.at(head) = v.at(min) ;</a>
<a class="sourceLine" id="cb402-22" data-line-number="22">        v.at(min) = temp ;</a>
<a class="sourceLine" id="cb402-23" data-line-number="23">    }</a>
<a class="sourceLine" id="cb402-24" data-line-number="24"></a>
<a class="sourceLine" id="cb402-25" data-line-number="25">    <span class="co">// 実行した後</span></a>
<a class="sourceLine" id="cb402-26" data-line-number="26">}</a></code></pre></div>
<p>ところで、このプログラムの「実行した後」地点でのvectorの中身はどうなっているだろうか。</p>
<div class="sourceCode" id="cb403"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb403-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb403-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb403-3" data-line-number="3">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = { <span class="dv">8</span>,<span class="dv">3</span>,<span class="dv">7</span>,<span class="dv">4</span>,<span class="dv">2</span>,<span class="dv">9</span>,<span class="dv">3</span> } ;</a>
<a class="sourceLine" id="cb403-4" data-line-number="4"></a>
<a class="sourceLine" id="cb403-5" data-line-number="5">    <span class="co">// 上と同じコードなので省略</span></a>
<a class="sourceLine" id="cb403-6" data-line-number="6"></a>
<a class="sourceLine" id="cb403-7" data-line-number="7">    <span class="co">// 実行した後</span></a>
<a class="sourceLine" id="cb403-8" data-line-number="8">    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb403-9" data-line-number="9">    </a>
<a class="sourceLine" id="cb403-10" data-line-number="10">    <span class="cf">for</span> ( <span class="bu">std::</span>size_t index = <span class="dv">0</span>, size = v.size() ; index != size ; ++index )</a>
<a class="sourceLine" id="cb403-11" data-line-number="11">    {</a>
<a class="sourceLine" id="cb403-12" data-line-number="12">        <span class="bu">std::</span>cout &lt;&lt; v.at(index) &lt;&lt; <span class="st">&quot; &quot;</span>s ;</a>
<a class="sourceLine" id="cb403-13" data-line-number="13">    }</a>
<a class="sourceLine" id="cb403-14" data-line-number="14">}</a></code></pre></div>
<p>これを実行すると以下のようになる。</p>
<pre><code>$ make run
2 3 3 4 7 8 9
2 3 3 4 7 8 9</code></pre>
<p>なんとvectorの要素も小さい順に並んでいる。この状態のことを、ソートされているという。ループの中で最も小さい値を出力していく代わりに、まずソートして先頭から値を出力してもよいということだ。</p>
<p>ソートには様々な方法があるが、今回使ったのは選択ソート(selection sort)というアルゴリズムだ。</p>
<p>vectorを使う方法には、イテレーターというもっと便利な方法があるが、それはイテレーターの章で説明する。</p>
<h1 id="デバッグprintfデバッグ">デバッグ：printfデバッグ</h1>
<p>ループと多数の要素の集合を扱えるようになったので、読者はもう相当複雑な処理をするプログラムでも書けるようになった。処理が複雑になってくると増えるのがバグだ。</p>
<p>この章では、伝統ある<code>printfデバッグ</code>を紹介する。</p>
<p><code>printfデバッグ</code>とは、プログラムの実行中に知りたい情報を出力することだ。<code>printf</code>とはC言語の伝統ある出力用のライブラリに由来する名前だが、本書ではiostreamを使う。</p>
<h2 id="実践例">実践例</h2>
<p>例えば前章で実装したようにvectorの要素を選択ソートでソートしたいとする。</p>
<p>選択ソートとは、要素の集合の中から0番目に来るべき要素の場所を探し、0番目の要素と交換し、1番目に来るべき要素の場所を探し、1番目の要素と交換し・・・を要素の数だけ繰り返すことによって要素全体をソートする方法だ。</p>
<p>以下のように書いたとする。</p>
<div class="sourceCode" id="cb405"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb405-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb405-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb405-3" data-line-number="3">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = { <span class="dv">3</span>,<span class="dv">8</span>,<span class="dv">2</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">9</span>,<span class="dv">4</span>,<span class="dv">1</span>,<span class="dv">7</span> } ;</a>
<a class="sourceLine" id="cb405-4" data-line-number="4">    <span class="kw">auto</span> size = v.size() ;</a>
<a class="sourceLine" id="cb405-5" data-line-number="5"></a>
<a class="sourceLine" id="cb405-6" data-line-number="6">    <span class="cf">for</span> ( <span class="bu">std::</span>size_t head = <span class="dv">0</span> ; head != size ; ++head )</a>
<a class="sourceLine" id="cb405-7" data-line-number="7">    {</a>
<a class="sourceLine" id="cb405-8" data-line-number="8">        <span class="kw">auto</span> min = head ;</a>
<a class="sourceLine" id="cb405-9" data-line-number="9">        <span class="cf">for</span> ( <span class="bu">std::</span>size_t index = head<span class="dv">+1</span> ; index != size ; ++index )</a>
<a class="sourceLine" id="cb405-10" data-line-number="10">        {</a>
<a class="sourceLine" id="cb405-11" data-line-number="11">            <span class="cf">if</span> ( v.at(index) &lt; v.at(min) )</a>
<a class="sourceLine" id="cb405-12" data-line-number="12">                min = index ;</a>
<a class="sourceLine" id="cb405-13" data-line-number="13">        }</a>
<a class="sourceLine" id="cb405-14" data-line-number="14">        </a>
<a class="sourceLine" id="cb405-15" data-line-number="15">        <span class="kw">auto</span> temp = v.at(head) ;</a>
<a class="sourceLine" id="cb405-16" data-line-number="16">        v.at(head) = v.at(min) ;</a>
<a class="sourceLine" id="cb405-17" data-line-number="17">        v.at(min) = v.at(head) ;</a>
<a class="sourceLine" id="cb405-18" data-line-number="18">    }</a>
<a class="sourceLine" id="cb405-19" data-line-number="19"></a>
<a class="sourceLine" id="cb405-20" data-line-number="20">    <span class="cf">for</span> ( <span class="bu">std::</span>size_t i = <span class="dv">0</span> ; i != size ; ++i )</a>
<a class="sourceLine" id="cb405-21" data-line-number="21">    {</a>
<a class="sourceLine" id="cb405-22" data-line-number="22">        <span class="bu">std::</span>cout &lt;&lt; v.at(i) &lt;&lt; <span class="st">&quot; &quot;</span>s ;</a>
<a class="sourceLine" id="cb405-23" data-line-number="23">    }</a>
<a class="sourceLine" id="cb405-24" data-line-number="24">}</a></code></pre></div>
<p>早速実行してみよう。</p>
<pre><code>$ make run
1 1 1 1 1 1 1 1 7</code></pre>
<p>コンパイルはできるが、なぜかうまく動かない。コードのどこかが間違っているのはわかる。しかしどこが間違っているのかはわからない。さっそく<code>printfデバッグ</code>により問題のある箇所を特定してみよう。</p>
<p><code>printfデバッグ</code>を行うには、まずコード中の間違っていそうな箇所にアタリをつける必要がある。</p>
<p>問題がどこにあるかわからないが、ループのどこかで間違っていそうだ。一番外側のループにアタリをつけよう。ループが実行されるごとに変数vの中身を表示してみる。</p>
<div class="sourceCode" id="cb407"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb407-1" data-line-number="1"><span class="cf">for</span> ( <span class="bu">std::</span>size_t head = <span class="dv">0</span> ; head != size ; ++head )</a>
<a class="sourceLine" id="cb407-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb407-3" data-line-number="3">    <span class="co">// printfデバッグ</span></a>
<a class="sourceLine" id="cb407-4" data-line-number="4">        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;debug: head = &quot;</span>s &lt;&lt; head &lt;&lt; <span class="st">&quot;, v = { &quot;</span>s;</a>
<a class="sourceLine" id="cb407-5" data-line-number="5">        <span class="cf">for</span> ( <span class="bu">std::</span>size_t i = <span class="dv">0</span> ; i != v.size() ; ++i )</a>
<a class="sourceLine" id="cb407-6" data-line-number="6">        {</a>
<a class="sourceLine" id="cb407-7" data-line-number="7">            <span class="bu">std::</span>cout &lt;&lt; v.at(i) &lt;&lt; <span class="st">&quot; &quot;</span>s ;</a>
<a class="sourceLine" id="cb407-8" data-line-number="8">        }</a>
<a class="sourceLine" id="cb407-9" data-line-number="9">        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;}</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb407-10" data-line-number="10">    <span class="co">// printfデバッグ</span></a></code></pre></div>
<p>そして実行した結果が以下だ。</p>
<pre><code>$ make run
debug: v = { 3, 8, 2, 5, 6, 9, 4, 1, 7, }
debug: v = { 1, 8, 2, 5, 6, 9, 4, 1, 7, }
debug: v = { 1, 1, 2, 5, 6, 9, 4, 1, 7, }
debug: v = { 1, 1, 1, 5, 6, 9, 4, 1, 7, }
debug: v = { 1, 1, 1, 1, 6, 9, 4, 1, 7, }
debug: v = { 1, 1, 1, 1, 1, 9, 4, 1, 7, }
debug: v = { 1, 1, 1, 1, 1, 1, 4, 1, 7, }
debug: v = { 1, 1, 1, 1, 1, 1, 1, 1, 7, }
debug: v = { 1, 1, 1, 1, 1, 1, 1, 1, 7, }
1 1 1 1 1 1 1 1 7 </code></pre>
<p>何故か1が増えている。明らかにおかしい。しかしまだ問題の特定にまでは至らない。</p>
<p>内側のループにも<code>printfデバッグ</code>を追加してみよう。</p>
<div class="sourceCode" id="cb409"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb409-1" data-line-number="1"><span class="kw">auto</span> min = head ;</a>
<a class="sourceLine" id="cb409-2" data-line-number="2"><span class="cf">for</span> ( <span class="bu">std::</span>size_t index = head<span class="dv">+1</span> ; index != size ; ++index )</a>
<a class="sourceLine" id="cb409-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb409-4" data-line-number="4">    <span class="co">// printfデバッグ</span></a>
<a class="sourceLine" id="cb409-5" data-line-number="5">        <span class="bu">std::</span>cout &lt;&lt; v.at(index) &lt;&lt; <span class="st">&quot;, &quot;</span>s ;</a>
<a class="sourceLine" id="cb409-6" data-line-number="6">    <span class="co">// printfデバッグ</span></a>
<a class="sourceLine" id="cb409-7" data-line-number="7"></a>
<a class="sourceLine" id="cb409-8" data-line-number="8">    <span class="cf">if</span> ( v.at(index) &lt; v.at(min) )</a>
<a class="sourceLine" id="cb409-9" data-line-number="9">        min = index ;</a>
<a class="sourceLine" id="cb409-10" data-line-number="10">}</a>
<a class="sourceLine" id="cb409-11" data-line-number="11"><span class="co">// printfデバッグ</span></a>
<a class="sourceLine" id="cb409-12" data-line-number="12">    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb409-13" data-line-number="13"><span class="co">// printfデバッグ</span></a></code></pre></div>
<p>そして実行する。</p>
<pre><code>debug: v = { 3, 8, 2, 5, 6, 9, 4, 1, 7, }
8, 2, 5, 6, 9, 4, 1, 7, 
debug: v = { 1, 8, 2, 5, 6, 9, 4, 1, 7, }
2, 5, 6, 9, 4, 1, 7, 
debug: v = { 1, 1, 2, 5, 6, 9, 4, 1, 7, }
5, 6, 9, 4, 1, 7, 
debug: v = { 1, 1, 1, 5, 6, 9, 4, 1, 7, }
6, 9, 4, 1, 7, 
debug: v = { 1, 1, 1, 1, 6, 9, 4, 1, 7, }
9, 4, 1, 7, 
debug: v = { 1, 1, 1, 1, 1, 9, 4, 1, 7, }
4, 1, 7, 
debug: v = { 1, 1, 1, 1, 1, 1, 4, 1, 7, }
1, 7, 
debug: v = { 1, 1, 1, 1, 1, 1, 1, 1, 7, }
7, 
debug: v = { 1, 1, 1, 1, 1, 1, 1, 1, 7, }

1 1 1 1 1 1 1 1 7 </code></pre>
<p>あまりいい情報は得られないようだ。問題はここではないらしい。</p>
<p>ひょっとしたら大小比較が間違っているのかもしれない。確かめてみよう。</p>
<div class="sourceCode" id="cb411"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb411-1" data-line-number="1"><span class="cf">for</span> ( <span class="bu">std::</span>size_t index = head<span class="dv">+1</span> ; index != size ; ++index )</a>
<a class="sourceLine" id="cb411-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb411-3" data-line-number="3"></a>
<a class="sourceLine" id="cb411-4" data-line-number="4">    <span class="cf">if</span> ( v.at(index) &lt; v.at(min) )</a>
<a class="sourceLine" id="cb411-5" data-line-number="5">    {</a>
<a class="sourceLine" id="cb411-6" data-line-number="6">        <span class="bu">std::</span>cout &lt;&lt; v.at(index) &lt;&lt; <span class="st">&quot; &lt; &quot;</span>s &lt;&lt; v.at(min) &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb411-7" data-line-number="7">        min = index ;</a>
<a class="sourceLine" id="cb411-8" data-line-number="8">    }</a>
<a class="sourceLine" id="cb411-9" data-line-number="9">    <span class="cf">else</span></a>
<a class="sourceLine" id="cb411-10" data-line-number="10">    {</a>
<a class="sourceLine" id="cb411-11" data-line-number="11">        <span class="bu">std::</span>cout &lt;&lt; v.at(index) &lt;&lt; <span class="st">&quot; &gt;= &quot;</span>s &lt;&lt; v.at(min) &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb411-12" data-line-number="12">    }</a>
<a class="sourceLine" id="cb411-13" data-line-number="13">}</a></code></pre></div>
<p>実行結果は長いので一部だけ記載しておく。</p>
<pre><code>debug: v = { 3, 8, 2, 5, 6, 9, 4, 1, 7, }
8 &gt;= 3
2 &lt; 3
5 &gt;= 2
6 &gt;= 2
9 &gt;= 2
4 &gt;= 2
1 &lt; 2
7 &gt;= 1

debug: v = { 1, 8, 2, 5, 6, 9, 4, 1, 7, }
2 &lt; 8
5 &gt;= 2
6 &gt;= 2
9 &gt;= 2
4 &gt;= 2
1 &lt; 2
7 &gt;= 1</code></pre>
<p>大小比較も問題ないようだ。では最終的に見つけた最も小さい値は、本当に最も小さい値だろうか。</p>
<div class="sourceCode" id="cb413"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb413-1" data-line-number="1"><span class="co">// 最小値を探すループ</span></a>
<a class="sourceLine" id="cb413-2" data-line-number="2"><span class="cf">for</span> ( <span class="bu">std::</span>size_t index = head<span class="dv">+1</span> ; index != size ; ++index )</a>
<a class="sourceLine" id="cb413-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb413-4" data-line-number="4">    <span class="co">// より小さい値があればそれを現在の最小値とする</span></a>
<a class="sourceLine" id="cb413-5" data-line-number="5">    <span class="cf">if</span> ( v.at(index) &lt; v.at(min) )</a>
<a class="sourceLine" id="cb413-6" data-line-number="6">        min = index ;</a>
<a class="sourceLine" id="cb413-7" data-line-number="7">}</a>
<a class="sourceLine" id="cb413-8" data-line-number="8"></a>
<a class="sourceLine" id="cb413-9" data-line-number="9"><span class="co">// printfデバッグ</span></a>
<a class="sourceLine" id="cb413-10" data-line-number="10">    <span class="bu">std::</span>cout &lt;&lt; v.at(min) &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb413-11" data-line-number="11"><span class="co">// printfデバッグ </span></a></code></pre></div>
<pre><code>debug: v = { 3, 8, 2, 5, 6, 9, 4, 1, 7, }
1
debug: v = { 1, 8, 2, 5, 6, 9, 4, 1, 7, }
1
debug: v = { 1, 1, 2, 5, 6, 9, 4, 1, 7, }
1
debug: v = { 1, 1, 1, 5, 6, 9, 4, 1, 7, }
1
debug: v = { 1, 1, 1, 1, 6, 9, 4, 1, 7, }
1
debug: v = { 1, 1, 1, 1, 1, 9, 4, 1, 7, }
1
debug: v = { 1, 1, 1, 1, 1, 1, 4, 1, 7, }
1
debug: v = { 1, 1, 1, 1, 1, 1, 1, 1, 7, }
1
debug: v = { 1, 1, 1, 1, 1, 1, 1, 1, 7, }
7
1 1 1 1 1 1 1 1 7 </code></pre>
<p>見つけた値は最も小さいようだ。しかし毎回1になる。1が残っているのだから当然だが、なぜ残っているのだろう。</p>
<p>ひょっとしたら要素の交換が間違っているのかもしれない。<code>printfデバッグ</code>してみよう。</p>
<div class="sourceCode" id="cb415"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb415-1" data-line-number="1"><span class="co">// printfデバッグ </span></a>
<a class="sourceLine" id="cb415-2" data-line-number="2">    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;debug before: &quot;</span>s &lt;&lt;  v.at(head) &lt;&lt; <span class="st">&quot;,  &quot;</span> &lt;&lt; v.at(min) &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb415-3" data-line-number="3"><span class="co">// printfデバッグ</span></a>
<a class="sourceLine" id="cb415-4" data-line-number="4"></a>
<a class="sourceLine" id="cb415-5" data-line-number="5">v.at(head) = v.at(min) ;</a>
<a class="sourceLine" id="cb415-6" data-line-number="6">v.at(min) = v.at(head) ;</a>
<a class="sourceLine" id="cb415-7" data-line-number="7"></a>
<a class="sourceLine" id="cb415-8" data-line-number="8"><span class="co">// printfデバッグ</span></a>
<a class="sourceLine" id="cb415-9" data-line-number="9">    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;debug after : &quot;</span>s &lt;&lt; v.at(head) &lt;&lt; <span class="st">&quot;, &quot;</span> &lt;&lt; v.at(min) &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb415-10" data-line-number="10"><span class="co">// printfデバッグ</span></a></code></pre></div>
<p>“debug before:”は交換前、“debug after:”は交換後の2つの要素の値だ。</p>
<p>以下は実行結果の一部だ。</p>
<pre><code>debug: v = { 3, 8, 2, 5, 6, 9, 4, 1, 7, }
debug before: 3,  1
debug after : 1, 1
debug: v = { 1, 8, 2, 5, 6, 9, 4, 1, 7, }
debug before: 8,  1
debug after : 1, 1
debug: v = { 1, 1, 2, 5, 6, 9, 4, 1, 7, }
debug before: 2,  1
debug after : 1, 1
debug: v = { 1, 1, 1, 5, 6, 9, 4, 1, 7, }</code></pre>
<p>これをみると、要素の値の交換が正しく行われていないことがわかる。</p>
<p>問題の場所がわかったので、早速コードを見てみよう。</p>
<div class="sourceCode" id="cb417"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb417-1" data-line-number="1">v.at(head) = v.at(min) ;</a>
<a class="sourceLine" id="cb417-2" data-line-number="2">v.at(min) = v.at(head) ;</a></code></pre></div>
<p>これは要するに以下のコードと同じだ。</p>
<div class="sourceCode" id="cb418"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb418-1" data-line-number="1"><span class="dt">int</span> a = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb418-2" data-line-number="2"><span class="dt">int</span> b = <span class="dv">1</span> ;</a>
<a class="sourceLine" id="cb418-3" data-line-number="3"></a>
<a class="sourceLine" id="cb418-4" data-line-number="4">a = b ; <span class="co">// a = 1</span></a>
<a class="sourceLine" id="cb418-5" data-line-number="5">b = a ; <span class="co">// b = 1</span></a></code></pre></div>
<p>変数a, bの値を交換したい場合、変数aに変数bを代入した後に、変数bに変数aを代入する処理は誤りだ。なぜならば、変数bの代入のときには、変数aの値は変数bの値になってしまっているからだ。</p>
<p>前章で学んだように、こういう場合、別の変数に値を代入して退避させておく。</p>
<div class="sourceCode" id="cb419"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb419-1" data-line-number="1"><span class="dt">int</span> a = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb419-2" data-line-number="2"><span class="dt">int</span> b = <span class="dv">1</span> ;</a>
<a class="sourceLine" id="cb419-3" data-line-number="3"></a>
<a class="sourceLine" id="cb419-4" data-line-number="4"><span class="dt">int</span> temp = a ;</a>
<a class="sourceLine" id="cb419-5" data-line-number="5">a = b ;</a>
<a class="sourceLine" id="cb419-6" data-line-number="6">b = temp ;</a></code></pre></div>
<p>こうして<code>printfデバッグ</code>によって問題が解決した。</p>
<h2 id="stdcerr"><code>std::cerr</code></h2>
<p><code>printfデバッグ</code>として標準出力である<code>std::cout</code>に出力すると、プログラムの通常の標準出力と混ざって見づらくなる。例えば以下のプログラムを見てみよう。</p>
<div class="sourceCode" id="cb420"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb420-1" data-line-number="1"><span class="co">// 1 * 2 * 3 * ... * nを計算するプログラム</span></a>
<a class="sourceLine" id="cb420-2" data-line-number="2"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb420-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb420-4" data-line-number="4">    <span class="dt">int</span> n{} ;</a>
<a class="sourceLine" id="cb420-5" data-line-number="5">    <span class="bu">std::</span>cin &gt;&gt; n ;</a>
<a class="sourceLine" id="cb420-6" data-line-number="6">    <span class="cf">if</span> ( n &lt; <span class="dv">1</span> )</a>
<a class="sourceLine" id="cb420-7" data-line-number="7">        <span class="cf">return</span> <span class="dv">-1</span> ;</a>
<a class="sourceLine" id="cb420-8" data-line-number="8"></a>
<a class="sourceLine" id="cb420-9" data-line-number="9">    <span class="dt">int</span> sum = <span class="dv">1</span> ;  </a>
<a class="sourceLine" id="cb420-10" data-line-number="10">    <span class="cf">for</span> ( <span class="dt">int</span> i = <span class="dv">2</span> ; i &lt;= n ; ++i )</a>
<a class="sourceLine" id="cb420-11" data-line-number="11">    {</a>
<a class="sourceLine" id="cb420-12" data-line-number="12">        sum *= i ;</a>
<a class="sourceLine" id="cb420-13" data-line-number="13"></a>
<a class="sourceLine" id="cb420-14" data-line-number="14">        <span class="co">// printfデバッグ</span></a>
<a class="sourceLine" id="cb420-15" data-line-number="15">            <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;debug: &quot;</span>s &lt;&lt; i &lt;&lt; <span class="st">&quot;, &quot;</span> &lt;&lt; sum &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb420-16" data-line-number="16">        <span class="co">// printfデバッグ</span></a>
<a class="sourceLine" id="cb420-17" data-line-number="17">    }</a>
<a class="sourceLine" id="cb420-18" data-line-number="18"></a>
<a class="sourceLine" id="cb420-19" data-line-number="19">    <span class="bu">std::</span>cout &lt;&lt; sum ;</a>
<a class="sourceLine" id="cb420-20" data-line-number="20">}</a></code></pre></div>
<p>この場合、標準エラー出力を使うとプログラムの通常の出力と<code>printfデバッグ</code>用の出力を分けることができる。</p>
<p>標準エラー出力を使うには、<code>std::cout</code>の代わりに<code>std::cerr</code>を使う。</p>
<div class="sourceCode" id="cb421"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb421-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb421-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb421-3" data-line-number="3">    <span class="co">// 標準出力</span></a>
<a class="sourceLine" id="cb421-4" data-line-number="4">    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;standard output</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb421-5" data-line-number="5"></a>
<a class="sourceLine" id="cb421-6" data-line-number="6">    <span class="co">// 標準エラー出力</span></a>
<a class="sourceLine" id="cb421-7" data-line-number="7">    <span class="bu">std::</span>cerr &lt;&lt; <span class="st">&quot;standard error output</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb421-8" data-line-number="8">}</a></code></pre></div>
<p>このプログラムを実行すると一見すべて同じように出力されているように見える。</p>
<pre><code>$ make run
standard output
standard error output</code></pre>
<p>違いはリダイレクトやパイプを使うとわかる。</p>
<pre><code>$ ./program &gt; /dev/null
standard error output
$ ./program | grep error
standard error output </code></pre>
<p>標準出力には“standard output”しか出力されていない。通常のリダイレクトやパイプで扱われるのも標準出力だけだ。そのため、<code>/dev/null</code>にリダイレクトすると標準エラー出力しか見えないし、grepにパイプしても標準出力しか受け取らない。</p>
<p>標準出力と標準エラー出力を別々にリダイレクトする方法もある。</p>
<pre><code>$ ./program &gt; cout.txt 2&gt; cerr.txt</code></pre>
<p>これを実行すると、ファイルcout.txtには“standard output”が、ファイルcerr.txtには“standard error output”が出力されている。</p>
<p>これを使って先程のプログラムを書き直すと以下のようになる。</p>
<div class="sourceCode" id="cb425"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb425-1" data-line-number="1"></a>
<a class="sourceLine" id="cb425-2" data-line-number="2"><span class="co">// 1 * 2 * 3 * ... * nを計算するプログラム</span></a>
<a class="sourceLine" id="cb425-3" data-line-number="3"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb425-4" data-line-number="4">{</a>
<a class="sourceLine" id="cb425-5" data-line-number="5">    <span class="dt">int</span> n{} ;</a>
<a class="sourceLine" id="cb425-6" data-line-number="6">    <span class="bu">std::</span>cin &gt;&gt; n ;</a>
<a class="sourceLine" id="cb425-7" data-line-number="7">    <span class="cf">if</span> ( n &lt; <span class="dv">1</span> )</a>
<a class="sourceLine" id="cb425-8" data-line-number="8">        <span class="cf">return</span> <span class="dv">-1</span> ;</a>
<a class="sourceLine" id="cb425-9" data-line-number="9"></a>
<a class="sourceLine" id="cb425-10" data-line-number="10">    <span class="dt">int</span> sum = <span class="dv">1</span> ;  </a>
<a class="sourceLine" id="cb425-11" data-line-number="11">    <span class="cf">for</span> ( <span class="dt">int</span> i = <span class="dv">2</span> ; i &lt;= n ; ++i )</a>
<a class="sourceLine" id="cb425-12" data-line-number="12">    {</a>
<a class="sourceLine" id="cb425-13" data-line-number="13">        sum *= i ;</a>
<a class="sourceLine" id="cb425-14" data-line-number="14"></a>
<a class="sourceLine" id="cb425-15" data-line-number="15">        <span class="co">// printfデバッグ</span></a>
<a class="sourceLine" id="cb425-16" data-line-number="16">            <span class="co">// 標準エラー出力</span></a>
<a class="sourceLine" id="cb425-17" data-line-number="17">            <span class="bu">std::</span>cerr &lt;&lt; <span class="st">&quot;debug: &quot;</span>s &lt;&lt; i &lt;&lt; <span class="st">&quot;, &quot;</span> &lt;&lt; sum &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb425-18" data-line-number="18">        <span class="co">// printfデバッグ</span></a>
<a class="sourceLine" id="cb425-19" data-line-number="19">    }</a>
<a class="sourceLine" id="cb425-20" data-line-number="20">    <span class="co">// 標準出力</span></a>
<a class="sourceLine" id="cb425-21" data-line-number="21">    <span class="bu">std::</span>cout &lt;&lt; sum ;</a>
<a class="sourceLine" id="cb425-22" data-line-number="22">}</a></code></pre></div>
<h2 id="まとめ">まとめ</h2>
<p><code>printfデバッグ</code>はコード中のどこに問題があるかを絞り込むための方法だ。プログラムに問題が存在し、問題の発生の有無はプログラムの状態を調べることで判断できるが、コード中のどこに問題が存在するかわからない時、<code>printfデバッグ</code>で問題の箇所を絞り込むことができる。</p>
<p><code>printfデバッグ</code>のやり方は以下の通り。</p>
<ol type="1">
<li>コード中の間違っていそうな箇所にアタリをつける</li>
<li>プログラムの状態を出力する</li>
<li>出力結果が期待通りかどうかを調べる</li>
</ol>
<p><code>printfデバッグ</code>は原始的だが効果的なデバッグ方法だ。後の章ではデバッガーというより高級でプログラマーらしいデバッグ方法も紹介するが、そのような高級なデバッグ方法が使えない環境でも、<code>printfデバッグ</code>ならば使えることは多い。</p>
<h1 id="整数">整数</h1>
<p>始めに書いておくがこの章はユーモア欠落症患者によって書かれており極めて退屈だ。しかし、整数の詳細はすべてのプログラマーが理解すべきものだ。心して読むとよい。</p>
<h2 id="整数リテラル">整数リテラル</h2>
<p>整数リテラルとは整数の値を直接ソースファイルに記述する機能だ。本書ではここまで何の説明もなくリテラルを使っていた。例えば以下のように。</p>
<div class="sourceCode" id="cb426"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb426-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb426-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb426-3" data-line-number="3">    <span class="dt">int</span> a = <span class="dv">123</span> ;</a>
<a class="sourceLine" id="cb426-4" data-line-number="4">    <span class="dt">int</span> b = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb426-5" data-line-number="5">    <span class="dt">int</span> c = <span class="dv">-123</span> ;</a>
<a class="sourceLine" id="cb426-6" data-line-number="6">}</a></code></pre></div>
<p>ここでは、‘123’, ‘0’がリテラルだ。’-123’というのは演算子operator -に整数リテラル123を適用したものだ。リテラルは<code>123</code>だけだ。ただしこれは細かい詳細なので今はそれほど気にしなくてもよい。</p>
<h3 id="進数リテラル">10進数リテラル</h3>
<p>10進数リテラルは最も簡単で我々が日常的に使っている数の表記方法と同じものだ。接頭語は何も使わず数字には0,1,2,3,4,5,6,7,8,9が使える。</p>
<div class="sourceCode" id="cb427"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb427-1" data-line-number="1"><span class="co">// 10進数で123</span></a>
<a class="sourceLine" id="cb427-2" data-line-number="2"><span class="dt">int</span> decimal = <span class="dv">123</span> ;</a></code></pre></div>
<p>ただし、10進数リテラルの先頭を0にしてはならない。これは8進数リテラルになってしまう。</p>
<div class="sourceCode" id="cb428"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb428-1" data-line-number="1"><span class="co">// 10進数で83</span></a>
<a class="sourceLine" id="cb428-2" data-line-number="2"><span class="dt">int</span> octal = <span class="bn">0123</span> ;</a></code></pre></div>
<h3 id="進数リテラル-1">2進数リテラル</h3>
<p>2進数リテラルは接頭語’0b’, ’0B’から始まる。数字には0, 1を使うことができる。</p>
<div class="sourceCode" id="cb429"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb429-1" data-line-number="1"><span class="co">// 10進数で5</span></a>
<a class="sourceLine" id="cb429-2" data-line-number="2"><span class="dt">int</span> binary = <span class="bn">0b1010</span> ;</a>
<a class="sourceLine" id="cb429-3" data-line-number="3"></a>
<a class="sourceLine" id="cb429-4" data-line-number="4"><span class="co">// 0bと0Bは同じ</span></a>
<a class="sourceLine" id="cb429-5" data-line-number="5"><span class="dt">int</span> a = <span class="bn">0B1010</span> ;</a></code></pre></div>
<h3 id="進数リテラル-2">8進数リテラル</h3>
<p>8進数リテラルは接頭語’0’から始まる。数字には0,1,2,3,4,5,6,7を使うことができる。</p>
<div class="sourceCode" id="cb430"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb430-1" data-line-number="1"><span class="co">// 10進数で83</span></a>
<a class="sourceLine" id="cb430-2" data-line-number="2"><span class="dt">int</span> octal = <span class="bn">0123</span> ;</a>
<a class="sourceLine" id="cb430-3" data-line-number="3"></a>
<a class="sourceLine" id="cb430-4" data-line-number="4"><span class="co">// 10進数で342391</span></a>
<a class="sourceLine" id="cb430-5" data-line-number="5"><span class="dt">int</span> a = <span class="bn">01234567</span> ;</a></code></pre></div>
<h3 id="進数リテラル-3">16進数リテラル</h3>
<p>16進数リテラルは接頭語’0x’, ’0X’から始まる。数字には0,1,2,3,4,5,6,7,8,9,a,b,c,d,e,f,A,B,C,D,E,Fが使える。ローマ字の大文字と小文字は意味が同じだ。a,b,c,d,e,fがそれぞれ10,11,12,13,14,15を意味する。</p>
<div class="sourceCode" id="cb431"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb431-1" data-line-number="1"><span class="co">// 10進数で291</span></a>
<a class="sourceLine" id="cb431-2" data-line-number="2"><span class="dt">int</span> hexadecimal = <span class="bn">0x123</span> ;</a>
<a class="sourceLine" id="cb431-3" data-line-number="3"></a>
<a class="sourceLine" id="cb431-4" data-line-number="4"><span class="co">// 0xと0Xは同じ</span></a>
<a class="sourceLine" id="cb431-5" data-line-number="5"><span class="dt">int</span> a = <span class="er">0X123</span> ;</a>
<a class="sourceLine" id="cb431-6" data-line-number="6"></a>
<a class="sourceLine" id="cb431-7" data-line-number="7"><span class="co">// 10進数で10</span></a>
<a class="sourceLine" id="cb431-8" data-line-number="8"><span class="dt">int</span> b = <span class="bn">0xa</span> ;</a>
<a class="sourceLine" id="cb431-9" data-line-number="9"></a>
<a class="sourceLine" id="cb431-10" data-line-number="10"><span class="co">// 10進数で15</span></a>
<a class="sourceLine" id="cb431-11" data-line-number="11"><span class="dt">int</span> c = <span class="bn">0xf</span> ;</a></code></pre></div>
<h3 id="数値区切り">数値区切り</h3>
<p>長い整数リテラルは読みにくい。例えば<code>10000000</code>と<code>100000000</code>はどちらが大きくて具体的にどのくらいの値なのかがわからない。C++には整数リテラルを読みやすいように区切ることのできる数値区切りという機能がある。整数リテラルはシングルクオート文字(’)で区切ることができる。</p>
<div class="sourceCode" id="cb432"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb432-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb432-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb432-3" data-line-number="3">    <span class="dt">int</span> a =   <span class="dv">1000&#39;0000</span> ;</a>
<a class="sourceLine" id="cb432-4" data-line-number="4">    <span class="dt">int</span> b = <span class="dv">1&#39;0000&#39;0000</span> ;</a>
<a class="sourceLine" id="cb432-5" data-line-number="5">}</a></code></pre></div>
<p>区切り幅は何文字でもよい。</p>
<div class="sourceCode" id="cb433"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb433-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb433-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb433-3" data-line-number="3">    <span class="dt">int</span> a = <span class="dv">1&#39;22&#39;333&#39;4444&#39;55555</span> ;</a>
<a class="sourceLine" id="cb433-4" data-line-number="4">}</a></code></pre></div>
<p>10進数整数リテラル以外でも使える。</p>
<div class="sourceCode" id="cb434"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb434-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb434-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb434-3" data-line-number="3">    <span class="kw">auto</span> a = <span class="bn">0b10101010&#39;11110000&#39;00001111</span> ;</a>
<a class="sourceLine" id="cb434-4" data-line-number="4">    <span class="kw">auto</span> b = <span class="bn">07&#39;7&#39;5</span> ;</a>
<a class="sourceLine" id="cb434-5" data-line-number="5">    <span class="kw">auto</span> c = <span class="bn">0xde&#39;ad&#39;be&#39;ef</span> ;</a>
<a class="sourceLine" id="cb434-6" data-line-number="6">}</a></code></pre></div>
<h2 id="整数の仕組み">整数の仕組み</h2>
<h3 id="情報の単位">情報の単位</h3>
<p>0から100までの整数を表現するには101種類の状態を表現できる必要がある。コンピューターはどうやって整数を表現しているのかをここで学ぶ。</p>
<p>情報の最小単位はビット(bit)だ。ビットは2種類の状態を表現できる。たとえばbool型はtrue/falseという2種類の状態を表現できる。</p>
<p>しかし、2種類の状態しか表現できない整数は使いづらい。0もしくは1しか表現できない整数とか、100もしく1000しか表現できない整数は使い物にならない。</p>
<p>また、ビットという単位も扱いづらい。コンピューターは膨大な情報を扱うので、ビットをいくつかまとめたバイト(byte)を単位として情報を扱っている。1バイトが何ビットであるかは環境により異なる。本書では最も普及している1バイトは8ビットを前提にする。</p>
<p>1ビットは2種類の状態を表現できるので、1バイトの中の8ビットは<span class="math inline">\(2^8 = 256\)</span>種類の状態を表現できる。2バイトならば16ビットとなり、<span class="math inline">\(2^16 = 65536\)</span>種類の状態を表現できる。</p>
<h3 id="バイトで表現された整数">1バイトで表現された整数</h3>
<p>整数の表現方法について理解するために、1バイトで表現された整数を考えよう。</p>
<p>1バイトは8ビットであり256種類の状態を表現できる。整数を0から正の方向の数だけ表現したいとすると、0から255までの値を表現できることになる。</p>
<p>その場合、1バイトの整数の中の8ビットはちょうど2進数8桁で表現できる。</p>
<div class="sourceCode" id="cb435"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb435-1" data-line-number="1"><span class="co">// 0</span></a>
<a class="sourceLine" id="cb435-2" data-line-number="2"><span class="kw">auto</span> zero = <span class="bn">0b00000000</span> ;</a>
<a class="sourceLine" id="cb435-3" data-line-number="3"><span class="co">// 255</span></a>
<a class="sourceLine" id="cb435-4" data-line-number="4"><span class="kw">auto</span> max  = <span class="bn">0b11111111</span> ;</a></code></pre></div>
<p>一番左側の桁が最上位桁で、一番右側の桁が最下位桁だ。これを最上位ビット、最下位ビットともいう。</p>
<p>正数だけを表現するならば話は簡単だ。1バイトの整数は0から255までの値を表現できる。これを符号なし整数(unsigned integer)という。</p>
<p>では負数を表現するにはどうしたらいいだろう。正数と負数を両方扱える整数表現のことを、符号付き正数(signed integer)という。1バイトは256種類の状態しか表現できないので、もし-1を表現したい場合、-1から254までの値を扱えることになる。</p>
<p>-1しか扱えないのでは実用的ではないので、負数と正数を同じ種類ぐらい表現したい。256の半分は128だが、1バイトで表現された整数は-128から128までを表現することはできない。0があるからだ。0を含めると、1バイトの整数は最大で-128から127までか、-127から128までを表現できる。どちらかに偏ってしまう。</p>
<p>では実際に1バイトで負数も表現できる正数表現を考えてみよう。</p>
<h4 id="符号ビット">符号ビット</h4>
<p>誰でも思いつきそうな表現方法に、符号ビットがある。これは最上位ビットを符号の有無を管理するフラグとして用いることにより、下位7ビットの値の符号を指定する方法だ。</p>
<p>符号ビット表現では-1と1は以下のように表現できる。</p>
<pre><code>// 1
0b0&#39;0000001
// -1
0b1&#39;0000001</code></pre>
<p>最上位ビットが0であれば正数、1であれば負数だ。</p>
<p>この一見わかりやすい表現方法には問題がある。まず表現できる値の範囲は-127から+127だ。さきほど、1バイトで正負になるべく均等に値を割り振る場合、-128から+127、もしくは-127から+128までを扱えると書いた。しかし符号ビット表現では-127から+127しか扱えない。残りの1はどこにいったのか。</p>
<p>答えはゼロにある。符号ビット表現ではゼロに二通りの表現がある。+0と-0だ。</p>
<pre><code>// +0
0b0&#39;0000000
// -0
0b1&#39;0000000</code></pre>
<p>+0も-0もゼロには違いない。しかし符号ビットが独立して存在しているために、ゼロが2種類ある。</p>
<p>符号ビットは電子回路で実装するには複雑という問題もある。</p>
<h4 id="の補数">1の補数</h4>
<p>1の補数は負数を絶対値を2進数で表したときの各ビットを反転させた値で表現する。たとえば-1は1(0b00000001)の1の補数の0b11111110で表現される。</p>
<pre><code>// -1
0b11111110

// -2
0b11111101</code></pre>
<p>-1と-2を足すと結果は-3だ。この計算を1の補数で行うとどうなるか。</p>
<p>まず1の補数表現による-1と-2を足す。</p>
<pre><code>   11111110
+) 11111101
-----------
 1&#39;11111011</code></pre>
<p>この結果は9ビットになる。この整数は8ビットなので、9ビット目を表現することはできない。ただし1の補数表現の計算では、もし9ビット目が繰り上がった場合は、演算結果に1を足す取り決めがある。</p>
<pre><code>   11111011
+)        1
-----------
   11111100</code></pre>
<p>1の補数による-3は3の各ビットを反転したものだ。3は0b00000011で、そのビットを反転させたものは0b11111100だ。上の計算結果は-3の1の補数表現になった。</p>
<p>もう一つ例を見てみよう。5と-2を足すと3になる。</p>
<pre><code>   00000101
+) 11111101
-----------
 1&#39;00000010</code></pre>
<p>繰り上がりが発生したので1を足すと</p>
<pre><code>   00000010
+)        1
-----------
   00000011</code></pre>
<p>3になった。</p>
<p>1の補数は引き算も足し算で表現できるので電子回路での実装が符号ビットよりもやや簡単になる。</p>
<p>ただし、1の補数にも問題がある。0の表現だ。0というのは0b00000000だが1の補数では-xはxの各ビット反転ということを適用すると、-0は0b11111111になる。すると、符号ビット表現と同じく、+0と-0が存在することになる。したがって、1の補数8ビットで表現できる範囲は-127から+127になる。</p>
<h4 id="の補数-1">2の補数</h4>
<p>符号ビットと1の補数による負数表現にある問題は、2の補数表現で解決できる。</p>
<p>2の補数表現による負数は1の補数表現の負数に、繰り上がり時に足すべき1を加えた値になる。</p>
<p>-1は1の補数表現では、1(0b00000001)の各ビットを反転させた値になる(0b11111110)。2の補数表現では、1の補数表現に1を加えた値になるので、0b11111111になる。</p>
<p>同様に、-2は0b11111110に、-3は0b11111101になる。</p>
<p>00000011 11111100</p>
<p>2の補数表現の-1と-2を足すと以下のようになる。</p>
<pre><code>   11111111
+) 11111110
-----------
 1&#39;11111101</code></pre>
<p>9ビット目の繰り上がりを無視すると、計算結果は0b11111101になる。これは2の補数表現による-3と同じだ。</p>
<p>5と-2の計算も見てみよう。</p>
<pre><code>   00000101
+) 11111110
-----------
 1&#39;00000011</code></pre>
<p>結果は3(0b00000011)だ。</p>
<p>2の補数表現は引き算も足し算で実装できる上に、ゼロの表現方法は一つで、+0と-0が存在しない。8ビットの2の補数表現された整数の範囲は-128から+127になる。とても便利な負数の表現方法なので殆どのコンピューターで採用されている。</p>
<h2 id="整数型">整数型</h2>
<p>C++には様々な整数型が存在する。C++はCから引き継いだ歴史的な経緯により、整数型の文法がわかりにくくなっている。</p>
<p>基本的には、符号付き整数型と符号なし整数型にわかれている。</p>
<p>符号付き整数型としては、<code>signed char</code>, <code>short int</code>, <code>int</code>, <code>long int</code>, <code>long long int</code>が存在する。符号付き整数型は負数を表現できる。</p>
<p>符号なし整数型としては、<code>unsigned char</code>, <code>unsigned short int</code>, <code>unsigned int</code>, <code>unsigned long int</code>, <code>unsigned long long int</code>が存在する。符号なし整数型は負数を表現できない。</p>
<h3 id="int型">int型</h3>
<p><code>int型</code>は最も基本となる整数型だ。C++で数値を扱う場合、多くはint型になる。</p>
<div class="sourceCode" id="cb445"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb445-1" data-line-number="1"><span class="dt">int</span> x = <span class="dv">123</span> ;</a></code></pre></div>
<p>整数リテラルの型は通常はint型になる。</p>
<div class="sourceCode" id="cb446"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb446-1" data-line-number="1"><span class="co">// int</span></a>
<a class="sourceLine" id="cb446-2" data-line-number="2"><span class="kw">auto</span> x = <span class="dv">123</span> ;</a></code></pre></div>
<p><code>unsigned int型</code>は符号のないint型だ。</p>
<div class="sourceCode" id="cb447"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb447-1" data-line-number="1"><span class="dt">unsigned</span> <span class="dt">int</span> x = <span class="dv">123</span> ;</a></code></pre></div>
<p>整数リテラルの末尾にu/Uと書いた場合、unsigned int型になる。</p>
<div class="sourceCode" id="cb448"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb448-1" data-line-number="1"><span class="co">// int</span></a>
<a class="sourceLine" id="cb448-2" data-line-number="2"><span class="kw">auto</span> x = <span class="dv">123</span> ;</a>
<a class="sourceLine" id="cb448-3" data-line-number="3"><span class="co">// unsigned int</span></a>
<a class="sourceLine" id="cb448-4" data-line-number="4"><span class="kw">auto</span> y = <span class="dv">123u</span> ;</a></code></pre></div>
<p>特殊なルールとして、単に<code>signed</code>と書いた場合、それは<code>int</code>になる。<code>unsigned</code>と書いた場合は、<code>unsigned int</code>になる。</p>
<div class="sourceCode" id="cb449"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb449-1" data-line-number="1"><span class="co">// int</span></a>
<a class="sourceLine" id="cb449-2" data-line-number="2"><span class="dt">signed</span> a = <span class="dv">1</span> ;</a>
<a class="sourceLine" id="cb449-3" data-line-number="3"><span class="co">// unsigned int</span></a>
<a class="sourceLine" id="cb449-4" data-line-number="4"><span class="dt">unsigned</span> b = <span class="dv">1</span> ;</a></code></pre></div>
<p><code>signed int</code>と書いた場合、<code>int型</code>になる。<code>signed int</code>は<code>int</code>の冗長な書き方だ。</p>
<h3 id="long-int型">long int型</h3>
<p><code>long int型</code>は<code>int型</code>以上の範囲の整数を扱える型だ。具体的な整数型の値の範囲は実装依存だが、<code>long int型</code>は<code>int型</code>の表現できる整数の範囲はすべて表現でき、かつ<code>int型</code>以上の範囲の整数型を表現できるかもしれない型だ。</p>
<p><code>unsigned long int型</code>は符号なしの<code>long int</code>だ。</p>
<div class="sourceCode" id="cb450"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb450-1" data-line-number="1"><span class="dt">long</span> <span class="dt">int</span> a = <span class="dv">123</span> ;</a>
<a class="sourceLine" id="cb450-2" data-line-number="2"><span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">int</span> b = <span class="dv">123</span> ;</a></code></pre></div>
<p>特殊なルールとして、単に<code>long</code>と書いた場合、それは<code>long int</code>になる。<code>unsigned long</code>と書いた場合、<code>unsigned long int</code>になる。</p>
<div class="sourceCode" id="cb451"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb451-1" data-line-number="1"><span class="co">// long int</span></a>
<a class="sourceLine" id="cb451-2" data-line-number="2"><span class="dt">long</span> a = <span class="dv">1</span> ;</a>
<a class="sourceLine" id="cb451-3" data-line-number="3"><span class="co">// unsigned long int</span></a>
<a class="sourceLine" id="cb451-4" data-line-number="4"><span class="dt">unsigned</span> <span class="dt">long</span> b = <span class="dv">1</span> ;</a></code></pre></div>
<p>通常、intを省略して単に<code>long</code>と書くことが多い。</p>
<p>整数リテラルの値が<code>int型</code>で表現できない場合、<code>long型</code>になる。例えば、<code>int型</code>で100億を表現できないが、<code>long型</code>では表現できる実装の場合、以下の変数aは<code>long型</code>になる。</p>
<div class="sourceCode" id="cb452"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb452-1" data-line-number="1"><span class="co">// 100億</span></a>
<a class="sourceLine" id="cb452-2" data-line-number="2"><span class="kw">auto</span> a = <span class="dv">100&#39;0000&#39;0000</span> ;</a></code></pre></div>
<p>整数リテラルの値が<code>long</code>では表現できないが<code>unsigned long</code>では表現できる場合、<code>unsigned long型</code>になる。</p>
<p>整数リテラルの末尾にl/Lと書いた場合、値にかかわらず<code>long型</code>になる。</p>
<div class="sourceCode" id="cb453"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb453-1" data-line-number="1"><span class="co">// int</span></a>
<a class="sourceLine" id="cb453-2" data-line-number="2"><span class="kw">auto</span> a = <span class="dv">123</span> ;</a>
<a class="sourceLine" id="cb453-3" data-line-number="3"><span class="co">// long</span></a>
<a class="sourceLine" id="cb453-4" data-line-number="4"><span class="kw">auto</span> b = <span class="dv">123l</span> ;</a>
<a class="sourceLine" id="cb453-5" data-line-number="5"><span class="co">// long</span></a>
<a class="sourceLine" id="cb453-6" data-line-number="6"><span class="kw">auto</span> c = <span class="dv">123L</span> ;</a></code></pre></div>
<p>符号なし整数型を意味するu/Uと組み合わせることもできる。</p>
<div class="sourceCode" id="cb454"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb454-1" data-line-number="1"><span class="co">// unsigned long</span></a>
<a class="sourceLine" id="cb454-2" data-line-number="2"><span class="kw">auto</span> a = <span class="dv">123ul</span> ;</a>
<a class="sourceLine" id="cb454-3" data-line-number="3"><span class="kw">auto</span> b = <span class="dv">123lu</span> ;</a></code></pre></div>
<p>順番と大文字小文字の組み合わせは自由だ。</p>
<h3 id="long-long-int型">long long int型</h3>
<p><code>long long int型</code>は<code>long int型</code>以上の範囲の整数を扱える型だ。<code>long</code>と同じく<code>long long</code>は<code>long long int</code>と同じで、<code>unsigned long long int</code>もある。</p>
<pre><code>// long long int
long long a = 1 ;
// unsigned long long int
unsinged long long b = 1 ;</code></pre>
<p>整数リテラルの値が<code>long型</code>でも表現できないときは、<code>long long</code>が使われる。<code>long long</code>でも表現できない場合は<code>unsigned long long</code>が使われる。</p>
<p>整数リテラルの末尾にll/LLと書くと<code>long long int型</code>になる。</p>
<div class="sourceCode" id="cb456"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb456-1" data-line-number="1"><span class="co">// long long int</span></a>
<a class="sourceLine" id="cb456-2" data-line-number="2"><span class="kw">auto</span> a = <span class="dv">123ll</span> ;</a>
<a class="sourceLine" id="cb456-3" data-line-number="3"><span class="co">// long long int</span></a>
<a class="sourceLine" id="cb456-4" data-line-number="4"><span class="kw">auto</span> b = <span class="dv">123LL</span> ;</a>
<a class="sourceLine" id="cb456-5" data-line-number="5"><span class="co">// unsigned long long int</span></a>
<a class="sourceLine" id="cb456-6" data-line-number="6"><span class="kw">auto</span> c = <span class="dv">123ull</span> ;</a></code></pre></div>
<h3 id="short-int型">short int型</h3>
<p><code>short int型</code>は<code>int型</code>より小さい範囲の値を扱う整数型だ。<code>long</code>, <code>long long</code>と同様に、<code>unsigned short int</code>型もある。単に<code>short</code>と書くと、<code>short int</code>と同じ意味になる。</p>
<p>整数リテラルで<code>short int</code>型を表現する方法はない。</p>
<h3 id="char型">char型</h3>
<p><code>char型</code>はやや特殊で、<code>char</code>, <code>signed char</code>, <code>unsigned char</code>の三種類の型がある。<code>signed char</code>と<code>char</code>は別物だ。<code>char型</code>は整数型であり、後で説明するように文字型でもある。<code>char型</code>の符号の有無は実装ごとに異なる。</p>
<h2 id="整数型のサイズ">整数型のサイズ</h2>
<p>整数型を含む変数のサイズは、<code>sizeof演算子</code>で確認することができる。sizeof(T)はTに型名や変数名を入れることで、サイズを取得することができる。</p>
<div class="sourceCode" id="cb457"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb457-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb457-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb457-3" data-line-number="3">    <span class="bu">std::</span>cout &lt;&lt; <span class="kw">sizeof</span>(<span class="dt">int</span>) &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb457-4" data-line-number="4"></a>
<a class="sourceLine" id="cb457-5" data-line-number="5">    <span class="dt">int</span> x{} ;</a>
<a class="sourceLine" id="cb457-6" data-line-number="6">    <span class="bu">std::</span>cout &lt;&lt; <span class="kw">sizeof</span>(x) ;</a>
<a class="sourceLine" id="cb457-7" data-line-number="7">}</a></code></pre></div>
<p><code>sizeof演算子</code>は<code>std::size_t型</code>を返す。vectorの章でも出てきたこの型は実装依存の符号なし型であると定義されている。単位はバイトだ。</p>
<p>以下が各種整数型のサイズを出力するプログラムだ。</p>
<div class="sourceCode" id="cb458"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb458-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb458-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb458-3" data-line-number="3">    <span class="kw">auto</span> print = []( <span class="bu">std::</span>size_t s )</a>
<a class="sourceLine" id="cb458-4" data-line-number="4">    { <span class="bu">std::</span>cout &lt;&lt; s &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ; } ;</a>
<a class="sourceLine" id="cb458-5" data-line-number="5"></a>
<a class="sourceLine" id="cb458-6" data-line-number="6">    print( <span class="kw">sizeof</span>(<span class="dt">char</span>) ) ;</a>
<a class="sourceLine" id="cb458-7" data-line-number="7">    print( <span class="kw">sizeof</span>(<span class="dt">short</span>) ) ;</a>
<a class="sourceLine" id="cb458-8" data-line-number="8">    print( <span class="kw">sizeof</span>(<span class="dt">int</span>) ) ;</a>
<a class="sourceLine" id="cb458-9" data-line-number="9">    print( <span class="kw">sizeof</span>(<span class="dt">long</span>) ) ;</a>
<a class="sourceLine" id="cb458-10" data-line-number="10">    print( <span class="kw">sizeof</span>(<span class="dt">long</span> <span class="dt">long</span> ) ) ;</a>
<a class="sourceLine" id="cb458-11" data-line-number="11">}</a></code></pre></div>
<p>このプログラムを筆者の環境で実行した結果が以下になる。</p>
<pre><code>1
2
4
8
8</code></pre>
<p>どうやら筆者の環境では、charが1バイト、shortが2バイト、intが4バイト、longとlong longが8バイトのようだ。この結果は環境ごとに異なるので読者も自分でsizeof演算子を様々な型に適用して試してほしい。</p>
<h2 id="整数型の表現できる値の範囲">整数型の表現できる値の範囲</h2>
<p>整数型の表現できる値の最小値と最大値は<code>std::numeric_limits&lt;T&gt;</code>で取得できる。最小値は::min()を、最大値は::max()で得られる。</p>
<div class="sourceCode" id="cb460"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb460-1" data-line-number="1"></a>
<a class="sourceLine" id="cb460-2" data-line-number="2"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb460-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb460-4" data-line-number="4">    <span class="bu">std::</span>cout</a>
<a class="sourceLine" id="cb460-5" data-line-number="5">        &lt;&lt; <span class="bu">std::</span>numeric_limits&lt;<span class="dt">int</span>&gt;::min() &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s</a>
<a class="sourceLine" id="cb460-6" data-line-number="6">        &lt;&lt; <span class="bu">std::</span>numeric_limits&lt;<span class="dt">int</span>&gt;::max() ;</a>
<a class="sourceLine" id="cb460-7" data-line-number="7">}</a></code></pre></div>
<p>実行結果</p>
<pre><code>-2147483648
2147483647</code></pre>
<p>どうやら筆者の環境ではint型は−21億4748万3648から21億4748万3647までの範囲の値を表現できるようだ。</p>
<p><code>unsigned int</code>はどうだろうか。</p>
<div class="sourceCode" id="cb462"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb462-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb462-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb462-3" data-line-number="3">    <span class="bu">std::</span>cout</a>
<a class="sourceLine" id="cb462-4" data-line-number="4">        &lt;&lt; <span class="bu">std::</span>numeric_limits&lt;<span class="dt">unsigned</span> <span class="dt">int</span>&gt;::min() &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s</a>
<a class="sourceLine" id="cb462-5" data-line-number="5">        &lt;&lt; <span class="bu">std::</span>numeric_limits&lt;<span class="dt">unsigned</span> <span class="dt">int</span>&gt;::max() ;</a>
<a class="sourceLine" id="cb462-6" data-line-number="6">}</a></code></pre></div>
<p>実行結果</p>
<pre><code>0
4294967295</code></pre>
<p>どうやら筆者の環境ではunsigned int型は0から42億9496万7295までの範囲の値を表現できるようだ。sizeof(int)が4バイトであり、1バイトが8ビットの筆者の環境では自然な値だ。符号なしの4バイト整数型は0から<span class="math inline">\(2^{32}-1\)</span>までの範囲の値を表現できる。符号付き4バイト整数型は<span class="math inline">\(-2^{31}\)</span>から<span class="math inline">\(2^{31}-1\)</span>までの範囲の値を表現できる。</p>
<p>整数の最小値を-1したり、最大値を+1した場合、何が起こるのだろうか。</p>
<p>符号なし整数型の場合は簡単だ。最小値-1は最大値になる。最大値+1は最小値になる。</p>
<div class="sourceCode" id="cb464"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb464-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb464-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb464-3" data-line-number="3">    <span class="dt">unsigned</span> <span class="dt">int</span> min = <span class="bu">std::</span>numeric_limits&lt;<span class="dt">unsigned</span> <span class="dt">int</span>&gt;::min() ;</a>
<a class="sourceLine" id="cb464-4" data-line-number="4">    <span class="dt">unsigned</span> <span class="dt">int</span> max = <span class="bu">std::</span>numeric_limits&lt;<span class="dt">unsigned</span> <span class="dt">int</span>&gt;::max() ;</a>
<a class="sourceLine" id="cb464-5" data-line-number="5"></a>
<a class="sourceLine" id="cb464-6" data-line-number="6">    <span class="dt">unsigned</span> <span class="dt">int</span> min_minus_one = min - <span class="dv">1u</span> ;</a>
<a class="sourceLine" id="cb464-7" data-line-number="7">    <span class="dt">unsigned</span> <span class="dt">int</span> max_plus_one = max + <span class="dv">1u</span> ;</a>
<a class="sourceLine" id="cb464-8" data-line-number="8"></a>
<a class="sourceLine" id="cb464-9" data-line-number="9">    <span class="bu">std::</span>cout &lt;&lt; min &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s &lt;&lt; max &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s</a>
<a class="sourceLine" id="cb464-10" data-line-number="10">        &lt;&lt; min_minus_one &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s &lt;&lt; max_plus_one ;</a>
<a class="sourceLine" id="cb464-11" data-line-number="11">}</a></code></pre></div>
<p>8ビットの符号なし整数型があるとして、最小値は0b00000000(0)になるが、この値を-1すると0b11111111(255)となり、これは最大値になる。逆に、最大値である0b11111111(255)に+1すると0b00000000(0)となり、これは最小値になる。</p>
<p>これを数学的に厳密に書くと、「符号なし整数は算術モジュロ<span class="math inline">\(2^n\)</span>の法に従う。ただしnは整数を表現する値のビット数である」となる。</p>
<p>符号付き整数型の場合、挙動は定められていない。ただし、一般に普及している2の補数表現の場合は、以下のような挙動になることが多い。</p>
<p>符号付き整数型の最小値を-1すると最大値になり、最大値を+1すると最小値になる。</p>
<div class="sourceCode" id="cb465"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb465-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb465-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb465-3" data-line-number="3">     <span class="dt">int</span> min = <span class="bu">std::</span>numeric_limits&lt;<span class="dt">int</span>&gt;::min() ;</a>
<a class="sourceLine" id="cb465-4" data-line-number="4">     <span class="dt">int</span> max = <span class="bu">std::</span>numeric_limits&lt;<span class="dt">int</span>&gt;::max() ;</a>
<a class="sourceLine" id="cb465-5" data-line-number="5"></a>
<a class="sourceLine" id="cb465-6" data-line-number="6">     <span class="dt">int</span> min_minus_one = min - <span class="dv">1</span> ;</a>
<a class="sourceLine" id="cb465-7" data-line-number="7">     <span class="dt">int</span> max_plus_one = max + <span class="dv">1</span> ;</a>
<a class="sourceLine" id="cb465-8" data-line-number="8"></a>
<a class="sourceLine" id="cb465-9" data-line-number="9">    <span class="bu">std::</span>cout &lt;&lt; min &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s &lt;&lt; max &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s</a>
<a class="sourceLine" id="cb465-10" data-line-number="10">        &lt;&lt; min_minus_one &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s &lt;&lt; max_plus_one ;</a>
<a class="sourceLine" id="cb465-11" data-line-number="11">}</a></code></pre></div>
<p>これはなぜか。2の補数表現の8ビットの符号付き整数の最小値は0b10000000(-128)だが、これを-1すると0b01111111(127)となり、これは最大値となる。逆に最大値0b01111111(127)を+1すると0b10000000(-128)となり、これは最小値となる。</p>
<h2 id="整数型の変換">整数型の変換</h2>
<p>整数型にはここで紹介しただけでも、様々な型がある。同じ型同士を使ったほうがよい。</p>
<p>以下は型が一致している例だ。</p>
<div class="sourceCode" id="cb466"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb466-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb466-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb466-3" data-line-number="3">    <span class="dt">int</span> a = <span class="dv">123</span> ;</a>
<a class="sourceLine" id="cb466-4" data-line-number="4">    <span class="dt">long</span> b = <span class="dv">123l</span> ;</a>
<a class="sourceLine" id="cb466-5" data-line-number="5">    <span class="dt">long</span> <span class="dt">long</span> c = <span class="dv">123ll</span> ;</a>
<a class="sourceLine" id="cb466-6" data-line-number="6"></a>
<a class="sourceLine" id="cb466-7" data-line-number="7">    <span class="dt">unsigned</span> <span class="dt">int</span> d = <span class="dv">123u</span> ; </a>
<a class="sourceLine" id="cb466-8" data-line-number="8">}</a></code></pre></div>
<p>以下は型が一致していない例だ。</p>
<div class="sourceCode" id="cb467"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb467-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb467-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb467-3" data-line-number="3">    <span class="co">// intからshort</span></a>
<a class="sourceLine" id="cb467-4" data-line-number="4">    <span class="dt">short</span> a = <span class="dv">123</span> ;</a>
<a class="sourceLine" id="cb467-5" data-line-number="5">    <span class="co">// longからint</span></a>
<a class="sourceLine" id="cb467-6" data-line-number="6">    <span class="dt">int</span> b = <span class="dv">123l</span> ;</a>
<a class="sourceLine" id="cb467-7" data-line-number="7"></a>
<a class="sourceLine" id="cb467-8" data-line-number="8">    <span class="co">// intからunsigned int</span></a>
<a class="sourceLine" id="cb467-9" data-line-number="9">    <span class="dt">unsigned</span> <span class="dt">int</span> c = <span class="dv">123</span> ;</a>
<a class="sourceLine" id="cb467-10" data-line-number="10">    <span class="co">// unsigned intからint</span></a>
<a class="sourceLine" id="cb467-11" data-line-number="11">    <span class="dt">int</span> d = <span class="dv">123u</span> ;</a>
<a class="sourceLine" id="cb467-12" data-line-number="12">}</a></code></pre></div>
<p>代入や演算で整数型が一致しない場合、整数型の変換が行われる。</p>
<p>整数型の変換で注意すべきこととしては、変換元の値を変換先の型で表現できない場合の挙動だ。</p>
<p>たとえばshort型とint型の表現できる最大値を調べるプログラムを書いてみよう。</p>
<div class="sourceCode" id="cb468"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb468-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb468-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb468-3" data-line-number="3">    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;short: &quot;</span>s &lt;&lt; <span class="bu">std::</span>numeric_limits&lt;<span class="dt">short</span>&gt;::max() &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s</a>
<a class="sourceLine" id="cb468-4" data-line-number="4">        &lt;&lt; <span class="st">&quot;int: &quot;</span>s &lt;&lt; <span class="bu">std::</span>numeric_limits&lt;<span class="dt">int</span>&gt;::max() ;</a>
<a class="sourceLine" id="cb468-5" data-line-number="5">}</a></code></pre></div>
<p>これを実行すると筆者の環境では以下のようになる。</p>
<pre><code>short: 32767
int: 2147483647</code></pre>
<p>どうやら筆者の環境ではshort型は約3万、int型は約21億ぐらいの値を表現できるようだ。</p>
<p>では約3万までしか表現できないshort型に4万を代入しようとするとどうなるのか。これは一つ前の整数型の表現できる値の範囲で説明したものと同じことがおこる。</p>
<div class="sourceCode" id="cb470"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb470-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb470-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb470-3" data-line-number="3">    <span class="dt">short</span> x = <span class="dv">40000</span> ;</a>
<a class="sourceLine" id="cb470-4" data-line-number="4">    <span class="bu">std::</span>cout &lt;&lt; x ;</a>
<a class="sourceLine" id="cb470-5" data-line-number="5">}</a></code></pre></div>
<p>このプログラムを実行した結果は実装ごとに異なる。例えば筆者の環境では以下のようになる。</p>
<pre><code>-25536</code></pre>
<p>整数型の変換は暗黙的に行われるが、明示的に行うこともできる。明示的な変換には<code>static_cast&lt;T&gt;(e)</code>を使う。<code>static_cast</code>は値eを型Tの値に変換する。</p>
<div class="sourceCode" id="cb472"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb472-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb472-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb472-3" data-line-number="3">    <span class="dt">int</span> x = <span class="dv">123</span> ;</a>
<a class="sourceLine" id="cb472-4" data-line-number="4">    <span class="dt">short</span> y = <span class="kw">static_cast</span>&lt;<span class="dt">short</span>&gt;(x) ;</a>
<a class="sourceLine" id="cb472-5" data-line-number="5">}</a></code></pre></div>
<h1 id="浮動小数点数">浮動小数点数</h1>
<p>浮動小数点数の型には<code>float</code>, <code>double</code>, <code>long double</code>がある。<code>float</code>が最も精度が低く、<code>double</code>はfloatと同等以上の精度を持ち、<code>long double</code>はdoubleと同等以上の精度を持つ。</p>
<div class="sourceCode" id="cb473"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb473-1" data-line-number="1"><span class="dt">float</span> f = <span class="fl">1.0</span> ;</a>
<a class="sourceLine" id="cb473-2" data-line-number="2"><span class="dt">double</span> d = <span class="fl">1.0</span> ;</a>
<a class="sourceLine" id="cb473-3" data-line-number="3"><span class="dt">long</span> <span class="dt">double</span> ld = <span class="fl">1.0</span> ;</a></code></pre></div>
<p>以下は浮動小数点数型の変数のサイズを調べるコードだ。</p>
<div class="sourceCode" id="cb474"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb474-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb474-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb474-3" data-line-number="3">    <span class="kw">auto</span> print = [](<span class="bu">std::</span>size_t s )</a>
<a class="sourceLine" id="cb474-4" data-line-number="4">    { <span class="bu">std::</span>cout &lt;&lt; s &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ; } ;</a>
<a class="sourceLine" id="cb474-5" data-line-number="5"></a>
<a class="sourceLine" id="cb474-6" data-line-number="6">    print( <span class="kw">sizeof</span>(<span class="dt">float</span>) ) ;</a>
<a class="sourceLine" id="cb474-7" data-line-number="7">    print( <span class="kw">sizeof</span>(<span class="dt">double</span>) ) ;</a>
<a class="sourceLine" id="cb474-8" data-line-number="8">    print( <span class="kw">sizeof</span>(<span class="dt">long</span> <span class="dt">double</span>) ) ;</a>
<a class="sourceLine" id="cb474-9" data-line-number="9">}</a></code></pre></div>
<p>筆者の環境では以下のように出力される。</p>
<pre><code>4
8
16</code></pre>
<p>浮動小数点数は一見整数と同じように扱える上、小数点以下の値も扱える。</p>
<div class="sourceCode" id="cb476"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb476-1" data-line-number="1"><span class="dt">double</span> a = <span class="fl">1.23</span> ;</a>
<a class="sourceLine" id="cb476-2" data-line-number="2"><span class="dt">double</span> b = <span class="fl">0.00001</span> ;</a></code></pre></div>
<p>浮動小数点数が表現できる最大値は実装依存だが、通常はかなり大きな値を表現できる。</p>
<p>しかし、浮動小数点数は値を正確に表現しているわけではない。例えば以下のコードを実行してみよう。</p>
<div class="sourceCode" id="cb477"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb477-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb477-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb477-3" data-line-number="3">    <span class="co">// １万</span></a>
<a class="sourceLine" id="cb477-4" data-line-number="4">    <span class="dt">float</span> a = <span class="fl">10000.0</span> ;</a>
<a class="sourceLine" id="cb477-5" data-line-number="5">    <span class="co">// １万分の1</span></a>
<a class="sourceLine" id="cb477-6" data-line-number="6">    <span class="dt">float</span> b = <span class="fl">0.0001</span> ;</a>
<a class="sourceLine" id="cb477-7" data-line-number="7"></a>
<a class="sourceLine" id="cb477-8" data-line-number="8">    <span class="co">// １万足す１万分の1</span></a>
<a class="sourceLine" id="cb477-9" data-line-number="9">    <span class="dt">float</span> c = a + b ;</a>
<a class="sourceLine" id="cb477-10" data-line-number="10"></a>
<a class="sourceLine" id="cb477-11" data-line-number="11">    <span class="bu">std::</span>cout &lt;&lt; a &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s &lt;&lt; b &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s &lt;&lt; c ;</a>
<a class="sourceLine" id="cb477-12" data-line-number="12">}</a></code></pre></div>
<p>変数aの値は１万、変数bの値は１万分の1だ。変数cの値はa+bで10000.0001となるはずだが結果はどうだろう。</p>
<pre><code>10000
0.0001
10000</code></pre>
<p>変数cの値は10000.0001ではない。この謎は浮動小数点数を学べば明らかになる。</p>
<h2 id="浮動小数点数リテラル">浮動小数点数リテラル</h2>
<h2 id="進浮動小数点数リテラル">10進浮動小数点数リテラル</h2>
<p>浮動小数点数リテラルの最も簡単な書き方は10進数で整数部を書き、小数点’.’を書き、続けて小数部を書く。末尾がf/Fならfloat型、末尾がなければdouble型、末尾がl/Lならlong double型だ。</p>
<div class="sourceCode" id="cb479"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb479-1" data-line-number="1"><span class="co">// float</span></a>
<a class="sourceLine" id="cb479-2" data-line-number="2"><span class="kw">auto</span> a = <span class="fl">123.456f</span> ;</a>
<a class="sourceLine" id="cb479-3" data-line-number="3"><span class="kw">auto</span> b = <span class="fl">123.456F</span> ;</a>
<a class="sourceLine" id="cb479-4" data-line-number="4"></a>
<a class="sourceLine" id="cb479-5" data-line-number="5"><span class="co">// double</span></a>
<a class="sourceLine" id="cb479-6" data-line-number="6"><span class="kw">auto</span> c = <span class="fl">123.456</span> ;</a>
<a class="sourceLine" id="cb479-7" data-line-number="7"></a>
<a class="sourceLine" id="cb479-8" data-line-number="8"><span class="co">// long double</span></a>
<a class="sourceLine" id="cb479-9" data-line-number="9"><span class="kw">auto</span> d = <span class="fl">123.456l</span> ;</a>
<a class="sourceLine" id="cb479-10" data-line-number="10"><span class="kw">auto</span> e = <span class="fl">123.456L</span> ;</a></code></pre></div>
<h3 id="進数の仮数と指数による表記">10進数の仮数と指数による表記</h3>
<p><code>123.456</code>という値について考えてみよう。この値は以下のように表現することができる。</p>
<p><span class="math display">\[1.23456 \times 10^{2}\]</span></p>
<p>あるいは以下のように表現することもできる。</p>
<p><span class="math display">\[123456 \times 10^{-3}\]</span></p>
<p>あるいは以下のようにも表現できる。</p>
<p><span class="math display">\[123.456 \times 10^{0}\]</span></p>
<p>一般に、値は以下のように表現できるということだ。</p>
<p><span class="math display">\[a \times 10^{b}\]</span></p>
<p>浮動小数点数リテラルのもう一つの文法として、この<code>a</code>と<code>b</code>を指定するものがある。</p>
<div class="sourceCode" id="cb480"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb480-1" data-line-number="1"><span class="co">// 値はすべて123.456</span></a>
<a class="sourceLine" id="cb480-2" data-line-number="2"><span class="kw">auto</span> a = <span class="fl">1.23456e2</span> ;</a>
<a class="sourceLine" id="cb480-3" data-line-number="3"><span class="kw">auto</span> b = <span class="fl">123456e-3</span> ;</a>
<a class="sourceLine" id="cb480-4" data-line-number="4"><span class="kw">auto</span> c = <span class="fl">123.456e0</span> ;</a>
<a class="sourceLine" id="cb480-5" data-line-number="5"><span class="kw">auto</span> d = <span class="fl">123.456E0</span> ;</a></code></pre></div>
<p>この文法は、<code>a</code>と<code>b</code>にe/Eを挟むことによって浮動小数点数の値を指定する。</p>
<p>この<code>a</code>を仮数部(fractional part)、bを指数部(exponent part)と言う。仮数のことは他にも、coefficient, significand, mantissaなどと呼ばれたりもする。</p>
<p>そして、指数は底が10になる。</p>
<p>浮動小数点数は、値を正確に表現しているのではなく、仮数と指数の組み合わせで表現している。浮動小数点数が浮動と呼ばれる理由は、指数の存在によって小数点数が浮いているかのように動くからだ。</p>
<p>例えば、仮数と指数がともに符号付き1バイトの整数で表現された2バイトの浮動小数点数があるとする。指数、仮数ともに、-128から127までの範囲の整数を表現できる。この浮動小数点数は10000(1万)も100000000(1億)も1000000000000(1兆)も表現できる。それぞれ、<code>1e4</code>, <code>1e8</code>, <code>1e12</code>だ。</p>
<p>しかし、この浮動小数点数では1000100010000(1兆1億1万)を表現できない。なぜならば、この値を正確に表現するには、<code>100010001e4</code>を表現できる必要があるが、仮数は100010001を表現できないからだ。</p>
<p>浮動小数点数は値を必ずしも正確に表現できない。その代わり、とても大きな値や、とても小さな値を表現できる。</p>
<p>浮動小数点数の型を表す末尾のf/F/l/Lは同じように使える。</p>
<div class="sourceCode" id="cb481"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb481-1" data-line-number="1"><span class="co">// float</span></a>
<a class="sourceLine" id="cb481-2" data-line-number="2"><span class="kw">auto</span> a = <span class="fl">1.0e0f</span> ;</a>
<a class="sourceLine" id="cb481-3" data-line-number="3"><span class="co">// double</span></a>
<a class="sourceLine" id="cb481-4" data-line-number="4"><span class="kw">auto</span> b = <span class="fl">1.0e0</span> ;</a>
<a class="sourceLine" id="cb481-5" data-line-number="5"><span class="co">// long double</span></a>
<a class="sourceLine" id="cb481-6" data-line-number="6"><span class="kw">auto</span> c = <span class="fl">1.0e0l</span> ;</a></code></pre></div>
<h3 id="進数の仮数と指数による表記-1">16進数の仮数と指数による表記</h3>
<p>浮動小数点数の仮数部と指数部によるリテラルは、16進数で記述することもできる。</p>
<p>文法は、0xからはじめ、16進数の仮数部を書き、e/Eの代わりにp/Pを使い、指数部を10進数で指定する。このときの指数部の底は2になる。</p>
<p>値は</p>
<p><span class="math display">\[仮数 \times 2^{指数}\]</span></p>
<p>になる。</p>
<div class="sourceCode" id="cb482"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb482-1" data-line-number="1"><span class="co">// 5496</span></a>
<a class="sourceLine" id="cb482-2" data-line-number="2"><span class="dt">double</span> a = <span class="bn">0xabc</span><span class="fl">.0</span>p0 ;</a>
<a class="sourceLine" id="cb482-3" data-line-number="3"><span class="co">// 7134</span></a>
<a class="sourceLine" id="cb482-4" data-line-number="4"><span class="dt">double</span> b = <span class="bn">0xde</span>.fp5 ;</a></code></pre></div>
<h2 id="浮動小数点数の表現と特性">浮動小数点数の表現と特性</h2>
<p>浮動小数点数は指数と仮数で表現される。浮動小数点数の表現は様々だが、多くのアーキテクチャーでは国際標準規格のISO/IEC/IEEE 60559:2011が使われている。これは米国電気電子学会の規格IEEE 754-2008と同じ内容になっている。その大本はIntelが立案した規格、IEEE 754-1985だ。一般にはIEEE 754(アイトリプルイー 754)という名称で知られている。</p>
<p>IEEE 754では、浮動小数点数は符号ビット、仮数部、指数部からなる。本書ではIEEE 754のを前提として、浮動小数点数で気をつけるべき特性を説明する。</p>
<h3 id="と-0.0">+0.0と-0.0</h3>
<p>IEEE 754では符号ビットがあるので、ゼロには2種類ある。正のゼロと負のゼロだ。</p>
<div class="sourceCode" id="cb483"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb483-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb483-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb483-3" data-line-number="3">    <span class="bu">std::</span>cout &lt;&lt; <span class="fl">0.0</span> &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s &lt;&lt; <span class="fl">-0.0</span> ;</a>
<a class="sourceLine" id="cb483-4" data-line-number="4">}</a></code></pre></div>
<p>+0.0と-0.0の違いを浮動小数点数で表現することはできるが、値を比較すると同じものだとみなされる。</p>
<div class="sourceCode" id="cb484"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb484-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb484-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb484-3" data-line-number="3">    <span class="co">// a, bは異なるビットパターンを持つ</span></a>
<a class="sourceLine" id="cb484-4" data-line-number="4">    <span class="dt">double</span> a = <span class="fl">+0.0</span> ;</a>
<a class="sourceLine" id="cb484-5" data-line-number="5">    <span class="dt">double</span> b = <span class="fl">-0.0</span> ;</a>
<a class="sourceLine" id="cb484-6" data-line-number="6"></a>
<a class="sourceLine" id="cb484-7" data-line-number="7">    <span class="co">// true</span></a>
<a class="sourceLine" id="cb484-8" data-line-number="8">    <span class="dt">bool</span> c = a == b ;</a>
<a class="sourceLine" id="cb484-9" data-line-number="9">}</a></code></pre></div>
<h3 id="と-無限大">+∞と-∞(無限大)</h3>
<p>IEEE 754の浮動小数点数は正の無限と負の無限を表現できる。</p>
<p>浮動小数点数の値としての無限は、計算の結果として現れるほか、<code>numeric_limits&lt;T&gt;::infinity()</code>を使って取得できる。</p>
<div class="sourceCode" id="cb485"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb485-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb485-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb485-3" data-line-number="3">    <span class="dt">double</span> a = <span class="bu">std::</span>numeric_limits&lt;<span class="dt">double</span>&gt;::infinity() ;</a>
<a class="sourceLine" id="cb485-4" data-line-number="4">    <span class="dt">double</span> b = -<span class="bu">std::</span>numeric_limits&lt;<span class="dt">double</span>&gt;::infinity() ;</a>
<a class="sourceLine" id="cb485-5" data-line-number="5"></a>
<a class="sourceLine" id="cb485-6" data-line-number="6">    <span class="bu">std::</span>cout &lt;&lt; a &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s &lt;&lt; b ;</a>
<a class="sourceLine" id="cb485-7" data-line-number="7">}</a></code></pre></div>
<h3 id="nannot-a-number">NaN(Not a Number)</h3>
<p>NaN(Not a Number)は計算結果が未定義の場合を表現する浮動小数点数の特別な値だ。</p>
<p>計算結果が未定義な場合とは、例えばゼロで除算する場合だ。</p>
<p>値としてのNaNは<code>numeric_limits&lt;T&gt;::quiet_NaN()</code>で取得できる。</p>
<div class="sourceCode" id="cb486"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb486-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb486-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb486-3" data-line-number="3">    <span class="dt">double</span> NaN = <span class="bu">std::</span>numeric_limits&lt;<span class="dt">double</span>&gt;::quiet_NaN() ;</a>
<a class="sourceLine" id="cb486-4" data-line-number="4">    <span class="bu">std::</span>cout &lt;&lt; NaN ;</a>
<a class="sourceLine" id="cb486-5" data-line-number="5">}</a></code></pre></div>
<p>NaNとの比較結果はすべてfalseとなる。</p>
<div class="sourceCode" id="cb487"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb487-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb487-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb487-3" data-line-number="3">    <span class="dt">double</span> NaN = <span class="bu">std::</span>numeric_limits&lt;<span class="dt">double</span>&gt;::quiet_NaN() ;</a>
<a class="sourceLine" id="cb487-4" data-line-number="4"></a>
<a class="sourceLine" id="cb487-5" data-line-number="5">    <span class="co">// すべてfalse</span></a>
<a class="sourceLine" id="cb487-6" data-line-number="6">    <span class="dt">bool</span> a = NaN == <span class="fl">0.0</span> ;</a>
<a class="sourceLine" id="cb487-7" data-line-number="7">    <span class="dt">bool</span> b = NaN != <span class="fl">0.0</span> ;</a>
<a class="sourceLine" id="cb487-8" data-line-number="8">    <span class="dt">bool</span> c = NaN == NaN ;</a>
<a class="sourceLine" id="cb487-9" data-line-number="9">    <span class="dt">bool</span> d = NaN != NaN ;</a>
<a class="sourceLine" id="cb487-10" data-line-number="10">    <span class="dt">bool</span> e = NaN &lt; <span class="fl">0.0</span> ;</a>
<a class="sourceLine" id="cb487-11" data-line-number="11">}</a></code></pre></div>
<p>整数であれば、’a == b’がfalseであるならば、’a != b’なのだと仮定してもよいが、こと浮動小数点数の場合、NaNの存在があるために必ずしもそうとは限らない。上の例でわかるように、NaNとの比較はすべてfalseになる。</p>
<h3 id="有効桁数">有効桁数</h3>
<p>浮動小数点数は正確な値のすべての桁数を表現できない。表現できるのは仮数部が何桁を正確に表現できるかに依存している。この有効桁数は、<code>numeric_limits&lt;T&gt;::digits10</code>で取得できる。</p>
<div class="sourceCode" id="cb488"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb488-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb488-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb488-3" data-line-number="3">    <span class="bu">std::</span>cout</a>
<a class="sourceLine" id="cb488-4" data-line-number="4">        &lt;&lt; <span class="st">&quot;float: &quot;</span>s &lt;&lt; <span class="bu">std::</span>numeric_limits&lt;<span class="dt">float</span>&gt;::digits10 &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s</a>
<a class="sourceLine" id="cb488-5" data-line-number="5">        &lt;&lt; <span class="st">&quot;double: &quot;</span>s &lt;&lt; <span class="bu">std::</span>numeric_limits&lt;<span class="dt">double</span>&gt;::digits10 &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s</a>
<a class="sourceLine" id="cb488-6" data-line-number="6">        &lt;&lt; <span class="st">&quot;long double: &quot;</span>s &lt;&lt; <span class="bu">std::</span>numeric_limits&lt;<span class="dt">long</span> <span class="dt">double</span>&gt;::digits10 &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb488-7" data-line-number="7">}</a></code></pre></div>
<p>浮動小数点数型Tの<code>numeric_limits&lt;T&gt;</code>にはもう一つ、max_digits10がある。これは浮動小数点数を10進数表記にして、その10進数表記を浮動小数点数に戻したときに、浮動小数点数としての値を精度が落ちることなく再現できる桁数のことだ。</p>
<p>もうひとつ興味深い値としては、<code>numeric_limits&lt;T&gt;::epsilon()</code>がある。これは浮動小数点数の1と比較可能な最小の値との差だ。</p>
<div class="sourceCode" id="cb489"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb489-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb489-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb489-3" data-line-number="3">    <span class="bu">std::</span>cout</a>
<a class="sourceLine" id="cb489-4" data-line-number="4">        &lt;&lt; <span class="st">&quot;float: &quot;</span>s &lt;&lt; <span class="bu">std::</span>numeric_limits&lt;<span class="dt">float</span>&gt;::epsilon() &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s</a>
<a class="sourceLine" id="cb489-5" data-line-number="5">        &lt;&lt; <span class="st">&quot;double: &quot;</span>s &lt;&lt; <span class="bu">std::</span>numeric_limits&lt;<span class="dt">double</span>&gt;::epsilon() &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s</a>
<a class="sourceLine" id="cb489-6" data-line-number="6">        &lt;&lt; <span class="st">&quot;long double: &quot;</span>s &lt;&lt; <span class="bu">std::</span>numeric_limits&lt;<span class="dt">long</span> <span class="dt">double</span>&gt;::epsilon() &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb489-7" data-line-number="7">}</a></code></pre></div>
<h2 id="浮動小数点数同士の変換">浮動小数点数同士の変換</h2>
<p>浮動小数点数型は相互に変換できる。変換先の浮動小数点数型が変換元の値を完全に表現できるならばその値に、できないのであれば近い値に変換される。</p>
<div class="sourceCode" id="cb490"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb490-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb490-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb490-3" data-line-number="3">    <span class="dt">double</span> a = <span class="fl">1.23456789</span> ;</a>
<a class="sourceLine" id="cb490-4" data-line-number="4"></a>
<a class="sourceLine" id="cb490-5" data-line-number="5">    <span class="co">// 変換</span></a>
<a class="sourceLine" id="cb490-6" data-line-number="6">    <span class="dt">float</span> b = a ;</a>
<a class="sourceLine" id="cb490-7" data-line-number="7">    <span class="co">// 変換</span></a>
<a class="sourceLine" id="cb490-8" data-line-number="8">    <span class="dt">long</span> <span class="dt">double</span> c = a ;</a>
<a class="sourceLine" id="cb490-9" data-line-number="9">}</a></code></pre></div>
<p>異なる浮動小数点数同士を演算すると、<code>float&lt;double&lt;long double</code>の順で大きい浮動小数点数型に合わせて変換される。</p>
<div class="sourceCode" id="cb491"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb491-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb491-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb491-3" data-line-number="3">    <span class="co">// float</span></a>
<a class="sourceLine" id="cb491-4" data-line-number="4">    <span class="kw">auto</span> a = <span class="fl">1.0f</span> + <span class="fl">1.0f</span> ;</a>
<a class="sourceLine" id="cb491-5" data-line-number="5">    <span class="co">// double</span></a>
<a class="sourceLine" id="cb491-6" data-line-number="6">    <span class="kw">auto</span> b = <span class="fl">1.0f</span> + <span class="fl">1.0</span> ;</a>
<a class="sourceLine" id="cb491-7" data-line-number="7">    <span class="co">// long double</span></a>
<a class="sourceLine" id="cb491-8" data-line-number="8">    <span class="kw">auto</span> c = <span class="fl">1.0f</span> + <span class="fl">1.0l</span> ;</a>
<a class="sourceLine" id="cb491-9" data-line-number="9">}</a></code></pre></div>
<h2 id="浮動小数点数と整数の変換">浮動小数点数と整数の変換</h2>
<p>浮動小数点数型を整数型に変換すると、小数部が切り捨てられる。</p>
<div class="sourceCode" id="cb492"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb492-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb492-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb492-3" data-line-number="3">    <span class="dt">double</span> a = <span class="fl">1.9999</span> ;</a>
<a class="sourceLine" id="cb492-4" data-line-number="4">    <span class="co">// 1</span></a>
<a class="sourceLine" id="cb492-5" data-line-number="5">    <span class="dt">int</span> x = a ;</a>
<a class="sourceLine" id="cb492-6" data-line-number="6">}</a></code></pre></div>
<p>変換元の浮動小数点数から小数部を切り捨てた値が変換先の整数型で表現できなかった場合は、何が起こるかわからない。</p>
<p>整数型を浮動小数点数型に変換すると、変換元の整数の値が変換先の浮動小数点数型で正確に表現できる場合はその値に、そうでない場合は表現できる最も近い値になる。</p>
<div class="sourceCode" id="cb493"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb493-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb493-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb493-3" data-line-number="3">    <span class="dt">int</span> a = <span class="dv">1</span> ;</a>
<a class="sourceLine" id="cb493-4" data-line-number="4">    <span class="co">// 1.0</span></a>
<a class="sourceLine" id="cb493-5" data-line-number="5">    <span class="dt">double</span> b = a ;</a>
<a class="sourceLine" id="cb493-6" data-line-number="6">}</a></code></pre></div>
<p>浮動小数点数と整数を演算した場合、浮動小数点数型になる。</p>
<div class="sourceCode" id="cb494"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb494-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb494-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb494-3" data-line-number="3">    <span class="co">// double</span></a>
<a class="sourceLine" id="cb494-4" data-line-number="4">    <span class="kw">auto</span> a = <span class="fl">1.0</span> + <span class="dv">1</span> ;</a>
<a class="sourceLine" id="cb494-5" data-line-number="5">    <span class="kw">auto</span> b = <span class="dv">1</span> + <span class="fl">1.0</span> ;</a>
<a class="sourceLine" id="cb494-6" data-line-number="6"></a>
<a class="sourceLine" id="cb494-7" data-line-number="7">    <span class="co">// float</span></a>
<a class="sourceLine" id="cb494-8" data-line-number="8">    <span class="kw">auto</span> c = <span class="fl">1.0f</span> + <span class="dv">1</span> ;</a>
<a class="sourceLine" id="cb494-9" data-line-number="9">}</a></code></pre></div>
<h1 id="名前">名前</h1>
<p>プログラミング言語C++には様々な名前が出てくる。変数、関数、型など、さまざまなものに名前がついている。この章では名前について学ぶ。</p>
<h2 id="キーワード">キーワード</h2>
<p>一部の名前はキーワードとして予約され、特別な意味を持つ。キーワードは名前として使うことができない。</p>
<p>キーワードの一覧は以下の通り。</p>
<pre><code>alignas         alignof     asm         auto        bool            break
case            catch       char        char16_t    char32_t        class
concept         const       constexpr   const_cast  continue        decltype
default         delete      do          double      dynamic_cast    else
enum            explicit    export      extern      false           float
for             friend      goto        if          inline          int
long            mutable     namespace   new         noexcept        nullptr
operator        private     protected   public      register        reinterpret_cast
requires        return      short       signed      sizeof          static
static_assert   static_cast struct      switch      template        this
thread_local    throw       true        try         typedef         typeid
typename        union       unsigned    using       virtual         void
volatile        wchar_t     while</code></pre>
<h2 id="名前に使える文字">名前に使える文字</h2>
<p>名前というのは根本的には識別子と呼ばれる文字列でなりたっている。</p>
<p>C++では識別子にラテンアルファベット小文字、大文字、アラビア数字、アンダースコア、を使うことができる。以下がその文字の一覧だ。</p>
<pre><code>a b c d e f g h i j k l m
n o p q r s t u v w x y z
A B C D E F G H I J K L M
N O P Q R S T U V W X Y Z
0 1 2 3 4 5 6 7 8 9
_</code></pre>
<p>小文字と大文字は区別される。名前<code>a</code>と名前<code>A</code>は別の名前だ。</p>
<p>ただし、名前はアラビア数字で始まってはならない。</p>
<div class="sourceCode" id="cb497"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb497-1" data-line-number="1"><span class="dt">int</span> <span class="er">123abc</span> = <span class="dv">0</span> ; <span class="co">// エラー</span></a></code></pre></div>
<p>名前にダブルアンダースコア(<code>__</code>)が含まれているものは予約されているので使ってはならない。ダブルアンダースコアとはアンダースコア文字が2つ連続したものをいう。</p>
<div class="sourceCode" id="cb498"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb498-1" data-line-number="1"><span class="co">// 使ってはならない</span></a>
<a class="sourceLine" id="cb498-2" data-line-number="2"><span class="co">// すべてダブルアンダースコアを含む</span></a>
<a class="sourceLine" id="cb498-3" data-line-number="3"><span class="dt">int</span> __ = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb498-4" data-line-number="4"><span class="dt">int</span> a__ = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb498-5" data-line-number="5"><span class="dt">int</span> __a = <span class="dv">0</span> ;</a></code></pre></div>
<p>アンダースコアに大文字から始まる名前も予約されているので使ってはならない。</p>
<div class="sourceCode" id="cb499"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb499-1" data-line-number="1"><span class="co">// 使ってはならない</span></a>
<a class="sourceLine" id="cb499-2" data-line-number="2"><span class="co">// アンダースコアに大文字から始まる</span></a>
<a class="sourceLine" id="cb499-3" data-line-number="3"><span class="dt">int</span> _A = <span class="dv">0</span> ;</a></code></pre></div>
<p>アンダースコアに小文字から始まる名前もグローバル名前空間で予約されているので使ってはならない。グローバル名前空間についてはこの後説明する。</p>
<div class="sourceCode" id="cb500"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb500-1" data-line-number="1"><span class="co">// 使ってはならない</span></a>
<a class="sourceLine" id="cb500-2" data-line-number="2"><span class="co">// アンダースコアに小文字から始まる</span></a>
<a class="sourceLine" id="cb500-3" data-line-number="3"><span class="dt">int</span> _a = <span class="dv">0</span> ;</a></code></pre></div>
<p>予約されているというのは、C++コンパイラーがその名前をC++の実装のために使うかもしれないということだ。例えばC++コンパイラーは<code>_A</code>という名前を特別な意味を持つものとして使うかもしれないし、その名前の変数や関数をプログラムに追加するかもしれない。</p>
<h2 id="宣言と定義">宣言と定義</h2>
<p>C++では、名前は使う前に宣言しなければならない。</p>
<div class="sourceCode" id="cb501"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb501-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb501-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb501-3" data-line-number="3">    <span class="dt">int</span> x = <span class="dv">0</span> ; <span class="co">// 宣言</span></a>
<a class="sourceLine" id="cb501-4" data-line-number="4">    x = <span class="dv">1</span> ; <span class="co">// 使用</span></a>
<a class="sourceLine" id="cb501-5" data-line-number="5">}</a></code></pre></div>
<p>宣言する前に使うことはできない。</p>
<div class="sourceCode" id="cb502"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb502-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb502-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb502-3" data-line-number="3">    <span class="co">// エラー、名前xは宣言されていない。</span></a>
<a class="sourceLine" id="cb502-4" data-line-number="4">    x = <span class="dv">1</span> ; </a>
<a class="sourceLine" id="cb502-5" data-line-number="5"></a>
<a class="sourceLine" id="cb502-6" data-line-number="6">    <span class="dt">int</span> x = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb502-7" data-line-number="7">}</a></code></pre></div>
<p>C++では多くの名前は宣言と定義に分かれている。宣言と定義の分離は関数が一番わかりやすい。</p>
<div class="sourceCode" id="cb503"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb503-1" data-line-number="1"><span class="co">// 関数の宣言</span></a>
<a class="sourceLine" id="cb503-2" data-line-number="2"><span class="dt">int</span> plus_one( <span class="dt">int</span> x ) ;</a>
<a class="sourceLine" id="cb503-3" data-line-number="3"></a>
<a class="sourceLine" id="cb503-4" data-line-number="4"><span class="co">// 関数の定義</span></a>
<a class="sourceLine" id="cb503-5" data-line-number="5"><span class="dt">int</span> plus_one( <span class="dt">int</span> x ) <span class="co">// 宣言部分</span></a>
<a class="sourceLine" id="cb503-6" data-line-number="6"><span class="co">// 定義部分</span></a>
<a class="sourceLine" id="cb503-7" data-line-number="7"><span class="co">// 関数の本体</span></a>
<a class="sourceLine" id="cb503-8" data-line-number="8">{</a>
<a class="sourceLine" id="cb503-9" data-line-number="9">    <span class="cf">return</span> x + <span class="dv">1</span> ;</a>
<a class="sourceLine" id="cb503-10" data-line-number="10">}</a></code></pre></div>
<p>関数の定義は宣言をかねる。</p>
<p>宣言は何度でも書くことができる。</p>
<div class="sourceCode" id="cb504"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb504-1" data-line-number="1"><span class="dt">int</span> plus_one( <span class="dt">int</span> x ) ; <span class="co">// 初出</span></a>
<a class="sourceLine" id="cb504-2" data-line-number="2"><span class="dt">int</span> plus_one( <span class="dt">int</span> x ) ; <span class="co">// OK</span></a>
<a class="sourceLine" id="cb504-3" data-line-number="3"><span class="dt">int</span> plus_one( <span class="dt">int</span> x ) ; <span class="co">// OK</span></a></code></pre></div>
<p>定義はプログラム中に一度しか書くことができない</p>
<div class="sourceCode" id="cb505"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb505-1" data-line-number="1"><span class="co">// 定義</span></a>
<a class="sourceLine" id="cb505-2" data-line-number="2"><span class="dt">int</span> odr() { }</a>
<a class="sourceLine" id="cb505-3" data-line-number="3"></a>
<a class="sourceLine" id="cb505-4" data-line-number="4"><span class="co">// エラー、定義の重複</span></a>
<a class="sourceLine" id="cb505-5" data-line-number="5"><span class="dt">int</span> odr() { }</a></code></pre></div>
<p>名前を使うのに事前に必要なのは宣言だ。定義は名前を使った後に書いてもよい。</p>
<div class="sourceCode" id="cb506"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb506-1" data-line-number="1"><span class="co">// 宣言</span></a>
<a class="sourceLine" id="cb506-2" data-line-number="2"><span class="dt">int</span> plus_one( <span class="dt">int</span> x ) ;</a>
<a class="sourceLine" id="cb506-3" data-line-number="3"></a>
<a class="sourceLine" id="cb506-4" data-line-number="4"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb506-5" data-line-number="5">{</a>
<a class="sourceLine" id="cb506-6" data-line-number="6">    plus_one( <span class="dv">1</span> ) ;</a>
<a class="sourceLine" id="cb506-7" data-line-number="7">}</a>
<a class="sourceLine" id="cb506-8" data-line-number="8"></a>
<a class="sourceLine" id="cb506-9" data-line-number="9"><span class="co">// 定義</span></a>
<a class="sourceLine" id="cb506-10" data-line-number="10"><span class="dt">int</span> plus_one( <span class="dt">int</span> x )</a>
<a class="sourceLine" id="cb506-11" data-line-number="11">{</a>
<a class="sourceLine" id="cb506-12" data-line-number="12">    <span class="cf">return</span> x + <span class="dv">1</span> ;</a>
<a class="sourceLine" id="cb506-13" data-line-number="13">}</a></code></pre></div>
<p>ほとんどの変数は宣言と定義が同時に行われる。変数でも宣言と定義を分割して行う方法もあるのだが、解説は分割コンパイルの章で行う。</p>
<h2 id="名前空間">名前空間</h2>
<p>本書をここまで読んだ読者は、一部の型名の記述がすこし変なことに気がついているだろう。</p>
<div class="sourceCode" id="cb507"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb507-1" data-line-number="1"><span class="bu">std::</span>string a ;</a>
<a class="sourceLine" id="cb507-2" data-line-number="2"><span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; b ;</a></code></pre></div>
<p>コロンやアングルブラケットは名前に使える文字ではない。信じられない読者は試してみるとよい。</p>
<div class="sourceCode" id="cb508"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb508-1" data-line-number="1"><span class="co">// エラー</span></a>
<a class="sourceLine" id="cb508-2" data-line-number="2"><span class="dt">int</span> :: = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb508-3" data-line-number="3"><span class="dt">int</span> &lt;<span class="dt">int</span>&gt; = <span class="dv">0</span> ;</a></code></pre></div>
<p>莫大なエラーが表示されるだろうが、すでに学んだようにとてもいいことだ。コンパイラーが間違いを見つけてくれたのだから。わからないことがあったらどんどんコンパイルエラーを出すとよい。</p>
<p>実は<code>std</code>というのは名前空間(namespace)の名前だ。ダブルコロン(<code>::</code>)は名前空間を指定する文法だ。</p>
<p>名前空間の文法は以下の通り</p>
<div class="sourceCode" id="cb509"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb509-1" data-line-number="1"><span class="kw">namespace</span> ns {</a>
<a class="sourceLine" id="cb509-2" data-line-number="2"><span class="co">// コード</span></a>
<a class="sourceLine" id="cb509-3" data-line-number="3">}</a></code></pre></div>
<p>名前空間の中の名前を参照するには<code>::</code>を使う。</p>
<div class="sourceCode" id="cb510"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb510-1" data-line-number="1">ns::name ;</a></code></pre></div>
<p>名前空間の中には変数も書ける。この変数は関数の内部に限定されたローカル変数とは違い、どの関数からでも参照できる。</p>
<div class="sourceCode" id="cb511"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb511-1" data-line-number="1"><span class="kw">namespace</span> ns {</a>
<a class="sourceLine" id="cb511-2" data-line-number="2">    <span class="dt">int</span> name{} ;</a>
<a class="sourceLine" id="cb511-3" data-line-number="3">}</a>
<a class="sourceLine" id="cb511-4" data-line-number="4"></a>
<a class="sourceLine" id="cb511-5" data-line-number="5"><span class="dt">int</span> f()</a>
<a class="sourceLine" id="cb511-6" data-line-number="6">{</a>
<a class="sourceLine" id="cb511-7" data-line-number="7">    <span class="cf">return</span> ns::name ;</a>
<a class="sourceLine" id="cb511-8" data-line-number="8">}</a>
<a class="sourceLine" id="cb511-9" data-line-number="9"></a>
<a class="sourceLine" id="cb511-10" data-line-number="10"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb511-11" data-line-number="11">{</a>
<a class="sourceLine" id="cb511-12" data-line-number="12">    ns::name = <span class="dv">1</span> ;</a>
<a class="sourceLine" id="cb511-13" data-line-number="13">}</a></code></pre></div>
<p>名前空間の中で宣言された名前は、名前空間を指定しなければ使えなくなる。</p>
<div class="sourceCode" id="cb512"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb512-1" data-line-number="1"><span class="kw">namespace</span> ns {</a>
<a class="sourceLine" id="cb512-2" data-line-number="2">    <span class="dt">int</span> f() { <span class="cf">return</span> <span class="dv">0</span> ; }</a>
<a class="sourceLine" id="cb512-3" data-line-number="3">}</a>
<a class="sourceLine" id="cb512-4" data-line-number="4"></a>
<a class="sourceLine" id="cb512-5" data-line-number="5"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb512-6" data-line-number="6">{</a>
<a class="sourceLine" id="cb512-7" data-line-number="7">    ns::f() ;</a>
<a class="sourceLine" id="cb512-8" data-line-number="8"></a>
<a class="sourceLine" id="cb512-9" data-line-number="9">    f() ; <span class="co">// エラー</span></a>
<a class="sourceLine" id="cb512-10" data-line-number="10">}</a></code></pre></div>
<p>異なる名前空間名の下の名前は別の名前になる。</p>
<div class="sourceCode" id="cb513"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb513-1" data-line-number="1"><span class="kw">namespace</span> a {</a>
<a class="sourceLine" id="cb513-2" data-line-number="2">    <span class="dt">int</span> f() { <span class="cf">return</span> <span class="dv">0</span> ; }</a>
<a class="sourceLine" id="cb513-3" data-line-number="3">}</a>
<a class="sourceLine" id="cb513-4" data-line-number="4"></a>
<a class="sourceLine" id="cb513-5" data-line-number="5"></a>
<a class="sourceLine" id="cb513-6" data-line-number="6"><span class="kw">namespace</span> b {</a>
<a class="sourceLine" id="cb513-7" data-line-number="7">    <span class="dt">int</span> f() { <span class="cf">return</span> <span class="dv">1</span> ; }</a>
<a class="sourceLine" id="cb513-8" data-line-number="8">}</a>
<a class="sourceLine" id="cb513-9" data-line-number="9"></a>
<a class="sourceLine" id="cb513-10" data-line-number="10"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb513-11" data-line-number="11">{</a>
<a class="sourceLine" id="cb513-12" data-line-number="12">    a::f() ; <span class="co">// 0</span></a>
<a class="sourceLine" id="cb513-13" data-line-number="13">    b::f() ; <span class="co">// 1</span></a>
<a class="sourceLine" id="cb513-14" data-line-number="14">}</a></code></pre></div>
<p>これだけを見ると、名前空間というのはわざわざ名前空間名を指定しなければ使えない面倒な機能に見えるだろう。名前空間の価値は複数人で同じプログラムのソースファイルを編集するときに出てくる。</p>
<p>例えば、アリスとボブがプログラムを共同で開発しているとする。あるプログラムのソースファイル<code>f</code>という名前の関数を書いたとする。ここで、同じプログラムを共同開発している他人も<code>func</code>という名前の関数を書いたらどうなるか。</p>
<div class="sourceCode" id="cb514"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb514-1" data-line-number="1"><span class="co">// アリスの書いた関数f</span></a>
<a class="sourceLine" id="cb514-2" data-line-number="2"><span class="dt">int</span> f() { <span class="cf">return</span> <span class="dv">0</span> ; }</a>
<a class="sourceLine" id="cb514-3" data-line-number="3"></a>
<a class="sourceLine" id="cb514-4" data-line-number="4"><span class="co">// ボブの書いた関数f</span></a>
<a class="sourceLine" id="cb514-5" data-line-number="5"><span class="dt">int</span> f() { <span class="cf">return</span> <span class="dv">1</span> ; }</a></code></pre></div>
<p>すでに宣言と定義で学んだように、このコードはエラーになる。なぜならば、同じ名前に対して定義が2つあるからだ。</p>
<p>名前空間なしでこの問題を解決するためはに、アリスとボブが事前の申し合わせて、名前が衝突しないように調整する必要がある。</p>
<p>しかし名前空間があるC++では、そのような面倒な調整は必要がない。アリスとボブが別の名前空間を使えばいいのだ。</p>
<div class="sourceCode" id="cb515"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb515-1" data-line-number="1"><span class="co">// アリスの名前空間</span></a>
<a class="sourceLine" id="cb515-2" data-line-number="2"><span class="kw">namespace</span> alice {</a>
<a class="sourceLine" id="cb515-3" data-line-number="3">    <span class="co">// アリスの書いた関数f</span></a>
<a class="sourceLine" id="cb515-4" data-line-number="4">    <span class="dt">int</span> f() { <span class="cf">return</span> <span class="dv">0</span> ; }</a>
<a class="sourceLine" id="cb515-5" data-line-number="5">}</a>
<a class="sourceLine" id="cb515-6" data-line-number="6"></a>
<a class="sourceLine" id="cb515-7" data-line-number="7"><span class="co">// ボブの名前空間</span></a>
<a class="sourceLine" id="cb515-8" data-line-number="8"><span class="kw">namespace</span> bob {</a>
<a class="sourceLine" id="cb515-9" data-line-number="9">    <span class="co">// ボブの書いた関数f</span></a>
<a class="sourceLine" id="cb515-10" data-line-number="10">    <span class="dt">int</span> f() { <span class="cf">return</span> <span class="dv">1</span> ; }</a>
<a class="sourceLine" id="cb515-11" data-line-number="11">}</a></code></pre></div>
<p><code>alice::f</code>と<code>bob::f</code>は別の名前なので定義の衝突は起こらない。</p>
<h3 id="グローバル名前空間">グローバル名前空間</h3>
<p>名前空間に包まれていないソースファイルのトップレベルの場所は、実はグローバル名前空間(global name space)という名前のない名前空間で包まれているという扱いになっている。</p>
<div class="sourceCode" id="cb516"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb516-1" data-line-number="1"><span class="co">// グローバル名前空間</span></a>
<a class="sourceLine" id="cb516-2" data-line-number="2"><span class="dt">int</span> f() { <span class="cf">return</span> <span class="dv">0</span> ; }</a>
<a class="sourceLine" id="cb516-3" data-line-number="3"></a>
<a class="sourceLine" id="cb516-4" data-line-number="4"><span class="kw">namespace</span> ns {</a>
<a class="sourceLine" id="cb516-5" data-line-number="5">    <span class="dt">int</span> f() { <span class="cf">return</span> <span class="dv">1</span> ; }</a>
<a class="sourceLine" id="cb516-6" data-line-number="6">}</a>
<a class="sourceLine" id="cb516-7" data-line-number="7"></a>
<a class="sourceLine" id="cb516-8" data-line-number="8"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb516-9" data-line-number="9">{</a>
<a class="sourceLine" id="cb516-10" data-line-number="10">    f() ; <span class="co">// 0</span></a>
<a class="sourceLine" id="cb516-11" data-line-number="11">    ns::f() ; <span class="co">// 1</span></a>
<a class="sourceLine" id="cb516-12" data-line-number="12">}</a></code></pre></div>
<p>グローバル名前空間は名前の指定のない単なる<code>::</code>で指定することもできる。</p>
<div class="sourceCode" id="cb517"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb517-1" data-line-number="1"><span class="dt">int</span> x { } ;</a>
<a class="sourceLine" id="cb517-2" data-line-number="2"></a>
<a class="sourceLine" id="cb517-3" data-line-number="3"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb517-4" data-line-number="4">{</a>
<a class="sourceLine" id="cb517-5" data-line-number="5">    x ; <span class="co">// ::xと同じ</span></a>
<a class="sourceLine" id="cb517-6" data-line-number="6">    ::x ;</a>
<a class="sourceLine" id="cb517-7" data-line-number="7">}</a></code></pre></div>
<p>すでに名前空間の中では変数を宣言できることは学んだ。グローバル名前空間は名前空間なので同じように変数を宣言できる。</p>
<p>main関数はグローバル名前空間に存在しなければならない。</p>
<div class="sourceCode" id="cb518"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb518-1" data-line-number="1"><span class="co">// グローバル名前空間</span></a>
<a class="sourceLine" id="cb518-2" data-line-number="2"><span class="dt">int</span> main() { }</a></code></pre></div>
<h3 id="名前空間のネスト">名前空間のネスト</h3>
<p>名前空間の中に名前空間を書くことができる。</p>
<div class="sourceCode" id="cb519"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb519-1" data-line-number="1"><span class="kw">namespace</span> A { <span class="kw">namespace</span> B { <span class="kw">namespace</span> C {</a>
<a class="sourceLine" id="cb519-2" data-line-number="2">    <span class="dt">int</span> name {} ;</a>
<a class="sourceLine" id="cb519-3" data-line-number="3">} } }</a>
<a class="sourceLine" id="cb519-4" data-line-number="4"></a>
<a class="sourceLine" id="cb519-5" data-line-number="5"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb519-6" data-line-number="6">{</a>
<a class="sourceLine" id="cb519-7" data-line-number="7">    A::B::C::name = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb519-8" data-line-number="8">}</a></code></pre></div>
<p>名前空間のネストは省略して書くこともできる。</p>
<div class="sourceCode" id="cb520"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb520-1" data-line-number="1"><span class="kw">namespace</span> A::B::C {</a>
<a class="sourceLine" id="cb520-2" data-line-number="2">    <span class="dt">int</span> name { } ;</a>
<a class="sourceLine" id="cb520-3" data-line-number="3">}</a>
<a class="sourceLine" id="cb520-4" data-line-number="4"></a>
<a class="sourceLine" id="cb520-5" data-line-number="5"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb520-6" data-line-number="6">{</a>
<a class="sourceLine" id="cb520-7" data-line-number="7">    A::B::C::name = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb520-8" data-line-number="8">}</a></code></pre></div>
<h3 id="名前空間名の別名を宣言する名前空間エイリアス">名前空間名の別名を宣言する名前空間エイリアス</h3>
<p>名前空間名には別名をつけることができる。これを名前空間エイリアスと呼ぶ。</p>
<p>たとえば名前空間名が重複することを恐れるあまり、とても長い名前空間名を付けたライブラリがあるとする。</p>
<div class="sourceCode" id="cb521"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb521-1" data-line-number="1"><span class="kw">namespace</span> very_long_name {</a>
<a class="sourceLine" id="cb521-2" data-line-number="2">    <span class="dt">int</span> f() { <span class="cf">return</span> <span class="dv">0</span> ; }</a>
<a class="sourceLine" id="cb521-3" data-line-number="3">}</a>
<a class="sourceLine" id="cb521-4" data-line-number="4"></a>
<a class="sourceLine" id="cb521-5" data-line-number="5"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb521-6" data-line-number="6">{</a>
<a class="sourceLine" id="cb521-7" data-line-number="7">    very_long_name::f() ;</a>
<a class="sourceLine" id="cb521-8" data-line-number="8">}</a></code></pre></div>
<p>この関数fを使うために毎回<code>very_long_name::f</code>と書くのは面倒だ。こういうときには名前空間エイリアスを使うとよい。名前空間エイリアスは名前空間名の別名を宣言できる。</p>
<pre><code>namespace 別名 = 名前空間名 ;</code></pre>
<p>使い方。</p>
<div class="sourceCode" id="cb523"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb523-1" data-line-number="1"><span class="kw">namespace</span> very_long_name {</a>
<a class="sourceLine" id="cb523-2" data-line-number="2">    <span class="dt">int</span> f() { <span class="cf">return</span> <span class="dv">0</span> ; }</a>
<a class="sourceLine" id="cb523-3" data-line-number="3">}</a>
<a class="sourceLine" id="cb523-4" data-line-number="4"></a>
<a class="sourceLine" id="cb523-5" data-line-number="5"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb523-6" data-line-number="6">{</a>
<a class="sourceLine" id="cb523-7" data-line-number="7">    <span class="co">// 名前空間エイリアス</span></a>
<a class="sourceLine" id="cb523-8" data-line-number="8">    <span class="kw">namespace</span> vln = very_long_name ;</a>
<a class="sourceLine" id="cb523-9" data-line-number="9">    <span class="co">// vlnはvery_long_nameのエイリアス</span></a>
<a class="sourceLine" id="cb523-10" data-line-number="10">    vln::f() ;</a>
<a class="sourceLine" id="cb523-11" data-line-number="11">}</a></code></pre></div>
<p>名前空間エイリアスは元の名前空間名と同じように使える。意味も同じだ。</p>
<p>名前空間エイリアスはネストされた名前空間にも使える。</p>
<div class="sourceCode" id="cb524"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb524-1" data-line-number="1"><span class="kw">namespace</span> A::B::C {</a>
<a class="sourceLine" id="cb524-2" data-line-number="2">    <span class="dt">int</span> f() { <span class="cf">return</span> <span class="dv">0</span> ; }</a>
<a class="sourceLine" id="cb524-3" data-line-number="3">}</a>
<a class="sourceLine" id="cb524-4" data-line-number="4"></a>
<a class="sourceLine" id="cb524-5" data-line-number="5"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb524-6" data-line-number="6">{</a>
<a class="sourceLine" id="cb524-7" data-line-number="7">    <span class="kw">namespace</span> D = A::B::C ;</a>
<a class="sourceLine" id="cb524-8" data-line-number="8">    <span class="co">// DはA::B::Cのエイリアス</span></a>
<a class="sourceLine" id="cb524-9" data-line-number="9">    D::f() ;</a>
<a class="sourceLine" id="cb524-10" data-line-number="10">}</a></code></pre></div>
<p>名前空間エイリアスを関数の中で宣言すると、その関数の中でだけ有効になる。</p>
<div class="sourceCode" id="cb525"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb525-1" data-line-number="1"><span class="kw">namespace</span> A { <span class="dt">int</span> x { } ; }</a>
<a class="sourceLine" id="cb525-2" data-line-number="2"></a>
<a class="sourceLine" id="cb525-3" data-line-number="3"><span class="dt">int</span> f()</a>
<a class="sourceLine" id="cb525-4" data-line-number="4">{</a>
<a class="sourceLine" id="cb525-5" data-line-number="5">    <span class="co">// Bの宣言</span></a>
<a class="sourceLine" id="cb525-6" data-line-number="6">    <span class="kw">namespace</span> B = A ;</a>
<a class="sourceLine" id="cb525-7" data-line-number="7">    <span class="co">// OK、Bは宣言されている</span></a>
<a class="sourceLine" id="cb525-8" data-line-number="8">    <span class="cf">return</span> B::x ;</a>
<a class="sourceLine" id="cb525-9" data-line-number="9">}</a>
<a class="sourceLine" id="cb525-10" data-line-number="10"></a>
<a class="sourceLine" id="cb525-11" data-line-number="11"><span class="dt">int</span> g()</a>
<a class="sourceLine" id="cb525-12" data-line-number="12">{</a>
<a class="sourceLine" id="cb525-13" data-line-number="13">    <span class="co">// エラー、Bは宣言されていない</span></a>
<a class="sourceLine" id="cb525-14" data-line-number="14">    <span class="cf">return</span> B::x ;</a>
<a class="sourceLine" id="cb525-15" data-line-number="15">}</a></code></pre></div>
<p>名前空間エイリアスを名前空間の中で宣言すると、宣言以降の名前空間内で有効になる。</p>
<div class="sourceCode" id="cb526"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb526-1" data-line-number="1"><span class="kw">namespace</span> ns {</a>
<a class="sourceLine" id="cb526-2" data-line-number="2">    <span class="kw">namespace</span> A { <span class="dt">int</span> x { } ; }</a>
<a class="sourceLine" id="cb526-3" data-line-number="3">    <span class="kw">namespace</span> B = A ;</a>
<a class="sourceLine" id="cb526-4" data-line-number="4"></a>
<a class="sourceLine" id="cb526-5" data-line-number="5">    <span class="co">// OK</span></a>
<a class="sourceLine" id="cb526-6" data-line-number="6">    <span class="dt">int</span> f(){ <span class="cf">return</span> B::x ; }</a>
<a class="sourceLine" id="cb526-7" data-line-number="7">    <span class="co">// OK</span></a>
<a class="sourceLine" id="cb526-8" data-line-number="8">    <span class="dt">int</span> g(){ <span class="cf">return</span> B::x ; }</a>
<a class="sourceLine" id="cb526-9" data-line-number="9"></a>
<a class="sourceLine" id="cb526-10" data-line-number="10">} <span class="co">// end namespace ns</span></a>
<a class="sourceLine" id="cb526-11" data-line-number="11"></a>
<a class="sourceLine" id="cb526-12" data-line-number="12"><span class="co">// エラー、Bは宣言されていない</span></a>
<a class="sourceLine" id="cb526-13" data-line-number="13"><span class="dt">int</span> h(){ <span class="cf">return</span> B::x ; }</a></code></pre></div>
<p>グローバル名前空間は名前空間なので、名前空間エイリアスを宣言できる。</p>
<div class="sourceCode" id="cb527"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb527-1" data-line-number="1"><span class="kw">namespace</span> long_name_is_loooong { }</a>
<a class="sourceLine" id="cb527-2" data-line-number="2"><span class="kw">namespace</span> cat = long_name_is_loooong ;</a></code></pre></div>
<h3 id="名前空間名の指定を省略するusingディレクティブ">名前空間名の指定を省略するusingディレクティブ</h3>
<p>名前空間は名前の衝突を防ぐ機能だが、名前空間名をわざわざ指定するのは面倒だ。</p>
<div class="sourceCode" id="cb528"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb528-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb528-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb528-3" data-line-number="3">    <span class="co">// std名前空間のstring</span></a>
<a class="sourceLine" id="cb528-4" data-line-number="4">    <span class="bu">std::</span>string s ;</a>
<a class="sourceLine" id="cb528-5" data-line-number="5">    <span class="co">// std名前空間のvector&lt;int&gt;</span></a>
<a class="sourceLine" id="cb528-6" data-line-number="6">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v ;</a>
<a class="sourceLine" id="cb528-7" data-line-number="7"></a>
<a class="sourceLine" id="cb528-8" data-line-number="8">    <span class="co">// std名前空間のcout</span></a>
<a class="sourceLine" id="cb528-9" data-line-number="9">    <span class="bu">std::</span>cout &lt;&lt; <span class="dv">123</span> ;</a>
<a class="sourceLine" id="cb528-10" data-line-number="10">}</a></code></pre></div>
<p>もし自分のソースファイルが<code>string</code>, <code>vector&lt;int&gt;</code>, <code>cout</code>、その他std名前空間で使われる名前を一切使っていない場合、名前の衝突は発生しないことになる。その場合でも名前空間名を指定しなければならないのは面倒だ。</p>
<p>C++では指定した名前空間を省略できる機能が存在する。usingディレクティブだ。</p>
<pre><code>using namespace 名前空間名 ;</code></pre>
<p>これを使えば、先程のコードは以下のように書ける。</p>
<div class="sourceCode" id="cb530"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb530-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb530-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb530-3" data-line-number="3">    <span class="kw">using</span> <span class="kw">namespace</span> std ;</a>
<a class="sourceLine" id="cb530-4" data-line-number="4">    <span class="co">// std名前空間のstring</span></a>
<a class="sourceLine" id="cb530-5" data-line-number="5">    string s ;</a>
<a class="sourceLine" id="cb530-6" data-line-number="6">    <span class="co">// std名前空間のvector&lt;int&gt;</span></a>
<a class="sourceLine" id="cb530-7" data-line-number="7">    vector&lt;<span class="dt">int</span>&gt; v ;</a>
<a class="sourceLine" id="cb530-8" data-line-number="8"></a>
<a class="sourceLine" id="cb530-9" data-line-number="9">    <span class="co">// std名前空間のcout</span></a>
<a class="sourceLine" id="cb530-10" data-line-number="10">    cout &lt;&lt; <span class="dv">123</span> ;</a>
<a class="sourceLine" id="cb530-11" data-line-number="11">}</a></code></pre></div>
<p>では名前が衝突した場合はどうなるのか。</p>
<div class="sourceCode" id="cb531"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb531-1" data-line-number="1"><span class="kw">namespace</span> abc {</a>
<a class="sourceLine" id="cb531-2" data-line-number="2">    <span class="dt">int</span> f() { <span class="cf">return</span> <span class="dv">0</span> ; }</a>
<a class="sourceLine" id="cb531-3" data-line-number="3">}</a>
<a class="sourceLine" id="cb531-4" data-line-number="4"></a>
<a class="sourceLine" id="cb531-5" data-line-number="5"><span class="dt">int</span> f() { <span class="cf">return</span> <span class="dv">1</span> ; }</a>
<a class="sourceLine" id="cb531-6" data-line-number="6"></a>
<a class="sourceLine" id="cb531-7" data-line-number="7"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb531-8" data-line-number="8">{</a>
<a class="sourceLine" id="cb531-9" data-line-number="9">    <span class="kw">using</span> <span class="kw">namespace</span> std ;</a>
<a class="sourceLine" id="cb531-10" data-line-number="10"></a>
<a class="sourceLine" id="cb531-11" data-line-number="11">    <span class="co">// エラー、名前が曖昧</span></a>
<a class="sourceLine" id="cb531-12" data-line-number="12">    f() ;</a>
<a class="sourceLine" id="cb531-13" data-line-number="13">}</a></code></pre></div>
<p>名前<code>f</code>に対してどの名前を使用するのか曖昧になってエラーになる。このエラーを回避するためには、名前空間を直接指定する。</p>
<div class="sourceCode" id="cb532"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb532-1" data-line-number="1"><span class="kw">namespace</span> abc {</a>
<a class="sourceLine" id="cb532-2" data-line-number="2">    <span class="dt">int</span> f() { <span class="cf">return</span> <span class="dv">0</span> ; }</a>
<a class="sourceLine" id="cb532-3" data-line-number="3">}</a>
<a class="sourceLine" id="cb532-4" data-line-number="4"></a>
<a class="sourceLine" id="cb532-5" data-line-number="5"><span class="dt">int</span> f() { <span class="cf">return</span> <span class="dv">1</span> ; }</a>
<a class="sourceLine" id="cb532-6" data-line-number="6"></a>
<a class="sourceLine" id="cb532-7" data-line-number="7"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb532-8" data-line-number="8">{</a>
<a class="sourceLine" id="cb532-9" data-line-number="9">    <span class="kw">using</span> <span class="kw">namespace</span> std ;</a>
<a class="sourceLine" id="cb532-10" data-line-number="10"></a>
<a class="sourceLine" id="cb532-11" data-line-number="11">    <span class="co">// OK、名前空間abcのf</span></a>
<a class="sourceLine" id="cb532-12" data-line-number="12">    abc::f() ;</a>
<a class="sourceLine" id="cb532-13" data-line-number="13"></a>
<a class="sourceLine" id="cb532-14" data-line-number="14">    <span class="co">// OK、グローバル名前空間のf</span></a>
<a class="sourceLine" id="cb532-15" data-line-number="15">    ::f() ;</a>
<a class="sourceLine" id="cb532-16" data-line-number="16">}</a></code></pre></div>
<p>usingディレクティブは関数の中だけではなく、名前空間の中にも書ける。</p>
<div class="sourceCode" id="cb533"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb533-1" data-line-number="1"><span class="kw">namespace</span> A {</a>
<a class="sourceLine" id="cb533-2" data-line-number="2">    <span class="dt">int</span> f(){ <span class="cf">return</span> <span class="dv">0</span> ; }</a>
<a class="sourceLine" id="cb533-3" data-line-number="3">}</a>
<a class="sourceLine" id="cb533-4" data-line-number="4"></a>
<a class="sourceLine" id="cb533-5" data-line-number="5"><span class="kw">namespace</span> B {</a>
<a class="sourceLine" id="cb533-6" data-line-number="6">    <span class="kw">using</span> <span class="kw">namespace</span> A ;</a>
<a class="sourceLine" id="cb533-7" data-line-number="7">    <span class="dt">int</span> g()</a>
<a class="sourceLine" id="cb533-8" data-line-number="8">    {</a>
<a class="sourceLine" id="cb533-9" data-line-number="9">        <span class="co">// OK、A::f</span></a>
<a class="sourceLine" id="cb533-10" data-line-number="10">        f() ;</a>
<a class="sourceLine" id="cb533-11" data-line-number="11">    }</a>
<a class="sourceLine" id="cb533-12" data-line-number="12">}</a></code></pre></div>
<p>名前空間のなかにusingディレクティブを書くと、その名前空間の中では指定した名前空間を省略できる。</p>
<p>グローバル名前空間は名前空間なのでusingディレクティブが書ける。</p>
<div class="sourceCode" id="cb534"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb534-1" data-line-number="1"><span class="kw">using</span> <span class="kw">namespace</span> std ;</a></code></pre></div>
<p>ただし、グローバル名前空間の中にusingディレクティブを書くと、それ以降全ての箇所で指定した名前空間の省略ができてしまうので注意が必要だ。</p>
<h3 id="名前空間を指定しなくてもよいinline名前空間">名前空間を指定しなくてもよいinline名前空間</h3>
<p><code>inline名前空間</code>は<code>inline namespace</code>で定義する。</p>
<pre><code>inline namespace name { }</code></pre>
<p>inline名前空間内の名前は名前空間名を指定して使うこともできるし、名前空間を指定せずとも使うことができる。</p>
<div class="sourceCode" id="cb536"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb536-1" data-line-number="1"><span class="kw">inline</span> <span class="kw">namespace</span> A {</a>
<a class="sourceLine" id="cb536-2" data-line-number="2">    <span class="dt">int</span> a { } ;</a>
<a class="sourceLine" id="cb536-3" data-line-number="3">}</a>
<a class="sourceLine" id="cb536-4" data-line-number="4"></a>
<a class="sourceLine" id="cb536-5" data-line-number="5"><span class="kw">namespace</span> B {</a>
<a class="sourceLine" id="cb536-6" data-line-number="6">    <span class="dt">int</span> b { } ;</a>
<a class="sourceLine" id="cb536-7" data-line-number="7">}</a>
<a class="sourceLine" id="cb536-8" data-line-number="8"></a>
<a class="sourceLine" id="cb536-9" data-line-number="9"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb536-10" data-line-number="10">{</a>
<a class="sourceLine" id="cb536-11" data-line-number="11">    a = <span class="dv">0</span> ;     <span class="co">// A::a</span></a>
<a class="sourceLine" id="cb536-12" data-line-number="12">    A::a = <span class="dv">0</span> ;  <span class="co">// A::a</span></a>
<a class="sourceLine" id="cb536-13" data-line-number="13"></a>
<a class="sourceLine" id="cb536-14" data-line-number="14">    b = <span class="dv">0</span> ;     <span class="co">// エラー、名前bは宣言されていない</span></a>
<a class="sourceLine" id="cb536-15" data-line-number="15">    B::b = <span class="dv">0</span> ;  <span class="co">// B::b</span></a>
<a class="sourceLine" id="cb536-16" data-line-number="16">}</a></code></pre></div>
<p>読者がinline名前空間を使うことはほとんど無いだろうが、ライブラリのソースファイルを読むときには出てくるだろう。</p>
<h2 id="型名">型名</h2>
<p>型名とは型を表す名前だ。</p>
<p>型名はintやdoubleのように言語組み込みのキーワードを使うこともあれば、独自に作った型名を使うこともある。この独自に作った型名を専門用語ではユーザー定義された型(user-defined type)という。ユーザー定義された型を作る方法は様々だ。具体的に説明するのは本書のだいぶ後の方になるだろう。例としては、<code>std::string</code>や<code>std::vector&lt;T&gt;</code>がある。標準ライブラリによってユーザー定義された型だ。</p>
<div class="sourceCode" id="cb537"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb537-1" data-line-number="1"><span class="co">// 組み込みの型名</span></a>
<a class="sourceLine" id="cb537-2" data-line-number="2"><span class="dt">int</span> i = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb537-3" data-line-number="3"><span class="dt">double</span> d = <span class="fl">0.0</span> ;</a>
<a class="sourceLine" id="cb537-4" data-line-number="4"></a>
<a class="sourceLine" id="cb537-5" data-line-number="5"><span class="co">// ユーザー定義された型名</span></a>
<a class="sourceLine" id="cb537-6" data-line-number="6"><span class="bu">std::</span>string s ;</a>
<a class="sourceLine" id="cb537-7" data-line-number="7"><span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v ;</a></code></pre></div>
<h3 id="型名の別名を宣言するエイリアス宣言">型名の別名を宣言するエイリアス宣言</h3>
<p>長い名前空間名を書くのが煩わしいように、長い型名を書くのも煩わしい。名前空間名の別名を宣言できるように、型名も別名を宣言できる。</p>
<p>型名の別名を宣言するにはエイリアス宣言を使う。</p>
<pre><code>using 別名 = 型名 ;</code></pre>
<p>使い方。</p>
<div class="sourceCode" id="cb539"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb539-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb539-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb539-3" data-line-number="3">    <span class="co">// エイリアス宣言</span></a>
<a class="sourceLine" id="cb539-4" data-line-number="4">    <span class="kw">using</span> Number = <span class="dt">int</span> ;</a>
<a class="sourceLine" id="cb539-5" data-line-number="5"></a>
<a class="sourceLine" id="cb539-6" data-line-number="6">    <span class="co">// Numberはintの別名</span></a>
<a class="sourceLine" id="cb539-7" data-line-number="7">    Number x = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb539-8" data-line-number="8">}</a></code></pre></div>
<p>型名の別名は型名と同じように使える。意味も同じだ。</p>
<p>歴史的な経緯により、エイリアス宣言による型名の別名のことを、typedef名(typedef name)という。これはtypedef名を宣言する文法が、かつてはtypedefキーワードを使ったものだったからだ。typedefキーワードを使ったtypedef名の宣言方法は、昔のコードによく出てくるので現代でも覚えておく必要はある。</p>
<pre><code>typedef 型名 typedef名 ;</code></pre>
<p>使い方。</p>
<div class="sourceCode" id="cb541"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb541-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb541-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb541-3" data-line-number="3">    <span class="co">// typedef名による型名の宣言</span></a>
<a class="sourceLine" id="cb541-4" data-line-number="4">    <span class="kw">typedef</span> <span class="dt">int</span> Number ;</a>
<a class="sourceLine" id="cb541-5" data-line-number="5"></a>
<a class="sourceLine" id="cb541-6" data-line-number="6">    Number x = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb541-7" data-line-number="7">}</a></code></pre></div>
<p>これは変数の宣言と同じ文法だ。変数の宣言が以下のような文法で、</p>
<pre><code>型名 変数名 ;</code></pre>
<p>これにtypedefキーワードを使えばtypedef名の宣言になる。</p>
<p>しかしtypedefキーワードによるtypedef名の宣言は罠が多い。例えば熟練のC++プログラマーでも、以下のコードが合法だということに驚くだろう。</p>
<div class="sourceCode" id="cb543"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb543-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb543-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb543-3" data-line-number="3">    <span class="dt">int</span> <span class="kw">typedef</span> Number ;</a>
<a class="sourceLine" id="cb543-4" data-line-number="4">    Number x = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb543-5" data-line-number="5">}</a></code></pre></div>
<p>しかし本書ではまだ教えていない複雑な型名について、このようなコードを書こうとするとコンパイルエラーになることに熟練のC++プログラマーは気がつくはずだ。その理由はとても難しい。</p>
<p>エイリアス宣言にはこのような罠はない。</p>
<h2 id="スコープ">スコープ</h2>
<p>スコープ(scope)というのはやや説明が難しい概念だ。名前空間や関数はスコープを持っている。とてもおおざっぱに説明するとカーリブラケット<code>{}</code>で囲まれた範囲がスコープだ。</p>
<div class="sourceCode" id="cb544"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb544-1" data-line-number="1"><span class="kw">namespace</span> ns</a>
<a class="sourceLine" id="cb544-2" data-line-number="2">{ <span class="co">// 名前空間スコープの始まり</span></a>
<a class="sourceLine" id="cb544-3" data-line-number="3">} <span class="co">// 関数スコープの終わり</span></a>
<a class="sourceLine" id="cb544-4" data-line-number="4"></a>
<a class="sourceLine" id="cb544-5" data-line-number="5"><span class="dt">void</span> f()</a>
<a class="sourceLine" id="cb544-6" data-line-number="6">{ <span class="co">// 関数スコープの始まり</span></a>
<a class="sourceLine" id="cb544-7" data-line-number="7"></a>
<a class="sourceLine" id="cb544-8" data-line-number="8">} <span class="co">// 関数スコープの終わり</span></a></code></pre></div>
<p>これとは別にブロック文のスコープもある。ブロックとは関数の中で複数の文をたばねて一つの文として扱う機能だ。覚えているだろうか。</p>
<div class="sourceCode" id="cb545"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb545-1" data-line-number="1"><span class="dt">void</span> f()</a>
<a class="sourceLine" id="cb545-2" data-line-number="2">{ <span class="co">// 関数スコープ</span></a>
<a class="sourceLine" id="cb545-3" data-line-number="3"></a>
<a class="sourceLine" id="cb545-4" data-line-number="4">    { <span class="co">// 外側のブロックスコープ</span></a>
<a class="sourceLine" id="cb545-5" data-line-number="5">        { <span class="co">// 内側のブロックスコープ</span></a>
<a class="sourceLine" id="cb545-6" data-line-number="6">        }</a>
<a class="sourceLine" id="cb545-7" data-line-number="7">    }</a>
<a class="sourceLine" id="cb545-8" data-line-number="8">}</a></code></pre></div>
<p>スコープは<code>{</code>に始まり<code>}</code>に終わる。</p>
<p>なぜスコープという概念について説明したかと言うと、宣言された名前が有効な範囲は、宣言された最も内側のスコープの範囲だからだ。</p>
<div class="sourceCode" id="cb546"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb546-1" data-line-number="1"><span class="kw">namespace</span> ns</a>
<a class="sourceLine" id="cb546-2" data-line-number="2">{<span class="co">// aの所属するスコープ</span></a>
<a class="sourceLine" id="cb546-3" data-line-number="3">    <span class="dt">int</span> a {} ;</a>
<a class="sourceLine" id="cb546-4" data-line-number="4"></a>
<a class="sourceLine" id="cb546-5" data-line-number="5">    <span class="dt">void</span> f()</a>
<a class="sourceLine" id="cb546-6" data-line-number="6">    { <span class="co">// bの所属するスコープ</span></a>
<a class="sourceLine" id="cb546-7" data-line-number="7">        <span class="dt">int</span> b {} ;</a>
<a class="sourceLine" id="cb546-8" data-line-number="8"></a>
<a class="sourceLine" id="cb546-9" data-line-number="9">        { <span class="co">// cの所属するスコープ</span></a>
<a class="sourceLine" id="cb546-10" data-line-number="10">            <span class="dt">int</span> c {} ;</a>
<a class="sourceLine" id="cb546-11" data-line-number="11">        }<span class="co">// cの範囲終わり</span></a>
<a class="sourceLine" id="cb546-12" data-line-number="12"></a>
<a class="sourceLine" id="cb546-13" data-line-number="13">        </a>
<a class="sourceLine" id="cb546-14" data-line-number="14">    }<span class="co">// bの範囲終わり</span></a>
<a class="sourceLine" id="cb546-15" data-line-number="15"></a>
<a class="sourceLine" id="cb546-16" data-line-number="16">} <span class="co">// aの範囲終わり</span></a></code></pre></div>
<p>名前が有効な範囲は、宣言された最も内側のスコープだ。</p>
<p>外側のスコープで宣言された名前は内側のスコープで使える。</p>
<div class="sourceCode" id="cb547"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb547-1" data-line-number="1"><span class="dt">void</span> f()</a>
<a class="sourceLine" id="cb547-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb547-3" data-line-number="3">    <span class="dt">int</span> a {} ;</a>
<a class="sourceLine" id="cb547-4" data-line-number="4">    {<span class="co">// 新たなスコープ</span></a>
<a class="sourceLine" id="cb547-5" data-line-number="5">        a = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb547-6" data-line-number="6">    }</a>
<a class="sourceLine" id="cb547-7" data-line-number="7">}</a></code></pre></div>
<p>その逆はできない。</p>
<div class="sourceCode" id="cb548"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb548-1" data-line-number="1"><span class="dt">void</span> f()</a>
<a class="sourceLine" id="cb548-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb548-3" data-line-number="3">    { <span class="dt">int</span> a {} ; }</a>
<a class="sourceLine" id="cb548-4" data-line-number="4">    <span class="co">// エラー</span></a>
<a class="sourceLine" id="cb548-5" data-line-number="5">    a = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb548-6" data-line-number="6">}</a></code></pre></div>
<p>名前空間も同じだ。</p>
<div class="sourceCode" id="cb549"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb549-1" data-line-number="1"><span class="co">// グローバル名前空間スコープ</span></a>
<a class="sourceLine" id="cb549-2" data-line-number="2"></a>
<a class="sourceLine" id="cb549-3" data-line-number="3"><span class="kw">namespace</span> ns {</a>
<a class="sourceLine" id="cb549-4" data-line-number="4">    <span class="dt">int</span> a {} ;</a>
<a class="sourceLine" id="cb549-5" data-line-number="5">    <span class="dt">void</span> f()</a>
<a class="sourceLine" id="cb549-6" data-line-number="6">    {</a>
<a class="sourceLine" id="cb549-7" data-line-number="7">        a = <span class="dv">0</span> ; <span class="co">// OK</span></a>
<a class="sourceLine" id="cb549-8" data-line-number="8">    }</a>
<a class="sourceLine" id="cb549-9" data-line-number="9">} <span class="co">// 名前空間nsのスコープの終了</span></a>
<a class="sourceLine" id="cb549-10" data-line-number="10"></a>
<a class="sourceLine" id="cb549-11" data-line-number="11"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb549-12" data-line-number="12">{</a>
<a class="sourceLine" id="cb549-13" data-line-number="13">    <span class="co">// エラー</span></a>
<a class="sourceLine" id="cb549-14" data-line-number="14">    a = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb549-15" data-line-number="15">    <span class="co">// OK </span></a>
<a class="sourceLine" id="cb549-16" data-line-number="16">    ns::a ;</a>
<a class="sourceLine" id="cb549-17" data-line-number="17">}</a></code></pre></div>
<p>名前空間スコープと関数スコープには違う点もあるが、名前の有効な範囲としては同じスコープだ。</p>
<p>外側のスコープで宣言された名前と同じ名前を内側で宣言すると、内側の名前が外側の名前を隠す。</p>
<div class="sourceCode" id="cb550"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb550-1" data-line-number="1"><span class="co">// グローバル名前空間のf</span></a>
<a class="sourceLine" id="cb550-2" data-line-number="2"><span class="kw">auto</span> f =  []()</a>
<a class="sourceLine" id="cb550-3" data-line-number="3">{ <span class="bu">std::</span>cout &lt;&lt; <span class="dv">1</span> ; } ;</a>
<a class="sourceLine" id="cb550-4" data-line-number="4"></a>
<a class="sourceLine" id="cb550-5" data-line-number="5"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb550-6" data-line-number="6">{</a>
<a class="sourceLine" id="cb550-7" data-line-number="7">    f() ; <span class="co">// 1</span></a>
<a class="sourceLine" id="cb550-8" data-line-number="8"></a>
<a class="sourceLine" id="cb550-9" data-line-number="9">    <span class="co">// 関数mainのf</span></a>
<a class="sourceLine" id="cb550-10" data-line-number="10">    <span class="kw">auto</span> f = []()</a>
<a class="sourceLine" id="cb550-11" data-line-number="11">    { <span class="bu">std::</span>cout &lt;&lt; <span class="dv">2</span> ; } ;</a>
<a class="sourceLine" id="cb550-12" data-line-number="12"></a>
<a class="sourceLine" id="cb550-13" data-line-number="13">    f() ; <span class="co">// 2</span></a>
<a class="sourceLine" id="cb550-14" data-line-number="14"></a>
<a class="sourceLine" id="cb550-15" data-line-number="15">    {</a>
<a class="sourceLine" id="cb550-16" data-line-number="16">        f() ; <span class="co">// 2</span></a>
<a class="sourceLine" id="cb550-17" data-line-number="17"></a>
<a class="sourceLine" id="cb550-18" data-line-number="18">        <span class="co">// ブロックのf</span></a>
<a class="sourceLine" id="cb550-19" data-line-number="19">        <span class="kw">auto</span> f = []()</a>
<a class="sourceLine" id="cb550-20" data-line-number="20">        { <span class="bu">std::</span>cout &lt;&lt; <span class="dv">3</span> ; } ;</a>
<a class="sourceLine" id="cb550-21" data-line-number="21">        f() ; <span class="co">// 3</span></a>
<a class="sourceLine" id="cb550-22" data-line-number="22">    }</a>
<a class="sourceLine" id="cb550-23" data-line-number="23"></a>
<a class="sourceLine" id="cb550-24" data-line-number="24">    f() ; <span class="co">// 2</span></a>
<a class="sourceLine" id="cb550-25" data-line-number="25">}</a></code></pre></div>
<p>宣言されている場所に注意が必要だ。名前fは3つある。最初の関数呼び出しの時点ではグローバル名前空間のfが呼ばれる。まだ名前fは関数mainの中で宣言されていないからだ。そして関数mainのスコープの中で名前fが宣言される。このときグローバル名前空間のfは隠される。そのため、次の関数fの呼び出しでは関数mainのfが呼ばれる。次にブロックの中に入る。ここで関数fが呼ばれるが、まだこのfは関数mainのfだ。その後にブロックの中で名前fが宣言される。すると次の関数fの呼び出しはブロックのfだ。ブロックから抜けた後の関数fの呼び出しは関数mainのfだ。</p>
<p>この章では名前について解説した。名前は難しい。難しいが、プログラミングにおいては名前と向き合わなければならない。</p>
<h1 id="イテレーターの基礎">イテレーターの基礎</h1>
<p>vectorの章ではvectorの要素にアクセスする方法としてメンバー関数<code>at(i)</code>を学んだ。<code>at(i)</code>はi番目の要素にアクセスできる。ただし最初の要素は0番目だ。</p>
<div class="sourceCode" id="cb551"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb551-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb551-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb551-3" data-line-number="3">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</a>
<a class="sourceLine" id="cb551-4" data-line-number="4"></a>
<a class="sourceLine" id="cb551-5" data-line-number="5">    <span class="dt">int</span> x = v.at(<span class="dv">2</span>) ; <span class="co">// 3</span></a>
<a class="sourceLine" id="cb551-6" data-line-number="6">    v.at(<span class="dv">2</span>) = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb551-7" data-line-number="7">    <span class="co">// vは{1,2,0,4,5}</span></a>
<a class="sourceLine" id="cb551-8" data-line-number="8">}</a></code></pre></div>
<p>この章ではvectorの要素にアクセスする方法としてイテレーター(iterator)を学ぶ。</p>
<h2 id="イテレーターの取得方法">イテレーターの取得方法</h2>
<p>イテレーターは<code>std::begin(v)</code>で取得する。vはvectorの変数だ。</p>
<div class="sourceCode" id="cb552"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb552-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb552-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb552-3" data-line-number="3">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</a>
<a class="sourceLine" id="cb552-4" data-line-number="4">    <span class="kw">auto</span> i = <span class="bu">std::</span>begin(v) ;</a>
<a class="sourceLine" id="cb552-5" data-line-number="5">}</a></code></pre></div>
<h2 id="イテレーターの参照する要素に対する読み書き">イテレーターの参照する要素に対する読み書き。</h2>
<p>イテレーターはvectorの先頭の要素を指し示している。イテレーターの指し示す要素を参照するには<code>*</code>を使う。</p>
<div class="sourceCode" id="cb553"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb553-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb553-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb553-3" data-line-number="3">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</a>
<a class="sourceLine" id="cb553-4" data-line-number="4"></a>
<a class="sourceLine" id="cb553-5" data-line-number="5">    <span class="kw">auto</span> i = <span class="bu">std::</span>begin(v) ;</a>
<a class="sourceLine" id="cb553-6" data-line-number="6"></a>
<a class="sourceLine" id="cb553-7" data-line-number="7">    <span class="dt">int</span> x = *i ; <span class="co">// 1</span></a>
<a class="sourceLine" id="cb553-8" data-line-number="8"></a>
<a class="sourceLine" id="cb553-9" data-line-number="9">    *i = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb553-10" data-line-number="10">    <span class="co">// vは{0,2,3,4,5} </span></a>
<a class="sourceLine" id="cb553-11" data-line-number="11">}</a></code></pre></div>
<p><code>*i</code>を読み込むと指し示す要素の値を読むことができ、<code>*i</code>に代入をすると指し示す要素の値を変えることができる。</p>
<h2 id="イテレーターの参照する要素を変更">イテレーターの参照する要素を変更</h2>
<p>現在指している要素の次の要素を指すように変更するには<code>++</code>を使う。</p>
<div class="sourceCode" id="cb554"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb554-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb554-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb554-3" data-line-number="3">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</a>
<a class="sourceLine" id="cb554-4" data-line-number="4"></a>
<a class="sourceLine" id="cb554-5" data-line-number="5">    <span class="kw">auto</span> i = <span class="bu">std::</span>begin(v) ;</a>
<a class="sourceLine" id="cb554-6" data-line-number="6"></a>
<a class="sourceLine" id="cb554-7" data-line-number="7">    *i ; <span class="co">// 1</span></a>
<a class="sourceLine" id="cb554-8" data-line-number="8">    ++i ;</a>
<a class="sourceLine" id="cb554-9" data-line-number="9">    *i ; <span class="co">// 2</span></a>
<a class="sourceLine" id="cb554-10" data-line-number="10">    ++i ;</a>
<a class="sourceLine" id="cb554-11" data-line-number="11">    *i ; <span class="co">// 3</span></a>
<a class="sourceLine" id="cb554-12" data-line-number="12">}</a></code></pre></div>
<p>現在指している要素の前の要素を指すように変更するには<code>--</code>を使う。</p>
<div class="sourceCode" id="cb555"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb555-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb555-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb555-3" data-line-number="3">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</a>
<a class="sourceLine" id="cb555-4" data-line-number="4"></a>
<a class="sourceLine" id="cb555-5" data-line-number="5">    <span class="kw">auto</span> i = <span class="bu">std::</span>begin(v) ;</a>
<a class="sourceLine" id="cb555-6" data-line-number="6"></a>
<a class="sourceLine" id="cb555-7" data-line-number="7">    *i ; <span class="co">// 1</span></a>
<a class="sourceLine" id="cb555-8" data-line-number="8">    ++i ;</a>
<a class="sourceLine" id="cb555-9" data-line-number="9">    *i ; <span class="co">// 2</span></a>
<a class="sourceLine" id="cb555-10" data-line-number="10">    --i ;</a>
<a class="sourceLine" id="cb555-11" data-line-number="11">    *i ; <span class="co">// 1</span></a>
<a class="sourceLine" id="cb555-12" data-line-number="12">}</a></code></pre></div>
<p>vectorの全要素を先頭からイテレーターでアクセスするには、要素数だけ<code>++i</code>すればよいことになる。</p>
<div class="sourceCode" id="cb556"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb556-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb556-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb556-3" data-line-number="3">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</a>
<a class="sourceLine" id="cb556-4" data-line-number="4">    <span class="kw">auto</span> iter = <span class="bu">std::</span>begin(v) ;</a>
<a class="sourceLine" id="cb556-5" data-line-number="5"></a>
<a class="sourceLine" id="cb556-6" data-line-number="6">    <span class="cf">for</span> ( <span class="bu">std::</span>size_t i = <span class="dv">0</span> ; i != <span class="bu">std::</span>size(v) ; ++i, ++iter )</a>
<a class="sourceLine" id="cb556-7" data-line-number="7">    {</a>
<a class="sourceLine" id="cb556-8" data-line-number="8">        <span class="bu">std::</span>cout &lt;&lt; *iter &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb556-9" data-line-number="9">    }</a>
<a class="sourceLine" id="cb556-10" data-line-number="10">}</a></code></pre></div>
<p>これは動く。ただしもっとマシな方法がある。イテレーターの比較だ。</p>
<h2 id="イテレーターの比較">イテレーターの比較</h2>
<p>イテレーターは比較できる。同じ順番の要素を指すイテレーターは等しく、そうではないイテレーターは等しくない。</p>
<div class="sourceCode" id="cb557"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb557-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb557-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb557-3" data-line-number="3">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</a>
<a class="sourceLine" id="cb557-4" data-line-number="4"></a>
<a class="sourceLine" id="cb557-5" data-line-number="5">    <span class="kw">auto</span> x = <span class="bu">std::</span>begin(v) ;</a>
<a class="sourceLine" id="cb557-6" data-line-number="6">    <span class="kw">auto</span> y = x ;</a>
<a class="sourceLine" id="cb557-7" data-line-number="7"></a>
<a class="sourceLine" id="cb557-8" data-line-number="8">    <span class="co">// x, yは0番目の要素を指す</span></a>
<a class="sourceLine" id="cb557-9" data-line-number="9"></a>
<a class="sourceLine" id="cb557-10" data-line-number="10">    <span class="dt">bool</span> b1 = (x == y) ; <span class="co">// true</span></a>
<a class="sourceLine" id="cb557-11" data-line-number="11">    <span class="dt">bool</span> b2 = (x != y) ; <span class="co">// false</span></a>
<a class="sourceLine" id="cb557-12" data-line-number="12"></a>
<a class="sourceLine" id="cb557-13" data-line-number="13">    ++x ; <span class="co">// xは1番目の要素を指す。</span></a>
<a class="sourceLine" id="cb557-14" data-line-number="14"></a>
<a class="sourceLine" id="cb557-15" data-line-number="15">    <span class="dt">bool</span> b3 = (x == y) ; <span class="co">// false</span></a>
<a class="sourceLine" id="cb557-16" data-line-number="16">    <span class="dt">bool</span> b4 = (x != y) ; <span class="co">// true</span></a>
<a class="sourceLine" id="cb557-17" data-line-number="17">}</a></code></pre></div>
<h2 id="最後の次の要素へのイテレーター">最後の次の要素へのイテレーター</h2>
<p><code>std::begin(v)</code>はvectorの変数vの最初の要素を指し示すイテレーターを取得する。</p>
<p><code>std::end(v)</code>はvectorの変数vの最後の次の要素を指し示すイテレーターを取得する。</p>
<div class="sourceCode" id="cb558"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb558-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb558-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb558-3" data-line-number="3">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = { <span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span> };</a>
<a class="sourceLine" id="cb558-4" data-line-number="4"></a>
<a class="sourceLine" id="cb558-5" data-line-number="5">    <span class="co">// 最後の次の要素を指し示すイテレーター</span></a>
<a class="sourceLine" id="cb558-6" data-line-number="6">    <span class="kw">auto</span> i = <span class="bu">std::</span>end(v) ;</a>
<a class="sourceLine" id="cb558-7" data-line-number="7">}</a></code></pre></div>
<p>最後の次の要素とは何か。ある<code>vector&lt;int&gt;</code>の変数の中身が<code>{1,2,3,4,5}</code>のとき、最初の0番目の要素の値は1だ。最後の4番目の要素の値は5だ。最後の次の要素とは、値が5の最後の要素の次の要素だ。そのような要素は実際には存在しないが、<code>std::end</code>は概念として最後の次の要素を返す。</p>
<p>最後の次の要素を指し示すイテレーターに対して、<code>*</code>で要素にアクセスを試みるとエラーになる。</p>
<div class="sourceCode" id="cb559"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb559-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb559-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb559-3" data-line-number="3">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</a>
<a class="sourceLine" id="cb559-4" data-line-number="4"></a>
<a class="sourceLine" id="cb559-5" data-line-number="5">    <span class="kw">auto</span> i = <span class="bu">std::</span>end(v) ;</a>
<a class="sourceLine" id="cb559-6" data-line-number="6"></a>
<a class="sourceLine" id="cb559-7" data-line-number="7">    *i ; <span class="co">// エラー</span></a>
<a class="sourceLine" id="cb559-8" data-line-number="8">}</a></code></pre></div>
<p>最後の次の要素を<code>++</code>しようとするとエラーになる。<code>--</code>することはできる。</p>
<div class="sourceCode" id="cb560"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb560-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb560-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb560-3" data-line-number="3">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</a>
<a class="sourceLine" id="cb560-4" data-line-number="4">    <span class="kw">auto</span> i = <span class="bu">std::</span>end(v) ;</a>
<a class="sourceLine" id="cb560-5" data-line-number="5"></a>
<a class="sourceLine" id="cb560-6" data-line-number="6">    --i ;   <span class="co">// 最後の要素を指す</span></a>
<a class="sourceLine" id="cb560-7" data-line-number="7">    *i ;    <span class="co">// 5</span></a>
<a class="sourceLine" id="cb560-8" data-line-number="8">    ++i ;   <span class="co">// 最後の次の要素を指す</span></a>
<a class="sourceLine" id="cb560-9" data-line-number="9">    *i ;    <span class="co">// エラー</span></a>
<a class="sourceLine" id="cb560-10" data-line-number="10">}</a></code></pre></div>
<p>実際には存在しない最後の次の要素を指し示すイテレーターは何の役に立つのか。答えはイテレーターの比較だ。</p>
<p>実際には存在しない最後の次の要素を指すイテレーターに’*’を使って要素にアクセスするのはエラーだが、イテレーター同士の比較はできる。すでに説明したように、イテレーターの比較は同じ要素を指す場合はtrue、違う要素を指す場合はfalseになる。</p>
<div class="sourceCode" id="cb561"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb561-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb561-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb561-3" data-line-number="3">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>} ;</a>
<a class="sourceLine" id="cb561-4" data-line-number="4"></a>
<a class="sourceLine" id="cb561-5" data-line-number="5">    <span class="co">// xは最初の要素を指す</span></a>
<a class="sourceLine" id="cb561-6" data-line-number="6">    <span class="kw">auto</span> x = <span class="bu">std::</span>begin(v) ;</a>
<a class="sourceLine" id="cb561-7" data-line-number="7">    <span class="co">// yは最後の次の要素を指す</span></a>
<a class="sourceLine" id="cb561-8" data-line-number="8">    <span class="kw">auto</span> y = <span class="bu">std::</span>end(v) ;</a>
<a class="sourceLine" id="cb561-9" data-line-number="9"></a>
<a class="sourceLine" id="cb561-10" data-line-number="10"></a>
<a class="sourceLine" id="cb561-11" data-line-number="11">    x == y ; <span class="co">// false</span></a>
<a class="sourceLine" id="cb561-12" data-line-number="12">    ++x ; <span class="co">// xは最初の次の要素を指す</span></a>
<a class="sourceLine" id="cb561-13" data-line-number="13">    x == y ; <span class="co">// false</span></a>
<a class="sourceLine" id="cb561-14" data-line-number="14">    ++x ; <span class="co">// xは最後の要素を指す</span></a>
<a class="sourceLine" id="cb561-15" data-line-number="15">    x == y ; <span class="co">// false</span></a>
<a class="sourceLine" id="cb561-16" data-line-number="16">    ++x ; <span class="co">// xは最後の次の要素を指す</span></a>
<a class="sourceLine" id="cb561-17" data-line-number="17">    x == y ; <span class="co">// true</span></a>
<a class="sourceLine" id="cb561-18" data-line-number="18">}</a></code></pre></div>
<p><code>std::end</code>で取得する最後の次の要素を指すイテレーターと比較することで、イテレーターが最後の次の要素を指し示す状態に到達したことを判定できる。</p>
<p>ということは、<code>vector</code>の要素を先頭から最後まで順番に出力するプログラムは、以下のように書ける。</p>
<div class="sourceCode" id="cb562"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb562-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb562-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb562-3" data-line-number="3">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</a>
<a class="sourceLine" id="cb562-4" data-line-number="4"></a>
<a class="sourceLine" id="cb562-5" data-line-number="5">    <span class="cf">for</span> ( <span class="kw">auto</span> iter = <span class="bu">std::</span>begin(v), last = <span class="bu">std::</span>end(v) ;</a>
<a class="sourceLine" id="cb562-6" data-line-number="6">          iter != last ; ++iter )</a>
<a class="sourceLine" id="cb562-7" data-line-number="7">    {</a>
<a class="sourceLine" id="cb562-8" data-line-number="8">        <span class="bu">std::</span>cout &lt;&lt; *iter &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb562-9" data-line-number="9">    }</a>
<a class="sourceLine" id="cb562-10" data-line-number="10">}</a></code></pre></div>
<h2 id="なんでもイテレーター">なんでもイテレーター</h2>
<p>イテレーターというのは要素にアクセスする回りくどくて面倒な方法に見える。イテレーターという面倒なものを使わずに、<code>vector::at(i)</code>でi番目の要素にアクセスするほうが楽ではないか。そう考える読者もいるだろう。イテレーターの利点はその汎用性にある。イテレーターの作法に従うことで、様々な処理が同じコードで書けるようになるのだ。</p>
<p>たとえば、vectorの要素を先頭から順番に出力する処理を振り返ってみよう。</p>
<div class="sourceCode" id="cb563"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb563-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb563-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb563-3" data-line-number="3">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</a>
<a class="sourceLine" id="cb563-4" data-line-number="4"></a>
<a class="sourceLine" id="cb563-5" data-line-number="5">    <span class="cf">for</span> ( <span class="bu">std::</span>size_t i = <span class="dv">0</span> ; i != <span class="bu">std::</span>size(v) ; ++i )</a>
<a class="sourceLine" id="cb563-6" data-line-number="6">    {</a>
<a class="sourceLine" id="cb563-7" data-line-number="7">        <span class="bu">std::</span>cout &lt;&lt; v.at(i) &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb563-8" data-line-number="8">    }</a>
<a class="sourceLine" id="cb563-9" data-line-number="9">}</a></code></pre></div>
<p>このコードは<code>vector</code>にしか使えないコードだ。イテレーターで書き直してみよう。</p>
<div class="sourceCode" id="cb564"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb564-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb564-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb564-3" data-line-number="3">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</a>
<a class="sourceLine" id="cb564-4" data-line-number="4"></a>
<a class="sourceLine" id="cb564-5" data-line-number="5">    <span class="cf">for</span> ( <span class="kw">auto</span> iter = <span class="bu">std::</span>begin(v), last = <span class="bu">std::</span>end(v) ;</a>
<a class="sourceLine" id="cb564-6" data-line-number="6">          iter != last ; ++iter )</a>
<a class="sourceLine" id="cb564-7" data-line-number="7">    {</a>
<a class="sourceLine" id="cb564-8" data-line-number="8">        <span class="bu">std::</span>cout &lt;&lt; *iter &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb564-9" data-line-number="9">    }</a>
<a class="sourceLine" id="cb564-10" data-line-number="10">}</a></code></pre></div>
<p>そして、この要素を先頭から出力する処理を関数にしてみよう。</p>
<div class="sourceCode" id="cb565"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb565-1" data-line-number="1"><span class="kw">auto</span> output_all = []( <span class="kw">auto</span> first, <span class="kw">auto</span> last )</a>
<a class="sourceLine" id="cb565-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb565-3" data-line-number="3">    <span class="cf">for</span> ( <span class="kw">auto</span> iter = first ; iter != last ; ++iter )</a>
<a class="sourceLine" id="cb565-4" data-line-number="4">    {</a>
<a class="sourceLine" id="cb565-5" data-line-number="5">        <span class="bu">std::</span>cout &lt;&lt; *iter &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb565-6" data-line-number="6">    }</a>
<a class="sourceLine" id="cb565-7" data-line-number="7">} ;</a>
<a class="sourceLine" id="cb565-8" data-line-number="8"></a>
<a class="sourceLine" id="cb565-9" data-line-number="9"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb565-10" data-line-number="10">{</a>
<a class="sourceLine" id="cb565-11" data-line-number="11">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</a>
<a class="sourceLine" id="cb565-12" data-line-number="12"></a>
<a class="sourceLine" id="cb565-13" data-line-number="13">    output_all( <span class="bu">std::</span>begin(v), <span class="bu">std::</span>end(v) ) ;</a>
<a class="sourceLine" id="cb565-14" data-line-number="14">}</a></code></pre></div>
<p>この<code>関数output_all</code>は<code>vector</code>以外のイテレーターにも対応している。C++には様々なイテレーターがある。例えば標準入力から値を受け取るイテレーターがある。早速使ってみよう。</p>
<div class="sourceCode" id="cb566"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb566-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb566-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb566-3" data-line-number="3">    <span class="bu">std::</span>istream_iterator&lt;<span class="dt">int</span>&gt; first( <span class="bu">std::</span>cin ), last ;</a>
<a class="sourceLine" id="cb566-4" data-line-number="4"></a>
<a class="sourceLine" id="cb566-5" data-line-number="5">    output_all( first, last ) ;</a>
<a class="sourceLine" id="cb566-6" data-line-number="6">}</a></code></pre></div>
<p>このプログラムは標準入力から<code>int</code>型の値を受け取り、それをそのまま標準出力する。</p>
<p>C++には他にも、カレントディレクトリーにあるファイルの一覧を取得するイテレーターがある。</p>
<div class="sourceCode" id="cb567"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb567-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb567-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb567-3" data-line-number="3">    <span class="bu">std::</span>filesystem<span class="bu">::</span>directory_iterator first(<span class="st">&quot;./&quot;</span>), last ;</a>
<a class="sourceLine" id="cb567-4" data-line-number="4"></a>
<a class="sourceLine" id="cb567-5" data-line-number="5">    output_all( first, last ) ;</a>
<a class="sourceLine" id="cb567-6" data-line-number="6">}</a></code></pre></div>
<p><code>関数output_all</code>のコードは何も変えていないのに、様々なイテレーターに対応できる。イテレーターというお作法に乗っ取ることで、様々な処理が可能になるのだ。</p>
<p>これは出力にも言えることだ。<code>関数output_all</code>は<code>std::cout</code>に出力していた。これをイテレーターに対する書き込みに変えてみよう。</p>
<div class="sourceCode" id="cb568"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb568-1" data-line-number="1"><span class="kw">auto</span> output_all = []( <span class="kw">auto</span> first, <span class="kw">auto</span> last, <span class="kw">auto</span> output_iter )</a>
<a class="sourceLine" id="cb568-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb568-3" data-line-number="3">    <span class="cf">for</span> ( <span class="kw">auto</span> iter = first ; iter != last ; ++iter, ++output_iter )</a>
<a class="sourceLine" id="cb568-4" data-line-number="4">    {</a>
<a class="sourceLine" id="cb568-5" data-line-number="5">        *output_iter = *iter ;</a>
<a class="sourceLine" id="cb568-6" data-line-number="6">    }</a>
<a class="sourceLine" id="cb568-7" data-line-number="7">} ;</a></code></pre></div>
<p>書き換えた<code>関数output_all</code>は新しく<code>output_iter</code>という引数を取る。これはイテレーターだ。<code>std::cout</code>に出力する代わりに、このイテレーターに書き込むように変更している。</p>
<p>こうすることによって、出力にも様々なイテレーターが使える。</p>
<p>標準出力に出力するイテレーターがある。</p>
<div class="sourceCode" id="cb569"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb569-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb569-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb569-3" data-line-number="3">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</a>
<a class="sourceLine" id="cb569-4" data-line-number="4">    </a>
<a class="sourceLine" id="cb569-5" data-line-number="5">    output_all( <span class="bu">std::</span>begin(v), <span class="bu">std::</span>end(v),</a>
<a class="sourceLine" id="cb569-6" data-line-number="6">                <span class="bu">std::</span>ostream_iterator&lt;<span class="dt">int</span>&gt;(<span class="bu">std::</span>cout) ) ;</a>
<a class="sourceLine" id="cb569-7" data-line-number="7">}</a></code></pre></div>
<p>vectorも出力先にできる。つまりvectorのコピーだ。</p>
<div class="sourceCode" id="cb570"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb570-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb570-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb570-3" data-line-number="3">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; source = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</a>
<a class="sourceLine" id="cb570-4" data-line-number="4">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; destination(<span class="dv">5</span>) ;</a>
<a class="sourceLine" id="cb570-5" data-line-number="5"></a>
<a class="sourceLine" id="cb570-6" data-line-number="6">    output_all( <span class="bu">std::</span>begin(source), <span class="bu">std::</span>end(source), <span class="bu">std::</span>begin( destination ) ) ;</a>
<a class="sourceLine" id="cb570-7" data-line-number="7">}</a></code></pre></div>
<p><code>destination(5)</code>というのは、<code>vector</code>にあらかじめ5個の要素を入れておくという意味だ。あらかじめ入っている要素の値はintの場合ゼロになる。</p>
<p>この他にもイテレーターは様々ある。自分でイテレーターを作ることもできる。そして、<code>関数output_all</code>はイテレーターにさえ対応していれば様々な処理にコードを一行たりとも変えずに使えるのだ。</p>
<h2 id="イテレーターと添字の範囲">イテレーターと添字の範囲</h2>
<p>イテレーターは順序のある値の集合を表現するために、最初の要素への参照と、最後の次の要素への参照のペアを用いる。</p>
<p>たとえば、{1,2,3,4,5}という順序の値の集合があった場合、イテレーターは最初の要素である1と最後の一つ次の要素である5の次の架空の要素を指し示す。</p>
<div class="sourceCode" id="cb571"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb571-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb571-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb571-3" data-line-number="3">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</a>
<a class="sourceLine" id="cb571-4" data-line-number="4"></a>
<a class="sourceLine" id="cb571-5" data-line-number="5">    <span class="kw">auto</span> i = <span class="bu">std::</span>begin(v) ;</a>
<a class="sourceLine" id="cb571-6" data-line-number="6">    <span class="kw">auto</span> j = <span class="bu">std::</span>end(v) ;</a>
<a class="sourceLine" id="cb571-7" data-line-number="7">}</a></code></pre></div>
<p>このようにして範囲を表現することを、<code>半閉鎖(half-closed)</code>とか、<code>[i,j)</code>などと表現する。</p>
<p>この状態から{2,3,4,5}のような値の集合を表現したい場合、イテレーターiをインクリメントすればよい。</p>
<pre><code>++i ;</code></pre>
<p>これで<code>[i,j)</code>は{2,3,4,5}になった。</p>
<p>このような範囲の表現方法に疑問を感じる読者もいるだろう。なぜ最後の次の要素という本来存在しない架空の要素をあたかも参照しているかのようなイテレーターが必要なのか。最後の要素を参照するのではだめなのか。</p>
<p>そのような範囲の表現方法は、<code>閉鎖(closed)</code>とか<code>[i,j]</code>などと表現する。</p>
<p>実はこの方法はvectorの要素の順番を指定する方法と同じなのだ。</p>
<p>{1,2,3,4,5}と5個の順序ある要素からなるvectorでは、最初の要素は0番目で、最後の要素は4番目だ。1番目から5番目ではない。</p>
<div class="sourceCode" id="cb573"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb573-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb573-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb573-3" data-line-number="3">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</a>
<a class="sourceLine" id="cb573-4" data-line-number="4"></a>
<a class="sourceLine" id="cb573-5" data-line-number="5">    v.at(<span class="dv">0</span>) ; <span class="co">// 最初の要素: 1</span></a>
<a class="sourceLine" id="cb573-6" data-line-number="6">    v.at(<span class="dv">4</span>) ; <span class="co">// 最後の要素: 5</span></a>
<a class="sourceLine" id="cb573-7" data-line-number="7">}</a></code></pre></div>
<p>ではなぜなのか。なぜvectorではn個の要素の順番を0番目からn-1番目として表現するのか。</p>
<p>実はC++に限らず、現在使われているすべてのプログラミングはインデックスを0から始めている。かつてはインデックスを1からはじめる言語も存在したが、そのような言語は今は使われていない。</p>
<p>この疑問はエドガー・ダイクストラがWhy numbering should start at zero(EWD831)で解説している。</p>
<p>2, 3, …, 12の範囲の自然数を表現するのに、慣習的に以下の4つの表記がある。</p>
<p><span class="math display">\[
a) 2 \le i \lt 13
\]</span></p>
<p><span class="math display">\[
b) 1 \lt i \le 12
\]</span></p>
<p><span class="math display">\[
c) 2 \le i \le 12
\]</span></p>
<p><span class="math display">\[
d) 2 \lt i \lt 13
\]</span></p>
<p>C++のイテレーターはa)を元にしている。</p>
<p>この4つのうち、a)とb)は上限から下限を引くと、範囲にある自然数の個数である11になる。</p>
<p>この性質はとても便利なのでC++でも、イテレーター同士の引き算ができるようになっている。イテレーターi, j(<span class="math inline">\(i \le j\)</span>)で<code>j - i</code>をした結果はイテレーターの範囲の要素の個数だ。</p>
<div class="sourceCode" id="cb574"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb574-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb574-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb574-3" data-line-number="3">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">10</span>,<span class="dv">11</span>,<span class="dv">12</span>} ;</a>
<a class="sourceLine" id="cb574-4" data-line-number="4"></a>
<a class="sourceLine" id="cb574-5" data-line-number="5">    <span class="kw">auto</span> i = <span class="bu">std::</span>begin(v) ;</a>
<a class="sourceLine" id="cb574-6" data-line-number="6">    <span class="kw">auto</span> j = <span class="bu">std::</span>end(v) ;</a>
<a class="sourceLine" id="cb574-7" data-line-number="7"></a>
<a class="sourceLine" id="cb574-8" data-line-number="8">    <span class="co">// 11</span></a>
<a class="sourceLine" id="cb574-9" data-line-number="9">    <span class="co">// イテレーターの範囲の要素の個数</span></a>
<a class="sourceLine" id="cb574-10" data-line-number="10">    <span class="bu">std::</span>cout &lt;&lt; j - i &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb574-11" data-line-number="11"></a>
<a class="sourceLine" id="cb574-12" data-line-number="12">    ++i ; <span class="co">// 先頭の次の要素を指す</span></a>
<a class="sourceLine" id="cb574-13" data-line-number="13">    <span class="co">// 10</span></a>
<a class="sourceLine" id="cb574-14" data-line-number="14">    <span class="bu">std::</span>cout &lt;&lt; j - i ; </a>
<a class="sourceLine" id="cb574-15" data-line-number="15">}</a></code></pre></div>
<p>a)とb)はどちらがいいのだろうか。b)を元にイテレーターを設計すると以下のようになる。</p>
<div class="sourceCode" id="cb575"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb575-1" data-line-number="1"><span class="co">// b)案を採用する場合</span></a>
<a class="sourceLine" id="cb575-2" data-line-number="2"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb575-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb575-4" data-line-number="4">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</a>
<a class="sourceLine" id="cb575-5" data-line-number="5"></a>
<a class="sourceLine" id="cb575-6" data-line-number="6">    <span class="co">// 最初の一つ前の架空の要素を指す</span></a>
<a class="sourceLine" id="cb575-7" data-line-number="7">    <span class="kw">auto</span> i = <span class="bu">std::</span>begin(v) ;</a>
<a class="sourceLine" id="cb575-8" data-line-number="8">    <span class="co">// 最後の要素を指す</span></a>
<a class="sourceLine" id="cb575-9" data-line-number="9">    <span class="kw">auto</span> j = <span class="bu">std::</span>end(v) ;</a>
<a class="sourceLine" id="cb575-10" data-line-number="10"></a>
<a class="sourceLine" id="cb575-11" data-line-number="11">    <span class="co">// 最初の要素を指すようにする。</span></a>
<a class="sourceLine" id="cb575-12" data-line-number="12">    ++i ;</a>
<a class="sourceLine" id="cb575-13" data-line-number="13"></a>
<a class="sourceLine" id="cb575-14" data-line-number="14">    <span class="co">// iが最後の要素を指すとループを抜ける</span></a>
<a class="sourceLine" id="cb575-15" data-line-number="15">    <span class="cf">for</span> ( ; i != j ; ++i )</a>
<a class="sourceLine" id="cb575-16" data-line-number="16">    {</a>
<a class="sourceLine" id="cb575-17" data-line-number="17">        <span class="bu">std::</span>cout &lt;&lt; *i ;</a>
<a class="sourceLine" id="cb575-18" data-line-number="18">    }</a>
<a class="sourceLine" id="cb575-19" data-line-number="19">    <span class="co">// 最後の要素を処理する</span></a>
<a class="sourceLine" id="cb575-20" data-line-number="20">    <span class="bu">std::</span>cout &lt;&lt; *i ;</a>
<a class="sourceLine" id="cb575-21" data-line-number="21">    </a>
<a class="sourceLine" id="cb575-22" data-line-number="22"></a>
<a class="sourceLine" id="cb575-23" data-line-number="23">}</a></code></pre></div>
<p>a)の方がよい。</p>
<div class="sourceCode" id="cb576"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb576-1" data-line-number="1"><span class="co">// a)案を採用する場合</span></a>
<a class="sourceLine" id="cb576-2" data-line-number="2"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb576-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb576-4" data-line-number="4">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</a>
<a class="sourceLine" id="cb576-5" data-line-number="5"></a>
<a class="sourceLine" id="cb576-6" data-line-number="6">    <span class="co">// 最初の要素を指す</span></a>
<a class="sourceLine" id="cb576-7" data-line-number="7">    <span class="kw">auto</span> i = <span class="bu">std::</span>begin(v) ;</a>
<a class="sourceLine" id="cb576-8" data-line-number="8">    <span class="co">// 最後の次の要素を指す</span></a>
<a class="sourceLine" id="cb576-9" data-line-number="9">    <span class="kw">auto</span> j = <span class="bu">std::</span>end(v) ;</a>
<a class="sourceLine" id="cb576-10" data-line-number="10"></a>
<a class="sourceLine" id="cb576-11" data-line-number="11">    <span class="co">// iが最後の次の要素を指すとループを抜ける</span></a>
<a class="sourceLine" id="cb576-12" data-line-number="12">    <span class="cf">for</span> ( ; i != j ; ++i )</a>
<a class="sourceLine" id="cb576-13" data-line-number="13">    {</a>
<a class="sourceLine" id="cb576-14" data-line-number="14">        <span class="bu">std::</span>cout &lt;&lt; *i ;</a>
<a class="sourceLine" id="cb576-15" data-line-number="15">    }</a>
<a class="sourceLine" id="cb576-16" data-line-number="16"></a>
<a class="sourceLine" id="cb576-17" data-line-number="17">    <span class="co">// すべての要素について処理を終えている</span></a>
<a class="sourceLine" id="cb576-18" data-line-number="18">}</a></code></pre></div>
<p>b)案では末尾から先頭まで後ろ向きに要素を一巡する操作はやりやすいが、実際には先頭から末尾まで一巡する操作の方が多い。</p>
<p>C++では要素の順番を数値で指し示す時、最初の要素は0番目であり、次の要素は1番目であり、N個目の要素はN-1番目になっている。この数値で指し示すことを<code>添字</code>とか<code>インデックス</code>というがなぜ最初の要素を1番目にしないのか。</p>
<p>C++では様々なところでa)を採用している。これを添字に適用すると、最初の要素が1番目から始まる場合、N個の要素を参照する添字の範囲は<span class="math inline">\(1 \le i \lt N+1\)</span>になる。そのような場合、以下のようなコードになる。</p>
<div class="sourceCode" id="cb577"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb577-1" data-line-number="1"><span class="co">// 最初の要素が1番目の場合</span></a>
<a class="sourceLine" id="cb577-2" data-line-number="2"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb577-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb577-4" data-line-number="4">    <span class="co">// 5個の要素を持つvector</span></a>
<a class="sourceLine" id="cb577-5" data-line-number="5">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</a>
<a class="sourceLine" id="cb577-6" data-line-number="6"></a>
<a class="sourceLine" id="cb577-7" data-line-number="7">    <span class="co">// iの値の範囲は1から5まで</span></a>
<a class="sourceLine" id="cb577-8" data-line-number="8">    <span class="cf">for</span> ( <span class="bu">std::</span>size_t i = <span class="dv">1</span> ; i &lt; <span class="dv">6</span> ; ++i )</a>
<a class="sourceLine" id="cb577-9" data-line-number="9">    {</a>
<a class="sourceLine" id="cb577-10" data-line-number="10">        <span class="bu">std::</span>cout &lt;&lt; v.at(i) ;</a>
<a class="sourceLine" id="cb577-11" data-line-number="11">    }    </a>
<a class="sourceLine" id="cb577-12" data-line-number="12">}</a></code></pre></div>
<p>要素数は5個なのに6が出てくる。最初の要素が0番目の場合、N個の要素を参照する添字の範囲は<span class="math inline">\(0 \le i \lt N\)</span>になる。</p>
<div class="sourceCode" id="cb578"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb578-1" data-line-number="1"><span class="co">// 最初の要素が0番目の場合</span></a>
<a class="sourceLine" id="cb578-2" data-line-number="2"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb578-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb578-4" data-line-number="4">    <span class="co">// 5個の要素を持つvector</span></a>
<a class="sourceLine" id="cb578-5" data-line-number="5">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</a>
<a class="sourceLine" id="cb578-6" data-line-number="6"></a>
<a class="sourceLine" id="cb578-7" data-line-number="7">    <span class="co">// iの値の範囲は0から5まで</span></a>
<a class="sourceLine" id="cb578-8" data-line-number="8">    <span class="cf">for</span> ( <span class="bu">std::</span>size_t i = <span class="dv">0</span> ; i &lt; <span class="dv">5</span> ; ++i )</a>
<a class="sourceLine" id="cb578-9" data-line-number="9">    {</a>
<a class="sourceLine" id="cb578-10" data-line-number="10">        <span class="bu">std::</span>cout &lt;&lt; v.at(i) ;</a>
<a class="sourceLine" id="cb578-11" data-line-number="11">    }    </a>
<a class="sourceLine" id="cb578-12" data-line-number="12">}</a></code></pre></div>
<p>一貫性のために最初の要素は0番目となっている。</p>
<p>また、空の集合にも対応できる。</p>
<div class="sourceCode" id="cb579"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb579-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb579-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb579-3" data-line-number="3">    <span class="co">// 空</span></a>
<a class="sourceLine" id="cb579-4" data-line-number="4">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v ;</a>
<a class="sourceLine" id="cb579-5" data-line-number="5"></a>
<a class="sourceLine" id="cb579-6" data-line-number="6">    <span class="co">// 空なので何も出力されない</span></a>
<a class="sourceLine" id="cb579-7" data-line-number="7">    <span class="cf">for</span> (   <span class="kw">auto</span> i = <span class="bu">std::</span>begin(v), j = <span class="bu">std::</span>end(v) ;</a>
<a class="sourceLine" id="cb579-8" data-line-number="8">            i != j ; ++i )</a>
<a class="sourceLine" id="cb579-9" data-line-number="9">    {</a>
<a class="sourceLine" id="cb579-10" data-line-number="10">        <span class="bu">std::</span>cout &lt;&lt; *i ;</a>
<a class="sourceLine" id="cb579-11" data-line-number="11">    }</a>
<a class="sourceLine" id="cb579-12" data-line-number="12">}</a></code></pre></div>
<p>変数vは空なので<code>i != j</code>はfalseとなり、for文の中の文は一度も実行されない。</p>
<h1 id="lvalueリファレンスとconst">lvalueリファレンスとconst</h1>
<pre><code>ポップカルチャーリファレンスというのは流行の要素をさり気なく作品中に取り入れることで、流行作品を知っている読者の笑いを誘う手法である
-- キャプテン・オブビウス ポップカルチャーリファレンスについて</code></pre>
<h2 id="lvalueリファレンス">lvalueリファレンス</h2>
<p>変数に変数を代入すると、代入元の値が代入先にコピーされる。代入先の値を変更しても、コピーされた値が変わるだけで、代入元には一切影響がない。</p>
<div class="sourceCode" id="cb581"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb581-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb581-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb581-3" data-line-number="3">    <span class="dt">int</span> a = <span class="dv">1</span> ;</a>
<a class="sourceLine" id="cb581-4" data-line-number="4">    <span class="dt">int</span> b = <span class="dv">2</span> ;</a>
<a class="sourceLine" id="cb581-5" data-line-number="5"></a>
<a class="sourceLine" id="cb581-6" data-line-number="6">    b = a ;</a>
<a class="sourceLine" id="cb581-7" data-line-number="7">    <span class="co">// b == 1</span></a>
<a class="sourceLine" id="cb581-8" data-line-number="8"></a>
<a class="sourceLine" id="cb581-9" data-line-number="9">    b = <span class="dv">3</span> ;</a>
<a class="sourceLine" id="cb581-10" data-line-number="10">    <span class="co">// a == 1</span></a>
<a class="sourceLine" id="cb581-11" data-line-number="11">    <span class="co">// b == 3</span></a>
<a class="sourceLine" id="cb581-12" data-line-number="12">}</a></code></pre></div>
<p>これは関数も同じだ。</p>
<div class="sourceCode" id="cb582"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb582-1" data-line-number="1"><span class="dt">void</span> assign_3( <span class="dt">int</span> x )</a>
<a class="sourceLine" id="cb582-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb582-3" data-line-number="3">    x = <span class="dv">3</span> ;</a>
<a class="sourceLine" id="cb582-4" data-line-number="4">}</a>
<a class="sourceLine" id="cb582-5" data-line-number="5"></a>
<a class="sourceLine" id="cb582-6" data-line-number="6"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb582-7" data-line-number="7">{</a>
<a class="sourceLine" id="cb582-8" data-line-number="8">    <span class="dt">int</span> a = <span class="dv">1</span> ;</a>
<a class="sourceLine" id="cb582-9" data-line-number="9">    assign_3( a ) ;</a>
<a class="sourceLine" id="cb582-10" data-line-number="10"></a>
<a class="sourceLine" id="cb582-11" data-line-number="11">    <span class="co">// a == 1</span></a>
<a class="sourceLine" id="cb582-12" data-line-number="12">}</a></code></pre></div>
<p>しかし、時には変数の値を直接書き換えたい場合がある。この時lvalueリファレンス(reference)が使える。lvalueリファレンスは変数に<code>&amp;</code>を付けて宣言する</p>
<div class="sourceCode" id="cb583"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb583-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb583-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb583-3" data-line-number="3">    <span class="dt">int</span> a = <span class="dv">1</span> ;</a>
<a class="sourceLine" id="cb583-4" data-line-number="4">    <span class="dt">int</span> &amp; ref = a ;</a>
<a class="sourceLine" id="cb583-5" data-line-number="5"></a>
<a class="sourceLine" id="cb583-6" data-line-number="6">    ref = <span class="dv">3</span> ;</a>
<a class="sourceLine" id="cb583-7" data-line-number="7"></a>
<a class="sourceLine" id="cb583-8" data-line-number="8">    <span class="co">// a == 3</span></a>
<a class="sourceLine" id="cb583-9" data-line-number="9">    <span class="co">// refはaなので同じく3</span></a>
<a class="sourceLine" id="cb583-10" data-line-number="10">}</a></code></pre></div>
<p>この例で、変数refは変数aへの参照(リファレンス)なので、変数aと同じように使える。</p>
<p>lvalueリファレンスは必ず初期化しなければならない。</p>
<div class="sourceCode" id="cb584"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb584-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb584-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb584-3" data-line-number="3">    <span class="co">// エラー</span></a>
<a class="sourceLine" id="cb584-4" data-line-number="4">    <span class="dt">int</span> &amp; ref ;</a>
<a class="sourceLine" id="cb584-5" data-line-number="5">}</a></code></pre></div>
<p>lvalueリファレンスは関数でも使える。</p>
<div class="sourceCode" id="cb585"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb585-1" data-line-number="1"><span class="dt">void</span> f( <span class="dt">int</span> &amp; x )</a>
<a class="sourceLine" id="cb585-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb585-3" data-line-number="3">    x = <span class="dv">3</span> ;</a>
<a class="sourceLine" id="cb585-4" data-line-number="4">}</a>
<a class="sourceLine" id="cb585-5" data-line-number="5"></a>
<a class="sourceLine" id="cb585-6" data-line-number="6"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb585-7" data-line-number="7">{</a>
<a class="sourceLine" id="cb585-8" data-line-number="8">    <span class="dt">int</span> a = <span class="dv">1</span> ;</a>
<a class="sourceLine" id="cb585-9" data-line-number="9">    f( a ) ;</a>
<a class="sourceLine" id="cb585-10" data-line-number="10"></a>
<a class="sourceLine" id="cb585-11" data-line-number="11">    <span class="co">// a == 3</span></a>
<a class="sourceLine" id="cb585-12" data-line-number="12">}</a></code></pre></div>
<p>選択ソートで2つの変数の値を交換する必要があったことを覚えているだろうか。</p>
<div class="sourceCode" id="cb586"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb586-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb586-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb586-3" data-line-number="3">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">3</span>,<span class="dv">2</span>,<span class="dv">1</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</a>
<a class="sourceLine" id="cb586-4" data-line-number="4"></a>
<a class="sourceLine" id="cb586-5" data-line-number="5">    <span class="co">// 0番目と2番目の要素を交換したい</span></a>
<a class="sourceLine" id="cb586-6" data-line-number="6">    <span class="kw">auto</span> temp = v.at(<span class="dv">0</span>) ;</a>
<a class="sourceLine" id="cb586-7" data-line-number="7">    v.at(<span class="dv">0</span>) = v.at(<span class="dv">2</span>) ;</a>
<a class="sourceLine" id="cb586-8" data-line-number="8">    v.at(<span class="dv">2</span>) = temp ;</a>
<a class="sourceLine" id="cb586-9" data-line-number="9">}</a></code></pre></div>
<p>いちいち交換のために別の変数<code>temp</code>を作って3回代入を書くのは面倒だ。これを関数にしてしまいたい。</p>
<pre><code>// 値を交換
swap( v.at(0), v.at(2) ) ;</code></pre>
<p>このような関数<code>swap</code>は普通に書くことはできない。</p>
<div class="sourceCode" id="cb588"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb588-1" data-line-number="1"><span class="co">// この実装は正しくない</span></a>
<a class="sourceLine" id="cb588-2" data-line-number="2"><span class="kw">auto</span> swap = []( <span class="kw">auto</span> a, <span class="kw">auto</span> b )</a>
<a class="sourceLine" id="cb588-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb588-4" data-line-number="4">    <span class="kw">auto</span> temp = a ;</a>
<a class="sourceLine" id="cb588-5" data-line-number="5">    a = b ;</a>
<a class="sourceLine" id="cb588-6" data-line-number="6">    b = temp ;</a>
<a class="sourceLine" id="cb588-7" data-line-number="7">} ;</a></code></pre></div>
<p>この実装では、変数は単にコピーされるだけなので、関数の呼び出し元には何の影響もない。</p>
<p>これをlvalueリファレンスに変えると、関数の呼び出し元の変数の値を交換する関数<code>swap</code>が作れる。</p>
<div class="sourceCode" id="cb589"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb589-1" data-line-number="1"><span class="co">// lvalueリファレンス</span></a>
<a class="sourceLine" id="cb589-2" data-line-number="2"><span class="kw">auto</span> swap = []( <span class="kw">auto</span> &amp; a, <span class="kw">auto</span> &amp; b )</a>
<a class="sourceLine" id="cb589-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb589-4" data-line-number="4">    <span class="kw">auto</span> temp = a ;</a>
<a class="sourceLine" id="cb589-5" data-line-number="5">    a = b ;</a>
<a class="sourceLine" id="cb589-6" data-line-number="6">    b = temp ;</a>
<a class="sourceLine" id="cb589-7" data-line-number="7">} ;</a></code></pre></div>
<p>C++の標準ライブラリには<code>std::swap</code>があるので、読者はわざわざこのような関数を自作する必要はない。</p>
<div class="sourceCode" id="cb590"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb590-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb590-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb590-3" data-line-number="3">    <span class="dt">int</span> a = <span class="dv">1</span> ;</a>
<a class="sourceLine" id="cb590-4" data-line-number="4">    <span class="dt">int</span> b = <span class="dv">2</span> ;</a>
<a class="sourceLine" id="cb590-5" data-line-number="5"></a>
<a class="sourceLine" id="cb590-6" data-line-number="6">    <span class="bu">std::</span>swap( a, b ) ;</a>
<a class="sourceLine" id="cb590-7" data-line-number="7"></a>
<a class="sourceLine" id="cb590-8" data-line-number="8">    <span class="co">// a == 2</span></a>
<a class="sourceLine" id="cb590-9" data-line-number="9">    <span class="co">// b == 1</span></a>
<a class="sourceLine" id="cb590-10" data-line-number="10">}</a></code></pre></div>
<p>ところで、この章では一貫してlvalueリファレンスと書いているのに気がついただろうか。lvalueとは何なのか、lvalueではないリファレンスはあるのか。その疑問は後の章で解決する。</p>
<h2 id="const">const</h2>
<p>値を変更したくない変数は、constをつけることで変更を禁止できる。</p>
<div class="sourceCode" id="cb591"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb591-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb591-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb591-3" data-line-number="3">    <span class="dt">int</span> x = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb591-4" data-line-number="4">    x = <span class="dv">1</span> ; <span class="co">// OK、変更できる</span></a>
<a class="sourceLine" id="cb591-5" data-line-number="5"></a>
<a class="sourceLine" id="cb591-6" data-line-number="6">    <span class="at">const</span> <span class="dt">int</span> y = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb591-7" data-line-number="7">    y = <span class="dv">0</span> ; <span class="co">// エラー、変更できない。</span></a>
<a class="sourceLine" id="cb591-8" data-line-number="8">}</a></code></pre></div>
<p>constはちょっと文法が変わっていて混乱する。例えば、<code>const int</code>でも<code>int const</code>でも意味が同じだ。</p>
<div class="sourceCode" id="cb592"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb592-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb592-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb592-3" data-line-number="3">    <span class="co">// 意味は同じ</span></a>
<a class="sourceLine" id="cb592-4" data-line-number="4">    <span class="at">const</span> <span class="dt">int</span> x = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb592-5" data-line-number="5">    <span class="dt">int</span> <span class="at">const</span> y = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb592-6" data-line-number="6">}</a></code></pre></div>
<p>constはlvalueリファレンスと組み合わせることができる。</p>
<div class="sourceCode" id="cb593"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb593-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb593-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb593-3" data-line-number="3">    <span class="dt">int</span> x = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb593-4" data-line-number="4"></a>
<a class="sourceLine" id="cb593-5" data-line-number="5">    <span class="dt">int</span> &amp; ref = x ;</a>
<a class="sourceLine" id="cb593-6" data-line-number="6">    <span class="co">// OK</span></a>
<a class="sourceLine" id="cb593-7" data-line-number="7">    ++ref ;</a>
<a class="sourceLine" id="cb593-8" data-line-number="8"></a>
<a class="sourceLine" id="cb593-9" data-line-number="9">    <span class="at">const</span> <span class="dt">int</span> &amp; const_ref = x ;</a>
<a class="sourceLine" id="cb593-10" data-line-number="10"></a>
<a class="sourceLine" id="cb593-11" data-line-number="11">    <span class="co">// エラー</span></a>
<a class="sourceLine" id="cb593-12" data-line-number="12">    ++const_ref ;</a>
<a class="sourceLine" id="cb593-13" data-line-number="13">}</a></code></pre></div>
<p>constは本当に文法が変わっていて混乱する。<code>const int &amp;</code>と<code>int const &amp;</code>は同じ意味だが、<code>int &amp; const</code>はエラーになる。</p>
<div class="sourceCode" id="cb594"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb594-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb594-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb594-3" data-line-number="3">    <span class="dt">int</span> a = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb594-4" data-line-number="4"></a>
<a class="sourceLine" id="cb594-5" data-line-number="5">    <span class="co">// OK、意味は同じ</span></a>
<a class="sourceLine" id="cb594-6" data-line-number="6">    <span class="at">const</span> <span class="dt">int</span> &amp; b = a ;</a>
<a class="sourceLine" id="cb594-7" data-line-number="7">    <span class="dt">int</span> <span class="at">const</span> &amp; c = a ;</a>
<a class="sourceLine" id="cb594-8" data-line-number="8"></a>
<a class="sourceLine" id="cb594-9" data-line-number="9">    <span class="co">// エラー</span></a>
<a class="sourceLine" id="cb594-10" data-line-number="10">    <span class="dt">int</span> &amp; <span class="at">const</span> d = a ;</a>
<a class="sourceLine" id="cb594-11" data-line-number="11">}</a></code></pre></div>
<p>これはとても複雑なルールで決まっているので、こういうものだと諦めて覚えるしかない。</p>
<p>constがついていない型のオブジェクトをconstなlvalueリファレンスで参照することができる。</p>
<div class="sourceCode" id="cb595"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb595-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb595-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb595-3" data-line-number="3">    <span class="co">// constのついていない型のオブジェクト</span></a>
<a class="sourceLine" id="cb595-4" data-line-number="4">    <span class="dt">int</span> x = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb595-5" data-line-number="5"></a>
<a class="sourceLine" id="cb595-6" data-line-number="6">    <span class="co">// OK</span></a>
<a class="sourceLine" id="cb595-7" data-line-number="7">    <span class="dt">int</span> &amp; ref = x ;</a>
<a class="sourceLine" id="cb595-8" data-line-number="8">    <span class="co">// OK、constはつけてもよい</span></a>
<a class="sourceLine" id="cb595-9" data-line-number="9">    <span class="at">const</span> <span class="dt">int</span> &amp; cref = x ;</a>
<a class="sourceLine" id="cb595-10" data-line-number="10">}</a></code></pre></div>
<p>constのついている型のオブジェクトをconstのついていないlvalueリファレンスで参照することはできない。</p>
<div class="sourceCode" id="cb596"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb596-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb596-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb596-3" data-line-number="3">    <span class="co">// constのついている型のオブジェクト</span></a>
<a class="sourceLine" id="cb596-4" data-line-number="4">    <span class="at">const</span> <span class="dt">int</span> x = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb596-5" data-line-number="5"></a>
<a class="sourceLine" id="cb596-6" data-line-number="6">    <span class="co">// エラー、constがない。</span></a>
<a class="sourceLine" id="cb596-7" data-line-number="7">    <span class="dt">int</span> &amp; ref = x ;</a>
<a class="sourceLine" id="cb596-8" data-line-number="8"></a>
<a class="sourceLine" id="cb596-9" data-line-number="9">    <span class="co">// OK、constがついている</span></a>
<a class="sourceLine" id="cb596-10" data-line-number="10">    <span class="at">const</span> <span class="dt">int</span> &amp; cref = x ;</a>
<a class="sourceLine" id="cb596-11" data-line-number="11">}</a></code></pre></div>
<p>constのついているlvalueリファレンスは何の役に立つのかというと、関数の引数を取るときに役に立つ。</p>
<p>例えば以下のコードは非効率的だ。</p>
<div class="sourceCode" id="cb597"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb597-1" data-line-number="1"><span class="dt">void</span> f( <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v )</a>
<a class="sourceLine" id="cb597-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb597-3" data-line-number="3">    <span class="bu">std::</span>cout &lt;&lt; v.at(<span class="dv">1234</span>) ;</a>
<a class="sourceLine" id="cb597-4" data-line-number="4">}</a>
<a class="sourceLine" id="cb597-5" data-line-number="5"></a>
<a class="sourceLine" id="cb597-6" data-line-number="6"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb597-7" data-line-number="7">{</a>
<a class="sourceLine" id="cb597-8" data-line-number="8">    <span class="co">// 10000個の要素を持つvector</span></a>
<a class="sourceLine" id="cb597-9" data-line-number="9">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v(<span class="dv">10000</span>) ;</a>
<a class="sourceLine" id="cb597-10" data-line-number="10"></a>
<a class="sourceLine" id="cb597-11" data-line-number="11">    f( v ) ;</a>
<a class="sourceLine" id="cb597-12" data-line-number="12">}</a></code></pre></div>
<p>なぜかというと、関数の引数に渡すときに、変数<code>v</code>はコピーされるからだ。</p>
<p>リファレンスを使うと不要なコピーをしなくて済む。</p>
<div class="sourceCode" id="cb598"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb598-1" data-line-number="1"><span class="dt">void</span> f( <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; &amp; v )</a>
<a class="sourceLine" id="cb598-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb598-3" data-line-number="3">    <span class="bu">std::</span>cout &lt;&lt; v.at(<span class="dv">1234</span>) ;</a>
<a class="sourceLine" id="cb598-4" data-line-number="4">}</a></code></pre></div>
<p>しかし、リファレンスで受け取ると、うっかり変数を変更してしまった場合、その変更が関数の呼び出し元に反映されてしまう。</p>
<div class="sourceCode" id="cb599"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb599-1" data-line-number="1"><span class="co">// 値を変更するかもしれない</span></a>
<a class="sourceLine" id="cb599-2" data-line-number="2"><span class="dt">void</span> f( <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; &amp; v ) ;</a>
<a class="sourceLine" id="cb599-3" data-line-number="3"></a>
<a class="sourceLine" id="cb599-4" data-line-number="4"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb599-5" data-line-number="5">{</a>
<a class="sourceLine" id="cb599-6" data-line-number="6">    <span class="co">// 要素数10000のvector</span></a>
<a class="sourceLine" id="cb599-7" data-line-number="7">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v(<span class="dv">10000</span>) ;</a>
<a class="sourceLine" id="cb599-8" data-line-number="8"></a>
<a class="sourceLine" id="cb599-9" data-line-number="9">    f(v) ;</a>
<a class="sourceLine" id="cb599-10" data-line-number="10"></a>
<a class="sourceLine" id="cb599-11" data-line-number="11">    <span class="co">// 値は変更されているかもしれない</span></a>
<a class="sourceLine" id="cb599-12" data-line-number="12">}</a></code></pre></div>
<p>このとき、constなlvalueリファレンスを使うと、引数に取った値を変更しないことを保証できる。</p>
<div class="sourceCode" id="cb600"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb600-1" data-line-number="1"><span class="dt">void</span> f( <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; <span class="at">const</span> &amp; v ) ;</a></code></pre></div>
<h1 id="アルゴリズム">アルゴリズム</h1>
<p>アルゴリズムは難しい。アルゴリズム自体の難しさに加え、アルゴリズムを正しくコードで表記するのも難しい。そこでC++ではアルゴリズム自体をライブラリにしている。ライブラリとしてのアルゴリズムを使うことで、読者はアルゴリズムを自前で実装することなく、すでに正しく実装されたアルゴリズムを使うことができる。</p>
<h2 id="for_each">for_each</h2>
<p>例えば<code>vector</code>の要素を先頭から順番に標準出力するコードを考えよう。</p>
<div class="sourceCode" id="cb601"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb601-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb601-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb601-3" data-line-number="3">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</a>
<a class="sourceLine" id="cb601-4" data-line-number="4"></a>
<a class="sourceLine" id="cb601-5" data-line-number="5">    <span class="cf">for</span> (</a>
<a class="sourceLine" id="cb601-6" data-line-number="6">        <span class="kw">auto</span> i = <span class="bu">std::</span>begin(v),</a>
<a class="sourceLine" id="cb601-7" data-line-number="7">             j = <span class="bu">std::</span>end(v) ;</a>
<a class="sourceLine" id="cb601-8" data-line-number="8">        i != j ;</a>
<a class="sourceLine" id="cb601-9" data-line-number="9">        ++i  )</a>
<a class="sourceLine" id="cb601-10" data-line-number="10">    {</a>
<a class="sourceLine" id="cb601-11" data-line-number="11">        <span class="bu">std::</span>cout &lt;&lt; *i ;</a>
<a class="sourceLine" id="cb601-12" data-line-number="12">    }</a>
<a class="sourceLine" id="cb601-13" data-line-number="13">}</a></code></pre></div>
<p>このコードを書くのは難しい。このコードを書くには、イテレーターで要素の範囲を取り、ループを実行するごとにイテレーターを適切にインクリメントし、イテレーターが範囲内であるかどうかの判定をしなければならない。</p>
<p>アルゴリズムを理解するだけでも難しいのに、正しくコード書くのは更に難しい。例えば以下はコンパイルが通る完全に合法なC++だが間違っている。</p>
<div class="sourceCode" id="cb602"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb602-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb602-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb602-3" data-line-number="3">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</a>
<a class="sourceLine" id="cb602-4" data-line-number="4"></a>
<a class="sourceLine" id="cb602-5" data-line-number="5">    <span class="cf">for</span> (</a>
<a class="sourceLine" id="cb602-6" data-line-number="6">        <span class="kw">auto</span> i = <span class="bu">std::</span>begin(v),</a>
<a class="sourceLine" id="cb602-7" data-line-number="7">             j = <span class="bu">std::</span>end(v) ;</a>
<a class="sourceLine" id="cb602-8" data-line-number="8">        i == j ;</a>
<a class="sourceLine" id="cb602-9" data-line-number="9">        ++i  )</a>
<a class="sourceLine" id="cb602-10" data-line-number="10">    {</a>
<a class="sourceLine" id="cb602-11" data-line-number="11">        <span class="bu">std::</span>cout &lt;&lt; i ;</a>
<a class="sourceLine" id="cb602-12" data-line-number="12">    }</a>
<a class="sourceLine" id="cb602-13" data-line-number="13">}</a></code></pre></div>
<p>間違っている箇所がわかるだろうか。</p>
<p>まず比較の条件が間違っている。<code>i != j</code>となるべきところが<code>i == j</code>となっている。出力する部分も間違っている。イテレーター<code>i</code>が指し示す値を得るには<code>*i</code>としなければならないところ、単に<code>i</code>としている。</p>
<p>毎回このようなイテレーターのループをするfor文を書くのは間違いの元だ。ここで重要なのは、要素のそれぞれに対して<code>std::cout &lt;&lt; *i ;</code>を実行するということだ。要素を先頭から末尾まで順番に処理するというのはライブラリにやってもらいたい。</p>
<p>そこでこの処理を関数に切り出してみよう。イテレーター<code>[first,last)</code>を渡すと、イテレーターを先頭から末尾まで順番に処理してくれる関数は以下のように書ける。</p>
<div class="sourceCode" id="cb603"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb603-1" data-line-number="1"><span class="kw">auto</span> print_all = []( <span class="kw">auto</span> first, <span class="kw">auto</span> last )</a>
<a class="sourceLine" id="cb603-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb603-3" data-line-number="3">    <span class="co">// ループ</span></a>
<a class="sourceLine" id="cb603-4" data-line-number="4">    <span class="cf">for</span> ( <span class="kw">auto</span> iter = first ; iter != last ; ++iter )</a>
<a class="sourceLine" id="cb603-5" data-line-number="5">    {</a>
<a class="sourceLine" id="cb603-6" data-line-number="6">        <span class="co">// 重要な処理</span></a>
<a class="sourceLine" id="cb603-7" data-line-number="7">        <span class="bu">std::</span>cout &lt;&lt; *iter ;</a>
<a class="sourceLine" id="cb603-8" data-line-number="8">    }</a>
<a class="sourceLine" id="cb603-9" data-line-number="9">} ; </a>
<a class="sourceLine" id="cb603-10" data-line-number="10"></a>
<a class="sourceLine" id="cb603-11" data-line-number="11"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb603-12" data-line-number="12">{</a>
<a class="sourceLine" id="cb603-13" data-line-number="13">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</a>
<a class="sourceLine" id="cb603-14" data-line-number="14"></a>
<a class="sourceLine" id="cb603-15" data-line-number="15">    print_all( <span class="bu">std::</span>begin(v), <span class="bu">std::</span>end(v) ) ;</a>
<a class="sourceLine" id="cb603-16" data-line-number="16">}</a></code></pre></div>
<p>関数<code>printf_all</code>は便利だが、重要な処理がハードコードされている。例えば要素の集合のうち100以下の値だけ出力したいとか、値を2倍して出力したいとか、値を出力するたびに改行を出力したいという場合、それぞれに関数を書く必要がある。</p>
<div class="sourceCode" id="cb604"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb604-1" data-line-number="1"><span class="co">// 値が100以下なら出力</span></a>
<a class="sourceLine" id="cb604-2" data-line-number="2"><span class="kw">auto</span> print_if_le_100 = []( <span class="kw">auto</span> first, <span class="kw">auto</span> last )</a>
<a class="sourceLine" id="cb604-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb604-4" data-line-number="4">    <span class="cf">for</span> ( <span class="kw">auto</span> iter = first ; iter != last ; ++iter )</a>
<a class="sourceLine" id="cb604-5" data-line-number="5">    { <span class="co">// 特別な処理</span></a>
<a class="sourceLine" id="cb604-6" data-line-number="6">        <span class="cf">if</span> ( *iter &lt;= <span class="dv">100</span> )</a>
<a class="sourceLine" id="cb604-7" data-line-number="7">            <span class="bu">std::</span>cout &lt;&lt; *iter ;</a>
<a class="sourceLine" id="cb604-8" data-line-number="8">    }</a>
<a class="sourceLine" id="cb604-9" data-line-number="9">} ;</a>
<a class="sourceLine" id="cb604-10" data-line-number="10"></a>
<a class="sourceLine" id="cb604-11" data-line-number="11"></a>
<a class="sourceLine" id="cb604-12" data-line-number="12"><span class="co">// 値を2倍して出力</span></a>
<a class="sourceLine" id="cb604-13" data-line-number="13"><span class="kw">auto</span> print_twice = []( <span class="kw">auto</span> first, <span class="kw">auto</span> last )</a>
<a class="sourceLine" id="cb604-14" data-line-number="14">{</a>
<a class="sourceLine" id="cb604-15" data-line-number="15">    <span class="cf">for</span> ( <span class="kw">auto</span> iter = first ; iter != last ; ++iter )</a>
<a class="sourceLine" id="cb604-16" data-line-number="16">    { <span class="co">// 特別な処理</span></a>
<a class="sourceLine" id="cb604-17" data-line-number="17">        <span class="bu">std::</span>cout &lt;&lt; <span class="dv">2</span> * (*iter) ;</a>
<a class="sourceLine" id="cb604-18" data-line-number="18">    }</a>
<a class="sourceLine" id="cb604-19" data-line-number="19">} ;</a>
<a class="sourceLine" id="cb604-20" data-line-number="20"></a>
<a class="sourceLine" id="cb604-21" data-line-number="21"></a>
<a class="sourceLine" id="cb604-22" data-line-number="22"><span class="co">// 値を出力するたびに改行を出力</span></a>
<a class="sourceLine" id="cb604-23" data-line-number="23"><span class="kw">auto</span> print_with_newline = []( <span class="kw">auto</span> first, <span class="kw">auto</span> last )</a>
<a class="sourceLine" id="cb604-24" data-line-number="24">{</a>
<a class="sourceLine" id="cb604-25" data-line-number="25">    <span class="cf">for</span> ( <span class="kw">auto</span> iter = first ; iter != last ; ++iter )</a>
<a class="sourceLine" id="cb604-26" data-line-number="26">    { <span class="co">// 特別な処理</span></a>
<a class="sourceLine" id="cb604-27" data-line-number="27">        <span class="bu">std::</span>cout &lt;&lt; *iter &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb604-28" data-line-number="28">    }</a>
<a class="sourceLine" id="cb604-29" data-line-number="29">} ;</a></code></pre></div>
<p>これを見ると、for文によるイテレーターのループは全く同じコードだとわかる。</p>
<p>全く同じfor文を手で書くのは間違いの元だ。同じコードはできれば書きたくない。ここで必要なのは、共通な処理は一度書くだけで済ませ、特別な処理だけを記述すればすむような方法だ。</p>
<p>この問題を解決するには、問題を分割することだ。問題を「for文によるループ」と「特別な処理」に分けることだ。</p>
<p>ところで、関数は変数に代入できる。</p>
<div class="sourceCode" id="cb605"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb605-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb605-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb605-3" data-line-number="3">    <span class="co">// 変数に代入された関数</span></a>
<a class="sourceLine" id="cb605-4" data-line-number="4">    <span class="kw">auto</span> print = []( <span class="kw">auto</span> x ) { <span class="bu">std::</span>cout &lt;&lt; x ; } ;</a>
<a class="sourceLine" id="cb605-5" data-line-number="5"></a>
<a class="sourceLine" id="cb605-6" data-line-number="6">    <span class="co">// 変数に代入された関数の呼び出し</span></a>
<a class="sourceLine" id="cb605-7" data-line-number="7">    print(<span class="dv">123</span>) ;</a>
<a class="sourceLine" id="cb605-8" data-line-number="8">}</a></code></pre></div>
<p>変数に代入できるということは、関数の引数として関数に渡せるということだ。</p>
<div class="sourceCode" id="cb606"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb606-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb606-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb606-3" data-line-number="3">    <span class="co">// 関数を引数にとり呼び出す関数</span></a>
<a class="sourceLine" id="cb606-4" data-line-number="4">    <span class="kw">auto</span> call_func = []( <span class="kw">auto</span> func )</a>
<a class="sourceLine" id="cb606-5" data-line-number="5">    {</a>
<a class="sourceLine" id="cb606-6" data-line-number="6">        func(<span class="dv">123</span>) ;</a>
<a class="sourceLine" id="cb606-7" data-line-number="7">    } ;</a>
<a class="sourceLine" id="cb606-8" data-line-number="8"></a>
<a class="sourceLine" id="cb606-9" data-line-number="9">    <span class="co">// 引数を出力する関数</span></a>
<a class="sourceLine" id="cb606-10" data-line-number="10">    <span class="kw">auto</span> print = []( <span class="kw">auto</span> x ) { <span class="bu">std::</span>cout &lt;&lt; x ; } ;</a>
<a class="sourceLine" id="cb606-11" data-line-number="11"></a>
<a class="sourceLine" id="cb606-12" data-line-number="12">    call_func( print ) ;</a>
<a class="sourceLine" id="cb606-13" data-line-number="13"></a>
<a class="sourceLine" id="cb606-14" data-line-number="14">    <span class="co">// 引数を2倍して出力する関数</span></a>
<a class="sourceLine" id="cb606-15" data-line-number="15">    <span class="kw">auto</span> print_twice = []( <span class="kw">auto</span> x ) { <span class="bu">std::</span>cout &lt;&lt; <span class="dv">2</span>*x ; } ;</a>
<a class="sourceLine" id="cb606-16" data-line-number="16"></a>
<a class="sourceLine" id="cb606-17" data-line-number="17">    call_func( print_twice ) ;</a>
<a class="sourceLine" id="cb606-18" data-line-number="18">}</a></code></pre></div>
<p>すると、要素ごとの特別な処理をする関数を引数で受け取り、要素ごとに関数を適用する関数を書くとどうなるのか。</p>
<div class="sourceCode" id="cb607"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb607-1" data-line-number="1"><span class="kw">auto</span> for_each = []( <span class="kw">auto</span> first, <span class="kw">auto</span> last, <span class="kw">auto</span> f )</a>
<a class="sourceLine" id="cb607-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb607-3" data-line-number="3">    <span class="cf">for</span> ( <span class="kw">auto</span> iter = first ; iter != last ; ++iter )</a>
<a class="sourceLine" id="cb607-4" data-line-number="4">    {</a>
<a class="sourceLine" id="cb607-5" data-line-number="5">        f( *iter ) ;</a>
<a class="sourceLine" id="cb607-6" data-line-number="6">    }</a>
<a class="sourceLine" id="cb607-7" data-line-number="7">} ;</a></code></pre></div>
<p>この関数はイテレーターをループで回す部分だけを実装していて、要素ごとの処理は引数に取った関数に任せている。早速使ってみよう。</p>
<div class="sourceCode" id="cb608"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb608-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb608-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb608-3" data-line-number="3">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</a>
<a class="sourceLine" id="cb608-4" data-line-number="4"></a>
<a class="sourceLine" id="cb608-5" data-line-number="5">    <span class="co">// 引数を出力する関数</span></a>
<a class="sourceLine" id="cb608-6" data-line-number="6">    <span class="kw">auto</span> print_value = []( <span class="kw">auto</span> value ) { <span class="bu">std::</span>cout &lt;&lt; value ; } ;</a>
<a class="sourceLine" id="cb608-7" data-line-number="7"></a>
<a class="sourceLine" id="cb608-8" data-line-number="8">    for_each( <span class="bu">std::</span>begin(v), <span class="bu">std::</span>end(v), print_value ) ;</a>
<a class="sourceLine" id="cb608-9" data-line-number="9"></a>
<a class="sourceLine" id="cb608-10" data-line-number="10">    <span class="co">// 引数を2倍して出力する関数</span></a>
<a class="sourceLine" id="cb608-11" data-line-number="11">    <span class="kw">auto</span> print_twice = []( <span class="kw">auto</span> value ) { <span class="bu">std::</span>cout &lt;&lt; <span class="dv">2</span> * value ; } ;</a>
<a class="sourceLine" id="cb608-12" data-line-number="12"></a>
<a class="sourceLine" id="cb608-13" data-line-number="13">    for_each( <span class="bu">std::</span>begin(v), <span class="bu">std::</span>end(v), print_twice ) ;</a>
<a class="sourceLine" id="cb608-14" data-line-number="14"></a>
<a class="sourceLine" id="cb608-15" data-line-number="15">    <span class="co">// 引数を出力した後に改行を出力する関数</span></a>
<a class="sourceLine" id="cb608-16" data-line-number="16">    <span class="kw">auto</span> print_with_newline = []( <span class="kw">auto</span> value ) { <span class="bu">std::</span>cout &lt;&lt; value &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ; } ;</a>
<a class="sourceLine" id="cb608-17" data-line-number="17"></a>
<a class="sourceLine" id="cb608-18" data-line-number="18">    for_each( <span class="bu">std::</span>begin(v), <span class="bu">std::</span>end(v), print_with_newline ) ;</a>
<a class="sourceLine" id="cb608-19" data-line-number="19">}</a></code></pre></div>
<p>関数は変数に代入しなくても使えるので、上のコードは以下のようにも書ける。</p>
<div class="sourceCode" id="cb609"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb609-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb609-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb609-3" data-line-number="3">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</a>
<a class="sourceLine" id="cb609-4" data-line-number="4"></a>
<a class="sourceLine" id="cb609-5" data-line-number="5">    <span class="co">// 引数を出力する</span></a>
<a class="sourceLine" id="cb609-6" data-line-number="6">    for_each( <span class="bu">std::</span>begin(v), <span class="bu">std::</span>end(v),</a>
<a class="sourceLine" id="cb609-7" data-line-number="7">        []( <span class="kw">auto</span> value ) { <span class="bu">std::</span>cout &lt;&lt; value ; } ) ;</a>
<a class="sourceLine" id="cb609-8" data-line-number="8"></a>
<a class="sourceLine" id="cb609-9" data-line-number="9">    <span class="co">// 引数を2倍して出力する</span></a>
<a class="sourceLine" id="cb609-10" data-line-number="10">    for_each( <span class="bu">std::</span>begin(v), <span class="bu">std::</span>end(v),</a>
<a class="sourceLine" id="cb609-11" data-line-number="11">        []( <span class="kw">auto</span> value ) { <span class="bu">std::</span>cout &lt;&lt; <span class="dv">2</span> * value ; } ) ;</a>
<a class="sourceLine" id="cb609-12" data-line-number="12"></a>
<a class="sourceLine" id="cb609-13" data-line-number="13">    <span class="co">// 引数を出力した後に改行を出力する関数</span></a>
<a class="sourceLine" id="cb609-14" data-line-number="14">    for_each( <span class="bu">std::</span>begin(v), <span class="bu">std::</span>end(v),</a>
<a class="sourceLine" id="cb609-15" data-line-number="15">        []( <span class="kw">auto</span> value ) { <span class="bu">std::</span>cout &lt;&lt; value &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ; } ) ;</a>
<a class="sourceLine" id="cb609-16" data-line-number="16">}</a></code></pre></div>
<p>わざわざfor文を書かずに、問題の本質的な処理だけを書くことができるようになった。</p>
<p>このイテレーターを先頭から末尾までループで回し、要素ごとに関数を呼び出すという処理はとても便利なので、標準ライブラリには<code>std::for_each( first, last, f)</code>がある。使い方は同じだ。</p>
<div class="sourceCode" id="cb610"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb610-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb610-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb610-3" data-line-number="3">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</a>
<a class="sourceLine" id="cb610-4" data-line-number="4"></a>
<a class="sourceLine" id="cb610-5" data-line-number="5">    <span class="bu">std::</span>for_each( <span class="bu">std::</span>begin(v), <span class="bu">std::</span>end(v),</a>
<a class="sourceLine" id="cb610-6" data-line-number="6">        []( <span class="kw">auto</span> value ) { <span class="bu">std::</span>cout &lt;&lt; value ; } ) ;</a>
<a class="sourceLine" id="cb610-7" data-line-number="7">}</a></code></pre></div>
<p>C++17の時点ではまだ使えないが、将来のC++では、イテレーターを渡さずに、vectorを直接渡すことができるようになる予定だ。</p>
<div class="sourceCode" id="cb611"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb611-1" data-line-number="1"><span class="co">// C++20予定</span></a>
<a class="sourceLine" id="cb611-2" data-line-number="2"></a>
<a class="sourceLine" id="cb611-3" data-line-number="3"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb611-4" data-line-number="4">{</a>
<a class="sourceLine" id="cb611-5" data-line-number="5">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</a>
<a class="sourceLine" id="cb611-6" data-line-number="6"></a>
<a class="sourceLine" id="cb611-7" data-line-number="7">    <span class="bu">std::</span>for_each( v, []( <span class="kw">auto</span> value ) { <span class="bu">std::</span>cout &lt;&lt; value ; } ) ;</a>
<a class="sourceLine" id="cb611-8" data-line-number="8">}</a></code></pre></div>
<p>ところでもう一度<code>for_each</code>の実装を見てみよう。</p>
<div class="sourceCode" id="cb612"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb612-1" data-line-number="1"><span class="kw">auto</span> for_each = []( <span class="kw">auto</span> first, <span class="kw">auto</span> last, <span class="kw">auto</span> f )</a>
<a class="sourceLine" id="cb612-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb612-3" data-line-number="3">    <span class="cf">for</span> ( <span class="kw">auto</span> iter = first ; iter != last ; ++iter )</a>
<a class="sourceLine" id="cb612-4" data-line-number="4">    {</a>
<a class="sourceLine" id="cb612-5" data-line-number="5">        f( *iter ) ;</a>
<a class="sourceLine" id="cb612-6" data-line-number="6">    }</a>
<a class="sourceLine" id="cb612-7" data-line-number="7">} ;</a></code></pre></div>
<p><code>f(*iter)</code>がとても興味深い。もし関数fがリファレンスを引数に取っていたらどうなるだろうか。</p>
<div class="sourceCode" id="cb613"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb613-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb613-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb613-3" data-line-number="3">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</a>
<a class="sourceLine" id="cb613-4" data-line-number="4"></a>
<a class="sourceLine" id="cb613-5" data-line-number="5">    <span class="co">// 引数をリファレンスでとって2倍にする関数</span></a>
<a class="sourceLine" id="cb613-6" data-line-number="6">    <span class="kw">auto</span> twice = [](<span class="kw">auto</span> &amp; value){ value = <span class="dv">2</span> * value ; } ;</a>
<a class="sourceLine" id="cb613-7" data-line-number="7"></a>
<a class="sourceLine" id="cb613-8" data-line-number="8">    <span class="bu">std::</span>for_each( <span class="bu">std::</span>begin(v), <span class="bu">std::</span>end(v), twice ) ;</a>
<a class="sourceLine" id="cb613-9" data-line-number="9"></a>
<a class="sourceLine" id="cb613-10" data-line-number="10">    <span class="co">// 引数を出力する関数</span></a>
<a class="sourceLine" id="cb613-11" data-line-number="11">    <span class="kw">auto</span> print = [](<span class="kw">auto</span> &amp; value){ <span class="bu">std::</span>cout &lt;&lt; value &lt;&lt; <span class="st">&quot;, &quot;</span>s ; } ;</a>
<a class="sourceLine" id="cb613-12" data-line-number="12"></a>
<a class="sourceLine" id="cb613-13" data-line-number="13">    <span class="co">// 2, 4, 6, 8, 10, </span></a>
<a class="sourceLine" id="cb613-14" data-line-number="14">    <span class="bu">std::</span>for_each( <span class="bu">std::</span>begin(v), <span class="bu">std::</span>end(v), print ) ;</a>
<a class="sourceLine" id="cb613-15" data-line-number="15">}</a></code></pre></div>
<p>元のvectorを書き換えることもできる。</p>
<h2 id="all_ofany_ofnone_of">all_of/any_of/none_of</h2>
<p>他のアルゴリズムも実装していくことで学んでいこう。</p>
<p><code>all_of(first, last, pred)</code>は、<code>[first,last)</code>の間のイテレーター<code>iter</code>のそれぞれに対して、<code>pred(*iter)</code>がすべて<code>true</code>を返すならば<code>true</code>、そうではないならば<code>false</code>を返すアルゴリズムだ。</p>
<p>この<code>all_of</code>は要素が全て条件を満たすかどうかを調べるのに使える。</p>
<div class="sourceCode" id="cb614"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb614-1" data-line-number="1"><span class="co">// 要素が全て偶数かどうか調べる関数</span></a>
<a class="sourceLine" id="cb614-2" data-line-number="2"><span class="kw">auto</span> is_all_of_odd = []( <span class="kw">auto</span> first, <span class="kw">auto</span> last )</a>
<a class="sourceLine" id="cb614-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb614-4" data-line-number="4">    <span class="cf">return</span> <span class="bu">std::</span>all_of( first, last,</a>
<a class="sourceLine" id="cb614-5" data-line-number="5">        []( <span class="kw">auto</span> value ) { <span class="cf">return</span> value % <span class="dv">2</span> == <span class="dv">0</span> ; } ) ;</a>
<a class="sourceLine" id="cb614-6" data-line-number="6">} ;</a>
<a class="sourceLine" id="cb614-7" data-line-number="7"></a>
<a class="sourceLine" id="cb614-8" data-line-number="8"><span class="co">// 要素が全て100以下かどうか調べる関数</span></a>
<a class="sourceLine" id="cb614-9" data-line-number="9"><span class="kw">auto</span> is_all_of_le_100 = []( <span class="kw">auto</span> first, <span class="kw">auto</span> last )</a>
<a class="sourceLine" id="cb614-10" data-line-number="10">{</a>
<a class="sourceLine" id="cb614-11" data-line-number="11">    <span class="cf">return</span> <span class="bu">std::</span>all_of( first, last,</a>
<a class="sourceLine" id="cb614-12" data-line-number="12">        []( <span class="kw">auto</span> value ) { <span class="cf">return</span> value &lt;= <span class="dv">100</span>; } ) ;</a>
<a class="sourceLine" id="cb614-13" data-line-number="13">} ;</a></code></pre></div>
<p>ところで、もし要素がゼロ個の、つまり空のイテレーターを渡した場合どうなるのだろうか。</p>
<div class="sourceCode" id="cb615"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb615-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb615-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb615-3" data-line-number="3">    <span class="co">// 空のvector</span></a>
<a class="sourceLine" id="cb615-4" data-line-number="4">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v ;</a>
<a class="sourceLine" id="cb615-5" data-line-number="5"></a>
<a class="sourceLine" id="cb615-6" data-line-number="6">    <span class="dt">bool</span> b = <span class="bu">std::</span>all_of( <span class="bu">std::</span>begin(v), <span class="bu">std::</span>end(v),</a>
<a class="sourceLine" id="cb615-7" data-line-number="7">        <span class="co">// 特に意味のない関数</span></a>
<a class="sourceLine" id="cb615-8" data-line-number="8">        [](<span class="kw">auto</span> value){ <span class="cf">return</span> <span class="kw">false</span> ; } ) ;</a>
<a class="sourceLine" id="cb615-9" data-line-number="9">}</a></code></pre></div>
<p>この場合、<code>all_of</code>はtrueを返す。</p>
<p>実装は以下のようになる。</p>
<div class="sourceCode" id="cb616"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb616-1" data-line-number="1"><span class="kw">auto</span> all_of = []( <span class="kw">auto</span> first, <span class="kw">auto</span> last, <span class="kw">auto</span> pred )</a>
<a class="sourceLine" id="cb616-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb616-3" data-line-number="3">    <span class="cf">for</span> ( <span class="kw">auto</span> iter = first ; iter != last ; ++iter )</a>
<a class="sourceLine" id="cb616-4" data-line-number="4">    {</a>
<a class="sourceLine" id="cb616-5" data-line-number="5">        <span class="cf">if</span> ( pred( *iter ) == <span class="kw">false</span> )</a>
<a class="sourceLine" id="cb616-6" data-line-number="6">            <span class="cf">return</span> <span class="kw">false</span> ;</a>
<a class="sourceLine" id="cb616-7" data-line-number="7">    }</a>
<a class="sourceLine" id="cb616-8" data-line-number="8"></a>
<a class="sourceLine" id="cb616-9" data-line-number="9">    <span class="cf">return</span> <span class="kw">true</span> ;</a>
<a class="sourceLine" id="cb616-10" data-line-number="10">} ;</a></code></pre></div>
<p><code>[first,last)</code>が空かどうかを確認する必要はない。というのも、空であればループは一度も実行されないからだ。</p>
<p><code>any_of(first, last, pred)</code>は<code>[first,last)</code>の間のイテレーター<code>iter</code>それぞれに対して、<code>pred(*iter)</code>がひとつでも<code>true</code>ならば<code>true</code>を返す。空の場合、すべて<code>false</code>の場合は<code>false</code>を返す。</p>
<p><code>any_of</code>は要素に一つでも条件を満たすものがあるかどうかを調べるのに使える。</p>
<div class="sourceCode" id="cb617"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb617-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb617-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb617-3" data-line-number="3">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</a>
<a class="sourceLine" id="cb617-4" data-line-number="4"></a>
<a class="sourceLine" id="cb617-5" data-line-number="5">    <span class="co">// 要素に一つでも3が含まれているか？</span></a>
<a class="sourceLine" id="cb617-6" data-line-number="6">    <span class="co">// true</span></a>
<a class="sourceLine" id="cb617-7" data-line-number="7">    <span class="dt">bool</span> has_3 = <span class="bu">std::</span>any_of( <span class="bu">std::</span>begin(v), <span class="bu">std::</span>end(v),</a>
<a class="sourceLine" id="cb617-8" data-line-number="8">        []( <span class="kw">auto</span> x ) { <span class="cf">return</span> x == <span class="dv">3</span> ;}  ) ;</a>
<a class="sourceLine" id="cb617-9" data-line-number="9"></a>
<a class="sourceLine" id="cb617-10" data-line-number="10">    <span class="co">// 要素に一つでも10が含まれているか？</span></a>
<a class="sourceLine" id="cb617-11" data-line-number="11">    <span class="co">// false</span></a>
<a class="sourceLine" id="cb617-12" data-line-number="12">    <span class="dt">bool</span> has_10 = <span class="bu">std::</span>any_of( <span class="bu">std::</span>begin(v), <span class="bu">std::</span>end(v),</a>
<a class="sourceLine" id="cb617-13" data-line-number="13">        []( <span class="kw">auto</span> x ) { <span class="cf">return</span> x == <span class="dv">10</span> ;}  ) ;</a>
<a class="sourceLine" id="cb617-14" data-line-number="14">}</a></code></pre></div>
<p>これも実装してみよう。</p>
<div class="sourceCode" id="cb618"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb618-1" data-line-number="1"><span class="kw">auto</span> any_of = []( <span class="kw">auto</span> first, <span class="kw">auto</span> last, <span class="kw">auto</span> pred )</a>
<a class="sourceLine" id="cb618-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb618-3" data-line-number="3">    <span class="cf">for</span> ( <span class="kw">auto</span> iter = first ; iter != last ; ++iter )</a>
<a class="sourceLine" id="cb618-4" data-line-number="4">    {</a>
<a class="sourceLine" id="cb618-5" data-line-number="5">        <span class="cf">if</span> ( pred( *iter ) )</a>
<a class="sourceLine" id="cb618-6" data-line-number="6">            <span class="cf">return</span> <span class="kw">true</span> ;</a>
<a class="sourceLine" id="cb618-7" data-line-number="7">    }</a>
<a class="sourceLine" id="cb618-8" data-line-number="8">    <span class="cf">return</span> <span class="kw">false</span> ;</a>
<a class="sourceLine" id="cb618-9" data-line-number="9">} ;</a></code></pre></div>
<p><code>none_of(first, last, pred)</code>は<code>[first,last)</code>の間のイテレーター<code>iter</code>それぞれに対して、<code>pred(*iter)</code>がすべて<code>false</code>ならば<code>true</code>を返す。空の場合の<code>true</code>を返す。それ以外は<code>false</code>を返す。</p>
<p><code>none_of</code>はすべての要素が条件を満たさない判定に使える。</p>
<div class="sourceCode" id="cb619"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb619-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb619-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb619-3" data-line-number="3">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</a>
<a class="sourceLine" id="cb619-4" data-line-number="4"></a>
<a class="sourceLine" id="cb619-5" data-line-number="5">    <span class="co">// 値は100か？</span></a>
<a class="sourceLine" id="cb619-6" data-line-number="6">    <span class="kw">auto</span> is_100 = [](<span class="kw">auto</span> x){ <span class="cf">return</span> x == <span class="dv">100</span> ; } ;</a>
<a class="sourceLine" id="cb619-7" data-line-number="7"></a>
<a class="sourceLine" id="cb619-8" data-line-number="8">    <span class="dt">bool</span> b = <span class="bu">std::</span>none_of( <span class="bu">std::</span>begin(v), <span class="bu">std::</span>end(v), is_100 ) ;</a>
<a class="sourceLine" id="cb619-9" data-line-number="9">}</a></code></pre></div>
<p>これも実装してみよう。</p>
<div class="sourceCode" id="cb620"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb620-1" data-line-number="1"><span class="kw">auto</span> none_of = []( <span class="kw">auto</span> first, <span class="kw">auto</span> last, <span class="kw">auto</span> pred )</a>
<a class="sourceLine" id="cb620-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb620-3" data-line-number="3">    <span class="cf">for</span> ( <span class="kw">auto</span> iter = first ; first != last ; ++iter )</a>
<a class="sourceLine" id="cb620-4" data-line-number="4">    {</a>
<a class="sourceLine" id="cb620-5" data-line-number="5">        <span class="cf">if</span> ( pred(*iter) )</a>
<a class="sourceLine" id="cb620-6" data-line-number="6">            <span class="cf">return</span> <span class="kw">false</span> ;</a>
<a class="sourceLine" id="cb620-7" data-line-number="7">    }</a>
<a class="sourceLine" id="cb620-8" data-line-number="8">    <span class="cf">return</span> <span class="kw">true</span> ;</a>
<a class="sourceLine" id="cb620-9" data-line-number="9">} ;</a></code></pre></div>
<h2 id="findfind_if">find/find_if</h2>
<p><code>find( first, last, value )</code>はイテレーター<code>[first,last)</code>からvalueに等しい値を見つけて、そのイテレーターを返すアルゴリズムだ。</p>
<div class="sourceCode" id="cb621"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb621-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb621-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb621-3" data-line-number="3">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</a>
<a class="sourceLine" id="cb621-4" data-line-number="4"></a>
<a class="sourceLine" id="cb621-5" data-line-number="5">    <span class="co">// 3を指すイテレーター</span></a>
<a class="sourceLine" id="cb621-6" data-line-number="6">    <span class="kw">auto</span> pos = <span class="bu">std::</span>find( <span class="bu">std::</span>begin(v), <span class="bu">std::</span>end(v), <span class="dv">3</span> ) ;</a>
<a class="sourceLine" id="cb621-7" data-line-number="7"></a>
<a class="sourceLine" id="cb621-8" data-line-number="8">    <span class="bu">std::</span>cout &lt;&lt; *pos ;</a>
<a class="sourceLine" id="cb621-9" data-line-number="9">}</a></code></pre></div>
<p>要素が見つからない場合はlastが返る。</p>
<div class="sourceCode" id="cb622"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb622-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb622-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb622-3" data-line-number="3">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</a>
<a class="sourceLine" id="cb622-4" data-line-number="4"></a>
<a class="sourceLine" id="cb622-5" data-line-number="5">    <span class="kw">auto</span> pos = <span class="bu">std::</span>find( <span class="bu">std::</span>begin(v), <span class="bu">std::</span>end(v), <span class="dv">0</span> ) ;</a>
<a class="sourceLine" id="cb622-6" data-line-number="6"></a>
<a class="sourceLine" id="cb622-7" data-line-number="7">    <span class="cf">if</span> ( pos != <span class="bu">std::</span>end(v) )</a>
<a class="sourceLine" id="cb622-8" data-line-number="8">    {</a>
<a class="sourceLine" id="cb622-9" data-line-number="9">        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Found.&quot;</span>s ; </a>
<a class="sourceLine" id="cb622-10" data-line-number="10">    }</a>
<a class="sourceLine" id="cb622-11" data-line-number="11">    <span class="cf">else</span></a>
<a class="sourceLine" id="cb622-12" data-line-number="12">    {</a>
<a class="sourceLine" id="cb622-13" data-line-number="13">        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Not found.&quot;</span>s ;</a>
<a class="sourceLine" id="cb622-14" data-line-number="14">    }</a>
<a class="sourceLine" id="cb622-15" data-line-number="15">}</a></code></pre></div>
<p>イテレーターがlastかどうかは実際にlastと比較すればよい。</p>
<p>アルゴリズムを理解するには、自分で実装してみるとよい。さっそくfindを実装してみよう。</p>
<div class="sourceCode" id="cb623"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb623-1" data-line-number="1"><span class="kw">auto</span> find = []( <span class="kw">auto</span> first, <span class="kw">auto</span> last, <span class="kw">auto</span> <span class="at">const</span> &amp; value )</a>
<a class="sourceLine" id="cb623-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb623-3" data-line-number="3">    <span class="cf">for</span> ( <span class="kw">auto</span> iter = first ; iter != last ; ++iter )</a>
<a class="sourceLine" id="cb623-4" data-line-number="4">    {</a>
<a class="sourceLine" id="cb623-5" data-line-number="5">        <span class="co">// 値を発見したらそのイテレーターを返す</span></a>
<a class="sourceLine" id="cb623-6" data-line-number="6">        <span class="cf">if</span> ( *iter == value )</a>
<a class="sourceLine" id="cb623-7" data-line-number="7">            <span class="cf">return</span> iter ;</a>
<a class="sourceLine" id="cb623-8" data-line-number="8">    }</a>
<a class="sourceLine" id="cb623-9" data-line-number="9">    <span class="co">// 値が見つからなければ最後のイテレーターを返す</span></a>
<a class="sourceLine" id="cb623-10" data-line-number="10">    <span class="cf">return</span> last ;</a>
<a class="sourceLine" id="cb623-11" data-line-number="11">} ;</a></code></pre></div>
<p><code>value</code>が<code>auto const &amp; value</code>になっているのは、リファレンスによってコピーを回避するためと、変更が必要ないためだ。しかし、intやdoubleのような単純な型については、わざわざconstなlvalueリファレンスを使う必要はない。</p>
<p><code>find_if(first, last, pred)</code>はイテレーター<code>[first,last)</code>から、要素を関数<code>pred</code>に渡したときにtrueを返す要素へのイテレーターを探すアルゴリズムだ。</p>
<p>関数<code>pred</code>についてはもう少し解説が必要だ。<code>pred</code>とは<code>predicate</code>の略で、以下のような形をしている。</p>
<div class="sourceCode" id="cb624"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb624-1" data-line-number="1"><span class="kw">auto</span> pred = []( <span class="kw">auto</span> <span class="at">const</span> &amp; value ) -&gt; <span class="dt">bool</span></a>
<a class="sourceLine" id="cb624-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb624-3" data-line-number="3">    <span class="cf">return</span> <span class="kw">true</span> ;</a>
<a class="sourceLine" id="cb624-4" data-line-number="4">} ;</a></code></pre></div>
<p>関数predは値を一つ引数にとり、bool型を返す関数だ。</p>
<p>早速使ってみよう。</p>
<div class="sourceCode" id="cb625"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb625-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb625-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb625-3" data-line-number="3">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">5</span>,<span class="dv">7</span>,<span class="dv">9</span>,<span class="dv">11</span>,<span class="dv">13</span>,<span class="dv">14</span>,<span class="dv">15</span>,<span class="dv">16</span>} ;</a>
<a class="sourceLine" id="cb625-4" data-line-number="4"></a>
<a class="sourceLine" id="cb625-5" data-line-number="5">    <span class="co">// 偶数ならばtrueを返す</span></a>
<a class="sourceLine" id="cb625-6" data-line-number="6">    <span class="kw">auto</span> is_even = []( <span class="kw">auto</span> value )</a>
<a class="sourceLine" id="cb625-7" data-line-number="7">    {</a>
<a class="sourceLine" id="cb625-8" data-line-number="8">        <span class="cf">return</span> value % <span class="dv">2</span> == <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb625-9" data-line-number="9">    } ;</a>
<a class="sourceLine" id="cb625-10" data-line-number="10">    <span class="co">// 奇数ならばtrueを返す</span></a>
<a class="sourceLine" id="cb625-11" data-line-number="11">    <span class="kw">auto</span> is_odd = []( <span class="kw">auto</span> value )</a>
<a class="sourceLine" id="cb625-12" data-line-number="12">    {</a>
<a class="sourceLine" id="cb625-13" data-line-number="13">        <span class="cf">return</span> value % <span class="dv">2</span> == <span class="dv">1</span> ;</a>
<a class="sourceLine" id="cb625-14" data-line-number="14">    } ;</a>
<a class="sourceLine" id="cb625-15" data-line-number="15"></a>
<a class="sourceLine" id="cb625-16" data-line-number="16">    <span class="co">// 最初の偶数の要素</span></a>
<a class="sourceLine" id="cb625-17" data-line-number="17">    <span class="kw">auto</span> even = <span class="bu">std::</span>find_if( <span class="bu">std::</span>begin(v), <span class="bu">std::</span>end(v), is_even ) ;</a>
<a class="sourceLine" id="cb625-18" data-line-number="18">    <span class="co">// 最初の奇数の要素</span></a>
<a class="sourceLine" id="cb625-19" data-line-number="19">    <span class="kw">auto</span> odd = <span class="bu">std::</span>find_if( <span class="bu">std::</span>begin(v), <span class="bu">std::</span>end(v), is_odd ) ;</a>
<a class="sourceLine" id="cb625-20" data-line-number="20">}</a></code></pre></div>
<p>実装はどうなるだろうか。</p>
<div class="sourceCode" id="cb626"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb626-1" data-line-number="1"><span class="kw">auto</span> find_if = []( <span class="kw">auto</span> first, <span class="kw">auto</span> last, <span class="kw">auto</span> pred )</a>
<a class="sourceLine" id="cb626-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb626-3" data-line-number="3">    <span class="cf">for</span> ( <span class="kw">auto</span> iter = first ; iter != last ; ++iter )</a>
<a class="sourceLine" id="cb626-4" data-line-number="4">    {</a>
<a class="sourceLine" id="cb626-5" data-line-number="5">        <span class="co">// predがtrueを返した最初のイテレーターを返す</span></a>
<a class="sourceLine" id="cb626-6" data-line-number="6">        <span class="cf">if</span> ( pred( *iter ) )</a>
<a class="sourceLine" id="cb626-7" data-line-number="7">            <span class="cf">return</span> iter ;</a>
<a class="sourceLine" id="cb626-8" data-line-number="8">    }</a>
<a class="sourceLine" id="cb626-9" data-line-number="9"></a>
<a class="sourceLine" id="cb626-10" data-line-number="10">    <span class="cf">return</span> last ;</a>
<a class="sourceLine" id="cb626-11" data-line-number="11">} ;</a></code></pre></div>
<p>値との比較が関数になっただけだ。</p>
<p>つまりある値と比較する関数を渡したならば、find_ifはfindと同じ動きをするということだ。</p>
<div class="sourceCode" id="cb627"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb627-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb627-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb627-3" data-line-number="3">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</a>
<a class="sourceLine" id="cb627-4" data-line-number="4"></a>
<a class="sourceLine" id="cb627-5" data-line-number="5">    <span class="co">// 引数が3の場合にtrueを返す関数</span></a>
<a class="sourceLine" id="cb627-6" data-line-number="6">    <span class="kw">auto</span> is_3 = []( <span class="kw">auto</span> x ) { <span class="cf">return</span> x == <span class="dv">3</span> ; } ;</a>
<a class="sourceLine" id="cb627-7" data-line-number="7"></a>
<a class="sourceLine" id="cb627-8" data-line-number="8">    <span class="co">// 最初に関数がtrueを返す要素へのイテレーターを探すfind_if</span></a>
<a class="sourceLine" id="cb627-9" data-line-number="9">    <span class="kw">auto</span> i = <span class="bu">std::</span>find_if( <span class="bu">std::</span>begin(v), <span class="bu">std::</span>end(v), is_3 ) ;</a>
<a class="sourceLine" id="cb627-10" data-line-number="10"></a>
<a class="sourceLine" id="cb627-11" data-line-number="11">    <span class="co">// 最初に3と等しい要素へのイテレーターを返すfind</span></a>
<a class="sourceLine" id="cb627-12" data-line-number="12">    <span class="kw">auto</span> j = <span class="bu">std::</span>find( <span class="bu">std::</span>begin(v), <span class="bu">std::</span>end(v), <span class="dv">3</span> ) ;</a>
<a class="sourceLine" id="cb627-13" data-line-number="13"></a>
<a class="sourceLine" id="cb627-14" data-line-number="14">    <span class="co">// 同じイテレーター</span></a>
<a class="sourceLine" id="cb627-15" data-line-number="15">    <span class="dt">bool</span> b = (i == j) ;</a>
<a class="sourceLine" id="cb627-16" data-line-number="16">}</a></code></pre></div>
<p>実は、関数は特別な<code>[=]</code>を使うことで、関数の外側の値をコピーして使うことができる</p>
<div class="sourceCode" id="cb628"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb628-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb628-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb628-3" data-line-number="3">    <span class="dt">int</span> value = <span class="dv">123</span> ;</a>
<a class="sourceLine" id="cb628-4" data-line-number="4"></a>
<a class="sourceLine" id="cb628-5" data-line-number="5">    <span class="kw">auto</span> f = [=]{ <span class="cf">return</span> value ; } ;</a>
<a class="sourceLine" id="cb628-6" data-line-number="6"></a>
<a class="sourceLine" id="cb628-7" data-line-number="7">    f() ; <span class="co">// 123</span></a>
<a class="sourceLine" id="cb628-8" data-line-number="8">}</a></code></pre></div>
<p>特別な<code>[&amp;]</code>を使うことで、関数の外側の値をリファレンスで使うことができる。</p>
<div class="sourceCode" id="cb629"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb629-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb629-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb629-3" data-line-number="3">    <span class="dt">int</span> value = <span class="dv">123</span> ;</a>
<a class="sourceLine" id="cb629-4" data-line-number="4"></a>
<a class="sourceLine" id="cb629-5" data-line-number="5">    <span class="kw">auto</span> f = [&amp;]{ ++value ; } ; </a>
<a class="sourceLine" id="cb629-6" data-line-number="6"></a>
<a class="sourceLine" id="cb629-7" data-line-number="7">    f() ;</a>
<a class="sourceLine" id="cb629-8" data-line-number="8">    <span class="bu">std::</span>cout &lt;&lt; value ; <span class="co">// 124</span></a>
<a class="sourceLine" id="cb629-9" data-line-number="9">}</a></code></pre></div>
<p>ということは、<code>find</code>は<code>find_if</code>で実装することもできるということだ。</p>
<div class="sourceCode" id="cb630"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb630-1" data-line-number="1"><span class="kw">auto</span> find = []( <span class="kw">auto</span> first, <span class="kw">auto</span> last, <span class="kw">auto</span> value )</a>
<a class="sourceLine" id="cb630-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb630-3" data-line-number="3">    <span class="cf">return</span> <span class="bu">std::</span>find_if( first, last,</a>
<a class="sourceLine" id="cb630-4" data-line-number="4">        [&amp;]( <span class="kw">auto</span> elem ) { <span class="cf">return</span> value == elem ; } ) ;</a>
<a class="sourceLine" id="cb630-5" data-line-number="5">} ;</a></code></pre></div>
<h2 id="countcount_if">count/count_if</h2>
<p><code>count(first, last, value)</code>は<code>[first,last)</code>の範囲のイテレーター<code>i</code>から<code>*i == value</code>になるイテレーター<code>i</code>の数を数える。</p>
<p><code>count</code>は指定した値と同じ要素の数を数える関数だ。</p>
<div class="sourceCode" id="cb631"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb631-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb631-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb631-3" data-line-number="3">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">3</span>} ;</a>
<a class="sourceLine" id="cb631-4" data-line-number="4"></a>
<a class="sourceLine" id="cb631-5" data-line-number="5">    <span class="co">// 3</span></a>
<a class="sourceLine" id="cb631-6" data-line-number="6">    <span class="kw">auto</span> a = <span class="bu">std::</span>count( <span class="bu">std::</span>begin(v), <span class="bu">std::</span>end(v), <span class="dv">1</span> ) ;</a>
<a class="sourceLine" id="cb631-7" data-line-number="7">    <span class="co">// 1</span></a>
<a class="sourceLine" id="cb631-8" data-line-number="8">    <span class="kw">auto</span> b = <span class="bu">std::</span>count( <span class="bu">std::</span>begin(v), <span class="bu">std::</span>end(v), <span class="dv">2</span> ) ;</a>
<a class="sourceLine" id="cb631-9" data-line-number="9">    <span class="co">// 2</span></a>
<a class="sourceLine" id="cb631-10" data-line-number="10">    <span class="kw">auto</span> c = <span class="bu">std::</span>count( <span class="bu">std::</span>begin(v), <span class="bu">std::</span>end(v), <span class="dv">3</span> ) ;</a>
<a class="sourceLine" id="cb631-11" data-line-number="11">}</a></code></pre></div>
<p>実装してみよう。</p>
<div class="sourceCode" id="cb632"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb632-1" data-line-number="1"><span class="kw">auto</span> count = []( <span class="kw">auto</span> first, <span class="kw">auto</span> last, <span class="kw">auto</span> value )</a>
<a class="sourceLine" id="cb632-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb632-3" data-line-number="3">    <span class="kw">auto</span> counter = <span class="dv">0u</span> ;</a>
<a class="sourceLine" id="cb632-4" data-line-number="4">    <span class="cf">for</span> ( <span class="kw">auto</span> i = first ; i != last ; ++i )</a>
<a class="sourceLine" id="cb632-5" data-line-number="5">    {</a>
<a class="sourceLine" id="cb632-6" data-line-number="6">        <span class="cf">if</span> ( *i == value )</a>
<a class="sourceLine" id="cb632-7" data-line-number="7">            ++counter ;  </a>
<a class="sourceLine" id="cb632-8" data-line-number="8">    }</a>
<a class="sourceLine" id="cb632-9" data-line-number="9">    <span class="cf">return</span> counter ;</a>
<a class="sourceLine" id="cb632-10" data-line-number="10">} ;</a></code></pre></div>
<p><code>count_if(first, last, pred)</code>は<code>[first, last)</code>の範囲のイテレーター<code>i</code>から<code>pred(*i) != false</code>になるイテレーター<code>i</code>の数を返す。</p>
<p><code>count_if</code>は要素を数える対象にするかどうかを判定する関数を渡せる<code>count</code>だ。</p>
<div class="sourceCode" id="cb633"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb633-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb633-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb633-3" data-line-number="3">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">3</span>} ;</a>
<a class="sourceLine" id="cb633-4" data-line-number="4"></a>
<a class="sourceLine" id="cb633-5" data-line-number="5">    <span class="co">// 奇数の数: 5</span></a>
<a class="sourceLine" id="cb633-6" data-line-number="6">    <span class="kw">auto</span> a = <span class="bu">std::</span>count_if( <span class="bu">std::</span>begin(v), <span class="bu">std::</span>end(v),</a>
<a class="sourceLine" id="cb633-7" data-line-number="7">        [](<span class="kw">auto</span> x){ <span class="cf">return</span> x%<span class="dv">2</span> == <span class="dv">1</span> ; } ) ;</a>
<a class="sourceLine" id="cb633-8" data-line-number="8"></a>
<a class="sourceLine" id="cb633-9" data-line-number="9">    <span class="co">// 偶数の数: 1</span></a>
<a class="sourceLine" id="cb633-10" data-line-number="10">    <span class="kw">auto</span> b = <span class="bu">std::</span>count_if( <span class="bu">std::</span>begin(v), <span class="bu">std::</span>end(v),</a>
<a class="sourceLine" id="cb633-11" data-line-number="11">        [](<span class="kw">auto</span> x){ <span class="cf">return</span> x%<span class="dv">2</span> == <span class="dv">0</span> ; } ) ;</a>
<a class="sourceLine" id="cb633-12" data-line-number="12"></a>
<a class="sourceLine" id="cb633-13" data-line-number="13">    <span class="co">// 2以上の数: 3</span></a>
<a class="sourceLine" id="cb633-14" data-line-number="14">    <span class="kw">auto</span> c = <span class="bu">std::</span>count_if( <span class="bu">std::</span>begin(v), <span class="bu">std::</span>end(v),</a>
<a class="sourceLine" id="cb633-15" data-line-number="15">        [](<span class="kw">auto</span> x){ <span class="cf">return</span> x &gt;= <span class="dv">2</span> ; } ) ;</a>
<a class="sourceLine" id="cb633-16" data-line-number="16">}</a></code></pre></div>
<p>実装してみよう。</p>
<div class="sourceCode" id="cb634"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb634-1" data-line-number="1"><span class="kw">auto</span> count = []( <span class="kw">auto</span> first, <span class="kw">auto</span> last, <span class="kw">auto</span> pred )</a>
<a class="sourceLine" id="cb634-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb634-3" data-line-number="3">    <span class="kw">auto</span> counter = <span class="dv">0u</span> ;</a>
<a class="sourceLine" id="cb634-4" data-line-number="4">    <span class="cf">for</span> ( <span class="kw">auto</span> i = first ; i != last ; ++i )</a>
<a class="sourceLine" id="cb634-5" data-line-number="5">    {</a>
<a class="sourceLine" id="cb634-6" data-line-number="6">        <span class="cf">if</span> ( pred(*i) != <span class="kw">false</span> )</a>
<a class="sourceLine" id="cb634-7" data-line-number="7">            ++counter ;  </a>
<a class="sourceLine" id="cb634-8" data-line-number="8">    }</a>
<a class="sourceLine" id="cb634-9" data-line-number="9">    <span class="cf">return</span> counter ;</a>
<a class="sourceLine" id="cb634-10" data-line-number="10">} ;</a></code></pre></div>
<h2 id="equal">equal</h2>
<p>これまでのアルゴリズムは一つのイテレーターの範囲だけを扱ってきた。アルゴリズムの中には複数の範囲を取るものもある。</p>
<p><code>equal(first1, last1, first2, last2)</code>は<code>[first1,last1)</code>と<code>[first2, last2)</code>が等しい場合にtrueを返す。「等しい」というのは、要素の数が同じで、各要素がそれぞれ等しい場合を指す。</p>
<div class="sourceCode" id="cb635"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb635-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb635-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb635-3" data-line-number="3">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; a = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</a>
<a class="sourceLine" id="cb635-4" data-line-number="4">    <span class="co">// aと等しい</span></a>
<a class="sourceLine" id="cb635-5" data-line-number="5">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; b = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</a>
<a class="sourceLine" id="cb635-6" data-line-number="6">    <span class="co">// aと等しくない</span></a>
<a class="sourceLine" id="cb635-7" data-line-number="7">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; c = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>} ;</a>
<a class="sourceLine" id="cb635-8" data-line-number="8">    <span class="co">// aと等しくない</span></a>
<a class="sourceLine" id="cb635-9" data-line-number="9">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; d = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">6</span>} ;</a>
<a class="sourceLine" id="cb635-10" data-line-number="10"></a>
<a class="sourceLine" id="cb635-11" data-line-number="11">    <span class="co">// true</span></a>
<a class="sourceLine" id="cb635-12" data-line-number="12">    <span class="dt">bool</span> ab = <span class="bu">std::</span>equal(</a>
<a class="sourceLine" id="cb635-13" data-line-number="13">        <span class="bu">std::</span>begin(a), <span class="bu">std::</span>end(a),</a>
<a class="sourceLine" id="cb635-14" data-line-number="14">        <span class="bu">std::</span>begin(b), <span class="bu">std::</span>end(b) ) ;</a>
<a class="sourceLine" id="cb635-15" data-line-number="15"></a>
<a class="sourceLine" id="cb635-16" data-line-number="16">    <span class="co">// false</span></a>
<a class="sourceLine" id="cb635-17" data-line-number="17">    <span class="dt">bool</span> ac = <span class="bu">std::</span>equal(</a>
<a class="sourceLine" id="cb635-18" data-line-number="18">        <span class="bu">std::</span>begin(a), <span class="bu">std::</span>end(a),</a>
<a class="sourceLine" id="cb635-19" data-line-number="19">        <span class="bu">std::</span>begin(c), <span class="bu">std::</span>end(c) ) ;</a>
<a class="sourceLine" id="cb635-20" data-line-number="20"></a>
<a class="sourceLine" id="cb635-21" data-line-number="21">    <span class="co">// false</span></a>
<a class="sourceLine" id="cb635-22" data-line-number="22">    <span class="dt">bool</span> ad = <span class="bu">std::</span>equal(</a>
<a class="sourceLine" id="cb635-23" data-line-number="23">        <span class="bu">std::</span>begin(a), <span class="bu">std::</span>end(a),</a>
<a class="sourceLine" id="cb635-24" data-line-number="24">        <span class="bu">std::</span>begin(d), <span class="bu">std::</span>end(d) ) ;</a>
<a class="sourceLine" id="cb635-25" data-line-number="25">}</a></code></pre></div>
<p>実装は、まず要素数を比較し、等しくなければ<code>false</code>を返す。次に各要素を一つづつ比較し、途中で等しくない要素が見つかれば<code>false</code>を、最後まで各要素が等しければ<code>true</code>を返す。</p>
<p>イテレーターの範囲<code>[first,last)</code>の要素数は<code>last-first</code>で取得できる。</p>
<div class="sourceCode" id="cb636"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb636-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb636-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb636-3" data-line-number="3">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</a>
<a class="sourceLine" id="cb636-4" data-line-number="4"></a>
<a class="sourceLine" id="cb636-5" data-line-number="5">    <span class="co">// 最初の要素</span></a>
<a class="sourceLine" id="cb636-6" data-line-number="6">    <span class="kw">auto</span> first = <span class="bu">std::</span>begin(v) ;</a>
<a class="sourceLine" id="cb636-7" data-line-number="7">    <span class="co">// 最後の一つ次の要素</span></a>
<a class="sourceLine" id="cb636-8" data-line-number="8">    <span class="kw">auto</span> last = <span class="bu">std::</span>end(v) ;</a>
<a class="sourceLine" id="cb636-9" data-line-number="9"></a>
<a class="sourceLine" id="cb636-10" data-line-number="10">    <span class="co">// 要素数: 5</span></a>
<a class="sourceLine" id="cb636-11" data-line-number="11">    <span class="kw">auto</span> size = last - first ;</a>
<a class="sourceLine" id="cb636-12" data-line-number="12"></a>
<a class="sourceLine" id="cb636-13" data-line-number="13">    <span class="co">// 最初の次の要素</span></a>
<a class="sourceLine" id="cb636-14" data-line-number="14">    <span class="kw">auto</span> next = first + <span class="dv">1</span> ;</a>
<a class="sourceLine" id="cb636-15" data-line-number="15"></a>
<a class="sourceLine" id="cb636-16" data-line-number="16">    <span class="co">// 4</span></a>
<a class="sourceLine" id="cb636-17" data-line-number="17">    <span class="kw">auto</span> size_from_next = last - next ;</a>
<a class="sourceLine" id="cb636-18" data-line-number="18">}</a></code></pre></div>
<p><code>last-first</code>という表記はわかりにくいので、C++には<code>distance(first, last)</code>というライブラリが用意されている。</p>
<div class="sourceCode" id="cb637"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb637-1" data-line-number="1"><span class="kw">auto</span> distance = []( <span class="kw">auto</span> first, <span class="kw">auto</span> last )</a>
<a class="sourceLine" id="cb637-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb637-3" data-line-number="3">    <span class="cf">return</span> last - first ;</a>
<a class="sourceLine" id="cb637-4" data-line-number="4">} ;</a></code></pre></div>
<p>これを使えばわかりやすく書ける。</p>
<div class="sourceCode" id="cb638"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb638-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb638-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb638-3" data-line-number="3">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</a>
<a class="sourceLine" id="cb638-4" data-line-number="4"></a>
<a class="sourceLine" id="cb638-5" data-line-number="5">    <span class="co">// 最初の要素</span></a>
<a class="sourceLine" id="cb638-6" data-line-number="6">    <span class="kw">auto</span> first = <span class="bu">std::</span>begin(v) ;</a>
<a class="sourceLine" id="cb638-7" data-line-number="7">    <span class="co">// 最後の一つ次の要素</span></a>
<a class="sourceLine" id="cb638-8" data-line-number="8">    <span class="kw">auto</span> last = <span class="bu">std::</span>end(v) ;</a>
<a class="sourceLine" id="cb638-9" data-line-number="9"></a>
<a class="sourceLine" id="cb638-10" data-line-number="10">    <span class="co">// 要素数: 5</span></a>
<a class="sourceLine" id="cb638-11" data-line-number="11">    <span class="kw">auto</span> size = <span class="bu">std::</span>distance( first, last ) ;</a>
<a class="sourceLine" id="cb638-12" data-line-number="12"></a>
<a class="sourceLine" id="cb638-13" data-line-number="13">    <span class="co">// 4</span></a>
<a class="sourceLine" id="cb638-14" data-line-number="14">    <span class="kw">auto</span> size_from_next = <span class="bu">std::</span>distance( first + <span class="dv">1</span>, last ) ;</a>
<a class="sourceLine" id="cb638-15" data-line-number="15">}</a></code></pre></div>
<p>後は実装するだけだ(この実装は最も効率のいい実装ではない。理由についてはイテレーターの章を参照)</p>
<div class="sourceCode" id="cb639"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb639-1" data-line-number="1"><span class="kw">auto</span> equal = []( <span class="kw">auto</span> first1, <span class="kw">auto</span> last1, <span class="kw">auto</span> first2, <span class="kw">auto</span> last2)</a>
<a class="sourceLine" id="cb639-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb639-3" data-line-number="3">    <span class="co">// 要素数が等しいことを確認</span></a>
<a class="sourceLine" id="cb639-4" data-line-number="4">    <span class="kw">auto</span> size1 = <span class="bu">std::</span>distance( first1, last1 ) ;</a>
<a class="sourceLine" id="cb639-5" data-line-number="5">    <span class="kw">auto</span> size2 = <span class="bu">std::</span>distance( first2, last2 ) ;</a>
<a class="sourceLine" id="cb639-6" data-line-number="6"></a>
<a class="sourceLine" id="cb639-7" data-line-number="7">    <span class="cf">if</span> ( size1 != size2 )</a>
<a class="sourceLine" id="cb639-8" data-line-number="8">        <span class="co">// 要素数が等しくなかった</span></a>
<a class="sourceLine" id="cb639-9" data-line-number="9">        <span class="cf">return</span> <span class="kw">false</span> ;</a>
<a class="sourceLine" id="cb639-10" data-line-number="10"></a>
<a class="sourceLine" id="cb639-11" data-line-number="11">    <span class="co">// 各要素が等しいことを確認</span></a>
<a class="sourceLine" id="cb639-12" data-line-number="12">    <span class="cf">for</span> (   <span class="kw">auto</span> i = first1, j = first2 ;</a>
<a class="sourceLine" id="cb639-13" data-line-number="13">            i != last1 ; ++i, ++j )</a>
<a class="sourceLine" id="cb639-14" data-line-number="14">    {</a>
<a class="sourceLine" id="cb639-15" data-line-number="15">        <span class="cf">if</span> ( *i != *j )</a>
<a class="sourceLine" id="cb639-16" data-line-number="16">            <span class="co">// 等しくない要素があった</span></a>
<a class="sourceLine" id="cb639-17" data-line-number="17">            <span class="cf">return</span> <span class="kw">false</span> ;</a>
<a class="sourceLine" id="cb639-18" data-line-number="18">    }</a>
<a class="sourceLine" id="cb639-19" data-line-number="19">    <span class="co">// 各要素がすべて等しかった</span></a>
<a class="sourceLine" id="cb639-20" data-line-number="20">    <span class="cf">return</span> <span class="kw">true</span> ;</a>
<a class="sourceLine" id="cb639-21" data-line-number="21">} ;</a></code></pre></div>
<p>for文の終了条件では<code>i != last1</code>だけを見ていて、<code>j != last2</code>は見ていないが、これは問題がない。なぜならば、このfor文が実行されるのは、要素数が等しい場合だけだからだ。</p>
<p>関数<code>pred</code>を取る<code>equal(first1, last1, first2, last2, pred)</code>もある。この<code>pred</code>は<code>pred(a, b)</code>で、<code>a</code>と<code>b</code>が等しい場合に<code>true</code>、そうでない場合に<code>false</code>を返す関数だ。つまり<code>a == b</code>のoperator ==の代わりに使う関数を指定する。</p>
<p><code>equal</code>に関数を渡すことにより、例えば小数点以下の値を誤差として切り捨てるような処理が書ける。</p>
<div class="sourceCode" id="cb640"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb640-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb640-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb640-3" data-line-number="3">    <span class="bu">std::</span>vector&lt;<span class="dt">double</span>&gt; v = {<span class="fl">1.3</span>, <span class="fl">2.2</span>, <span class="fl">3.0</span>, <span class="fl">4.9</span>, <span class="fl">5.7</span>} ;</a>
<a class="sourceLine" id="cb640-4" data-line-number="4">    <span class="bu">std::</span>vector&lt;<span class="dt">double</span>&gt; w = {<span class="fl">1.9</span>, <span class="fl">2.4</span>, <span class="fl">3.8</span>, <span class="fl">4.5</span>, <span class="fl">5.0</span>} ;</a>
<a class="sourceLine" id="cb640-5" data-line-number="5"></a>
<a class="sourceLine" id="cb640-6" data-line-number="6">    <span class="co">// 小数点以下は誤差として切り捨てる比較</span></a>
<a class="sourceLine" id="cb640-7" data-line-number="7">    <span class="kw">auto</span> comp = []( <span class="kw">auto</span> a, <span class="kw">auto</span> b )</a>
<a class="sourceLine" id="cb640-8" data-line-number="8">    {</a>
<a class="sourceLine" id="cb640-9" data-line-number="9">        <span class="cf">return</span> <span class="bu">std::</span>floor(a) == <span class="bu">std::</span>floor(b) ;</a>
<a class="sourceLine" id="cb640-10" data-line-number="10">    } ;</a>
<a class="sourceLine" id="cb640-11" data-line-number="11"></a>
<a class="sourceLine" id="cb640-12" data-line-number="12">    <span class="dt">bool</span> b = <span class="bu">std::</span>equal(</a>
<a class="sourceLine" id="cb640-13" data-line-number="13">        <span class="bu">std::</span>begin(v), <span class="bu">std::</span>end(v),</a>
<a class="sourceLine" id="cb640-14" data-line-number="14">        <span class="bu">std::</span>begin(w), <span class="bu">std::</span>end(w),</a>
<a class="sourceLine" id="cb640-15" data-line-number="15">        comp ) ;</a>
<a class="sourceLine" id="cb640-16" data-line-number="16">}</a></code></pre></div>
<p><code>std::floor(x)</code>は浮動小数点数<code>x</code>の小数点数以下を切り捨てた結果を返す関数だ。<code>floor(0.999)</code>は<code>0.0</code>に、<code>floor(1.999)</code>は<code>1.0</code>になる。</p>
<p>本書をここまで読んできた読者であれば実装は自力でできるだろう。</p>
<h2 id="search">search</h2>
<p><code>search( first1, last1, first2, last2)</code>はイテレーター<code>[first2, last2)</code>の範囲で示された連続した要素の並びがイテレーター<code>[first1, last1)</code>の範囲に存在すれば<code>true</code>、そうでない場合は<code>false</code>を返す。</p>
<p>こう書くと難しいが、例を見るとわかりやすい。</p>
<div class="sourceCode" id="cb641"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb641-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb641-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb641-3" data-line-number="3">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v1 = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>} ;</a>
<a class="sourceLine" id="cb641-4" data-line-number="4">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v2 = {<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>} ;</a>
<a class="sourceLine" id="cb641-5" data-line-number="5"></a>
<a class="sourceLine" id="cb641-6" data-line-number="6">    <span class="co">// true</span></a>
<a class="sourceLine" id="cb641-7" data-line-number="7">    <span class="dt">bool</span> a = <span class="bu">std::</span>search( <span class="bu">std::</span>begin(v1), <span class="bu">std::</span>end(v1), <span class="bu">std::</span>begin(v2), <span class="bu">std::</span>end(v2) ) ;</a>
<a class="sourceLine" id="cb641-8" data-line-number="8"></a>
<a class="sourceLine" id="cb641-9" data-line-number="9">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v3 = {<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">5</span>} ;</a>
<a class="sourceLine" id="cb641-10" data-line-number="10">    <span class="co">// false </span></a>
<a class="sourceLine" id="cb641-11" data-line-number="11">    <span class="dt">bool</span> a = <span class="bu">std::</span>search( <span class="bu">std::</span>begin(v1), <span class="bu">std::</span>end(v1), <span class="bu">std::</span>begin(v3), <span class="bu">std::</span>end(v3) ) ;</a>
<a class="sourceLine" id="cb641-12" data-line-number="12">}</a></code></pre></div>
<p>この例では、v1の中にv2と同じ並びの<code>{4,5,6}</code>が存在するので<code>true</code>、v3と同じ並びの<code>{1,3,5}</code>は存在しないので<code>false</code>になる。</p>
<p><code>search</code>の実装例は今の読者にはまだ理解できない。<code>equal</code>や<code>search</code>を効率的に実装するにはイテレーターの詳細な理解が必要だ。</p>
<h2 id="copy">copy</h2>
<p>これまでのアルゴリズムは<code>for_each</code>を除き要素の変更をしてこなかった。<code>copy</code>は要素の変更をするアルゴリズムだ。</p>
<p>イテレーター<code>i</code>は<code>*i</code>で参照する要素の値として使うことができるほか、<code>*i=x</code>で要素に値<code>x</code>を代入できる。</p>
<div class="sourceCode" id="cb642"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb642-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb642-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb642-3" data-line-number="3">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>} ;</a>
<a class="sourceLine" id="cb642-4" data-line-number="4"></a>
<a class="sourceLine" id="cb642-5" data-line-number="5">    <span class="kw">auto</span> i = <span class="bu">std::</span>begin(v) ;</a>
<a class="sourceLine" id="cb642-6" data-line-number="6"></a>
<a class="sourceLine" id="cb642-7" data-line-number="7">    <span class="co">// 参照する要素を値として使う</span></a>
<a class="sourceLine" id="cb642-8" data-line-number="8">    <span class="bu">std::</span>cout &lt;&lt; *i ;</a>
<a class="sourceLine" id="cb642-9" data-line-number="9">    <span class="co">// 参照する要素に値を代入する。</span></a>
<a class="sourceLine" id="cb642-10" data-line-number="10">    *i = <span class="dv">2</span> ;</a>
<a class="sourceLine" id="cb642-11" data-line-number="11">}</a></code></pre></div>
<p><code>copy(first, last, result)</code>はイテレーター<code>[first, last)</code>の範囲の値を、先頭から順番にイテレーター<code>result</code>に書き込んでいくアルゴリズムだ。</p>
<div class="sourceCode" id="cb643"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb643-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb643-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb643-3" data-line-number="3">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; source = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</a>
<a class="sourceLine" id="cb643-4" data-line-number="4">    <span class="co">// 要素数5のvector</span></a>
<a class="sourceLine" id="cb643-5" data-line-number="5">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; destination(<span class="dv">5</span>) ;</a>
<a class="sourceLine" id="cb643-6" data-line-number="6"></a>
<a class="sourceLine" id="cb643-7" data-line-number="7">    <span class="bu">std::</span>copy( <span class="bu">std::</span>begin(source), <span class="bu">std::</span>end(source), <span class="bu">std::</span>begin(destination) ) ;</a>
<a class="sourceLine" id="cb643-8" data-line-number="8"></a>
<a class="sourceLine" id="cb643-9" data-line-number="9">    <span class="co">// destinationの中身は{1,2,3,4,5}</span></a>
<a class="sourceLine" id="cb643-10" data-line-number="10">}</a></code></pre></div>
<p>これは実質的に以下のような操作をしたのと等しい。</p>
<div class="sourceCode" id="cb644"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb644-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb644-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb644-3" data-line-number="3">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; source = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</a>
<a class="sourceLine" id="cb644-4" data-line-number="4">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; destination(<span class="dv">5</span>) ; </a>
<a class="sourceLine" id="cb644-5" data-line-number="5">}</a></code></pre></div>
<p>イテレーター<code>result</code>は先頭のイテレーターのみで末尾のイテレーターは渡さない。イテレーター<code>result</code>はイテレーター<code>[first, last)</code>の範囲の要素数をコピーできるだけの要素数の範囲を参照していなければならない。</p>
<p>例えば以下の例はエラーになる。</p>
<div class="sourceCode" id="cb645"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb645-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb645-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb645-3" data-line-number="3">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; source = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</a>
<a class="sourceLine" id="cb645-4" data-line-number="4">    <span class="co">// 要素数3のvector</span></a>
<a class="sourceLine" id="cb645-5" data-line-number="5">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; destination(<span class="dv">3</span>) ;</a>
<a class="sourceLine" id="cb645-6" data-line-number="6"></a>
<a class="sourceLine" id="cb645-7" data-line-number="7">    <span class="co">// エラー</span></a>
<a class="sourceLine" id="cb645-8" data-line-number="8">    <span class="bu">std::</span>copy( <span class="bu">std::</span>begin(source), <span class="bu">std::</span>end(source), <span class="bu">std::</span>begin(destination) ) ;</a>
<a class="sourceLine" id="cb645-9" data-line-number="9">}</a></code></pre></div>
<p>要素数が3しかないvectorに5個の要素をコピーしようとしている。</p>
<p><code>copy</code>の戻り値は<code>[first,last)</code>の要素数だけ進めたイテレーター<code>result</code>になる。これはつまり、<code>result + (last - first)</code>だ。</p>
<div class="sourceCode" id="cb646"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb646-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb646-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb646-3" data-line-number="3">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; source = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</a>
<a class="sourceLine" id="cb646-4" data-line-number="4">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; destination(<span class="dv">5</span>) ;</a>
<a class="sourceLine" id="cb646-5" data-line-number="5">    </a>
<a class="sourceLine" id="cb646-6" data-line-number="6">    <span class="kw">auto</span> first = <span class="bu">std::</span>begin(source) ;</a>
<a class="sourceLine" id="cb646-7" data-line-number="7">    <span class="kw">auto</span> last = <span class="bu">std::</span>end(source) ;</a>
<a class="sourceLine" id="cb646-8" data-line-number="8">    <span class="kw">auto</span> result = <span class="bu">std::</span>begin(destination) ;</a>
<a class="sourceLine" id="cb646-9" data-line-number="9">    </a>
<a class="sourceLine" id="cb646-10" data-line-number="10">    <span class="kw">auto</span> returned = <span class="bu">std::</span>copy( first, last, result ) ;</a>
<a class="sourceLine" id="cb646-11" data-line-number="11"></a>
<a class="sourceLine" id="cb646-12" data-line-number="12">    <span class="co">// true</span></a>
<a class="sourceLine" id="cb646-13" data-line-number="13">    <span class="dt">bool</span> b = (returned == (result + (last - first)) ;</a>
<a class="sourceLine" id="cb646-14" data-line-number="14">}</a></code></pre></div>
<p>ここで、<code>last-first</code>は<code>source</code>の要素数の5なので、<code>result + 5</code>は<code>copy</code>の戻り値のイテレーターと等しい。</p>
<p><code>copy</code>には<code>[first,last)</code>の範囲が<code>result</code>から続く範囲とオーバーラップしてはいけないという制約がある。</p>
<p>オーバーラップというのは、同じ要素を参照しているという意味だ。</p>
<div class="sourceCode" id="cb647"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb647-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb647-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb647-3" data-line-number="3">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>} ;</a>
<a class="sourceLine" id="cb647-4" data-line-number="4"></a>
<a class="sourceLine" id="cb647-5" data-line-number="5">    <span class="co">// [first,last)とresultがオーバーラップしている</span></a>
<a class="sourceLine" id="cb647-6" data-line-number="6">    <span class="bu">std::</span>copy( <span class="bu">std::</span>begin(v), <span class="bu">std::</span>end(v), <span class="bu">std::</span>begin(v) ) ;</a>
<a class="sourceLine" id="cb647-7" data-line-number="7">}</a></code></pre></div>
<p>オーバーラップした場合、<code>copy</code>の動作は保証されない。</p>
<p>実装例。</p>
<div class="sourceCode" id="cb648"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb648-1" data-line-number="1"><span class="kw">auto</span> copy = []( <span class="kw">auto</span> first, <span class="kw">auto</span> last, <span class="kw">auto</span> result )</a>
<a class="sourceLine" id="cb648-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb648-3" data-line-number="3">    <span class="cf">for</span> ( <span class="kw">auto</span> iter = first ; iter != last ; ++iter, ++result )</a>
<a class="sourceLine" id="cb648-4" data-line-number="4">    { *result = *iter ; }</a>
<a class="sourceLine" id="cb648-5" data-line-number="5"></a>
<a class="sourceLine" id="cb648-6" data-line-number="6">    <span class="cf">return</span> result ;</a>
<a class="sourceLine" id="cb648-7" data-line-number="7">}</a></code></pre></div>
<h2 id="transform">transform</h2>
<p><code>transform(first, last, result, op)</code>は<code>copy</code>に似ているが、<code>result</code>へのコピーが<code>*result = *iter ;</code>ではなく、<code>*result = op(*iter) ;</code>になる。opは関数だ。</p>
<p>以下が実装例だ。<code>copy</code>とほぼ同じだ。</p>
<div class="sourceCode" id="cb649"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb649-1" data-line-number="1"><span class="kw">auto</span> transform = []( <span class="kw">auto</span> first, <span class="kw">auto</span> last, <span class="kw">auto</span> result, <span class="kw">auto</span> op )</a>
<a class="sourceLine" id="cb649-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb649-3" data-line-number="3">    <span class="cf">for</span> ( <span class="kw">auto</span> iter = first ; iter != last ; ++iter, ++result )</a>
<a class="sourceLine" id="cb649-4" data-line-number="4">    { *result = op(*iter) ; }</a>
<a class="sourceLine" id="cb649-5" data-line-number="5"></a>
<a class="sourceLine" id="cb649-6" data-line-number="6">    <span class="cf">return</span> result ;</a>
<a class="sourceLine" id="cb649-7" data-line-number="7">}</a></code></pre></div>
<p>使い方は<code>copy</code>と似ているが、値をコピーをする際に関数を適用することができる。</p>
<div class="sourceCode" id="cb650"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb650-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb650-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb650-3" data-line-number="3">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; a = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</a>
<a class="sourceLine" id="cb650-4" data-line-number="4"></a>
<a class="sourceLine" id="cb650-5" data-line-number="5">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; b(<span class="dv">5</span>) ;</a>
<a class="sourceLine" id="cb650-6" data-line-number="6">    <span class="bu">std::</span>transform( <span class="bu">std::</span>begin(a), <span class="bu">std::</span>end(a), <span class="bu">std::</span>begin(b),</a>
<a class="sourceLine" id="cb650-7" data-line-number="7">        [](<span class="kw">auto</span> x){ <span class="cf">return</span> <span class="dv">2</span>*x ; } ) ;</a>
<a class="sourceLine" id="cb650-8" data-line-number="8">    <span class="co">// bは{2,4,6,8,10}</span></a>
<a class="sourceLine" id="cb650-9" data-line-number="9"></a>
<a class="sourceLine" id="cb650-10" data-line-number="10"></a>
<a class="sourceLine" id="cb650-11" data-line-number="11">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; c(<span class="dv">5</span>) ;</a>
<a class="sourceLine" id="cb650-12" data-line-number="12">    <span class="bu">std::</span>transform( <span class="bu">std::</span>begin(a), <span class="bu">std::</span>end(a), <span class="bu">std::</span>begin(c),</a>
<a class="sourceLine" id="cb650-13" data-line-number="13">        [](<span class="kw">auto</span> x){ <span class="cf">return</span> x % <span class="dv">3</span> ; } ) ;</a>
<a class="sourceLine" id="cb650-14" data-line-number="14">    <span class="co">// cは{1,2,0,1,2}</span></a>
<a class="sourceLine" id="cb650-15" data-line-number="15"></a>
<a class="sourceLine" id="cb650-16" data-line-number="16">    </a>
<a class="sourceLine" id="cb650-17" data-line-number="17">    <span class="bu">std::</span>vector&lt;<span class="dt">bool</span>&gt; d(<span class="dv">5</span>) ;</a>
<a class="sourceLine" id="cb650-18" data-line-number="18">    <span class="bu">std::</span>transform( <span class="bu">std::</span>begin(a), <span class="bu">std::</span>end(a), <span class="bu">std::</span>begin(d),</a>
<a class="sourceLine" id="cb650-19" data-line-number="19">        [](<span class="kw">auto</span> x){ <span class="cf">return</span> x &lt; <span class="dv">3</span> ; } ) ;</a>
<a class="sourceLine" id="cb650-20" data-line-number="20">    <span class="co">// dは{true,true,false,false,false}</span></a>
<a class="sourceLine" id="cb650-21" data-line-number="21">}</a></code></pre></div>
<p><code>result</code>に代入されるのは関数<code>op</code>の戻り値だ。関数<code>op</code>は値を一つの引数受け取り値を返す関数だ。</p>
<h2 id="replace">replace</h2>
<p><code>replace(first, last, old_value, new_value)</code>はイテレーター<code>[first,last)</code>の範囲のイテレーターが指す要素の値が<code>old_value</code>に等しいものを<code>new_value</code>に置換する関数だ。</p>
<div class="sourceCode" id="cb651"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb651-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb651-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb651-3" data-line-number="3">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; a = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</a>
<a class="sourceLine" id="cb651-4" data-line-number="4">    <span class="bu">std::</span>replace( <span class="bu">std::</span>begin(a), <span class="bu">std::</span>end(a), <span class="dv">3</span>, <span class="dv">0</span> ) ;</a>
<a class="sourceLine" id="cb651-5" data-line-number="5">    <span class="co">// aは{1,2,0,0,4,5,0,4,5}</span></a>
<a class="sourceLine" id="cb651-6" data-line-number="6">}</a></code></pre></div>
<p>実装も簡単。</p>
<div class="sourceCode" id="cb652"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb652-1" data-line-number="1"><span class="kw">auto</span> replace = []( <span class="kw">auto</span> first, <span class="kw">auto</span> last, <span class="kw">auto</span> old_value, <span class="kw">auto</span> new_value )</a>
<a class="sourceLine" id="cb652-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb652-3" data-line-number="3">    <span class="cf">for</span> ( <span class="kw">auto</span> iter = first ; first != last ; ++iter )</a>
<a class="sourceLine" id="cb652-4" data-line-number="4">    {</a>
<a class="sourceLine" id="cb652-5" data-line-number="5">        <span class="cf">if</span> ( *iter == old_value )</a>
<a class="sourceLine" id="cb652-6" data-line-number="6">            *iter = new_value ;</a>
<a class="sourceLine" id="cb652-7" data-line-number="7">    }</a>
<a class="sourceLine" id="cb652-8" data-line-number="8">} ;</a></code></pre></div>
<h2 id="fill">fill</h2>
<p><code>fill(first, last, value)</code>はイテレーター<code>[first,last)</code>の範囲をのイテレーターが参照する要素に<code>value</code>を代入する。</p>
<div class="sourceCode" id="cb653"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb653-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb653-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb653-3" data-line-number="3">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</a>
<a class="sourceLine" id="cb653-4" data-line-number="4">    <span class="bu">std::</span>fill( <span class="bu">std::</span>begin(v), <span class="bu">std::</span>end(v), <span class="dv">0</span> ) ;</a>
<a class="sourceLine" id="cb653-5" data-line-number="5">    <span class="co">// vは{0,0,0,0,0}</span></a>
<a class="sourceLine" id="cb653-6" data-line-number="6">}</a></code></pre></div>
<p><code>fill_n(first, n, value)</code>はイテレーター<code>[first, first+n)</code>の範囲のイテレーターが参照する要素に<code>value</code>を代入する関数だ。</p>
<div class="sourceCode" id="cb654"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb654-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb654-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb654-3" data-line-number="3">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</a>
<a class="sourceLine" id="cb654-4" data-line-number="4">    <span class="bu">std::</span>fill_n( <span class="bu">std::</span>begin(v), <span class="dv">5</span>, <span class="dv">0</span> ) ;</a>
<a class="sourceLine" id="cb654-5" data-line-number="5">    <span class="co">// vは{0,0,0,0,0}</span></a>
<a class="sourceLine" id="cb654-6" data-line-number="6">}</a></code></pre></div>
<p>実装例。</p>
<div class="sourceCode" id="cb655"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb655-1" data-line-number="1"><span class="kw">auto</span> fill_n = []( <span class="kw">auto</span> first, <span class="kw">auto</span> n, <span class="kw">auto</span> value )</a>
<a class="sourceLine" id="cb655-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb655-3" data-line-number="3">    <span class="cf">for</span> ( <span class="kw">auto</span> i = <span class="dv">0</span> ; i != n ; ++i, ++first )</a>
<a class="sourceLine" id="cb655-4" data-line-number="4">    {</a>
<a class="sourceLine" id="cb655-5" data-line-number="5">        *first = value ;</a>
<a class="sourceLine" id="cb655-6" data-line-number="6">    }</a>
<a class="sourceLine" id="cb655-7" data-line-number="7">}</a></code></pre></div>
<h2 id="generate">generate</h2>
<p><code>generate</code>は<code>fill</code>に似ているが、値として<code>value</code>をとるのではなく、関数<code>gen</code>を取る。</p>
<p><code>generate(first, last, gen)</code>はイテレーター<code>[first, last)</code>の範囲のイテレーターが参照する要素に<code>gen()</code>を代入する。</p>
<div class="sourceCode" id="cb656"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb656-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb656-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb656-3" data-line-number="3">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</a>
<a class="sourceLine" id="cb656-4" data-line-number="4">    <span class="kw">auto</span> gen_zero = [](){ <span class="cf">return</span> <span class="dv">0</span> ; } ;</a>
<a class="sourceLine" id="cb656-5" data-line-number="5">    <span class="bu">std::</span>generate( <span class="bu">std::</span>begin(v), <span class="bu">std::</span>end(v), gen_zero ) ;</a>
<a class="sourceLine" id="cb656-6" data-line-number="6">    <span class="co">// vは{0,0,0,0,0}</span></a>
<a class="sourceLine" id="cb656-7" data-line-number="7">}</a></code></pre></div>
<p><code>generate_n(first, n, gen)</code>は<code>fill_n</code>の<code>generate</code>版だ。</p>
<div class="sourceCode" id="cb657"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb657-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb657-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb657-3" data-line-number="3">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</a>
<a class="sourceLine" id="cb657-4" data-line-number="4">    <span class="kw">auto</span> gen_zero = []{ <span class="cf">return</span> <span class="dv">0</span> ; } ;</a>
<a class="sourceLine" id="cb657-5" data-line-number="5">    <span class="bu">std::</span>generate_n( <span class="bu">std::</span>begin(v), <span class="dv">5</span>, gen_zero ) ;</a>
<a class="sourceLine" id="cb657-6" data-line-number="6">    <span class="co">// vは{0,0,0,0,0}</span></a>
<a class="sourceLine" id="cb657-7" data-line-number="7">}</a></code></pre></div>
<p>実装例は単純だ。</p>
<div class="sourceCode" id="cb658"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb658-1" data-line-number="1"><span class="kw">auto</span> generate = []( first, last, gen )</a>
<a class="sourceLine" id="cb658-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb658-3" data-line-number="3">    <span class="cf">for</span> ( <span class="kw">auto</span> iter = first ; iter != last ; ++iter )</a>
<a class="sourceLine" id="cb658-4" data-line-number="4">    {</a>
<a class="sourceLine" id="cb658-5" data-line-number="5">        *iter = gen() ;</a>
<a class="sourceLine" id="cb658-6" data-line-number="6">    }</a>
<a class="sourceLine" id="cb658-7" data-line-number="7">} ;</a>
<a class="sourceLine" id="cb658-8" data-line-number="8"></a>
<a class="sourceLine" id="cb658-9" data-line-number="9"><span class="kw">auto</span> generate_n = []( first, n, gen )</a>
<a class="sourceLine" id="cb658-10" data-line-number="10">{</a>
<a class="sourceLine" id="cb658-11" data-line-number="11">    <span class="cf">for</span> ( <span class="kw">auto</span> i = <span class="dv">0u</span> ; i != n ; ++i, ++iter )</a>
<a class="sourceLine" id="cb658-12" data-line-number="12">    {</a>
<a class="sourceLine" id="cb658-13" data-line-number="13">        *iter = gen() ;</a>
<a class="sourceLine" id="cb658-14" data-line-number="14">    }</a>
<a class="sourceLine" id="cb658-15" data-line-number="15">} ;</a></code></pre></div>
<h2 id="remove">remove</h2>
<p><code>remove(first, last, value)</code>はイテレーター<code>[first,last)</code>の範囲の参照する要素から、値<code>value</code>に等しいものを取り除く。そして新しい終端イテレーターを返す。</p>
<p>アルゴリズム<code>remove</code>が値を取り除くというとやや語弊がある。例えば以下のような数列があり、</p>
<pre><code>1, 2, 3</code></pre>
<p>この中から値<code>2</code>を<code>remove</code>のように取り除く場合、以下のようになる。</p>
<pre><code>1, 3, ?</code></pre>
<p><code>remove</code>は取り除くべき値の入った要素を、後続の値で上書きする。この場合、1番目の<code>2</code>を2番目の<code>3</code>で上書きする。2番目は不定な状態になる。これは、<code>remove</code>アルゴリズムは2番目がどのような値になるかを保証しないという意味だ。</p>
<p>以下のような数列で値<code>2</code>をremoveしたとき</p>
<pre><code>1,2,2,3,2,2,4</code></pre>
<p>以下のようになる。</p>
<pre><code>1,3,4,?,?,?,?</code></pre>
<p><code>remove</code>の戻り値は、新しいイテレーターの終端を返す。</p>
<div class="sourceCode" id="cb663"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb663-1" data-line-number="1"><span class="kw">auto</span> last2 = remove( first, last, value ) ;</a></code></pre></div>
<p>この例では、<code>remove</code>は<code>[first,last)</code>から値<code>value</code>に等しい要素を取り除いたイテレーターの範囲を戻り値として返す。その戻り値が<code>last2</code>だ。<code>[first,last2)</code>が値を取り除いた後の新しいイテレーターの範囲だ。</p>
<p><code>remove</code>を呼び出しても元のvectorの要素数が変わることはない。<code>remove</code>はvectorの要素の値を変更するだけだ。</p>
<p>以上を踏まえて、以下が<code>remove</code>を使う例だ。</p>
<div class="sourceCode" id="cb664"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb664-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb664-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb664-3" data-line-number="3">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>} ;</a>
<a class="sourceLine" id="cb664-4" data-line-number="4"></a>
<a class="sourceLine" id="cb664-5" data-line-number="5">    <span class="kw">auto</span> last = <span class="bu">std::</span>remove( <span class="bu">std::</span>begin(v), <span class="bu">std::</span>end(v), <span class="dv">2</span> ) ;</a>
<a class="sourceLine" id="cb664-6" data-line-number="6"></a>
<a class="sourceLine" id="cb664-7" data-line-number="7">    <span class="co">// &quot;12&quot;</span></a>
<a class="sourceLine" id="cb664-8" data-line-number="8">    <span class="bu">std::</span>for_each( <span class="bu">std::</span>begin(v), last,</a>
<a class="sourceLine" id="cb664-9" data-line-number="9">        [](<span class="kw">auto</span> x) { <span class="bu">std::</span>cout &lt;&lt; x ; } ) ;</a>
<a class="sourceLine" id="cb664-10" data-line-number="10"></a>
<a class="sourceLine" id="cb664-11" data-line-number="11">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; w = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">4</span>} ;</a>
<a class="sourceLine" id="cb664-12" data-line-number="12"></a>
<a class="sourceLine" id="cb664-13" data-line-number="13">    <span class="kw">auto</span> last2 = <span class="bu">std::</span>remove( <span class="bu">std::</span>begin(w), <span class="bu">std::</span>end(w), <span class="dv">2</span> ) ;</a>
<a class="sourceLine" id="cb664-14" data-line-number="14"></a>
<a class="sourceLine" id="cb664-15" data-line-number="15">    <span class="co">// &quot;134&quot;</span></a>
<a class="sourceLine" id="cb664-16" data-line-number="16">    <span class="bu">std::</span>for_each( <span class="bu">std::</span>begin(w), last2,</a>
<a class="sourceLine" id="cb664-17" data-line-number="17">        [](<span class="kw">auto</span> x) { <span class="bu">std::</span>cout &lt;&lt; x ; } ) ;</a>
<a class="sourceLine" id="cb664-18" data-line-number="18">   </a>
<a class="sourceLine" id="cb664-19" data-line-number="19">}</a></code></pre></div>
<p><code>remove_if(first, last, pred)</code>は、<code>[first,last]</code>の範囲の要素を指すイテレーター<code>i</code>のうち、関数<code>pred</code>に渡した結果<code>pred(*i)</code>が<code>true</code>になる要素を取り除くアルゴリズムだ。</p>
<div class="sourceCode" id="cb665"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb665-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb665-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb665-3" data-line-number="3">    <span class="co">// 偶数の場合true、奇数の場合falseを返す関数</span></a>
<a class="sourceLine" id="cb665-4" data-line-number="4">    <span class="kw">auto</span> is_even = []( <span class="kw">auto</span> x ) { <span class="cf">return</span> x%<span class="dv">2</span> == <span class="dv">0</span> ; } ;</a>
<a class="sourceLine" id="cb665-5" data-line-number="5"></a>
<a class="sourceLine" id="cb665-6" data-line-number="6">    <span class="bu">std::</span>vector v = { <span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span> } ;</a>
<a class="sourceLine" id="cb665-7" data-line-number="7">    <span class="co">// 偶数を取り除く</span></a>
<a class="sourceLine" id="cb665-8" data-line-number="8">    <span class="kw">auto</span> last = <span class="bu">std::</span>remove_if( <span class="bu">std::</span>begin(v), <span class="bu">std::</span>end(v), is_even ) ;</a>
<a class="sourceLine" id="cb665-9" data-line-number="9"></a>
<a class="sourceLine" id="cb665-10" data-line-number="10">    <span class="co">// [ std::begin(v), last)は{1,3,5,7,9}</span></a>
<a class="sourceLine" id="cb665-11" data-line-number="11">}</a></code></pre></div>
<p><code>remove</code>は現在知っている知識だけではまだ完全に実装できない。以下は不完全な実装の例だ。<code>remove</code>を完全に理解するためには<code>ムーブセマンティクス</code>の理解が必要だ。</p>
<div class="sourceCode" id="cb666"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb666-1" data-line-number="1"><span class="kw">auto</span> remove_if = []( <span class="kw">auto</span> first, <span class="kw">auto</span> last, <span class="kw">auto</span> pred )</a>
<a class="sourceLine" id="cb666-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb666-3" data-line-number="3">    <span class="co">// removeする最初の要素</span></a>
<a class="sourceLine" id="cb666-4" data-line-number="4">    <span class="kw">auto</span> removing = <span class="bu">std::</span>find_if( first, last, pred ) ;</a>
<a class="sourceLine" id="cb666-5" data-line-number="5">    <span class="co">// removeする要素がなかった</span></a>
<a class="sourceLine" id="cb666-6" data-line-number="6">    <span class="cf">if</span> ( removing == last )</a>
<a class="sourceLine" id="cb666-7" data-line-number="7">        <span class="cf">return</span> last ;</a>
<a class="sourceLine" id="cb666-8" data-line-number="8"></a>
<a class="sourceLine" id="cb666-9" data-line-number="9">    <span class="co">// removeする要素の次の要素</span></a>
<a class="sourceLine" id="cb666-10" data-line-number="10">    <span class="kw">auto</span> remaining = removing ;</a>
<a class="sourceLine" id="cb666-11" data-line-number="11">    ++remaining ;</a>
<a class="sourceLine" id="cb666-12" data-line-number="12"></a>
<a class="sourceLine" id="cb666-13" data-line-number="13">    <span class="co">// removeする要素に上書きする</span></a>
<a class="sourceLine" id="cb666-14" data-line-number="14">    <span class="cf">for</span> (  ; remaining != last ; ++remaining )</a>
<a class="sourceLine" id="cb666-15" data-line-number="15">    {</a>
<a class="sourceLine" id="cb666-16" data-line-number="16">        <span class="co">// 上書き元も取り除くのであればスキップ</span></a>
<a class="sourceLine" id="cb666-17" data-line-number="17">        <span class="cf">if</span> ( pred( *remaining ) == <span class="kw">false</span> )</a>
<a class="sourceLine" id="cb666-18" data-line-number="18">        {</a>
<a class="sourceLine" id="cb666-19" data-line-number="19">            *removing = *remaining ;</a>
<a class="sourceLine" id="cb666-20" data-line-number="20">            ++removing ;</a>
<a class="sourceLine" id="cb666-21" data-line-number="21">        }</a>
<a class="sourceLine" id="cb666-22" data-line-number="22"></a>
<a class="sourceLine" id="cb666-23" data-line-number="23">    }</a>
<a class="sourceLine" id="cb666-24" data-line-number="24">    <span class="co">// 新しい終端イテレーター</span></a>
<a class="sourceLine" id="cb666-25" data-line-number="25">    <span class="cf">return</span> removing ;</a>
<a class="sourceLine" id="cb666-26" data-line-number="26">} ;</a></code></pre></div>
<h1 id="ラムダ式">ラムダ式</h1>
<p>実は以下の形の関数は、「関数」ではない。</p>
<div class="sourceCode" id="cb667"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb667-1" data-line-number="1"><span class="kw">auto</span> function = []( <span class="kw">auto</span> value ) { <span class="cf">return</span> value } ;</a></code></pre></div>
<p>これは<code>ラムダ式</code>と呼ばれるC++の機能で、関数のように振る舞うオブジェクトを作るための式だ。</p>
<h2 id="基本">基本</h2>
<p><code>ラムダ式</code>の基本の文法は以下の通り</p>
<div class="sourceCode" id="cb668"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb668-1" data-line-number="1">[](){} ;</a></code></pre></div>
<p>これを細かく分解すると以下のようになる。</p>
<div class="sourceCode" id="cb669"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb669-1" data-line-number="1">[]  <span class="co">// ラムダ導入子</span></a>
<a class="sourceLine" id="cb669-2" data-line-number="2">()  <span class="co">// 引数リスト</span></a>
<a class="sourceLine" id="cb669-3" data-line-number="3">{}  <span class="co">// 複合文</span></a>
<a class="sourceLine" id="cb669-4" data-line-number="4">;   <span class="co">// 文末</span></a></code></pre></div>
<p><code>ラムダ導入子</code>はさておく。</p>
<p><code>引数リスト</code>は通常の関数と同じように型名と名前を書ける。</p>
<div class="sourceCode" id="cb670"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb670-1" data-line-number="1"><span class="dt">void</span> f( <span class="dt">int</span> x, <span class="dt">double</span> d ) { }</a>
<a class="sourceLine" id="cb670-2" data-line-number="2"></a>
<a class="sourceLine" id="cb670-3" data-line-number="3">[]( <span class="dt">int</span> x, <span class="dt">double</span> d ) { } ;</a></code></pre></div>
<p><code>ラムダ式</code>では、<code>引数リスト</code>に<code>auto</code>キーワードが使える。</p>
<div class="sourceCode" id="cb671"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb671-1" data-line-number="1">[]( <span class="kw">auto</span> x ) { } ;</a></code></pre></div>
<p>このように書くとどんな型でも受け取れるようになる。</p>
<div class="sourceCode" id="cb672"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb672-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb672-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb672-3" data-line-number="3">    <span class="kw">auto</span> f = []( <span class="kw">auto</span> x )</a>
<a class="sourceLine" id="cb672-4" data-line-number="4">    { <span class="bu">std::</span>cout &lt;&lt; x ; } ;</a>
<a class="sourceLine" id="cb672-5" data-line-number="5"></a>
<a class="sourceLine" id="cb672-6" data-line-number="6">    f(<span class="dv">0</span>) ; <span class="co">// int</span></a>
<a class="sourceLine" id="cb672-7" data-line-number="7">    f(<span class="fl">1.0</span>) ; <span class="co">// double</span></a>
<a class="sourceLine" id="cb672-8" data-line-number="8">    f(<span class="st">&quot;hello&quot;</span>s) ; <span class="co">// std::string</span></a>
<a class="sourceLine" id="cb672-9" data-line-number="9">}</a></code></pre></div>
<p><code>複合文</code>は<code>{}</code>だ。この<code>{}</code>の中に通常の関数と同じように複数の文を書くことができる。</p>
<div class="sourceCode" id="cb673"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb673-1" data-line-number="1">[]()</a>
<a class="sourceLine" id="cb673-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb673-3" data-line-number="3">    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;hello&quot;</span>s ;</a>
<a class="sourceLine" id="cb673-4" data-line-number="4">    <span class="dt">int</span> x = <span class="dv">1</span> + <span class="dv">1</span> ;</a>
<a class="sourceLine" id="cb673-5" data-line-number="5">} ;</a></code></pre></div>
<p>最後の<code>文末</code>は<code>文</code>の最後につけるセミコロンだ。これは“1+1 ;”とするのと変わらない。“1+1”や“<a href=""></a>”は<code>式</code>で、<code>文</code>は<code>式</code>を使うことができる。<code>式</code>だけが入った<code>文</code>を専門用語では<code>式文</code>と呼ぶが特に覚える必要はない。</p>
<div class="sourceCode" id="cb674"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb674-1" data-line-number="1"><span class="dv">1</span> + <span class="dv">1</span> ; <span class="co">// OK、式文</span></a>
<a class="sourceLine" id="cb674-2" data-line-number="2">[](){} ; <span class="co">// OK、式文</span></a></code></pre></div>
<p><code>ラムダ式</code>は<code>式</code>なので<code>式文</code>の中に書くことができる。</p>
<p><code>ラムダ式</code>は<code>式</code>なので、そのまま<code>関数呼び出し</code>することもできる。</p>
<div class="sourceCode" id="cb675"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb675-1" data-line-number="1"><span class="dt">void</span> f( <span class="bu">std::</span>string x )</a>
<a class="sourceLine" id="cb675-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb675-3" data-line-number="3">    <span class="bu">std::</span>cout &lt;&lt; x ;</a>
<a class="sourceLine" id="cb675-4" data-line-number="4">}</a>
<a class="sourceLine" id="cb675-5" data-line-number="5"></a>
<a class="sourceLine" id="cb675-6" data-line-number="6"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb675-7" data-line-number="7">{</a>
<a class="sourceLine" id="cb675-8" data-line-number="8">    f( <span class="st">&quot;hello&quot;</span>s ) ;</a>
<a class="sourceLine" id="cb675-9" data-line-number="9">    []( <span class="kw">auto</span> x ){ <span class="bu">std::</span>cout &lt;&lt; x ; }( <span class="st">&quot;hello&quot;</span>s ) ;</a>
<a class="sourceLine" id="cb675-10" data-line-number="10">}</a></code></pre></div>
<p>これはわかりやすくインデントすると以下のようになる。</p>
<div class="sourceCode" id="cb676"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb676-1" data-line-number="1">f               <span class="co">// 関数</span></a>
<a class="sourceLine" id="cb676-2" data-line-number="2">( <span class="st">&quot;hello&quot;</span>s ) ;  <span class="co">// 関数呼び出し</span></a>
<a class="sourceLine" id="cb676-3" data-line-number="3"></a>
<a class="sourceLine" id="cb676-4" data-line-number="4"><span class="co">// ラムダ式</span></a>
<a class="sourceLine" id="cb676-5" data-line-number="5">[]( <span class="kw">auto</span> x ){ <span class="bu">std::</span>cout &lt;&lt; x ; }</a>
<a class="sourceLine" id="cb676-6" data-line-number="6">( <span class="st">&quot;hello&quot;</span>s ) ;  <span class="co">// 関数呼び出し</span></a></code></pre></div>
<p>ラムダ式が引数を一つも取らない場合、<code>引数リスト</code>は省略できる。</p>
<div class="sourceCode" id="cb677"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb677-1" data-line-number="1"><span class="co">// 引数を取らないラムダ式</span></a>
<a class="sourceLine" id="cb677-2" data-line-number="2">[](){} ;</a>
<a class="sourceLine" id="cb677-3" data-line-number="3"><span class="co">// 引数リストは省略できる</span></a>
<a class="sourceLine" id="cb677-4" data-line-number="4">[]{} ;</a></code></pre></div>
<p>ラムダ式の戻り値の型はreturn文から推定される。</p>
<div class="sourceCode" id="cb678"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb678-1" data-line-number="1"><span class="co">// int</span></a>
<a class="sourceLine" id="cb678-2" data-line-number="2">[]{ <span class="cf">return</span> <span class="dv">0</span> ; } ;</a>
<a class="sourceLine" id="cb678-3" data-line-number="3"><span class="co">// double</span></a>
<a class="sourceLine" id="cb678-4" data-line-number="4">[]{ <span class="cf">return</span> <span class="fl">0.0</span> ; } ;</a>
<a class="sourceLine" id="cb678-5" data-line-number="5"><span class="co">// std::string</span></a>
<a class="sourceLine" id="cb678-6" data-line-number="6">[]{ <span class="cf">return</span> <span class="st">&quot;hello&quot;</span>s ; } ;</a></code></pre></div>
<p>return文で複数の型を返した場合は推定ができないのでエラーになる。</p>
<div class="sourceCode" id="cb679"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb679-1" data-line-number="1">[]( <span class="dt">bool</span> b )</a>
<a class="sourceLine" id="cb679-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb679-3" data-line-number="3">    <span class="cf">if</span> ( b )</a>
<a class="sourceLine" id="cb679-4" data-line-number="4">        <span class="cf">return</span> <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb679-5" data-line-number="5">    <span class="cf">else</span></a>
<a class="sourceLine" id="cb679-6" data-line-number="6">        <span class="cf">return</span> <span class="fl">0.0</span> ;</a>
<a class="sourceLine" id="cb679-7" data-line-number="7">} ;</a></code></pre></div>
<p>戻り値の型を指定したい場合は<code>引数リスト</code>の後に<code>-&gt;</code>を書き、型名を書く。</p>
<div class="sourceCode" id="cb680"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb680-1" data-line-number="1">[]( <span class="dt">bool</span> b ) -&gt; <span class="dt">int</span></a>
<a class="sourceLine" id="cb680-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb680-3" data-line-number="3">    <span class="cf">if</span> ( b )</a>
<a class="sourceLine" id="cb680-4" data-line-number="4">        <span class="cf">return</span> <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb680-5" data-line-number="5">    <span class="cf">else</span></a>
<a class="sourceLine" id="cb680-6" data-line-number="6">        <span class="co">// doubleからintへの変換</span></a>
<a class="sourceLine" id="cb680-7" data-line-number="7">        <span class="cf">return</span> <span class="fl">0.0</span> ;</a>
<a class="sourceLine" id="cb680-8" data-line-number="8">} ;</a></code></pre></div>
<p>戻り値の型の推定は通常の関数も同じだ。</p>
<div class="sourceCode" id="cb681"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb681-1" data-line-number="1"><span class="co">// int</span></a>
<a class="sourceLine" id="cb681-2" data-line-number="2"><span class="kw">auto</span> f() { <span class="cf">return</span> <span class="dv">0</span> ; }</a>
<a class="sourceLine" id="cb681-3" data-line-number="3"></a>
<a class="sourceLine" id="cb681-4" data-line-number="4"><span class="co">// 戻り値の型の明示的な指定</span></a>
<a class="sourceLine" id="cb681-5" data-line-number="5"><span class="kw">auto</span> f() -&gt; <span class="dt">int</span> { <span class="cf">return</span> <span class="dv">0</span> ; }</a></code></pre></div>
<h2 id="キャプチャー">キャプチャー</h2>
<p><code>ラムダ式</code>は書かれている関数のローカル変数を使うことができる。これを<code>キャプチャー</code>という。<code>キャプチャー</code>は通常の関数にはできない<code>ラムダ式</code>の機能だ。</p>
<div class="sourceCode" id="cb682"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb682-1" data-line-number="1"><span class="dt">void</span> f()</a>
<a class="sourceLine" id="cb682-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb682-3" data-line-number="3">    <span class="co">// ローカル関数</span></a>
<a class="sourceLine" id="cb682-4" data-line-number="4">    <span class="kw">auto</span> message = <span class="st">&quot;hello&quot;</span>s ;</a>
<a class="sourceLine" id="cb682-5" data-line-number="5"></a>
<a class="sourceLine" id="cb682-6" data-line-number="6">    [=](){ <span class="bu">std::</span>cout &lt;&lt; message ; } ;</a>
<a class="sourceLine" id="cb682-7" data-line-number="7">}</a></code></pre></div>
<p><code>キャプチャー</code>には<code>コピーキャプチャー</code>と<code>リファレンスキャプチャー</code>がある。</p>
<h3 id="コピーキャプチャー">コピーキャプチャー</h3>
<p><code>コピーキャプチャー</code>は変数をコピーによってキャプチャーする。</p>
<p><code>コピーキャプチャー</code>をするには、<code>ラムダ式</code>を<code>[=]</code>と書く。</p>
<div class="sourceCode" id="cb683"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb683-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb683-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb683-3" data-line-number="3">    <span class="dt">int</span> x = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb683-4" data-line-number="4">    <span class="co">// コピーキャプチャー</span></a>
<a class="sourceLine" id="cb683-5" data-line-number="5">    [=]{ <span class="cf">return</span> x ; } ;</a>
<a class="sourceLine" id="cb683-6" data-line-number="6">}</a></code></pre></div>
<p><code>コピーキャプチャー</code>した変数はラムダ式の中で変更できない。</p>
<div class="sourceCode" id="cb684"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb684-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb684-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb684-3" data-line-number="3">    <span class="dt">int</span> x = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb684-4" data-line-number="4">    <span class="co">// エラー</span></a>
<a class="sourceLine" id="cb684-5" data-line-number="5">    [=]{ x = <span class="dv">0</span> ; } ;</a>
<a class="sourceLine" id="cb684-6" data-line-number="6">}</a></code></pre></div>
<p>変更できるようにする方法もあるのだが、通常は使われない。</p>
<h3 id="リファレンスキャプチャー">リファレンスキャプチャー</h3>
<p><code>リファレンスキャプチャー</code>は変数をリファレンスによってキャプチャーする。</p>
<p><code>リファレンス</code>を覚えているだろうか。リファレンスは初期化時の元の変数を参照する変数だ。</p>
<div class="sourceCode" id="cb685"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb685-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb685-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb685-3" data-line-number="3">    <span class="dt">int</span> x = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb685-4" data-line-number="4">    <span class="co">// 通常の変数</span></a>
<a class="sourceLine" id="cb685-5" data-line-number="5">    <span class="dt">int</span> y = x ;</a>
<a class="sourceLine" id="cb685-6" data-line-number="6"></a>
<a class="sourceLine" id="cb685-7" data-line-number="7">    <span class="co">// 変数を変更</span></a>
<a class="sourceLine" id="cb685-8" data-line-number="8">    y = <span class="dv">1</span> ;</a>
<a class="sourceLine" id="cb685-9" data-line-number="9">    <span class="co">// xの値は変わらない</span></a>
<a class="sourceLine" id="cb685-10" data-line-number="10"></a>
<a class="sourceLine" id="cb685-11" data-line-number="11">    <span class="co">// リファレンス</span></a>
<a class="sourceLine" id="cb685-12" data-line-number="12">    <span class="dt">int</span> &amp; ref = x ;</a>
<a class="sourceLine" id="cb685-13" data-line-number="13"></a>
<a class="sourceLine" id="cb685-14" data-line-number="14">    <span class="co">// リファレンスを変更</span></a>
<a class="sourceLine" id="cb685-15" data-line-number="15">    ref = <span class="dv">1</span> ;</a>
<a class="sourceLine" id="cb685-16" data-line-number="16">    <span class="co">// xの値が変わる</span></a>
<a class="sourceLine" id="cb685-17" data-line-number="17">}</a></code></pre></div>
<p><code>リファレンスキャプチャー</code>を使うには、<code>ラムダ式</code>を<code>[&amp;]</code>と書く。</p>
<div class="sourceCode" id="cb686"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb686-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb686-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb686-3" data-line-number="3">    <span class="dt">int</span> x = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb686-4" data-line-number="4">    [&amp;] { <span class="cf">return</span> x ; } ;</a>
<a class="sourceLine" id="cb686-5" data-line-number="5">}</a></code></pre></div>
<p><code>リファレンスキャプチャー</code>した変数を<code>ラムダ式</code>の中で変更すると、元の変数が変更される。</p>
<div class="sourceCode" id="cb687"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb687-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb687-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb687-3" data-line-number="3">    <span class="dt">int</span> x = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb687-4" data-line-number="4">    <span class="kw">auto</span> f = [&amp;]{ ++x ; } ;</a>
<a class="sourceLine" id="cb687-5" data-line-number="5"></a>
<a class="sourceLine" id="cb687-6" data-line-number="6">    f() ; <span class="co">// x == 1</span></a>
<a class="sourceLine" id="cb687-7" data-line-number="7">    f() ; <span class="co">// x == 2</span></a>
<a class="sourceLine" id="cb687-8" data-line-number="8">    f() ; <span class="co">// x == 3</span></a>
<a class="sourceLine" id="cb687-9" data-line-number="9">}</a></code></pre></div>
<p>ラムダ式についてはまだ色々な機能があるが、本書での解説はここまでとする。</p>
<h1 id="クラスの基本">クラスの基本</h1>
<p>C++はもともとC言語に<code>クラス</code>の機能を追加することを目的とした言語だった。</p>
<p><code>クラス</code>とは何か。クラスには様々な機能があるが、最も基本的な機能としては以下の2つがある。</p>
<ul>
<li>変数をまとめる</li>
<li>まとめた変数に関数を提供する</li>
</ul>
<p>この章は<code>クラス</code>の数ある機能のうち、この2つの機能だけを説明する。</p>
<h2 id="変数をまとめる">変数をまとめる</h2>
<p>2次元座標上の点<code>(x,y)</code>を表現するプログラムを書くとする。</p>
<p>とりあえずint型で表現してみよう。</p>
<div class="sourceCode" id="cb688"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb688-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb688-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb688-3" data-line-number="3">    <span class="co">// 表現</span></a>
<a class="sourceLine" id="cb688-4" data-line-number="4">    <span class="dt">int</span> point_x = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb688-5" data-line-number="5">    <span class="dt">int</span> point_y = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb688-6" data-line-number="6">}</a></code></pre></div>
<p>これはわかりやすい。ところでものは相談だが、点は複数表現したい。</p>
<div class="sourceCode" id="cb689"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb689-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb689-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb689-3" data-line-number="3">    <span class="dt">int</span> x1 = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb689-4" data-line-number="4">    <span class="dt">int</span> y1 = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb689-5" data-line-number="5"></a>
<a class="sourceLine" id="cb689-6" data-line-number="6">    <span class="dt">int</span> x2 = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb689-7" data-line-number="7">    <span class="dt">int</span> y2 = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb689-8" data-line-number="8"></a>
<a class="sourceLine" id="cb689-9" data-line-number="9">    <span class="dt">int</span> x3 = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb689-10" data-line-number="10">    <span class="dt">int</span> y3 = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb689-11" data-line-number="11">}</a></code></pre></div>
<p>これはわかりにくい。ところで点はユーザーがいくつでも入力できるものとしよう。</p>
<div class="sourceCode" id="cb690"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb690-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb690-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb690-3" data-line-number="3">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; xs ;</a>
<a class="sourceLine" id="cb690-4" data-line-number="4">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; ys ;</a>
<a class="sourceLine" id="cb690-5" data-line-number="5"></a>
<a class="sourceLine" id="cb690-6" data-line-number="6">    <span class="co">// xs.at(i)とys.at(i)は同じ点のための変数</span></a>
<a class="sourceLine" id="cb690-7" data-line-number="7"></a>
<a class="sourceLine" id="cb690-8" data-line-number="8">    <span class="dt">int</span> x {} ;</a>
<a class="sourceLine" id="cb690-9" data-line-number="9">    <span class="dt">int</span> y {} ;</a>
<a class="sourceLine" id="cb690-10" data-line-number="10">    <span class="cf">while</span> ( <span class="bu">std::</span>cin &gt;&gt; x &gt;&gt; y )</a>
<a class="sourceLine" id="cb690-11" data-line-number="11">    {</a>
<a class="sourceLine" id="cb690-12" data-line-number="12">        xs.push_back(x) ;</a>
<a class="sourceLine" id="cb690-13" data-line-number="13">        ys.push_back(y) ;</a>
<a class="sourceLine" id="cb690-14" data-line-number="14">    }</a>
<a class="sourceLine" id="cb690-15" data-line-number="15">}</a></code></pre></div>
<p>これはとてもわかりにくい。</p>
<p>ここで<code>クラス</code>の出番だ。<code>クラス</code>を使うと点を表現するコードは以下のように書ける。</p>
<div class="sourceCode" id="cb691"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb691-1" data-line-number="1"><span class="kw">struct</span> point</a>
<a class="sourceLine" id="cb691-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb691-3" data-line-number="3">    <span class="dt">int</span> x = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb691-4" data-line-number="4">    <span class="dt">int</span> y = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb691-5" data-line-number="5">} ;</a>
<a class="sourceLine" id="cb691-6" data-line-number="6"></a>
<a class="sourceLine" id="cb691-7" data-line-number="7"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb691-8" data-line-number="8">{</a>
<a class="sourceLine" id="cb691-9" data-line-number="9">    point p ;</a>
<a class="sourceLine" id="cb691-10" data-line-number="10"></a>
<a class="sourceLine" id="cb691-11" data-line-number="11">    <span class="bu">std::</span>cout &lt;&lt; p.x &lt;&lt; p.y ;</a>
<a class="sourceLine" id="cb691-12" data-line-number="12">}</a></code></pre></div>
<p>点を複数表現するのもわかりやすい。</p>
<div class="sourceCode" id="cb692"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb692-1" data-line-number="1">point p1 ;</a>
<a class="sourceLine" id="cb692-2" data-line-number="2">point p2 ;</a>
<a class="sourceLine" id="cb692-3" data-line-number="3">point p3 ;</a></code></pre></div>
<p>ユーザーが好きなだけ点を入力できるプログラムもわかりやすく書ける。</p>
<div class="sourceCode" id="cb693"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb693-1" data-line-number="1"><span class="kw">struct</span> point</a>
<a class="sourceLine" id="cb693-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb693-3" data-line-number="3">    <span class="dt">int</span> x = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb693-4" data-line-number="4">    <span class="dt">int</span> y = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb693-5" data-line-number="5">} ;</a>
<a class="sourceLine" id="cb693-6" data-line-number="6"></a>
<a class="sourceLine" id="cb693-7" data-line-number="7"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb693-8" data-line-number="8">{</a>
<a class="sourceLine" id="cb693-9" data-line-number="9">    <span class="bu">std::</span>vector&lt;point&gt; ps ;</a>
<a class="sourceLine" id="cb693-10" data-line-number="10"></a>
<a class="sourceLine" id="cb693-11" data-line-number="11">    <span class="dt">int</span> x { } ;</a>
<a class="sourceLine" id="cb693-12" data-line-number="12">    <span class="dt">int</span> y { } ;</a>
<a class="sourceLine" id="cb693-13" data-line-number="13"></a>
<a class="sourceLine" id="cb693-14" data-line-number="14">    <span class="cf">while</span>( <span class="bu">std::</span>cin &gt;&gt; x &gt;&gt; y )</a>
<a class="sourceLine" id="cb693-15" data-line-number="15">    {</a>
<a class="sourceLine" id="cb693-16" data-line-number="16">        ps.push_back( point{ x, y } ) ;</a>
<a class="sourceLine" id="cb693-17" data-line-number="17">    }    </a>
<a class="sourceLine" id="cb693-18" data-line-number="18">}</a></code></pre></div>
<p>これが<code>クラス</code>の変数をまとめる機能だ。</p>
<p><code>クラス</code>を定義するには、キーワード<code>struct</code>に続いて<code>クラス名</code>を書く。</p>
<div class="sourceCode" id="cb694"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb694-1" data-line-number="1"><span class="kw">struct</span> class_name </a>
<a class="sourceLine" id="cb694-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb694-3" data-line-number="3"></a>
<a class="sourceLine" id="cb694-4" data-line-number="4">} ;</a></code></pre></div>
<p>変数は<code>{}</code>の中に書く。</p>
<div class="sourceCode" id="cb695"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb695-1" data-line-number="1"><span class="kw">struct</span> S</a>
<a class="sourceLine" id="cb695-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb695-3" data-line-number="3">    <span class="dt">int</span> a = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb695-4" data-line-number="4">    <span class="dt">double</span> b = <span class="fl">0.0</span> ;</a>
<a class="sourceLine" id="cb695-5" data-line-number="5">    <span class="bu">std::</span>string c = <span class="st">&quot;hello&quot;</span>s ;</a>
<a class="sourceLine" id="cb695-6" data-line-number="6">} ;</a></code></pre></div>
<p>このクラスの中に書かれた変数のことを、<code>データメンバー</code>という。正確には変数ではない。</p>
<p>定義した<code>クラス</code>は変数として宣言して使うことができる。<code>クラス</code>の<code>データメンバー</code>を使うには、クラス名に引き続いてドット文字を書きデータメンバー名を書く。</p>
<div class="sourceCode" id="cb696"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb696-1" data-line-number="1"><span class="co">// 名前と年齢を表現するクラスPerson</span></a>
<a class="sourceLine" id="cb696-2" data-line-number="2"><span class="kw">struct</span> Person</a>
<a class="sourceLine" id="cb696-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb696-4" data-line-number="4">    <span class="bu">std::</span>string name ;</a>
<a class="sourceLine" id="cb696-5" data-line-number="5">    <span class="dt">int</span> age ;</a>
<a class="sourceLine" id="cb696-6" data-line-number="6">} ;</a>
<a class="sourceLine" id="cb696-7" data-line-number="7"></a>
<a class="sourceLine" id="cb696-8" data-line-number="8"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb696-9" data-line-number="9">{</a>
<a class="sourceLine" id="cb696-10" data-line-number="10">    Person john ;</a>
<a class="sourceLine" id="cb696-11" data-line-number="11">    john.name = <span class="st">&quot;john&quot;</span> ;</a>
<a class="sourceLine" id="cb696-12" data-line-number="12">    john.age = <span class="dv">20</span> ;</a>
<a class="sourceLine" id="cb696-13" data-line-number="13">}</a></code></pre></div>
<p><code>クラス</code>の<code>データメンバー</code>の定義は変数ではない。オブジェクトではない。つまり、それ自体にストレージが割り当てられてはいない。</p>
<div class="sourceCode" id="cb697"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb697-1" data-line-number="1"><span class="kw">struct</span> S</a>
<a class="sourceLine" id="cb697-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb697-3" data-line-number="3">    <span class="co">// これは変数ではない。</span></a>
<a class="sourceLine" id="cb697-4" data-line-number="4">    <span class="dt">int</span> data ;</a>
<a class="sourceLine" id="cb697-5" data-line-number="5">} ;</a></code></pre></div>
<p>クラスの変数を定義したときに、その変数のオブジェクトに紐付いたストレージが使われる。</p>
<div class="sourceCode" id="cb698"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb698-1" data-line-number="1"><span class="kw">struct</span> S</a>
<a class="sourceLine" id="cb698-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb698-3" data-line-number="3">    <span class="dt">int</span> data ;</a>
<a class="sourceLine" id="cb698-4" data-line-number="4">} ;</a>
<a class="sourceLine" id="cb698-5" data-line-number="5"></a>
<a class="sourceLine" id="cb698-6" data-line-number="6"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb698-7" data-line-number="7">{</a>
<a class="sourceLine" id="cb698-8" data-line-number="8">    S s1 ; <span class="co">// 変数</span></a>
<a class="sourceLine" id="cb698-9" data-line-number="9">    <span class="co">// オブジェクトs1に紐付いたストレージ</span></a>
<a class="sourceLine" id="cb698-10" data-line-number="10">    s1.data = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb698-11" data-line-number="11"></a>
<a class="sourceLine" id="cb698-12" data-line-number="12">    S s2 ;</a>
<a class="sourceLine" id="cb698-13" data-line-number="13">    <span class="co">// 別のストレージ</span></a>
<a class="sourceLine" id="cb698-14" data-line-number="14">    s2.data = <span class="dv">1</span> ; </a>
<a class="sourceLine" id="cb698-15" data-line-number="15"></a>
<a class="sourceLine" id="cb698-16" data-line-number="16">    <span class="co">// false</span></a>
<a class="sourceLine" id="cb698-17" data-line-number="17">    <span class="dt">bool</span> b = s1.data == s2.data ;</a>
<a class="sourceLine" id="cb698-18" data-line-number="18">}</a></code></pre></div>
<p>クラスの変数を定義するときにデータメンバーを初期化できる。</p>
<div class="sourceCode" id="cb699"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb699-1" data-line-number="1"><span class="kw">struct</span> S</a>
<a class="sourceLine" id="cb699-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb699-3" data-line-number="3">    <span class="dt">int</span> x ;</a>
<a class="sourceLine" id="cb699-4" data-line-number="4">    <span class="dt">int</span> y ;</a>
<a class="sourceLine" id="cb699-5" data-line-number="5">    <span class="dt">int</span> z ;</a>
<a class="sourceLine" id="cb699-6" data-line-number="6">} ;</a>
<a class="sourceLine" id="cb699-7" data-line-number="7"></a>
<a class="sourceLine" id="cb699-8" data-line-number="8"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb699-9" data-line-number="9">{</a>
<a class="sourceLine" id="cb699-10" data-line-number="10">    S s { <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span> } ;</a>
<a class="sourceLine" id="cb699-11" data-line-number="11">    <span class="co">// s.x == 1</span></a>
<a class="sourceLine" id="cb699-12" data-line-number="12">    <span class="co">// s.y == 2</span></a>
<a class="sourceLine" id="cb699-13" data-line-number="13">    <span class="co">// s.z == 3</span></a>
<a class="sourceLine" id="cb699-14" data-line-number="14">}</a></code></pre></div>
<p>クラスの初期化で<code>{1,2,3}</code>と書くと、クラスの最初のデータメンバーが1で、次のデータメンバーが2で、その次のデータメンバーが3で、それぞれ初期化される。</p>
<p>クラスをコピーすると、データメンバーがそれぞれコピーされる。</p>
<div class="sourceCode" id="cb700"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb700-1" data-line-number="1"><span class="kw">struct</span> S { <span class="dt">int</span> a ; <span class="dt">double</span> b ; <span class="bu">std::</span>string c ; } ;</a>
<a class="sourceLine" id="cb700-2" data-line-number="2"></a>
<a class="sourceLine" id="cb700-3" data-line-number="3"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb700-4" data-line-number="4">{</a>
<a class="sourceLine" id="cb700-5" data-line-number="5">    S a{<span class="dv">123</span>, <span class="fl">1.23</span>, <span class="st">&quot;123&quot;</span>} ;</a>
<a class="sourceLine" id="cb700-6" data-line-number="6">    <span class="co">// データメンバーがそれぞれコピーされる</span></a>
<a class="sourceLine" id="cb700-7" data-line-number="7">    S b = a ;</a>
<a class="sourceLine" id="cb700-8" data-line-number="8">}</a></code></pre></div>
<h1 id="まとめた変数に関数を提供する">まとめた変数に関数を提供する</h1>
<p>分数を表現するプログラムを書いてみよう。</p>
<div class="sourceCode" id="cb701"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb701-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb701-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb701-3" data-line-number="3">    <span class="dt">int</span> num = <span class="dv">1</span> ;</a>
<a class="sourceLine" id="cb701-4" data-line-number="4">    <span class="dt">int</span> denom = <span class="dv">2</span> ;</a>
<a class="sourceLine" id="cb701-5" data-line-number="5"></a>
<a class="sourceLine" id="cb701-6" data-line-number="6">    <span class="co">// 出力</span></a>
<a class="sourceLine" id="cb701-7" data-line-number="7">    <span class="bu">std::</span>cout &lt;&lt; <span class="kw">static_cast</span>&lt;<span class="dt">double</span>&gt;(num) / <span class="kw">static_cast</span>&lt;<span class="dt">double</span>&gt;(denom) ;</a>
<a class="sourceLine" id="cb701-8" data-line-number="8">}</a></code></pre></div>
<p>分子<code>num</code>と分母<code>denom</code>はクラスにまとめることができそうだ。そうすれば複数の分数を扱うのも楽になる。</p>
<div class="sourceCode" id="cb702"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb702-1" data-line-number="1"><span class="kw">struct</span> fractional</a>
<a class="sourceLine" id="cb702-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb702-3" data-line-number="3">    <span class="dt">int</span> num ;</a>
<a class="sourceLine" id="cb702-4" data-line-number="4">    <span class="dt">int</span> denom ;</a>
<a class="sourceLine" id="cb702-5" data-line-number="5">} ;</a>
<a class="sourceLine" id="cb702-6" data-line-number="6"></a>
<a class="sourceLine" id="cb702-7" data-line-number="7"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb702-8" data-line-number="8">{</a>
<a class="sourceLine" id="cb702-9" data-line-number="9">    fractional x{<span class="dv">1</span>, <span class="dv">2</span>} ;</a>
<a class="sourceLine" id="cb702-10" data-line-number="10"></a>
<a class="sourceLine" id="cb702-11" data-line-number="11">    <span class="co">// 出力</span></a>
<a class="sourceLine" id="cb702-12" data-line-number="12">    <span class="bu">std::</span>cout &lt;&lt; <span class="kw">static_cast</span>&lt;<span class="dt">double</span>&gt;(x.num) / <span class="kw">static_cast</span>&lt;<span class="dt">double</span>&gt;(x.denom) ;</a>
<a class="sourceLine" id="cb702-13" data-line-number="13">}</a></code></pre></div>
<p>ところで、この出力を毎回書くのが面倒だ。こういう処理は関数にまとめたい。</p>
<div class="sourceCode" id="cb703"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb703-1" data-line-number="1"><span class="dt">double</span> value( fractional &amp; x )</a>
<a class="sourceLine" id="cb703-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb703-3" data-line-number="3">    <span class="cf">return</span> <span class="kw">static_cast</span>&lt;<span class="dt">double</span>&gt;(x.num) / <span class="kw">static_cast</span>&lt;<span class="dt">double</span>&gt;(x.denom) ;</a>
<a class="sourceLine" id="cb703-4" data-line-number="4">}</a>
<a class="sourceLine" id="cb703-5" data-line-number="5"></a>
<a class="sourceLine" id="cb703-6" data-line-number="6"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb703-7" data-line-number="7">{</a>
<a class="sourceLine" id="cb703-8" data-line-number="8">    fractional x{ <span class="dv">1</span>, <span class="dv">2</span> } ;</a>
<a class="sourceLine" id="cb703-9" data-line-number="9">    <span class="bu">std::</span>cout &lt;&lt; value( x ) ;</a>
<a class="sourceLine" id="cb703-10" data-line-number="10">}</a></code></pre></div>
<p>この関数<code>value</code>はクラス<code>fractional</code>専用だ。であれば、この関数をクラス自体に関連付けたい。そこでC++には<code>メンバー関数</code>という機能がある。</p>
<p><code>メンバー関数</code>はクラスの中で定義する関数だ。</p>
<div class="sourceCode" id="cb704"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb704-1" data-line-number="1"><span class="kw">struct</span> S</a>
<a class="sourceLine" id="cb704-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb704-3" data-line-number="3">    <span class="dt">void</span> member_function( <span class="dt">int</span> x )</a>
<a class="sourceLine" id="cb704-4" data-line-number="4">    {</a>
<a class="sourceLine" id="cb704-5" data-line-number="5">        <span class="cf">return</span> x ;</a>
<a class="sourceLine" id="cb704-6" data-line-number="6">    }</a>
<a class="sourceLine" id="cb704-7" data-line-number="7">} ;</a></code></pre></div>
<p><code>メンバー関数</code>はクラスの<code>データメンバー</code>を使うことができる。</p>
<div class="sourceCode" id="cb705"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb705-1" data-line-number="1"><span class="kw">struct</span> fractional</a>
<a class="sourceLine" id="cb705-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb705-3" data-line-number="3">    <span class="dt">int</span> num ;</a>
<a class="sourceLine" id="cb705-4" data-line-number="4">    <span class="dt">int</span> denom ;</a>
<a class="sourceLine" id="cb705-5" data-line-number="5"></a>
<a class="sourceLine" id="cb705-6" data-line-number="6">    <span class="dt">double</span> value()</a>
<a class="sourceLine" id="cb705-7" data-line-number="7">    {</a>
<a class="sourceLine" id="cb705-8" data-line-number="8">        <span class="cf">return</span> <span class="kw">static_cast</span>&lt;<span class="dt">double</span>&gt;(num) / <span class="kw">static_cast</span>&lt;<span class="dt">double</span>&gt;(denom) ;</a>
<a class="sourceLine" id="cb705-9" data-line-number="9">    }</a>
<a class="sourceLine" id="cb705-10" data-line-number="10">} ;</a></code></pre></div>
<p>メンバー関数を呼び出すには、クラスのオブジェクトに続いてドット文字を書き、メンバー関数名を書く。後は通常の関数のように書く。</p>
<div class="sourceCode" id="cb706"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb706-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb706-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb706-3" data-line-number="3">    fractional x{ <span class="dv">1</span>, <span class="dv">2</span> } ;</a>
<a class="sourceLine" id="cb706-4" data-line-number="4">    <span class="bu">std::</span>cout &lt;&lt; x.value() ;</a>
<a class="sourceLine" id="cb706-5" data-line-number="5">}</a></code></pre></div>
<p><code>メンバー関数</code>から使える<code>データメンバー</code>は、メンバー関数が呼ばれたクラスのオブジェクトのデータメンバーだ。</p>
<div class="sourceCode" id="cb707"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb707-1" data-line-number="1"><span class="kw">struct</span> S</a>
<a class="sourceLine" id="cb707-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb707-3" data-line-number="3">    <span class="dt">int</span> x ;</a>
<a class="sourceLine" id="cb707-4" data-line-number="4">    <span class="dt">void</span> print()</a>
<a class="sourceLine" id="cb707-5" data-line-number="5">    {</a>
<a class="sourceLine" id="cb707-6" data-line-number="6">        <span class="bu">std::</span>cout &lt;&lt; x ;</a>
<a class="sourceLine" id="cb707-7" data-line-number="7">    }</a>
<a class="sourceLine" id="cb707-8" data-line-number="8">} ;</a>
<a class="sourceLine" id="cb707-9" data-line-number="9"></a>
<a class="sourceLine" id="cb707-10" data-line-number="10"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb707-11" data-line-number="11">{</a>
<a class="sourceLine" id="cb707-12" data-line-number="12">    S s1(<span class="dv">1</span>) ;</a>
<a class="sourceLine" id="cb707-13" data-line-number="13">    s1.print() ; <span class="co">// 1</span></a>
<a class="sourceLine" id="cb707-14" data-line-number="14"></a>
<a class="sourceLine" id="cb707-15" data-line-number="15">    S s2(<span class="dv">2</span>) ;</a>
<a class="sourceLine" id="cb707-16" data-line-number="16">    s2.print() ; <span class="co">// 2</span></a>
<a class="sourceLine" id="cb707-17" data-line-number="17">}</a></code></pre></div>
<p>この<code>print</code>を非メンバー関数として書くと以下のようになる。</p>
<div class="sourceCode" id="cb708"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb708-1" data-line-number="1"><span class="dt">void</span> print( S &amp; s )</a>
<a class="sourceLine" id="cb708-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb708-3" data-line-number="3">    <span class="bu">std::</span>cout &lt;&lt; s.x ;</a>
<a class="sourceLine" id="cb708-4" data-line-number="4">}</a></code></pre></div>
<p>メンバー関数は隠し引数としてクラスのオブジェクトを受け取っている関数だ。メンバー関数の呼び出しには、対応するクラスのオブジェクトが必要になる。</p>
<div class="sourceCode" id="cb709"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb709-1" data-line-number="1"><span class="kw">struct</span> S</a>
<a class="sourceLine" id="cb709-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb709-3" data-line-number="3">    <span class="dt">void</span> f() { }</a>
<a class="sourceLine" id="cb709-4" data-line-number="4">} ;</a>
<a class="sourceLine" id="cb709-5" data-line-number="5"></a>
<a class="sourceLine" id="cb709-6" data-line-number="6"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb709-7" data-line-number="7">{</a>
<a class="sourceLine" id="cb709-8" data-line-number="8">    f() ; <span class="co">// エラー</span></a>
<a class="sourceLine" id="cb709-9" data-line-number="9">    S s ;</a>
<a class="sourceLine" id="cb709-10" data-line-number="10">    s.f() ; <span class="co">// OK</span></a>
<a class="sourceLine" id="cb709-11" data-line-number="11">}</a></code></pre></div>
<p><code>メンバー関数</code>はデータメンバーを変更することもできる。</p>
<div class="sourceCode" id="cb710"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb710-1" data-line-number="1"><span class="kw">struct</span> X</a>
<a class="sourceLine" id="cb710-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb710-3" data-line-number="3">    <span class="dt">int</span> data ;</a>
<a class="sourceLine" id="cb710-4" data-line-number="4">    <span class="dt">void</span> f()</a>
<a class="sourceLine" id="cb710-5" data-line-number="5">    {</a>
<a class="sourceLine" id="cb710-6" data-line-number="6">        data = <span class="dv">3</span> ;</a>
<a class="sourceLine" id="cb710-7" data-line-number="7">    }</a>
<a class="sourceLine" id="cb710-8" data-line-number="8">} ;</a></code></pre></div>
<p>先程の分数クラスに値を設定するための<code>メンバー関数</code>を追加してみよう。</p>
<div class="sourceCode" id="cb711"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb711-1" data-line-number="1"><span class="kw">struct</span> fractional</a>
<a class="sourceLine" id="cb711-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb711-3" data-line-number="3">    <span class="dt">int</span> num ;</a>
<a class="sourceLine" id="cb711-4" data-line-number="4">    <span class="dt">int</span> denom ;</a>
<a class="sourceLine" id="cb711-5" data-line-number="5"></a>
<a class="sourceLine" id="cb711-6" data-line-number="6">    <span class="dt">void</span> set( <span class="dt">int</span> <span class="va">num_</span> )</a>
<a class="sourceLine" id="cb711-7" data-line-number="7">    {</a>
<a class="sourceLine" id="cb711-8" data-line-number="8">        num = <span class="va">num_</span> ;</a>
<a class="sourceLine" id="cb711-9" data-line-number="9">        denom = <span class="dv">1</span> ;</a>
<a class="sourceLine" id="cb711-10" data-line-number="10">    }</a>
<a class="sourceLine" id="cb711-11" data-line-number="11">    <span class="dt">void</span> set( <span class="dt">int</span> <span class="va">num_</span>, <span class="dt">int</span> <span class="va">denom_</span> )</a>
<a class="sourceLine" id="cb711-12" data-line-number="12">    {</a>
<a class="sourceLine" id="cb711-13" data-line-number="13">        num = <span class="va">num_</span> ;</a>
<a class="sourceLine" id="cb711-14" data-line-number="14">        denom = <span class="va">denom_</span> ;</a>
<a class="sourceLine" id="cb711-15" data-line-number="15">    }</a>
<a class="sourceLine" id="cb711-16" data-line-number="16">} ;</a>
<a class="sourceLine" id="cb711-17" data-line-number="17"></a>
<a class="sourceLine" id="cb711-18" data-line-number="18"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb711-19" data-line-number="19">{</a>
<a class="sourceLine" id="cb711-20" data-line-number="20">    fractional x ;</a>
<a class="sourceLine" id="cb711-21" data-line-number="21"></a>
<a class="sourceLine" id="cb711-22" data-line-number="22"></a>
<a class="sourceLine" id="cb711-23" data-line-number="23">    x.set(<span class="dv">5</span>) ;</a>
<a class="sourceLine" id="cb711-24" data-line-number="24">    <span class="co">// x.num == 5</span></a>
<a class="sourceLine" id="cb711-25" data-line-number="25">    <span class="co">// x.denom == 1</span></a>
<a class="sourceLine" id="cb711-26" data-line-number="26"></a>
<a class="sourceLine" id="cb711-27" data-line-number="27">    x.set( <span class="dv">2</span>, <span class="dv">3</span> ) ;</a>
<a class="sourceLine" id="cb711-28" data-line-number="28">    <span class="co">// x.num == 2</span></a>
<a class="sourceLine" id="cb711-29" data-line-number="29">    <span class="co">// x.denom == 3</span></a>
<a class="sourceLine" id="cb711-30" data-line-number="30">}</a></code></pre></div>
<p>メンバー関数<code>set(num)</code>を呼び出すと、値が<span class="math inline">\(\frac{num}{1}\)</span>になる。メンバー関数<code>set(num, denom)</code>を呼び出すと、値が<span class="math inline">\(\frac{num}{denom}\)</span>になる。</p>
<p>ところで上のコードを見ると、<code>データメンバー</code>と引数の名前の衝突を避けるために、アンダースコアを使っている。</p>
<p><code>データメンバー</code>と引数の名前が衝突するとどうなるのか。確かめてみよう。</p>
<div class="sourceCode" id="cb712"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb712-1" data-line-number="1"><span class="kw">struct</span> S</a>
<a class="sourceLine" id="cb712-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb712-3" data-line-number="3">    <span class="dt">int</span> x ;</a>
<a class="sourceLine" id="cb712-4" data-line-number="4">    <span class="dt">void</span> f( <span class="dt">int</span> x )</a>
<a class="sourceLine" id="cb712-5" data-line-number="5">    {</a>
<a class="sourceLine" id="cb712-6" data-line-number="6">        x = x ;</a>
<a class="sourceLine" id="cb712-7" data-line-number="7">    }</a>
<a class="sourceLine" id="cb712-8" data-line-number="8">} ;</a>
<a class="sourceLine" id="cb712-9" data-line-number="9"></a>
<a class="sourceLine" id="cb712-10" data-line-number="10"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb712-11" data-line-number="11">{</a>
<a class="sourceLine" id="cb712-12" data-line-number="12">    S s{<span class="dv">0</span>} ;</a>
<a class="sourceLine" id="cb712-13" data-line-number="13">    s.f(<span class="dv">1</span>) ;</a>
<a class="sourceLine" id="cb712-14" data-line-number="14"></a>
<a class="sourceLine" id="cb712-15" data-line-number="15">    <span class="bu">std::</span>cout &lt;&lt; s.x ;</a>
<a class="sourceLine" id="cb712-16" data-line-number="16">}</a></code></pre></div>
<p>結果は<code>0</code>だ。メンバー関数<code>f</code>の中の名前<code>x</code>は引数名のxだからだ。</p>
<p>すでに名前は<code>スコープ</code>に属するということは説明した。実はクラスも<code>スコープ</code>を持つ。上のコードは以下のようなスコープを持つ。</p>
<div class="sourceCode" id="cb713"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb713-1" data-line-number="1"><span class="co">// グローバル名前空間スコープ</span></a>
<a class="sourceLine" id="cb713-2" data-line-number="2"><span class="dt">int</span> x ;</a>
<a class="sourceLine" id="cb713-3" data-line-number="3"></a>
<a class="sourceLine" id="cb713-4" data-line-number="4"><span class="kw">struct</span> S</a>
<a class="sourceLine" id="cb713-5" data-line-number="5">{</a>
<a class="sourceLine" id="cb713-6" data-line-number="6">    <span class="co">// クラススコープ</span></a>
<a class="sourceLine" id="cb713-7" data-line-number="7">    <span class="dt">int</span> x ;</a>
<a class="sourceLine" id="cb713-8" data-line-number="8"></a>
<a class="sourceLine" id="cb713-9" data-line-number="9">    <span class="dt">void</span> f( <span class="dt">int</span> x )</a>
<a class="sourceLine" id="cb713-10" data-line-number="10">    {</a>
<a class="sourceLine" id="cb713-11" data-line-number="11">        <span class="co">// 関数のブロックスコープ</span></a>
<a class="sourceLine" id="cb713-12" data-line-number="12">        x = x ;</a>
<a class="sourceLine" id="cb713-13" data-line-number="13">    }</a>
<a class="sourceLine" id="cb713-14" data-line-number="14">} ;</a></code></pre></div>
<p>内側の<code>スコープ</code>は外側の<code>スコープ</code>の名前を隠す。そのため、クラススコープのxはグローバル名前空間スコープxを隠す。関数のブロックスコープのxはクラススコープのxを隠す。</p>
<p>名前がどのスコープに属するかを明示的に指定することによって、隠された名前を使うことができる。</p>
<div class="sourceCode" id="cb714"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb714-1" data-line-number="1"><span class="dt">int</span> x ;</a>
<a class="sourceLine" id="cb714-2" data-line-number="2"></a>
<a class="sourceLine" id="cb714-3" data-line-number="3"><span class="kw">struct</span> S</a>
<a class="sourceLine" id="cb714-4" data-line-number="4">{</a>
<a class="sourceLine" id="cb714-5" data-line-number="5">    <span class="dt">int</span> x ;</a>
<a class="sourceLine" id="cb714-6" data-line-number="6"></a>
<a class="sourceLine" id="cb714-7" data-line-number="7">    <span class="dt">void</span> f( <span class="dt">int</span> x )</a>
<a class="sourceLine" id="cb714-8" data-line-number="8">    {</a>
<a class="sourceLine" id="cb714-9" data-line-number="9">        <span class="co">// 関数のブロックスコープのx</span></a>
<a class="sourceLine" id="cb714-10" data-line-number="10">        x = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb714-11" data-line-number="11">        <span class="co">// クラススコープのx</span></a>
<a class="sourceLine" id="cb714-12" data-line-number="12">        S::x = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb714-13" data-line-number="13">        <span class="co">// グローバル名前空間のスコープ</span></a>
<a class="sourceLine" id="cb714-14" data-line-number="14">        ::x = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb714-15" data-line-number="15">    }</a>
<a class="sourceLine" id="cb714-16" data-line-number="16">} ;</a></code></pre></div>
<p>名前空間スコープを明示するために<code>namespace_name::name</code>を使うように、クラススコープを明示するために<code>class_name::name</code>を使うことができる。</p>
<p>これを使えば、分数クラスは以下のように書ける。</p>
<div class="sourceCode" id="cb715"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb715-1" data-line-number="1"><span class="kw">struct</span> fractional</a>
<a class="sourceLine" id="cb715-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb715-3" data-line-number="3">    <span class="dt">int</span> num ;</a>
<a class="sourceLine" id="cb715-4" data-line-number="4">    <span class="dt">int</span> denom ;</a>
<a class="sourceLine" id="cb715-5" data-line-number="5"></a>
<a class="sourceLine" id="cb715-6" data-line-number="6">    <span class="dt">void</span> set( <span class="dt">int</span> num, <span class="dt">int</span> denom )</a>
<a class="sourceLine" id="cb715-7" data-line-number="7">    {</a>
<a class="sourceLine" id="cb715-8" data-line-number="8">        fractional::num = num ;</a>
<a class="sourceLine" id="cb715-9" data-line-number="9">        fractional::denom = denom ;</a>
<a class="sourceLine" id="cb715-10" data-line-number="10">    }</a>
<a class="sourceLine" id="cb715-11" data-line-number="11">}</a></code></pre></div>
<h1 id="より自然に振る舞うクラス">より自然に振る舞うクラス</h1>
<p>整数型の<code>int</code>について考えてみよう。</p>
<div class="sourceCode" id="cb716"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb716-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb716-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb716-3" data-line-number="3">    <span class="dt">int</span> a = <span class="dv">1</span> ;</a>
<a class="sourceLine" id="cb716-4" data-line-number="4">    <span class="dt">int</span> b = a + a ;</a>
<a class="sourceLine" id="cb716-5" data-line-number="5">    <span class="dt">int</span> c = a + b ;</a>
<a class="sourceLine" id="cb716-6" data-line-number="6">}</a></code></pre></div>
<p>同様のことを、前章の分数クラスで書いてみよう。</p>
<div class="sourceCode" id="cb717"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb717-1" data-line-number="1"><span class="kw">struct</span> fractional</a>
<a class="sourceLine" id="cb717-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb717-3" data-line-number="3">    <span class="dt">int</span> num ;</a>
<a class="sourceLine" id="cb717-4" data-line-number="4">    <span class="dt">int</span> denom ;</a>
<a class="sourceLine" id="cb717-5" data-line-number="5">} ;</a>
<a class="sourceLine" id="cb717-6" data-line-number="6"></a>
<a class="sourceLine" id="cb717-7" data-line-number="7">fractional add( fractional &amp; l, fractional &amp; r )</a>
<a class="sourceLine" id="cb717-8" data-line-number="8">{</a>
<a class="sourceLine" id="cb717-9" data-line-number="9">    <span class="co">// 分母が同じなら</span></a>
<a class="sourceLine" id="cb717-10" data-line-number="10">    <span class="cf">if</span> ( l.denom == r.denom )</a>
<a class="sourceLine" id="cb717-11" data-line-number="11">        <span class="co">// 単に分子を足す</span></a>
<a class="sourceLine" id="cb717-12" data-line-number="12">        <span class="cf">return</span> fractional{ l.num + r.num, l.denom } ;</a>
<a class="sourceLine" id="cb717-13" data-line-number="13"></a>
<a class="sourceLine" id="cb717-14" data-line-number="14">    <span class="co">// 分母を合わせて分子を足す</span></a>
<a class="sourceLine" id="cb717-15" data-line-number="15">    <span class="cf">return</span> fractional{ l.num * r.denom + r.num * l.denom, l.denom * r.denom } ;</a>
<a class="sourceLine" id="cb717-16" data-line-number="16">}</a>
<a class="sourceLine" id="cb717-17" data-line-number="17"></a>
<a class="sourceLine" id="cb717-18" data-line-number="18"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb717-19" data-line-number="19">{</a>
<a class="sourceLine" id="cb717-20" data-line-number="20">    fractional a{<span class="dv">1</span>,<span class="dv">1</span>} ;</a>
<a class="sourceLine" id="cb717-21" data-line-number="21">    fractional b = add(a, a) ;</a>
<a class="sourceLine" id="cb717-22" data-line-number="22">    fractional c = add(a, b) ;</a>
<a class="sourceLine" id="cb717-23" data-line-number="23">}</a></code></pre></div>
<p>これは読みにくい。できれば以下のように書きたいところだ。</p>
<div class="sourceCode" id="cb718"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb718-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb718-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb718-3" data-line-number="3">    fractional a = <span class="dv">1</span> ;</a>
<a class="sourceLine" id="cb718-4" data-line-number="4">    fractional b = a + a ;</a>
<a class="sourceLine" id="cb718-5" data-line-number="5">    fractional c = a + b ;</a>
<a class="sourceLine" id="cb718-6" data-line-number="6">}</a></code></pre></div>
<p>C++ではクラスをこのように自然に振る舞わせることができる。</p>
<h2 id="より自然な初期化">より自然な初期化</h2>
<p>int型は初期化にあたって値を設定できる。</p>
<div class="sourceCode" id="cb719"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb719-1" data-line-number="1"><span class="dt">int</span> a = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb719-2" data-line-number="2"><span class="dt">int</span> b(<span class="dv">0</span>) ;</a>
<a class="sourceLine" id="cb719-3" data-line-number="3"><span class="dt">int</span> c{<span class="dv">0</span>} ;</a></code></pre></div>
<p><code>クラス</code>でこのような初期化をするには、<code>コンストラクター</code>を書く。</p>
<div class="sourceCode" id="cb720"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb720-1" data-line-number="1"><span class="kw">struct</span> fractional</a>
<a class="sourceLine" id="cb720-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb720-3" data-line-number="3">    <span class="dt">int</span> num ;</a>
<a class="sourceLine" id="cb720-4" data-line-number="4">    <span class="dt">int</span> denom ;</a>
<a class="sourceLine" id="cb720-5" data-line-number="5"></a>
<a class="sourceLine" id="cb720-6" data-line-number="6">    <span class="co">// コンストラクター</span></a>
<a class="sourceLine" id="cb720-7" data-line-number="7">    fractional( <span class="dt">int</span> num )</a>
<a class="sourceLine" id="cb720-8" data-line-number="8">        : num(num), denom(<span class="dv">1</span>)</a>
<a class="sourceLine" id="cb720-9" data-line-number="9">    { }</a>
<a class="sourceLine" id="cb720-10" data-line-number="10">} ;</a>
<a class="sourceLine" id="cb720-11" data-line-number="11"></a>
<a class="sourceLine" id="cb720-12" data-line-number="12"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb720-13" data-line-number="13">{</a>
<a class="sourceLine" id="cb720-14" data-line-number="14">    fractional a = <span class="dv">1</span> ;</a>
<a class="sourceLine" id="cb720-15" data-line-number="15">    fractional b = <span class="dv">2</span> ;</a>
<a class="sourceLine" id="cb720-16" data-line-number="16">}</a></code></pre></div>
<p><code>コンストラクター</code>は<code>クラス</code>の<code>特殊なメンバー関数</code>として定義する。<code>メンバー関数</code>としての<code>コンストラクター</code>は、名前がクラス名で、戻り値の型は記述しない。</p>
<div class="sourceCode" id="cb721"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb721-1" data-line-number="1"><span class="kw">struct</span> clas<span class="va">s_name</span></a>
<a class="sourceLine" id="cb721-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb721-3" data-line-number="3">    <span class="co">// コンストラクター</span></a>
<a class="sourceLine" id="cb721-4" data-line-number="4">    class_name() { }</a>
<a class="sourceLine" id="cb721-5" data-line-number="5">} ;</a></code></pre></div>
<p><code>コンストラクター</code>は<code>データメンバー</code>の初期化に特別な文法を持っている。関数の本体の前にコロンを書き、データメンバー名をそれぞれカンマで区切って初期化する。</p>
<div class="sourceCode" id="cb722"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb722-1" data-line-number="1"><span class="kw">struct</span> clas<span class="va">s_name</span></a>
<a class="sourceLine" id="cb722-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb722-3" data-line-number="3">    <span class="dt">int</span> data_member ;</a>
<a class="sourceLine" id="cb722-4" data-line-number="4"></a>
<a class="sourceLine" id="cb722-5" data-line-number="5">    class_name( <span class="dt">int</span> value )</a>
<a class="sourceLine" id="cb722-6" data-line-number="6">        : data_member(value)</a>
<a class="sourceLine" id="cb722-7" data-line-number="7">    { }</a>
<a class="sourceLine" id="cb722-8" data-line-number="8">    </a>
<a class="sourceLine" id="cb722-9" data-line-number="9">} ;</a></code></pre></div>
<p>このとき、引数名とデータメンバー名が同じでもよい。</p>
<div class="sourceCode" id="cb723"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb723-1" data-line-number="1"><span class="kw">struct</span> clas<span class="va">s_name</span></a>
<a class="sourceLine" id="cb723-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb723-3" data-line-number="3">    <span class="dt">int</span> x ;</a>
<a class="sourceLine" id="cb723-4" data-line-number="4">    class_name( <span class="dt">int</span> x )</a>
<a class="sourceLine" id="cb723-5" data-line-number="5">        : x(x) { }</a>
<a class="sourceLine" id="cb723-6" data-line-number="6">} ;</a></code></pre></div>
<p><code>x(x)</code>の最初の<code>x</code>は<code>class_name::x</code>として、次の<code>x</code>は引数名の<code>x</code>として認識される。そのためこのコードは期待通りに動く。</p>
<p><code>コンストラクター</code>の特別なメンバー初期化を使わずに、<code>コンストラクター</code>の関数の本体で<code>データメンバー</code>を変更してもよい。</p>
<div class="sourceCode" id="cb724"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb724-1" data-line-number="1"><span class="kw">struct</span> clas<span class="va">s_name</span></a>
<a class="sourceLine" id="cb724-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb724-3" data-line-number="3">    <span class="dt">int</span> x ;</a>
<a class="sourceLine" id="cb724-4" data-line-number="4">    class_name( <span class="dt">int</span> x )</a>
<a class="sourceLine" id="cb724-5" data-line-number="5">    {</a>
<a class="sourceLine" id="cb724-6" data-line-number="6">        class_name::x = x ;</a>
<a class="sourceLine" id="cb724-7" data-line-number="7">    }</a>
<a class="sourceLine" id="cb724-8" data-line-number="8">} ;</a></code></pre></div>
<p>この場合、<code>x</code>は関数の本体が実行される前に一度初期化され、その後、値を代入されるという挙動の違いがある。</p>
<p>コンストラクターはクラスが初期化されるときに実行される。例えば以下のプログラムを実行すると、</p>
<div class="sourceCode" id="cb725"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb725-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb725-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb725-3" data-line-number="3">    S a(<span class="dv">1</span>) ;</a>
<a class="sourceLine" id="cb725-4" data-line-number="4">    S b(<span class="dv">2</span>) ;</a>
<a class="sourceLine" id="cb725-5" data-line-number="5">    S c(<span class="dv">3</span>) ;</a>
<a class="sourceLine" id="cb725-6" data-line-number="6">}</a></code></pre></div>
<p>以下のように出力される。</p>
<pre><code>123</code></pre>
<p><code>コンストラクター</code>のついでに<code>デストラクター</code>も学んでおこう。<code>コンストラクター</code>はクラスのオブジェクトが初期化されるときに実行されるが、<code>デストラクター</code>はクラスのオブジェクトが破棄されるときに実行される。</p>
<p><code>デストラクター</code>の宣言は<code>コンストラクター</code>と似ている。違う点は、クラス名の前にチルダ文字を書くところだ。</p>
<div class="sourceCode" id="cb727"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb727-1" data-line-number="1"><span class="kw">struct</span> S</a>
<a class="sourceLine" id="cb727-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb727-3" data-line-number="3">    <span class="co">// デストラクター</span></a>
<a class="sourceLine" id="cb727-4" data-line-number="4">    ~S()</a>
<a class="sourceLine" id="cb727-5" data-line-number="5">    {</a>
<a class="sourceLine" id="cb727-6" data-line-number="6">        <span class="co">// オブジェクトの破棄時に実行される</span></a>
<a class="sourceLine" id="cb727-7" data-line-number="7">    }</a>
<a class="sourceLine" id="cb727-8" data-line-number="8">} ;</a></code></pre></div>
<p>関数のローカル変数は、ブロックスコープを抜ける際に破棄される。破棄は構築の逆順に行われる。</p>
<div class="sourceCode" id="cb728"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb728-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb728-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb728-3" data-line-number="3">    <span class="dt">int</span> a ;</a>
<a class="sourceLine" id="cb728-4" data-line-number="4">    {</a>
<a class="sourceLine" id="cb728-5" data-line-number="5">        <span class="dt">int</span> b ;</a>
<a class="sourceLine" id="cb728-6" data-line-number="6">    <span class="co">// bが破棄される</span></a>
<a class="sourceLine" id="cb728-7" data-line-number="7">    }</a>
<a class="sourceLine" id="cb728-8" data-line-number="8">    <span class="dt">int</span> c ;</a>
<a class="sourceLine" id="cb728-9" data-line-number="9"><span class="co">// cが破棄される</span></a>
<a class="sourceLine" id="cb728-10" data-line-number="10"><span class="co">// aが破棄される</span></a>
<a class="sourceLine" id="cb728-11" data-line-number="11">}</a></code></pre></div>
<p>さっそく初期化時と終了時に標準出力をするクラスで確かめてみよう。</p>
<div class="sourceCode" id="cb729"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb729-1" data-line-number="1"><span class="kw">struct</span> S</a>
<a class="sourceLine" id="cb729-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb729-3" data-line-number="3">    <span class="dt">int</span> n ;</a>
<a class="sourceLine" id="cb729-4" data-line-number="4">    S( <span class="dt">int</span> n )</a>
<a class="sourceLine" id="cb729-5" data-line-number="5">        : n(n)</a>
<a class="sourceLine" id="cb729-6" data-line-number="6">    {</a>
<a class="sourceLine" id="cb729-7" data-line-number="7">        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;constructed: &quot;</span>s &lt;&lt; n &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb729-8" data-line-number="8">    }</a>
<a class="sourceLine" id="cb729-9" data-line-number="9"></a>
<a class="sourceLine" id="cb729-10" data-line-number="10">    ~S()</a>
<a class="sourceLine" id="cb729-11" data-line-number="11">    {</a>
<a class="sourceLine" id="cb729-12" data-line-number="12">        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;destructed: &quot;</span>s &lt;&lt; n &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb729-13" data-line-number="13">    }</a>
<a class="sourceLine" id="cb729-14" data-line-number="14">} ;</a></code></pre></div>
<p>このクラスを以下のように使うと、</p>
<div class="sourceCode" id="cb730"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb730-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb730-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb730-3" data-line-number="3">    S a(<span class="dv">1</span>) ;</a>
<a class="sourceLine" id="cb730-4" data-line-number="4">    { S b(<span class="dv">2</span>) ; }</a>
<a class="sourceLine" id="cb730-5" data-line-number="5">    S c(<span class="dv">3</span>) ;</a>
<a class="sourceLine" id="cb730-6" data-line-number="6">}</a></code></pre></div>
<p>以下のように出力される</p>
<pre><code>constructed: 1
constructed: 2
destructed: 2
constructed: 3
destructed: 3
destructed: 1</code></pre>
<p>この出力は以下のような意味だ。</p>
<ol type="1">
<li>aが構築される</li>
<li>bが構築される</li>
<li>bが破棄される</li>
<li>cが構築される</li>
<li>cが破棄される</li>
<li>aが破棄される</li>
</ol>
<p>bはブロックスコープの終わりに達したのでaの構築の後、cの構築の前に破棄される。破棄は構築の逆順で行われるので、aよりも先にcが破棄される。</p>
<p><code>コンストラクター</code>と<code>デストラクター</code>は戻り値を返さないので、<code>return文</code>には値を書かない。</p>
<div class="sourceCode" id="cb732"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb732-1" data-line-number="1"><span class="kw">struct</span> clas<span class="va">s_name</span></a>
<a class="sourceLine" id="cb732-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb732-3" data-line-number="3">    class_name()</a>
<a class="sourceLine" id="cb732-4" data-line-number="4">    {</a>
<a class="sourceLine" id="cb732-5" data-line-number="5">        <span class="cf">return</span> ;</a>
<a class="sourceLine" id="cb732-6" data-line-number="6">    }</a>
<a class="sourceLine" id="cb732-7" data-line-number="7">} ;</a></code></pre></div>
<p><code>コンストラクター</code>は複数の引数を取ることもできる。</p>
<div class="sourceCode" id="cb733"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb733-1" data-line-number="1"><span class="kw">struct</span> fractional</a>
<a class="sourceLine" id="cb733-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb733-3" data-line-number="3">    <span class="dt">int</span> num ;</a>
<a class="sourceLine" id="cb733-4" data-line-number="4">    <span class="dt">int</span> denom ;</a>
<a class="sourceLine" id="cb733-5" data-line-number="5"></a>
<a class="sourceLine" id="cb733-6" data-line-number="6">    fractional( <span class="dt">int</span> num )</a>
<a class="sourceLine" id="cb733-7" data-line-number="7">        : num(num), denom(<span class="dv">1</span>)</a>
<a class="sourceLine" id="cb733-8" data-line-number="8">    { }</a>
<a class="sourceLine" id="cb733-9" data-line-number="9"></a>
<a class="sourceLine" id="cb733-10" data-line-number="10">    fractional( <span class="dt">int</span> num, <span class="dt">int</span> denom )</a>
<a class="sourceLine" id="cb733-11" data-line-number="11">        : num(num), denom(denom)</a>
<a class="sourceLine" id="cb733-12" data-line-number="12">    { }</a>
<a class="sourceLine" id="cb733-13" data-line-number="13">} ;</a>
<a class="sourceLine" id="cb733-14" data-line-number="14"></a>
<a class="sourceLine" id="cb733-15" data-line-number="15"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb733-16" data-line-number="16">{</a>
<a class="sourceLine" id="cb733-17" data-line-number="17">    <span class="co">// fractional(int)が呼ばれる</span></a>
<a class="sourceLine" id="cb733-18" data-line-number="18">    fractional a = <span class="dv">1</span> ;</a>
<a class="sourceLine" id="cb733-19" data-line-number="19"></a>
<a class="sourceLine" id="cb733-20" data-line-number="20">    <span class="co">// fractional(int,int)が呼ばれる</span></a>
<a class="sourceLine" id="cb733-21" data-line-number="21">    fractional b(<span class="dv">1</span>, <span class="dv">2</span>) ;</a>
<a class="sourceLine" id="cb733-22" data-line-number="22">    fractional c{<span class="dv">1</span>, <span class="dv">2</span>} ;</a>
<a class="sourceLine" id="cb733-23" data-line-number="23">}</a></code></pre></div>
<p>複数の引数をとるコンストラクターを呼び出すには“=”は使えない。“()”か“{}”を使う必要がある。</p>
<p>上のコードを見ると、コンストラクターは引数の数以外にやっていることはほとんど同じだ。こういう場合、コンストラクターを一つにする方法がある。</p>
<p>実はコンストラクターに限らず、関数は<code>デフォルト実引数</code>を取ることができる。書き方は仮引数に“=”で値を書く</p>
<div class="sourceCode" id="cb734"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb734-1" data-line-number="1"><span class="dt">void</span> f( <span class="dt">int</span> x = <span class="dv">0</span> )</a>
<a class="sourceLine" id="cb734-2" data-line-number="2">{ }</a>
<a class="sourceLine" id="cb734-3" data-line-number="3"></a>
<a class="sourceLine" id="cb734-4" data-line-number="4"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb734-5" data-line-number="5">{</a>
<a class="sourceLine" id="cb734-6" data-line-number="6">    f() ;  <span class="co">// f(0)</span></a>
<a class="sourceLine" id="cb734-7" data-line-number="7">    f(<span class="dv">1</span>) ; <span class="co">// f(1)</span></a>
<a class="sourceLine" id="cb734-8" data-line-number="8">}</a></code></pre></div>
<p><code>デフォルト実引数</code>を指定した関数の仮引数に実引数を渡さない場合、<code>デフォルト実引数</code>で指定した値が渡される。</p>
<p>ところで、<code>仮引数</code>、<code>実引数</code>という聞きなれない言葉が出てきた。これは関数の引数を区別するための言葉だ。<code>仮引数</code>は関数の宣言の引数。実引数は関数呼び出しのときに引数に渡す値のことを意味する。</p>
<div class="sourceCode" id="cb735"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb735-1" data-line-number="1"><span class="co">// xは仮引数</span></a>
<a class="sourceLine" id="cb735-2" data-line-number="2"><span class="dt">void</span> f( <span class="dt">int</span> x ) { }</a>
<a class="sourceLine" id="cb735-3" data-line-number="3"></a>
<a class="sourceLine" id="cb735-4" data-line-number="4"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb735-5" data-line-number="5">{</a>
<a class="sourceLine" id="cb735-6" data-line-number="6">    <span class="co">// 123は仮引数xに対する実引数</span></a>
<a class="sourceLine" id="cb735-7" data-line-number="7">    f( <span class="dv">123</span> ) ;</a>
<a class="sourceLine" id="cb735-8" data-line-number="8">}</a></code></pre></div>
<p><code>デフォルト実引数</code>は関数の実引数の一部を省略できる。</p>
<p>ただし、<code>デフォルト実引数</code>を使った以後の仮引数には、すべて<code>デフォルト実引数</code>がなければならない。</p>
<div class="sourceCode" id="cb736"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb736-1" data-line-number="1"><span class="co">// OK</span></a>
<a class="sourceLine" id="cb736-2" data-line-number="2"><span class="dt">void</span> f( <span class="dt">int</span> x, <span class="dt">int</span> y = <span class="dv">0</span>, <span class="dt">int</span> z = <span class="dv">0</span> ) { }</a>
<a class="sourceLine" id="cb736-3" data-line-number="3"><span class="co">// エラー</span></a>
<a class="sourceLine" id="cb736-4" data-line-number="4"><span class="co">// zにデフォルト実引数がない</span></a>
<a class="sourceLine" id="cb736-5" data-line-number="5"><span class="dt">void</span> g( <span class="dt">int</span> x, <span class="dt">int</span> y = <span class="dv">0</span>, <span class="dt">int</span> z ) { }</a></code></pre></div>
<p><code>デフォルト実引数</code>で途中の引数だけ省略することはできない。</p>
<div class="sourceCode" id="cb737"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb737-1" data-line-number="1"></a>
<a class="sourceLine" id="cb737-2" data-line-number="2"><span class="dt">void</span> f( <span class="dt">int</span> x = <span class="dv">0</span>, <span class="dt">int</span> y = <span class="dv">0</span>, <span class="dt">int</span> z = <span class="dv">0</span>) { }</a>
<a class="sourceLine" id="cb737-3" data-line-number="3"></a>
<a class="sourceLine" id="cb737-4" data-line-number="4"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb737-5" data-line-number="5">{</a>
<a class="sourceLine" id="cb737-6" data-line-number="6">    <span class="co">// エラー</span></a>
<a class="sourceLine" id="cb737-7" data-line-number="7">    f( <span class="dv">1</span>, , <span class="dv">2</span> ) ;</a>
<a class="sourceLine" id="cb737-8" data-line-number="8">}</a></code></pre></div>
<p><code>デフォルト実引数</code>を使うと、コンストラクターを一つにできる。</p>
<div class="sourceCode" id="cb738"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb738-1" data-line-number="1"><span class="kw">struct</span> fractional</a>
<a class="sourceLine" id="cb738-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb738-3" data-line-number="3">    <span class="dt">int</span> num ;</a>
<a class="sourceLine" id="cb738-4" data-line-number="4">    <span class="dt">int</span> denom ;</a>
<a class="sourceLine" id="cb738-5" data-line-number="5"></a>
<a class="sourceLine" id="cb738-6" data-line-number="6">    fractional( <span class="dt">int</span> num, <span class="dt">int</span> denom = <span class="dv">1</span> )</a>
<a class="sourceLine" id="cb738-7" data-line-number="7">        : num(num), denom(denom)</a>
<a class="sourceLine" id="cb738-8" data-line-number="8">    { }</a>
<a class="sourceLine" id="cb738-9" data-line-number="9">} ;</a>
<a class="sourceLine" id="cb738-10" data-line-number="10"></a>
<a class="sourceLine" id="cb738-11" data-line-number="11"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb738-12" data-line-number="12">{</a>
<a class="sourceLine" id="cb738-13" data-line-number="13">    fractional a = <span class="dv">1</span> ;</a>
<a class="sourceLine" id="cb738-14" data-line-number="14">    fractional b(<span class="dv">1</span>,<span class="dv">2</span>) ;</a>
<a class="sourceLine" id="cb738-15" data-line-number="15">    fractional c{<span class="dv">1</span>,<span class="dv">2</span>} ;</a>
<a class="sourceLine" id="cb738-16" data-line-number="16">}</a></code></pre></div>
<p>コンストラクターの数を減らす方法はもう一つある。<code>デリゲートコンストラクター</code>だ。</p>
<div class="sourceCode" id="cb739"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb739-1" data-line-number="1"><span class="kw">struct</span> fractional</a>
<a class="sourceLine" id="cb739-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb739-3" data-line-number="3">    <span class="dt">int</span> num ;</a>
<a class="sourceLine" id="cb739-4" data-line-number="4">    <span class="dt">int</span> denom ;</a>
<a class="sourceLine" id="cb739-5" data-line-number="5"></a>
<a class="sourceLine" id="cb739-6" data-line-number="6">    fractional( <span class="dt">int</span> num, <span class="dt">int</span> denom )</a>
<a class="sourceLine" id="cb739-7" data-line-number="7">        : num(num), denom(denom)</a>
<a class="sourceLine" id="cb739-8" data-line-number="8">    { }</a>
<a class="sourceLine" id="cb739-9" data-line-number="9"></a>
<a class="sourceLine" id="cb739-10" data-line-number="10">    <span class="co">// デリゲートコンストラクター</span></a>
<a class="sourceLine" id="cb739-11" data-line-number="11">    fractional( <span class="dt">int</span> num )</a>
<a class="sourceLine" id="cb739-12" data-line-number="12">        : fractional( num, <span class="dv">1</span> )</a>
<a class="sourceLine" id="cb739-13" data-line-number="13">    { }</a>
<a class="sourceLine" id="cb739-14" data-line-number="14">} ;</a></code></pre></div>
<p><code>デリゲートコンストラクター</code>は初期化処理を別のコンストラクターにデリゲート(丸投げ)する。丸投げ先のコンストラクターの初期化処理が終わり次第、デリゲートコンストラクターの関数の本体が実行される。</p>
<div class="sourceCode" id="cb740"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb740-1" data-line-number="1"><span class="kw">struct</span> S</a>
<a class="sourceLine" id="cb740-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb740-3" data-line-number="3">    S()</a>
<a class="sourceLine" id="cb740-4" data-line-number="4">        : S(<span class="dv">1</span>)</a>
<a class="sourceLine" id="cb740-5" data-line-number="5">    {</a>
<a class="sourceLine" id="cb740-6" data-line-number="6">        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;delegating constructor</span><span class="sc">\n</span><span class="st">&quot;</span> ;</a>
<a class="sourceLine" id="cb740-7" data-line-number="7">    }</a>
<a class="sourceLine" id="cb740-8" data-line-number="8"></a>
<a class="sourceLine" id="cb740-9" data-line-number="9">    S( <span class="dt">int</span> n )</a>
<a class="sourceLine" id="cb740-10" data-line-number="10">    {</a>
<a class="sourceLine" id="cb740-11" data-line-number="11">        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;constructor</span><span class="sc">\n</span><span class="st">&quot;</span> ;</a>
<a class="sourceLine" id="cb740-12" data-line-number="12">    }</a>
<a class="sourceLine" id="cb740-13" data-line-number="13">} ;</a>
<a class="sourceLine" id="cb740-14" data-line-number="14"></a>
<a class="sourceLine" id="cb740-15" data-line-number="15"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb740-16" data-line-number="16">{</a>
<a class="sourceLine" id="cb740-17" data-line-number="17">    S s ;</a>
<a class="sourceLine" id="cb740-18" data-line-number="18">}</a></code></pre></div>
<p>このプログラムを実行すると、以下のように出力される。</p>
<pre><code>constructor
delegating constructor</code></pre>
<p>まず“S()”が呼ばれるが、処理を“S(int)”にデリゲートする。“S(int)”の処理が終わり次第“S()”の関数の本体が実行される。そのためこのような出力になる。</p>
<p>コンストラクターを減らすのはよいが、減らしすぎても不便だ。以下の例を見てみよう。</p>
<div class="sourceCode" id="cb742"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb742-1" data-line-number="1"><span class="kw">struct</span> A { } ;</a>
<a class="sourceLine" id="cb742-2" data-line-number="2"><span class="kw">struct</span> B { B(<span class="dt">int</span>) { } } ;</a>
<a class="sourceLine" id="cb742-3" data-line-number="3"></a>
<a class="sourceLine" id="cb742-4" data-line-number="4"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb742-5" data-line-number="5">{</a>
<a class="sourceLine" id="cb742-6" data-line-number="6">    A a ; <span class="co">// OK</span></a>
<a class="sourceLine" id="cb742-7" data-line-number="7">    B b ; <span class="co">// エラー</span></a>
<a class="sourceLine" id="cb742-8" data-line-number="8">}</a></code></pre></div>
<p>クラス<code>A</code>の変数は問題ないのに、クラス<code>B</code>の変数はエラーになる。これはクラス<code>B</code>には引数を取らないコンストラクターがないためだ。</p>
<p>クラス<code>B</code>に引数を必要としないコンストラクターを書くと、具体的に引数を渡さなくても初期化ができるようになる。</p>
<div class="sourceCode" id="cb743"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb743-1" data-line-number="1"><span class="kw">struct</span> B</a>
<a class="sourceLine" id="cb743-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb743-3" data-line-number="3">    B() { }</a>
<a class="sourceLine" id="cb743-4" data-line-number="4">    B( <span class="dt">int</span> x ) { }</a>
<a class="sourceLine" id="cb743-5" data-line-number="5">} ;</a>
<a class="sourceLine" id="cb743-6" data-line-number="6"></a>
<a class="sourceLine" id="cb743-7" data-line-number="7"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb743-8" data-line-number="8">{</a>
<a class="sourceLine" id="cb743-9" data-line-number="9">    B b ; <span class="co">// OK</span></a>
<a class="sourceLine" id="cb743-10" data-line-number="10">}</a></code></pre></div>
<p>もしくは、デフォルト引数を使ってもよい。</p>
<div class="sourceCode" id="cb744"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb744-1" data-line-number="1"><span class="kw">struct</span> B</a>
<a class="sourceLine" id="cb744-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb744-3" data-line-number="3">    B( <span class="dt">int</span> x = <span class="dv">0</span> ) { }</a>
<a class="sourceLine" id="cb744-4" data-line-number="4">} ;</a></code></pre></div>
<p>もちろん、ユーザーが値を指定しなければならないようなクラスは値を指定するべきだ。</p>
<div class="sourceCode" id="cb745"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb745-1" data-line-number="1"><span class="co">// 人間クラス</span></a>
<a class="sourceLine" id="cb745-2" data-line-number="2"><span class="co">// 必ず名前が必要</span></a>
<a class="sourceLine" id="cb745-3" data-line-number="3"><span class="kw">struct</span> person</a>
<a class="sourceLine" id="cb745-4" data-line-number="4">{</a>
<a class="sourceLine" id="cb745-5" data-line-number="5">    <span class="bu">std::</span>string name</a>
<a class="sourceLine" id="cb745-6" data-line-number="6">    person( <span class="bu">std::</span>string name )</a>
<a class="sourceLine" id="cb745-7" data-line-number="7">        : name(name) { }</a>
<a class="sourceLine" id="cb745-8" data-line-number="8">} ;</a></code></pre></div>
<h1 id="自然な演算子">自然な演算子</h1>
<p>int型は<code>+-*/</code>といった演算子を使うことができる。</p>
<div class="sourceCode" id="cb746"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb746-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb746-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb746-3" data-line-number="3">    <span class="dt">int</span> a = <span class="dv">1</span> ;</a>
<a class="sourceLine" id="cb746-4" data-line-number="4">    <span class="dt">int</span> b = <span class="dv">1</span> ;</a>
<a class="sourceLine" id="cb746-5" data-line-number="5">    a + b ;</a>
<a class="sourceLine" id="cb746-6" data-line-number="6">    a - b ;</a>
<a class="sourceLine" id="cb746-7" data-line-number="7">    a * b ;</a>
<a class="sourceLine" id="cb746-8" data-line-number="8">    a / b ;</a>
<a class="sourceLine" id="cb746-9" data-line-number="9">}</a></code></pre></div>
<p>クラスも演算子を使った自然な記述ができる。クラスを演算子に対応させることを、<code>演算子のオーバーロード</code>という。</p>
<p>分数クラスの足し算を考えよう。</p>
<ul>
<li>分母が同じならば分子を足す</li>
<li>分母が異なるならば互いの分母を掛けて、分母を揃えて足す。</li>
</ul>
<p>コードにすると以下のようになる。</p>
<div class="sourceCode" id="cb747"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb747-1" data-line-number="1"><span class="kw">struct</span> fractional</a>
<a class="sourceLine" id="cb747-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb747-3" data-line-number="3">    <span class="dt">int</span> num ;</a>
<a class="sourceLine" id="cb747-4" data-line-number="4">    <span class="dt">int</span> denom ;</a>
<a class="sourceLine" id="cb747-5" data-line-number="5"></a>
<a class="sourceLine" id="cb747-6" data-line-number="6"><span class="co">// コンストラクターなど</span></a>
<a class="sourceLine" id="cb747-7" data-line-number="7">} ;</a>
<a class="sourceLine" id="cb747-8" data-line-number="8"></a>
<a class="sourceLine" id="cb747-9" data-line-number="9">fractional add( fractional &amp; l, fractional &amp; r )</a>
<a class="sourceLine" id="cb747-10" data-line-number="10">{</a>
<a class="sourceLine" id="cb747-11" data-line-number="11">    <span class="co">// 分母が同じなら</span></a>
<a class="sourceLine" id="cb747-12" data-line-number="12">    <span class="cf">if</span> ( l.denom == r.denom )</a>
<a class="sourceLine" id="cb747-13" data-line-number="13">        <span class="co">// 単に分子を足す</span></a>
<a class="sourceLine" id="cb747-14" data-line-number="14">        <span class="cf">return</span> fractional{ l.num + r.num, l.denom } ;</a>
<a class="sourceLine" id="cb747-15" data-line-number="15"></a>
<a class="sourceLine" id="cb747-16" data-line-number="16">    <span class="co">// 分母を合わせて分子を足す</span></a>
<a class="sourceLine" id="cb747-17" data-line-number="17">    <span class="cf">return</span> fractional{ l.num * r.denom + r.num * l.denom, l.denom * r.denom } ;</a>
<a class="sourceLine" id="cb747-18" data-line-number="18">}</a></code></pre></div>
<p>しかし、この関数<code>add</code>を使ったコードは以下のようになる。</p>
<div class="sourceCode" id="cb748"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb748-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb748-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb748-3" data-line-number="3">    fractional a{<span class="dv">1</span>,<span class="dv">2</span>} ;</a>
<a class="sourceLine" id="cb748-4" data-line-number="4">    fractional b{<span class="dv">1</span>,<span class="dv">3</span>} ;</a>
<a class="sourceLine" id="cb748-5" data-line-number="5"></a>
<a class="sourceLine" id="cb748-6" data-line-number="6">    <span class="kw">auto</span> c = add(a, b) ;</a>
<a class="sourceLine" id="cb748-7" data-line-number="7">}</a></code></pre></div>
<p>これはわかりにくい。できれば、以下のように書きたい。</p>
<div class="sourceCode" id="cb749"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb749-1" data-line-number="1"><span class="kw">auto</span> c = a + b ;</a></code></pre></div>
<p>C++では演算子は関数として扱うことができる。演算子の名前は<code>operator op</code>で、例えば<code>+演算子</code>の名前は<code>operator +</code>になる。</p>
<p>関数<code>operator +</code>は引数を2つ取り、戻り値を返す関数だ。</p>
<div class="sourceCode" id="cb750"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb750-1" data-line-number="1">fractional <span class="kw">operator</span> +( fractional &amp; l, fractional &amp; r )</a>
<a class="sourceLine" id="cb750-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb750-3" data-line-number="3">    <span class="co">// 分母が同じなら</span></a>
<a class="sourceLine" id="cb750-4" data-line-number="4">    <span class="cf">if</span> ( l.denom == r.denom )</a>
<a class="sourceLine" id="cb750-5" data-line-number="5">        <span class="co">// 単に分子を足す</span></a>
<a class="sourceLine" id="cb750-6" data-line-number="6">        <span class="cf">return</span> fractional{ l.num + r.num, l.denom } ;</a>
<a class="sourceLine" id="cb750-7" data-line-number="7">    <span class="cf">else</span></a>
<a class="sourceLine" id="cb750-8" data-line-number="8">        <span class="co">// 分母を合わせて分子を足す</span></a>
<a class="sourceLine" id="cb750-9" data-line-number="9">        <span class="cf">return</span> fractional{ l.num * r.denom + r.num * l.denom, l.denom * r.denom } ;</a>
<a class="sourceLine" id="cb750-10" data-line-number="10">}</a></code></pre></div>
<p>このように<code>operator +</code>を書くと、以下のようなコードが書ける。</p>
<div class="sourceCode" id="cb751"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb751-1" data-line-number="1"><span class="kw">auto</span> c = a + b ;</a></code></pre></div>
<p>同様に、引き算は<code>operator -</code>、掛け算は<code>operator *</code>、割り算は<code>operator /</code>だ。</p>
<p>以下に関数の宣言を示すので実際に分数の計算を実装してみよう。</p>
<div class="sourceCode" id="cb752"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb752-1" data-line-number="1">fractional <span class="kw">operator</span> -( fractional &amp; l, fractional &amp; r ) ;</a>
<a class="sourceLine" id="cb752-2" data-line-number="2">fractional <span class="kw">operator</span> *( fractional &amp; l, fractional &amp; r ) ;</a>
<a class="sourceLine" id="cb752-3" data-line-number="3">fractional <span class="kw">operator</span> /( fractional &amp; l, fractional &amp; r ) ;</a></code></pre></div>
<p>引き算は足し算とほぼ同じだ。</p>
<div class="sourceCode" id="cb753"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb753-1" data-line-number="1">fractional <span class="kw">operator</span> -( fractional &amp; l, fractional &amp; r )</a>
<a class="sourceLine" id="cb753-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb753-3" data-line-number="3">    <span class="co">// 分母が同じ</span></a>
<a class="sourceLine" id="cb753-4" data-line-number="4">    <span class="cf">if</span> ( l.denom == r.denom )</a>
<a class="sourceLine" id="cb753-5" data-line-number="5">        <span class="cf">return</span> fractional{ l.num - r.num, l.denom } ;</a>
<a class="sourceLine" id="cb753-6" data-line-number="6">    <span class="cf">else</span></a>
<a class="sourceLine" id="cb753-7" data-line-number="7">        <span class="cf">return</span> fractional{ l.num * r.denom - r.num * l.denom, l.denom * r.denom } ;</a>
<a class="sourceLine" id="cb753-8" data-line-number="8">}</a></code></pre></div>
<p>掛け算と割り算は楽だ。</p>
<div class="sourceCode" id="cb754"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb754-1" data-line-number="1">fractional <span class="kw">operator</span> *( fractional &amp; l, fractional &amp; r )</a>
<a class="sourceLine" id="cb754-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb754-3" data-line-number="3">    <span class="cf">return</span> fractional{ l.num * r.num, l.denom * r.denom } ;</a>
<a class="sourceLine" id="cb754-4" data-line-number="4">}</a>
<a class="sourceLine" id="cb754-5" data-line-number="5"></a>
<a class="sourceLine" id="cb754-6" data-line-number="6">fractional <span class="kw">operator</span> /( fractional &amp; l, fractional &amp; r )</a>
<a class="sourceLine" id="cb754-7" data-line-number="7">{</a>
<a class="sourceLine" id="cb754-8" data-line-number="8">    <span class="cf">return</span> fractional{ l.num * r.denom, l.denom * r.num } ;</a>
<a class="sourceLine" id="cb754-9" data-line-number="9">}</a></code></pre></div>
<h2 id="演算子のオーバーロード">演算子のオーバーロード</h2>
<h3 id="二項演算子">二項演算子</h3>
<p>C++には様々な演算子があるが、多くが<code>二項演算子</code>と呼ばれる演算子だ。<code>二項演算子</code>は2つの引数を取り、値を返す。</p>
<div class="sourceCode" id="cb755"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb755-1" data-line-number="1">a + b ;</a>
<a class="sourceLine" id="cb755-2" data-line-number="2">a - b ;</a>
<a class="sourceLine" id="cb755-3" data-line-number="3">a * b ;</a>
<a class="sourceLine" id="cb755-4" data-line-number="4">a / b ;</a></code></pre></div>
<p>このような演算子は<code>operator +</code>のように、キーワード<code>operator</code>に続いて演算子の文字を書くことで、関数名とする。あとは通常の関数と変わらない。</p>
<div class="sourceCode" id="cb756"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb756-1" data-line-number="1"><span class="kw">struct</span> S { } ;</a>
<a class="sourceLine" id="cb756-2" data-line-number="2"></a>
<a class="sourceLine" id="cb756-3" data-line-number="3">S add( S a, S b ) ;</a>
<a class="sourceLine" id="cb756-4" data-line-number="4">S <span class="kw">operator</span> + ( S a, S b ) ;</a></code></pre></div>
<p>戻り値の型は何でもよい。</p>
<div class="sourceCode" id="cb757"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb757-1" data-line-number="1"><span class="kw">struct</span> S { } ;</a>
<a class="sourceLine" id="cb757-2" data-line-number="2"></a>
<a class="sourceLine" id="cb757-3" data-line-number="3"><span class="dt">int</span> <span class="kw">operator</span> +( S, S ) { <span class="cf">return</span> <span class="dv">0</span> ; }</a>
<a class="sourceLine" id="cb757-4" data-line-number="4"><span class="dt">void</span> <span class="kw">operator</span> -( S, S ) { }</a>
<a class="sourceLine" id="cb757-5" data-line-number="5"></a>
<a class="sourceLine" id="cb757-6" data-line-number="6"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb757-7" data-line-number="7">{</a>
<a class="sourceLine" id="cb757-8" data-line-number="8">    S s ;</a>
<a class="sourceLine" id="cb757-9" data-line-number="9">    <span class="dt">int</span> x = s + s ;</a>
<a class="sourceLine" id="cb757-10" data-line-number="10">    s - s ; <span class="co">// 戻り値はない</span></a>
<a class="sourceLine" id="cb757-11" data-line-number="11">}</a></code></pre></div>
<p>演算子としてではなく、関数と同じように呼び出すこともできる。</p>
<div class="sourceCode" id="cb758"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb758-1" data-line-number="1"></a>
<a class="sourceLine" id="cb758-2" data-line-number="2"><span class="kw">struct</span> S { } ;</a>
<a class="sourceLine" id="cb758-3" data-line-number="3"></a>
<a class="sourceLine" id="cb758-4" data-line-number="4"><span class="co">// S f( S, S )のようなもの</span></a>
<a class="sourceLine" id="cb758-5" data-line-number="5">S <span class="kw">operator</span> + ( S, S ) { }</a>
<a class="sourceLine" id="cb758-6" data-line-number="6"></a>
<a class="sourceLine" id="cb758-7" data-line-number="7"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb758-8" data-line-number="8">{</a>
<a class="sourceLine" id="cb758-9" data-line-number="9">    S s ;</a>
<a class="sourceLine" id="cb758-10" data-line-number="10">    <span class="co">// f(s,s)のようなもの</span></a>
<a class="sourceLine" id="cb758-11" data-line-number="11">    <span class="kw">operator</span> +(s,s) ;</a>
<a class="sourceLine" id="cb758-12" data-line-number="12">}</a></code></pre></div>
<p><code>演算子のオーバーロード</code>では、少なくとも1つのユーザー定義された型がなければならない。つまり以下のような演算子のオーバーロードはできないということだ。</p>
<div class="sourceCode" id="cb759"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb759-1" data-line-number="1"><span class="dt">int</span> <span class="kw">operator</span> +( <span class="dt">int</span>, <span class="dt">int</span> ) ;</a>
<a class="sourceLine" id="cb759-2" data-line-number="2"><span class="dt">int</span> <span class="kw">operator</span> +( <span class="dt">int</span>, <span class="dt">double</span> ) ;</a></code></pre></div>
<p>二項演算子には<code>オペランド</code>と呼ばれる式を取る。</p>
<div class="sourceCode" id="cb760"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb760-1" data-line-number="1">a + b ;</a></code></pre></div>
<p>この場合、二項演算子<code>operator +</code>にはa, bという2つのオペランドがある。</p>
<p>二項演算子をオーバーロードする場合、最初の引数が最初のオペランド、次の引数が次のオペランドに対応する。</p>
<div class="sourceCode" id="cb761"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb761-1" data-line-number="1"><span class="kw">struct</span> X { } ;</a>
<a class="sourceLine" id="cb761-2" data-line-number="2"><span class="kw">struct</span> Y { } ;</a>
<a class="sourceLine" id="cb761-3" data-line-number="3"></a>
<a class="sourceLine" id="cb761-4" data-line-number="4"><span class="dt">void</span> <span class="kw">operator</span> +( X, Y ) { }</a>
<a class="sourceLine" id="cb761-5" data-line-number="5"></a>
<a class="sourceLine" id="cb761-6" data-line-number="6"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb761-7" data-line-number="7">{</a>
<a class="sourceLine" id="cb761-8" data-line-number="8">    X x ;</a>
<a class="sourceLine" id="cb761-9" data-line-number="9">    Y y ;</a>
<a class="sourceLine" id="cb761-10" data-line-number="10"></a>
<a class="sourceLine" id="cb761-11" data-line-number="11">    <span class="co">// OK</span></a>
<a class="sourceLine" id="cb761-12" data-line-number="12">    x + y ;</a>
<a class="sourceLine" id="cb761-13" data-line-number="13"></a>
<a class="sourceLine" id="cb761-14" data-line-number="14">    <span class="co">// エラー</span></a>
<a class="sourceLine" id="cb761-15" data-line-number="15">    <span class="co">// operator +(Y,X)は存在しない</span></a>
<a class="sourceLine" id="cb761-16" data-line-number="16">    y + x ;</a>
<a class="sourceLine" id="cb761-17" data-line-number="17">}</a></code></pre></div>
<p>そのため、上の例で“x+y”と“y+x”を両方使いたい場合は、</p>
<div class="sourceCode" id="cb762"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb762-1" data-line-number="1"><span class="dt">void</span> <span class="kw">operator</span> +(Y,X) { }</a></code></pre></div>
<p>も必要だ。</p>
<p>現実のコードでは、二項演算子のオーバーロードは以下のように書くことが多い。</p>
<div class="sourceCode" id="cb763"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb763-1" data-line-number="1"><span class="kw">struct</span> S { } ;</a>
<a class="sourceLine" id="cb763-2" data-line-number="2"></a>
<a class="sourceLine" id="cb763-3" data-line-number="3"><span class="co">// 引数名は様々</span></a>
<a class="sourceLine" id="cb763-4" data-line-number="4">S <span class="kw">operator</span> +( S <span class="at">const</span> &amp; left, S <span class="at">const</span> &amp; right )</a>
<a class="sourceLine" id="cb763-5" data-line-number="5">{</a>
<a class="sourceLine" id="cb763-6" data-line-number="6"></a>
<a class="sourceLine" id="cb763-7" data-line-number="7">}</a></code></pre></div>
<p><code>const &amp;</code>という特別な書き方をする。<code>&amp;</code>についてはすでに学んだように、リファレンスだ。リファレンスを使うことによって値をコピーせずに効率的に使うことができる。</p>
<p><code>const</code>というのは値を変更しない変数を宣言する機能だ。</p>
<div class="sourceCode" id="cb764"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb764-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb764-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb764-3" data-line-number="3">    <span class="dt">int</span> x = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb764-4" data-line-number="4">    x = <span class="dv">1</span> ; <span class="co">// OK</span></a>
<a class="sourceLine" id="cb764-5" data-line-number="5"></a>
<a class="sourceLine" id="cb764-6" data-line-number="6">    <span class="dt">int</span> <span class="at">const</span> y = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb764-7" data-line-number="7">    y = <span class="dv">0</span> ; <span class="co">// エラー</span></a>
<a class="sourceLine" id="cb764-8" data-line-number="8">}</a></code></pre></div>
<p>constをつけると値を変更できなくなる。</p>
<p>一般に<code>operator +</code>のような演算子は、オペランドに渡した変数を書き換えない処理をすることが期待されている。</p>
<div class="sourceCode" id="cb765"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb765-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb765-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb765-3" data-line-number="3">    <span class="dt">int</span> a = <span class="dv">1</span> ;</a>
<a class="sourceLine" id="cb765-4" data-line-number="4">    <span class="dt">int</span> b = <span class="dv">1</span> ;</a>
<a class="sourceLine" id="cb765-5" data-line-number="5"></a>
<a class="sourceLine" id="cb765-6" data-line-number="6">    <span class="co">// a, bは書き換わらない</span></a>
<a class="sourceLine" id="cb765-7" data-line-number="7">    <span class="dt">int</span> c = a + b ;</a>
<a class="sourceLine" id="cb765-8" data-line-number="8">}</a></code></pre></div>
<p>もちろん、<code>operator +</code>をオーバーロードして引数をリファレンスで取り、値を書き換えるような処理を書くこともできる。ただ、通常はそのような処理をすることはない。</p>
<p>しかし、処理の効率のためにリファレンスは使いたい。</p>
<p>そのようなときに、constかつリファレンスを使うと、効率的で値の変更ができないコードが書ける。</p>
<div class="sourceCode" id="cb766"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb766-1" data-line-number="1"><span class="kw">struct</span> IntLike{ <span class="dt">int</span> data ;} ;</a>
<a class="sourceLine" id="cb766-2" data-line-number="2"></a>
<a class="sourceLine" id="cb766-3" data-line-number="3">IntLike <span class="kw">operator</span> + ( IntLike <span class="at">const</span> &amp; l, IntLike <span class="at">const</span> &amp; r )</a>
<a class="sourceLine" id="cb766-4" data-line-number="4">{</a>
<a class="sourceLine" id="cb766-5" data-line-number="5">    <span class="cf">return</span> IntLike{ l.data + r.data }</a>
<a class="sourceLine" id="cb766-6" data-line-number="6">}</a></code></pre></div>
<p>constリファレンスの変数をうっかり書き換えてしまった場合、コンパイラーが検出してくれるので、バグを未然に発見することができる。</p>
<h3 id="単項演算子">単項演算子</h3>
<p><code>単項演算子</code>はオペランドを一つしか取らない演算子のことだ。</p>
<p><code>単項演算子</code>についてはまだ説明していないものも多い。例えば、<code>operator +</code>や<code>operator -</code>がある。</p>
<div class="sourceCode" id="cb767"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb767-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb767-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb767-3" data-line-number="3">    <span class="dt">int</span> x = <span class="dv">1</span> ;</a>
<a class="sourceLine" id="cb767-4" data-line-number="4">    +x ; <span class="co">//  1: operator +</span></a>
<a class="sourceLine" id="cb767-5" data-line-number="5">    -x ; <span class="co">// -1: operator -</span></a>
<a class="sourceLine" id="cb767-6" data-line-number="6">}</a></code></pre></div>
<p><code>単項演算子</code>は引数を一つしか取らない関数として書く。</p>
<div class="sourceCode" id="cb768"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb768-1" data-line-number="1"><span class="kw">struct</span> IntLike{ <span class="dt">int</span> data ;} ;</a>
<a class="sourceLine" id="cb768-2" data-line-number="2"></a>
<a class="sourceLine" id="cb768-3" data-line-number="3">IntLike <span class="kw">operator</span> +( IntLike <span class="at">const</span> &amp; obj )</a>
<a class="sourceLine" id="cb768-4" data-line-number="4">{</a>
<a class="sourceLine" id="cb768-5" data-line-number="5">    <span class="cf">return</span> obj ;</a>
<a class="sourceLine" id="cb768-6" data-line-number="6">}</a>
<a class="sourceLine" id="cb768-7" data-line-number="7"></a>
<a class="sourceLine" id="cb768-8" data-line-number="8">IntLIke <span class="kw">operator</span> -( IntLike <span class="at">const</span> &amp; obj )</a>
<a class="sourceLine" id="cb768-9" data-line-number="9">{</a>
<a class="sourceLine" id="cb768-10" data-line-number="10">    <span class="cf">return</span> IntLike{ -obj.data } ;</a>
<a class="sourceLine" id="cb768-11" data-line-number="11">}</a></code></pre></div>
<h3 id="インクリメントデクリメント">インクリメント/デクリメント</h3>
<p><code>インクリメント演算子</code>と<code>デクリメント演算子</code>はやや変わっている。この演算子には、オペランドの前に書く前置演算子(++i)と、後に書く後置演算子(i++)がある。</p>
<div class="sourceCode" id="cb769"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb769-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb769-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb769-3" data-line-number="3">    <span class="dt">int</span> i = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb769-4" data-line-number="4">    ++i ;</a>
<a class="sourceLine" id="cb769-5" data-line-number="5">    i++ ;</a>
<a class="sourceLine" id="cb769-6" data-line-number="6"></a>
<a class="sourceLine" id="cb769-7" data-line-number="7">    --i ;</a>
<a class="sourceLine" id="cb769-8" data-line-number="8">    i-- ;</a>
<a class="sourceLine" id="cb769-9" data-line-number="9">}</a></code></pre></div>
<p>前置演算子を評価すると、演算子を評価した後の値になる。</p>
<div class="sourceCode" id="cb770"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb770-1" data-line-number="1"><span class="dt">int</span> i = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb770-2" data-line-number="2">++i ;   <span class="co">// 1</span></a>
<a class="sourceLine" id="cb770-3" data-line-number="3">i ;     <span class="co">// 1</span></a></code></pre></div>
<p>一方、後置演算子を評価すると、演算子を評価する前の値になる。</p>
<div class="sourceCode" id="cb771"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb771-1" data-line-number="1"><span class="dt">int</span> i = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb771-2" data-line-number="2">i++ ;   <span class="co">// 0</span></a>
<a class="sourceLine" id="cb771-3" data-line-number="3">i ;     <span class="co">// 1</span></a></code></pre></div>
<p>さらに前置演算子を評価した結果はリファレンスになるので代入やさらなる演算子の適用ができる。</p>
<div class="sourceCode" id="cb772"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb772-1" data-line-number="1"><span class="dt">int</span> i = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb772-2" data-line-number="2">++i = <span class="dv">0</span> ;   <span class="co">// iは0</span></a>
<a class="sourceLine" id="cb772-3" data-line-number="3">++++i ;     <span class="co">// iは2</span></a>
<a class="sourceLine" id="cb772-4" data-line-number="4"></a>
<a class="sourceLine" id="cb772-5" data-line-number="5">i++ = <span class="dv">0</span> ;   <span class="co">// エラー</span></a>
<a class="sourceLine" id="cb772-6" data-line-number="6">i++++ ;     <span class="co">// エラー</span></a></code></pre></div>
<p>インクリメントとデクリメントの前置演算子は、単項演算子と同じ方法で書くことができる。</p>
<div class="sourceCode" id="cb773"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb773-1" data-line-number="1"><span class="kw">struct</span> IntLike { <span class="dt">int</span> data ; } ;</a>
<a class="sourceLine" id="cb773-2" data-line-number="2"></a>
<a class="sourceLine" id="cb773-3" data-line-number="3">IntLike &amp; <span class="kw">operator</span> ++( IntLike &amp; obj )</a>
<a class="sourceLine" id="cb773-4" data-line-number="4">{</a>
<a class="sourceLine" id="cb773-5" data-line-number="5">    ++obj.data ;</a>
<a class="sourceLine" id="cb773-6" data-line-number="6">    <span class="cf">return</span> obj ;</a>
<a class="sourceLine" id="cb773-7" data-line-number="7">}</a>
<a class="sourceLine" id="cb773-8" data-line-number="8">IntLike &amp; <span class="kw">operator</span> --( IntLike &amp; obj )</a>
<a class="sourceLine" id="cb773-9" data-line-number="9">{</a>
<a class="sourceLine" id="cb773-10" data-line-number="10">    --obj.data ;</a>
<a class="sourceLine" id="cb773-11" data-line-number="11">    <span class="cf">return</span> obj ;</a>
<a class="sourceLine" id="cb773-12" data-line-number="12">}</a></code></pre></div>
<p>引数を変更するのでconstではないリファレンスを使う。戻り値は引数をそのままリファレンスで返す。</p>
<p>もちろん、この実装はインクリメントとデクリメントの挙動を自然に再現したい場合の実装だ。以下のような挙動を実装することも可能だ。</p>
<div class="sourceCode" id="cb774"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb774-1" data-line-number="1"><span class="kw">struct</span> S { } ;</a>
<a class="sourceLine" id="cb774-2" data-line-number="2"></a>
<a class="sourceLine" id="cb774-3" data-line-number="3"><span class="dt">void</span> <span class="kw">operator</span> ++( S <span class="at">const</span> &amp; s )</a>
<a class="sourceLine" id="cb774-4" data-line-number="4">{</a>
<a class="sourceLine" id="cb774-5" data-line-number="5">    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;increment!</span><span class="sc">\n</span><span class="st">&quot;</span> ;</a>
<a class="sourceLine" id="cb774-6" data-line-number="6">}</a>
<a class="sourceLine" id="cb774-7" data-line-number="7"></a>
<a class="sourceLine" id="cb774-8" data-line-number="8"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb774-9" data-line-number="9">{</a>
<a class="sourceLine" id="cb774-10" data-line-number="10"></a>
<a class="sourceLine" id="cb774-11" data-line-number="11">    S s ;</a>
<a class="sourceLine" id="cb774-12" data-line-number="12">    ++s ;</a>
<a class="sourceLine" id="cb774-13" data-line-number="13">}</a></code></pre></div>
<p>演算子のオーバーロードは演算子の文法で関数を呼べるという機能で、その呼び出した結果の関数が何をしようとも自由だからだ。</p>
<p>後置演算子は少し変わっている。以下が後置演算子の実装だ。</p>
<div class="sourceCode" id="cb775"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb775-1" data-line-number="1"><span class="kw">struct</span> IntLike { <span class="dt">int</span> data ; } ;</a>
<a class="sourceLine" id="cb775-2" data-line-number="2"></a>
<a class="sourceLine" id="cb775-3" data-line-number="3">IntLike <span class="kw">operator</span> ++( IntLike &amp; obj, <span class="dt">int</span> )</a>
<a class="sourceLine" id="cb775-4" data-line-number="4">{</a>
<a class="sourceLine" id="cb775-5" data-line-number="5">    <span class="kw">auto</span> temp = obj ;</a>
<a class="sourceLine" id="cb775-6" data-line-number="6">    ++obj.data ;</a>
<a class="sourceLine" id="cb775-7" data-line-number="7">    <span class="cf">return</span> temp ;</a>
<a class="sourceLine" id="cb775-8" data-line-number="8">}</a>
<a class="sourceLine" id="cb775-9" data-line-number="9">IntLike <span class="kw">operator</span> --( IntLike &amp; obj, <span class="dt">int</span> )</a>
<a class="sourceLine" id="cb775-10" data-line-number="10">{</a>
<a class="sourceLine" id="cb775-11" data-line-number="11">    <span class="kw">auto</span> temp = obj ;</a>
<a class="sourceLine" id="cb775-12" data-line-number="12">    --obj.data ;</a>
<a class="sourceLine" id="cb775-13" data-line-number="13">    <span class="cf">return</span> temp ;</a>
<a class="sourceLine" id="cb775-14" data-line-number="14">}</a></code></pre></div>
<p>後置演算子は2つめの引数としてint型を取る。この引数はダミーで前置演算子と後置演算子を区別する以外の意味はない。意味はないので引数名は省略している。</p>
<div class="sourceCode" id="cb776"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb776-1" data-line-number="1"><span class="kw">struct</span> S { } ;</a>
<a class="sourceLine" id="cb776-2" data-line-number="2"></a>
<a class="sourceLine" id="cb776-3" data-line-number="3"><span class="co">// 前置演算子</span></a>
<a class="sourceLine" id="cb776-4" data-line-number="4"><span class="dt">void</span> <span class="kw">operator</span> ++( S ) ;</a>
<a class="sourceLine" id="cb776-5" data-line-number="5"><span class="co">// 後置演算子</span></a>
<a class="sourceLine" id="cb776-6" data-line-number="6"><span class="dt">void</span> <span class="kw">operator</span> ++( S, <span class="dt">int</span> ) ;</a></code></pre></div>
<p>後置演算子はオペランドである引数を変更するが、戻り値は変更する前の値だ。なので変更前の値をまずコピーしておき、そのコピーを返す。</p>
<h3 id="メンバー関数での演算子のオーバーロード">メンバー関数での演算子のオーバーロード</h3>
<p>実は演算子のオーバーロードはメンバー関数で書くことも可能だ。</p>
<p>例えば、</p>
<div class="sourceCode" id="cb777"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb777-1" data-line-number="1">S s ;</a>
<a class="sourceLine" id="cb777-2" data-line-number="2">s + s ;</a></code></pre></div>
<p>を可能にするクラスSに対する<code>operator +</code>は、</p>
<div class="sourceCode" id="cb778"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb778-1" data-line-number="1"><span class="kw">struct</span> S { }</a>
<a class="sourceLine" id="cb778-2" data-line-number="2">S <span class="kw">operator</span> + ( S <span class="at">const</span> &amp;, S <span class="at">const</span> &amp; ) ;</a></code></pre></div>
<p>でも実装できるが、メンバー関数としても実装できる。</p>
<div class="sourceCode" id="cb779"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb779-1" data-line-number="1"><span class="kw">struct</span> S</a>
<a class="sourceLine" id="cb779-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb779-3" data-line-number="3">    S <span class="kw">operator</span> +( S <span class="at">const</span> &amp; right )</a>
<a class="sourceLine" id="cb779-4" data-line-number="4">    {</a>
<a class="sourceLine" id="cb779-5" data-line-number="5">        <span class="cf">return</span> S{} ;</a>
<a class="sourceLine" id="cb779-6" data-line-number="6">    }</a>
<a class="sourceLine" id="cb779-7" data-line-number="7">} ;</a></code></pre></div>
<p>演算子のオーバーロードをメンバー関数で書く場合、最初のオペランドがメンバー関数の属するクラスのオブジェクト、2つめのオペランドが一つ目の引数になる。</p>
<div class="sourceCode" id="cb780"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb780-1" data-line-number="1"><span class="kw">struct</span> IntLike</a>
<a class="sourceLine" id="cb780-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb780-3" data-line-number="3">    <span class="dt">int</span> data ;</a>
<a class="sourceLine" id="cb780-4" data-line-number="4"></a>
<a class="sourceLine" id="cb780-5" data-line-number="5">    IntLike <span class="kw">operator</span> +( IntLike <span class="at">const</span> &amp; right )</a>
<a class="sourceLine" id="cb780-6" data-line-number="6">    {</a>
<a class="sourceLine" id="cb780-7" data-line-number="7">        <span class="cf">return</span> IntLike { data + right.data } ;</a>
<a class="sourceLine" id="cb780-8" data-line-number="8">    }</a>
<a class="sourceLine" id="cb780-9" data-line-number="9">} ;</a>
<a class="sourceLine" id="cb780-10" data-line-number="10"></a>
<a class="sourceLine" id="cb780-11" data-line-number="11"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb780-12" data-line-number="12">{</a>
<a class="sourceLine" id="cb780-13" data-line-number="13">    IntLike a(<span class="dv">1</span>) ;</a>
<a class="sourceLine" id="cb780-14" data-line-number="14">    IntLike b(<span class="dv">2</span>) ;</a>
<a class="sourceLine" id="cb780-15" data-line-number="15"></a>
<a class="sourceLine" id="cb780-16" data-line-number="16">    IntLike c = a + b ;</a>
<a class="sourceLine" id="cb780-17" data-line-number="17">}</a></code></pre></div>
<p>この場合、メンバー関数は変数aに対して呼ばれ、変数bが<code>right</code>となる。</p>
<p>普通のメンバー関数のように呼ぶこともできる。</p>
<div class="sourceCode" id="cb781"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb781-1" data-line-number="1">IntLike c = a.<span class="kw">operator</span> +( b ) ;</a></code></pre></div>
<p>一見戸惑うかも知れないが、これは普通のメンバー関数呼び出しと何ら変わらない。</p>
<div class="sourceCode" id="cb782"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb782-1" data-line-number="1"><span class="kw">struct</span> S</a>
<a class="sourceLine" id="cb782-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb782-3" data-line-number="3">    <span class="dt">void</span> plus( S <span class="at">const</span> &amp; other ) { }</a>
<a class="sourceLine" id="cb782-4" data-line-number="4">    <span class="dt">void</span> <span class="kw">operator</span> +( S <span class="at">const</span> &amp; other ) { }</a>
<a class="sourceLine" id="cb782-5" data-line-number="5">} ;</a>
<a class="sourceLine" id="cb782-6" data-line-number="6"></a>
<a class="sourceLine" id="cb782-7" data-line-number="7"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb782-8" data-line-number="8">{</a>
<a class="sourceLine" id="cb782-9" data-line-number="9">    S a ;</a>
<a class="sourceLine" id="cb782-10" data-line-number="10">    S b ;</a>
<a class="sourceLine" id="cb782-11" data-line-number="11"></a>
<a class="sourceLine" id="cb782-12" data-line-number="12">    <span class="co">// これはメンバー関数呼び出し</span></a>
<a class="sourceLine" id="cb782-13" data-line-number="13">    a.plus(b) ;</a>
<a class="sourceLine" id="cb782-14" data-line-number="14">    <span class="co">// これもメンバー関数呼び出し</span></a>
<a class="sourceLine" id="cb782-15" data-line-number="15">    a.<span class="kw">operator</span> +(b) ;</a>
<a class="sourceLine" id="cb782-16" data-line-number="16">    <span class="co">// 同じくメンバー関数呼び出し</span></a>
<a class="sourceLine" id="cb782-17" data-line-number="17">    a + b ;</a>
<a class="sourceLine" id="cb782-18" data-line-number="18">}</a></code></pre></div>
<p>演算子のオーバーロードはフリー関数とメンバー関数のどちらで実装すればいいのだろうか。答えはどちらでもよい。ただし、ごく一部の演算子はメンバー関数でしか実装できない。</p>
<p>こうして、この章の冒頭にある演算子を使った自然な四則演算の記述が、自作のクラスでも可能になる。</p>
<h1 id="stdarray">std::array</h1>
<p><code>std::vector&lt;T&gt;</code>を覚えているだろうか。T型の値をいくつでも保持できるクラスだ。</p>
<div class="sourceCode" id="cb783"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb783-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb783-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb783-3" data-line-number="3">    <span class="co">// int型の値を10個保持するクラス</span></a>
<a class="sourceLine" id="cb783-4" data-line-number="4">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v(<span class="dv">10</span>) ;</a>
<a class="sourceLine" id="cb783-5" data-line-number="5"></a>
<a class="sourceLine" id="cb783-6" data-line-number="6">    <span class="co">// 0番目の値を1に</span></a>
<a class="sourceLine" id="cb783-7" data-line-number="7">    v.at(<span class="dv">0</span>) = <span class="dv">1</span> ;</a>
<a class="sourceLine" id="cb783-8" data-line-number="8"></a>
<a class="sourceLine" id="cb783-9" data-line-number="9">    <span class="co">// イテレーターを取る</span></a>
<a class="sourceLine" id="cb783-10" data-line-number="10">    <span class="kw">auto</span> i = <span class="bu">std::</span>begin(v) ;</a>
<a class="sourceLine" id="cb783-11" data-line-number="11">}</a></code></pre></div>
<p>この章では、<code>vector</code>と似ているクラス、<code>std::array&lt;T, N&gt;</code>を学ぶ。<code>array</code>はT型の値をN個保持するクラスだ。</p>
<p>その使い方は一見<code>vector</code>と似ている。</p>
<div class="sourceCode" id="cb784"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb784-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb784-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb784-3" data-line-number="3">    <span class="co">// int型の値を10個保持するクラス</span></a>
<a class="sourceLine" id="cb784-4" data-line-number="4">    <span class="bu">std::</span>array&lt;<span class="dt">int</span>, <span class="dv">10</span>&gt; a ;</a>
<a class="sourceLine" id="cb784-5" data-line-number="5"></a>
<a class="sourceLine" id="cb784-6" data-line-number="6">    <span class="co">// 0番目の値を1に</span></a>
<a class="sourceLine" id="cb784-7" data-line-number="7">    a.at(<span class="dv">0</span>) = <span class="dv">1</span> ;</a>
<a class="sourceLine" id="cb784-8" data-line-number="8"></a>
<a class="sourceLine" id="cb784-9" data-line-number="9">    <span class="co">// イテレーターを取る</span></a>
<a class="sourceLine" id="cb784-10" data-line-number="10">    <span class="kw">auto</span> i = <span class="bu">std::</span>begin(a) ;</a>
<a class="sourceLine" id="cb784-11" data-line-number="11">}</a></code></pre></div>
<p><code>vector</code>と違う点は、コンパイル時に要素数が固定されるということだ。</p>
<p><code>vector</code>は実行時に要素数を決めることができる。</p>
<div class="sourceCode" id="cb785"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb785-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb785-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb785-3" data-line-number="3">    <span class="bu">std::</span>size_t N{} ;</a>
<a class="sourceLine" id="cb785-4" data-line-number="4">    <span class="bu">std::</span>cin &gt;&gt; N ;</a>
<a class="sourceLine" id="cb785-5" data-line-number="5"></a>
<a class="sourceLine" id="cb785-6" data-line-number="6">    <span class="co">// 要素数N</span></a>
<a class="sourceLine" id="cb785-7" data-line-number="7">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v(N) ;</a>
<a class="sourceLine" id="cb785-8" data-line-number="8">}</a></code></pre></div>
<p>一方、<code>array</code>はコンパイル時に要素数を決める。標準入力から得た値は実行時のものなので、使うことはできない。</p>
<div class="sourceCode" id="cb786"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb786-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb786-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb786-3" data-line-number="3">    <span class="bu">std::</span>size_T N{} ;</a>
<a class="sourceLine" id="cb786-4" data-line-number="4">    <span class="bu">std::</span>cin &gt;&gt; N ;</a>
<a class="sourceLine" id="cb786-5" data-line-number="5"></a>
<a class="sourceLine" id="cb786-6" data-line-number="6">    <span class="co">// エラー</span></a>
<a class="sourceLine" id="cb786-7" data-line-number="7">    <span class="bu">std::</span>array&lt; <span class="dt">int</span>, N &gt; a ;</a>
<a class="sourceLine" id="cb786-8" data-line-number="8">}</a></code></pre></div>
<p><code>vector</code>は実行時に要素数を変更することができる。メンバー関数<code>push_back</code>は要素数を1増やす。メンバー関数<code>resize(sz)</code>は要素数を<code>sz</code>にする。</p>
<div class="sourceCode" id="cb787"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb787-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb787-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb787-3" data-line-number="3">    <span class="co">// 要素数5</span></a>
<a class="sourceLine" id="cb787-4" data-line-number="4">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v(<span class="dv">5</span>) ;</a>
<a class="sourceLine" id="cb787-5" data-line-number="5">    <span class="co">// 要素数6</span></a>
<a class="sourceLine" id="cb787-6" data-line-number="6">    v.push_back(<span class="dv">1</span>) ;</a>
<a class="sourceLine" id="cb787-7" data-line-number="7">    <span class="co">// 要素数2</span></a>
<a class="sourceLine" id="cb787-8" data-line-number="8">    v.resize(<span class="dv">2</span>) ;</a>
<a class="sourceLine" id="cb787-9" data-line-number="9">}</a></code></pre></div>
<p><code>array</code>は<code>push_back</code>も<code>resize</code>も提供していない。</p>
<p><code>vector</code>も<code>array</code>もメンバー関数<code>at(i)</code>でi番目の要素にアクセスできる。実は、i番目にアクセスする方法は他にもある。<code>[i]</code>を使う方法だ。</p>
<div class="sourceCode" id="cb788"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb788-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb788-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb788-3" data-line-number="3">    <span class="bu">std::</span>array&lt;<span class="dt">int</span>, <span class="dv">10</span>&gt; a ;</a>
<a class="sourceLine" id="cb788-4" data-line-number="4"></a>
<a class="sourceLine" id="cb788-5" data-line-number="5">    <span class="co">// どちらも0番目の要素に1を代入</span></a>
<a class="sourceLine" id="cb788-6" data-line-number="6">    a.at(<span class="dv">0</span>) = <span class="dv">1</span> ;</a>
<a class="sourceLine" id="cb788-7" data-line-number="7">    a[<span class="dv">0</span>] = <span class="dv">1</span> ;</a>
<a class="sourceLine" id="cb788-8" data-line-number="8"></a>
<a class="sourceLine" id="cb788-9" data-line-number="9">    <span class="co">// どちらも0番目の要素を標準出力</span></a>
<a class="sourceLine" id="cb788-10" data-line-number="10">    <span class="bu">std::</span>cout &lt;&lt; a.at(<span class="dv">0</span>) ;</a>
<a class="sourceLine" id="cb788-11" data-line-number="11">    <span class="bu">std::</span>cout &lt;&lt; a[<span class="dv">0</span>] ;</a>
<a class="sourceLine" id="cb788-12" data-line-number="12">}</a></code></pre></div>
<p><code>at(i)</code>と<code>[i]</code>の違いは、要素の範囲外にアクセスしたときの挙動だ。<code>at(i)</code>はエラー処理が行われる。<code>[i]</code>は何が起こるかわからない。</p>
<div class="sourceCode" id="cb789"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb789-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb789-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb789-3" data-line-number="3">    <span class="co">// 10個の要素を持つ</span></a>
<a class="sourceLine" id="cb789-4" data-line-number="4">    <span class="co">// 0番目から9番目までが妥当な範囲</span></a>
<a class="sourceLine" id="cb789-5" data-line-number="5">    <span class="bu">std::</span>array&lt;<span class="dt">int</span>, <span class="dv">10</span>&gt; a ;</a>
<a class="sourceLine" id="cb789-6" data-line-number="6"></a>
<a class="sourceLine" id="cb789-7" data-line-number="7">    <span class="co">// エラー処理が行われる</span></a>
<a class="sourceLine" id="cb789-8" data-line-number="8">    <span class="co">// プログラムは終了する</span></a>
<a class="sourceLine" id="cb789-9" data-line-number="9">    a.at(<span class="dv">10</span>) = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb789-10" data-line-number="10">    <span class="co">// 何が起こるかわからない</span></a>
<a class="sourceLine" id="cb789-11" data-line-number="11">    a[<span class="dv">10</span>] = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb789-12" data-line-number="12">}</a></code></pre></div>
<p>この理由は、<code>[i]</code>は要素数が妥当な範囲かどうかを確認する処理を行っていないためだ。その分余計な処理が発生しないが、間違えたときに何が起こるかわからないという危険性がある。通常は<code>at(i)</code>を使うべきだ。</p>
<p>実はこの<code>[i]</code>は<code>operator []</code>というれっきとした演算子だ。演算子のオーバーロードもできる。例えば以下は任意個の要素を持ち、常にゼロを返すarrayのように振る舞う意味のないクラスだ。</p>
<div class="sourceCode" id="cb790"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb790-1" data-line-number="1"><span class="co">// 常にゼロを返すクラス</span></a>
<a class="sourceLine" id="cb790-2" data-line-number="2"><span class="co">// 何を書き込んでもゼロを返す</span></a>
<a class="sourceLine" id="cb790-3" data-line-number="3"><span class="kw">struct</span> null_array</a>
<a class="sourceLine" id="cb790-4" data-line-number="4">{</a>
<a class="sourceLine" id="cb790-5" data-line-number="5">    <span class="dt">int</span> dummy ;</a>
<a class="sourceLine" id="cb790-6" data-line-number="6">    <span class="co">// 引数は無視</span></a>
<a class="sourceLine" id="cb790-7" data-line-number="7">    <span class="dt">int</span> &amp; <span class="kw">operator</span> [] ( <span class="bu">std::</span>size_t )</a>
<a class="sourceLine" id="cb790-8" data-line-number="8">    {</a>
<a class="sourceLine" id="cb790-9" data-line-number="9">        dummy = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb790-10" data-line-number="10">        <span class="cf">return</span> dummy ;</a>
<a class="sourceLine" id="cb790-11" data-line-number="11">    }</a>
<a class="sourceLine" id="cb790-12" data-line-number="12">} ;</a>
<a class="sourceLine" id="cb790-13" data-line-number="13"></a>
<a class="sourceLine" id="cb790-14" data-line-number="14"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb790-15" data-line-number="15">{</a>
<a class="sourceLine" id="cb790-16" data-line-number="16">    null_array a ;</a>
<a class="sourceLine" id="cb790-17" data-line-number="17"></a>
<a class="sourceLine" id="cb790-18" data-line-number="18">    <span class="co">// 0</span></a>
<a class="sourceLine" id="cb790-19" data-line-number="19">    <span class="bu">std::</span>cout &lt;&lt; a[<span class="dv">0</span>] ;</a>
<a class="sourceLine" id="cb790-20" data-line-number="20">    <span class="co">// 0</span></a>
<a class="sourceLine" id="cb790-21" data-line-number="21">    <span class="bu">std::</span>cout &lt;&lt; a[<span class="dv">999</span>] ;</a>
<a class="sourceLine" id="cb790-22" data-line-number="22"></a>
<a class="sourceLine" id="cb790-23" data-line-number="23">    a[<span class="dv">100</span>] = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb790-24" data-line-number="24">    <span class="co">// 0</span></a>
<a class="sourceLine" id="cb790-25" data-line-number="25">    <span class="bu">std::</span>cout &lt;&lt; a[<span class="dv">100</span>] ;</a>
<a class="sourceLine" id="cb790-26" data-line-number="26">}</a></code></pre></div>
<p>なぜ<code>vector</code>という実行時に要素数を設定でき実行時に要素数を変更できる便利なクラスがありながら、<code>array</code>のようなコンパイル時に要素数が決め打ちで要素数の変更もできないようなクラスもあるのだろうか。その理由は<code>array</code>と<code>vector</code>はパフォーマンスの特性が異なるからだ。<code>vector</code>はストレージ(メモリー)の動的確保をしている。ストレージの動的確保は実行時の要素数を変更できるのだが、そのために予測不可能な非決定的なパフォーマンス特性を持つ。<code>array</code>はストレージの動的確保を行わない。この結果実行時に要素数を変更することはできないが、予測可能で決定的なパフォーマンス特性を持つ。</p>
<p>その他の<code>array</code>の使い方は、<code>vector</code>とほぼ同じだ。</p>
<p>さて、これから<code>array</code>を実装していこう。実装を通じて読者はC++のクラスとその他の機能を学んでいくことになる。</p>
<h1 id="プログラマーの三大美徳">プログラマーの三大美徳</h1>
<p>プログラミング言語Perlの作者、Larry Wallは著書「プログラミング言語Perl」の初版で以下のように宣言した。</p>
<blockquote>
<p>読者はプログラマーの三大美徳である、怠惰、短気、傲慢を会得すべきである。</p>
</blockquote>
<p>第二版の巻末の用語集では、以下のような定義が与えらた。</p>
<dl>
<dt>怠惰</dt>
<dd><p>プログラマーは労力を削減するための労力を惜しまないこと。怠惰のために書いたプログラムは他人にも便利であり、そしてドキュメントを書くことにより自ら他人の質問に答えずにすむようにすること。これがプログラマーの第一の美徳である。これが本書の書かれた理由である。</p>
</dd>
<dt>短気</dt>
<dd><p>コンピューターが怠惰であるときにプログラマーが感ずる怒り。短気によって書かれたプログラムは、単に労力を削減するばかりではなく、事前に解決しておく。少なくとも、すでに解決済みのように振る舞う。これがプログラマーの第二の美徳である。</p>
</dd>
<dt>傲慢</dt>
<dd><p>ゼウスも罰したもう過剰なまでの奢り。他人がそしりを入れられぬほどのプログラムを書く推進剤。これがプログラマーの第三の美徳である。</p>
</dd>
</dl>
<p>これから学ぶ<code>array</code>を実装するためのC++の機能を学ぶときに、このプログラマーの三大美徳のことを頭にいれておこう。</p>
<h1 id="配列">配列</h1>
<h2 id="ナイーブなarray実装">ナイーブなarray実装</h2>
<p><code>std::array</code>を実装してみよう。すでにクラスを作る方法については学んだ。</p>
<p><code>std::array&lt;T,N&gt;</code>はT型の要素をN個保持するクラスだ。この<code>&lt;T,N&gt;</code>についてはまだ学んでいないので、今回はint型を3個確保する。今までに学んだ要素だけで実装してみよう。</p>
<div class="sourceCode" id="cb791"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb791-1" data-line-number="1"><span class="kw">struct</span> array_int_3</a>
<a class="sourceLine" id="cb791-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb791-3" data-line-number="3">    <span class="dt">int</span> m0 ;</a>
<a class="sourceLine" id="cb791-4" data-line-number="4">    <span class="dt">int</span> m1 ;</a>
<a class="sourceLine" id="cb791-5" data-line-number="5">    <span class="dt">int</span> m2 ;</a>
<a class="sourceLine" id="cb791-6" data-line-number="6">} ;</a></code></pre></div>
<p>そして<code>operator []</code>を実装しよう。引数が0ならm0を、1ならm1を、2ならm2を返す。それ以外の値の場合、プログラムを強制的に終了させる標準ライブラリ、<code>std::abort</code>を呼び出す。</p>
<div class="sourceCode" id="cb792"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb792-1" data-line-number="1"><span class="kw">struct</span> array_int_3</a>
<a class="sourceLine" id="cb792-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb792-3" data-line-number="3">    <span class="dt">int</span> m0 ; <span class="dt">int</span> m1 ; <span class="dt">int</span> m2 ;</a>
<a class="sourceLine" id="cb792-4" data-line-number="4"></a>
<a class="sourceLine" id="cb792-5" data-line-number="5">    <span class="dt">int</span> &amp; <span class="kw">operator</span> []( <span class="bu">std::</span>size_t i )</a>
<a class="sourceLine" id="cb792-6" data-line-number="6">    {</a>
<a class="sourceLine" id="cb792-7" data-line-number="7">        <span class="cf">switch</span>(i)</a>
<a class="sourceLine" id="cb792-8" data-line-number="8">        {</a>
<a class="sourceLine" id="cb792-9" data-line-number="9">            <span class="cf">case</span> <span class="dv">0</span> :</a>
<a class="sourceLine" id="cb792-10" data-line-number="10">                <span class="cf">return</span> m0 ;</a>
<a class="sourceLine" id="cb792-11" data-line-number="11">            <span class="cf">case</span> <span class="dv">1</span> :</a>
<a class="sourceLine" id="cb792-12" data-line-number="12">                <span class="cf">return</span> m1 ;</a>
<a class="sourceLine" id="cb792-13" data-line-number="13">            <span class="cf">case</span> <span class="dv">2</span> :</a>
<a class="sourceLine" id="cb792-14" data-line-number="14">                <span class="cf">return</span> m2 ;</a>
<a class="sourceLine" id="cb792-15" data-line-number="15">            <span class="cf">default</span> :</a>
<a class="sourceLine" id="cb792-16" data-line-number="16">                <span class="co">// 間違った引数</span></a>
<a class="sourceLine" id="cb792-17" data-line-number="17">                <span class="co">// 強制終了</span></a>
<a class="sourceLine" id="cb792-18" data-line-number="18">                <span class="bu">std::</span>abort() ;</a>
<a class="sourceLine" id="cb792-19" data-line-number="19">        }</a>
<a class="sourceLine" id="cb792-20" data-line-number="20">    }</a>
<a class="sourceLine" id="cb792-21" data-line-number="21">} ;</a></code></pre></div>
<p>これは動く。では要素数を10個に増やした<code>array_int_10</code>はどうなるだろうか。要素数100個はどう書くのだろうか。この方法で実装するとソースコードが膨大になり、ソースコードを出力するソースコードを書かなければならなくなる。これは怠惰で短気なプログラマーには耐えられない作業だ。</p>
<h2 id="配列-1">配列</h2>
<p><code>std::array</code>を実装するには、<code>配列(array)</code>を使う。</p>
<p>int型の要素数10の配列aは以下のように書く。</p>
<div class="sourceCode" id="cb793"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb793-1" data-line-number="1"><span class="dt">int</span> a[<span class="dv">10</span>] ;</a></code></pre></div>
<p>double型の要素数5の配列bは以下のように書く。</p>
<div class="sourceCode" id="cb794"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb794-1" data-line-number="1"><span class="dt">double</span> b[<span class="dv">5</span>] ;</a></code></pre></div>
<p><code>配列</code>の要素数は<code>std::array&lt;T,N&gt;</code>のNと同じようにコンパイル時定数でなければならない。</p>
<div class="sourceCode" id="cb795"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb795-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb795-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb795-3" data-line-number="3">    <span class="bu">std::</span>size_t size ;</a>
<a class="sourceLine" id="cb795-4" data-line-number="4">    <span class="bu">std::</span>cin &gt;&gt; size ;</a>
<a class="sourceLine" id="cb795-5" data-line-number="5">    <span class="co">// エラー</span></a>
<a class="sourceLine" id="cb795-6" data-line-number="6">    <span class="dt">int</span> a[size] ;</a>
<a class="sourceLine" id="cb795-7" data-line-number="7">}</a></code></pre></div>
<p>配列は<code>={1,2,3}</code>のように初期化できる。</p>
<div class="sourceCode" id="cb796"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb796-1" data-line-number="1"><span class="dt">int</span> a[<span class="dv">5</span>] = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</a>
<a class="sourceLine" id="cb796-2" data-line-number="2"><span class="dt">double</span> b[<span class="dv">3</span>] = {<span class="fl">1.0</span>, <span class="fl">2.0</span>, <span class="fl">3.0</span> } ;</a></code></pre></div>
<p>配列の要素にアクセスするには<code>operator []</code>を使う</p>
<div class="sourceCode" id="cb797"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb797-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb797-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb797-3" data-line-number="3">    <span class="dt">int</span> a[<span class="dv">5</span>] = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</a>
<a class="sourceLine" id="cb797-4" data-line-number="4"></a>
<a class="sourceLine" id="cb797-5" data-line-number="5">    <span class="co">// 4</span></a>
<a class="sourceLine" id="cb797-6" data-line-number="6">    <span class="bu">std::</span>cout &lt;&lt; a[<span class="dv">3</span>] ;</a>
<a class="sourceLine" id="cb797-7" data-line-number="7"></a>
<a class="sourceLine" id="cb797-8" data-line-number="8">    a[<span class="dv">2</span>] = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb797-9" data-line-number="9">    <span class="co">// {1,2,0,4,5}</span></a>
<a class="sourceLine" id="cb797-10" data-line-number="10">}</a></code></pre></div>
<p>配列にはメンバー関数はない。<code>at(i)</code>や<code>size()</code>のような便利なメンバー関数はない。</p>
<p>配列のサイズは<code>sizeof</code>で取得できる。配列のサイズは配列の要素の型のサイズかけることの要素数のサイズになる。</p>
<div class="sourceCode" id="cb798"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb798-1" data-line-number="1"></a>
<a class="sourceLine" id="cb798-2" data-line-number="2"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb798-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb798-4" data-line-number="4">    <span class="kw">auto</span> print = [](<span class="kw">auto</span> s){ <span class="bu">std::</span>cout &lt;&lt; s &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ; } ;</a>
<a class="sourceLine" id="cb798-5" data-line-number="5">    <span class="dt">int</span> a[<span class="dv">5</span>] ;</a>
<a class="sourceLine" id="cb798-6" data-line-number="6">    print( <span class="kw">sizeof</span>(a) ) ;</a>
<a class="sourceLine" id="cb798-7" data-line-number="7">    print( <span class="kw">sizeof</span>(<span class="dt">int</span>) * <span class="dv">5</span> ) ;</a>
<a class="sourceLine" id="cb798-8" data-line-number="8"></a>
<a class="sourceLine" id="cb798-9" data-line-number="9">    <span class="dt">double</span> b [<span class="dv">5</span>] ;</a>
<a class="sourceLine" id="cb798-10" data-line-number="10">    print( <span class="kw">sizeof</span>(b) ) ;</a>
<a class="sourceLine" id="cb798-11" data-line-number="11">    print( <span class="kw">sizeof</span>(<span class="dt">double</span>) * <span class="dv">5</span> ) ;</a>
<a class="sourceLine" id="cb798-12" data-line-number="12">}</a></code></pre></div>
<p><code>sizeof</code>は型やオブジェクトのバイト数を取得するのに対し、<code>vector</code>や<code>array</code>のメンバー関数<code>size()</code>は要素数を取得する。この違いに注意すること。</p>
<div class="sourceCode" id="cb799"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb799-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb799-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb799-3" data-line-number="3">    <span class="kw">auto</span> print = [](<span class="kw">auto</span> s){ <span class="bu">std::</span>cout &lt;&lt; s &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ; } ;</a>
<a class="sourceLine" id="cb799-4" data-line-number="4">    <span class="bu">std::</span>array&lt;<span class="dt">int</span>, <span class="dv">5</span>&gt; a ;</a>
<a class="sourceLine" id="cb799-5" data-line-number="5"></a>
<a class="sourceLine" id="cb799-6" data-line-number="6">    <span class="co">// aのバイト数</span></a>
<a class="sourceLine" id="cb799-7" data-line-number="7">    print( <span class="kw">sizeof</span>(a) ) ;</a>
<a class="sourceLine" id="cb799-8" data-line-number="8">    <span class="co">// 要素数: 5</span></a>
<a class="sourceLine" id="cb799-9" data-line-number="9">    print( a.size() ) ;</a>
<a class="sourceLine" id="cb799-10" data-line-number="10"></a>
<a class="sourceLine" id="cb799-11" data-line-number="11">}</a></code></pre></div>
<p><code>配列</code>はとても低級な機能だ。その実装はある型を連続してストレージ上に並べたものになっている。</p>
<div class="sourceCode" id="cb800"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb800-1" data-line-number="1"><span class="dt">int</span> a[<span class="dv">5</span>] ;</a></code></pre></div>
<p>のような配列があり、int型が4バイトの環境では、20バイトのストレージが確保され、その先頭の4バイトが最初の0番目の要素に、その次の4バイトが1番目の要素になる。最後の4番目の要素は最後の4バイトになる。</p>
<pre><code>配列のストレージ上のイメージ図

□一つが1バイトのストレージ
     1番目のint
    |--|
□□□□□□□□□□□□□□□□□□□□
|--|            |--|
 0番目のint       4番目のint</code></pre>
<p>配列にはメンバー関数がない上、コピーもできない。<code>std::array</code>はコピーできる。</p>
<div class="sourceCode" id="cb802"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb802-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb802-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb802-3" data-line-number="3">    <span class="dt">int</span> a[<span class="dv">5</span>] = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</a>
<a class="sourceLine" id="cb802-4" data-line-number="4">    <span class="co">// エラー、コピーできない</span></a>
<a class="sourceLine" id="cb802-5" data-line-number="5">    <span class="dt">int</span> b[<span class="dv">5</span>] = a ;</a>
<a class="sourceLine" id="cb802-6" data-line-number="6"></a>
<a class="sourceLine" id="cb802-7" data-line-number="7">    <span class="bu">std::</span>array&lt;<span class="dt">int</span>, <span class="dv">5</span>&gt; c = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</a>
<a class="sourceLine" id="cb802-8" data-line-number="8">    <span class="co">// OK、コピーできる</span></a>
<a class="sourceLine" id="cb802-9" data-line-number="9">    <span class="bu">std::</span>array&lt;<span class="dt">int</span>, <span class="dv">5</span>&gt; d = c ;</a>
<a class="sourceLine" id="cb802-10" data-line-number="10">}</a></code></pre></div>
<p><code>配列</code>は低級で使いにくいので、<code>std::array</code>という配列をラップした高級なライブラリが標準で用意されている。</p>
<p>さて、配列の使い方は覚えたので、さっそく<code>std::array_int_10</code>を実装してみよう。</p>
<p>まずクラスのデータメンバーとして配列を宣言する。</p>
<div class="sourceCode" id="cb803"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb803-1" data-line-number="1"><span class="kw">struct</span> array_int_10</a>
<a class="sourceLine" id="cb803-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb803-3" data-line-number="3">    <span class="dt">int</span> storage[<span class="dv">10</span>] ;</a>
<a class="sourceLine" id="cb803-4" data-line-number="4">} ;</a></code></pre></div>
<p>配列はコピーできないが、クラスのデータメンバーとして宣言した配列は、クラスのコピーの際に、その対応する順番の要素がそれぞれコピーされる。</p>
<div class="sourceCode" id="cb804"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb804-1" data-line-number="1"><span class="kw">struct</span> array_int_3 { <span class="dt">int</span> storage [<span class="dv">3</span>] ; } ;</a>
<a class="sourceLine" id="cb804-2" data-line-number="2"></a>
<a class="sourceLine" id="cb804-3" data-line-number="3"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb804-4" data-line-number="4">{</a>
<a class="sourceLine" id="cb804-5" data-line-number="5">    array_int_10 a = { <span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">2</span> } ;</a>
<a class="sourceLine" id="cb804-6" data-line-number="6"></a>
<a class="sourceLine" id="cb804-7" data-line-number="7">    array_int_10 b = a ;</a>
<a class="sourceLine" id="cb804-8" data-line-number="8">    <span class="co">// b.storage[0] == a.storage[0] </span></a>
<a class="sourceLine" id="cb804-9" data-line-number="9">    <span class="co">// b.storage[1] == a.storage[1] </span></a>
<a class="sourceLine" id="cb804-10" data-line-number="10">    <span class="co">// b.storage[2] == a.storage[2] </span></a>
<a class="sourceLine" id="cb804-11" data-line-number="11">}</a></code></pre></div>
<p>これはあたかも以下のように書いたかのように動く。</p>
<div class="sourceCode" id="cb805"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb805-1" data-line-number="1"><span class="kw">struct</span> array_int_3</a>
<a class="sourceLine" id="cb805-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb805-3" data-line-number="3">    <span class="dt">int</span> storage[<span class="dv">3</span>] ;</a>
<a class="sourceLine" id="cb805-4" data-line-number="4"></a>
<a class="sourceLine" id="cb805-5" data-line-number="5">    array_int_3( array_int_3 <span class="at">const</span> &amp; other )</a>
<a class="sourceLine" id="cb805-6" data-line-number="6">    {</a>
<a class="sourceLine" id="cb805-7" data-line-number="7">        <span class="bu">std::</span>copy(</a>
<a class="sourceLine" id="cb805-8" data-line-number="8">            <span class="bu">std::</span>begin(other.storage), <span class="bu">std::</span>end(other.storage),</a>
<a class="sourceLine" id="cb805-9" data-line-number="9">            <span class="bu">std::</span>begin(storage)</a>
<a class="sourceLine" id="cb805-10" data-line-number="10">        ) ;</a>
<a class="sourceLine" id="cb805-11" data-line-number="11"></a>
<a class="sourceLine" id="cb805-12" data-line-number="12"></a>
<a class="sourceLine" id="cb805-13" data-line-number="13">    }</a>
<a class="sourceLine" id="cb805-14" data-line-number="14">}</a></code></pre></div>
<p><code>operator []</code>も実装しよう。</p>
<div class="sourceCode" id="cb806"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb806-1" data-line-number="1"><span class="kw">struct</span> array_int_10</a>
<a class="sourceLine" id="cb806-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb806-3" data-line-number="3">    <span class="dt">int</span> storage[<span class="dv">10</span>] ;</a>
<a class="sourceLine" id="cb806-4" data-line-number="4"></a>
<a class="sourceLine" id="cb806-5" data-line-number="5">    <span class="dt">int</span> &amp; <span class="kw">operator</span> [] ( <span class="bu">std::</span>size_t i )</a>
<a class="sourceLine" id="cb806-6" data-line-number="6">    {</a>
<a class="sourceLine" id="cb806-7" data-line-number="7">        <span class="cf">return</span> storage[i] ;</a>
<a class="sourceLine" id="cb806-8" data-line-number="8">    }</a>
<a class="sourceLine" id="cb806-9" data-line-number="9">} ;</a>
<a class="sourceLine" id="cb806-10" data-line-number="10"></a>
<a class="sourceLine" id="cb806-11" data-line-number="11"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb806-12" data-line-number="12">{</a>
<a class="sourceLine" id="cb806-13" data-line-number="13">    array_int_10 a = {<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>} ;</a>
<a class="sourceLine" id="cb806-14" data-line-number="14">    a[<span class="dv">3</span>] = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb806-15" data-line-number="15">    <span class="bu">std::</span>cout &lt;&lt; a[<span class="dv">6</span>] ;</a>
<a class="sourceLine" id="cb806-16" data-line-number="16">}</a></code></pre></div>
<p><code>std::array</code>にはまだ様々なメンバーがある。一つづつ順番に学んでいこう。</p>
<h1 id="テンプレート">テンプレート</h1>
<h2 id="問題点">問題点</h2>
<p>前回、我々は’std::array’のようなものを実装した。C++を何も知らなかった我々がとうとうクールなキッズは皆やっているというクラスを書くことができた。素晴らしい成果だ。</p>
<p>しかし、我々の書いた’array_int_10’は’std::array’とは異なる。</p>
<div class="sourceCode" id="cb807"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb807-1" data-line-number="1"><span class="co">// 標準ライブラリ</span></a>
<a class="sourceLine" id="cb807-2" data-line-number="2"><span class="bu">std::</span>array&lt;<span class="dt">int</span>, <span class="dv">10</span>&gt; a ;</a>
<a class="sourceLine" id="cb807-3" data-line-number="3"><span class="co">// 我々のクラス</span></a>
<a class="sourceLine" id="cb807-4" data-line-number="4">array_int_10 a ;</a></code></pre></div>
<p>もし要素数を20個にしたければ<code>array_int_20</code>を新たに書かなければならない。すると<code>array_int_1</code>とか<code>array_int_10000</code>のようなクラスを無数に書かなければならないのだろうか。要素の型をdoubleにしたければ<code>array_double_10</code>が必要だ。</p>
<p>しかし、そのようなクラスはほとんど同じような退屈な記述の羅列になる。</p>
<div class="sourceCode" id="cb808"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb808-1" data-line-number="1"><span class="kw">struct</span> array_int_1</a>
<a class="sourceLine" id="cb808-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb808-3" data-line-number="3">    <span class="dt">int</span> storage[<span class="dv">1</span>] ;</a>
<a class="sourceLine" id="cb808-4" data-line-number="4">    <span class="dt">int</span> &amp; <span class="kw">operator</span> []( <span class="bu">std::</span>size_t i )</a>
<a class="sourceLine" id="cb808-5" data-line-number="5">    { <span class="cf">return</span> storage[i] ; }</a>
<a class="sourceLine" id="cb808-6" data-line-number="6">} ;</a>
<a class="sourceLine" id="cb808-7" data-line-number="7"></a>
<a class="sourceLine" id="cb808-8" data-line-number="8"><span class="co">// array_int_2, array_int_3, ...</span></a>
<a class="sourceLine" id="cb808-9" data-line-number="9"></a>
<a class="sourceLine" id="cb808-10" data-line-number="10"><span class="kw">struct</span> array_int_10000</a>
<a class="sourceLine" id="cb808-11" data-line-number="11">{</a>
<a class="sourceLine" id="cb808-12" data-line-number="12">    <span class="dt">int</span> storage[<span class="dv">10000</span>] ;</a>
<a class="sourceLine" id="cb808-13" data-line-number="13">    <span class="dt">int</span> &amp; <span class="kw">operator</span> []( <span class="bu">std::</span>size_t i )</a>
<a class="sourceLine" id="cb808-14" data-line-number="14">    { <span class="cf">return</span> storage[i] ; }</a>
<a class="sourceLine" id="cb808-15" data-line-number="15">} ;</a>
<a class="sourceLine" id="cb808-16" data-line-number="16"></a>
<a class="sourceLine" id="cb808-17" data-line-number="17"><span class="kw">struct</span> array_double_1</a>
<a class="sourceLine" id="cb808-18" data-line-number="18">{</a>
<a class="sourceLine" id="cb808-19" data-line-number="19">    <span class="dt">double</span> storage[<span class="dv">1</span>] ;</a>
<a class="sourceLine" id="cb808-20" data-line-number="20">    <span class="dt">double</span> &amp; <span class="kw">operator</span> []( <span class="bu">std::</span>size_t i )</a>
<a class="sourceLine" id="cb808-21" data-line-number="21">    { <span class="cf">return</span> storage[i] ; }</a>
<a class="sourceLine" id="cb808-22" data-line-number="22">}</a>
<a class="sourceLine" id="cb808-23" data-line-number="23"></a>
<a class="sourceLine" id="cb808-24" data-line-number="24"><span class="co">// array_double_2, array_double_3, ...</span></a></code></pre></div>
<p>これは怠惰で短気なプログラマーには耐えられない作業だ。C++にはこのような退屈なコードを書かなくてもすむ機能がある。しかしその前に、引数について考えてみよう。</p>
<h2 id="関数の引数">関数の引数</h2>
<p>1を2倍する関数を考えよう。</p>
<div class="sourceCode" id="cb809"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb809-1" data-line-number="1"><span class="dt">int</span> one_twice()</a>
<a class="sourceLine" id="cb809-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb809-3" data-line-number="3">    <span class="cf">return</span> <span class="dv">1</span> * <span class="dv">2</span> ;</a>
<a class="sourceLine" id="cb809-4" data-line-number="4">}</a></code></pre></div>
<p>上出来だ。では2を2倍する関数を考えよう。</p>
<div class="sourceCode" id="cb810"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb810-1" data-line-number="1"><span class="dt">int</span> two_twice()</a>
<a class="sourceLine" id="cb810-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb810-3" data-line-number="3">    <span class="cf">return</span> <span class="dv">2</span> * <span class="dv">2</span> ;</a>
<a class="sourceLine" id="cb810-4" data-line-number="4">}</a></code></pre></div>
<p>すばらしい。では3を2倍する関数、4を2倍する関数…と考えていこう。</p>
<p>ここまで読んでthree_twiceやfour_twiceを思い浮かべた読者にはプログラマーに備わるべき美徳が欠けている。怠惰で短気で傲慢なプログラマーはそんなコードを書かない。引数を使う。</p>
<div class="sourceCode" id="cb811"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb811-1" data-line-number="1"><span class="dt">int</span> twice( <span class="dt">int</span> n )</a>
<a class="sourceLine" id="cb811-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb811-3" data-line-number="3">    <span class="cf">return</span> n * <span class="dv">2</span> ;</a>
<a class="sourceLine" id="cb811-4" data-line-number="4">}</a></code></pre></div>
<p>具体的な値を2倍する関数を値の数だけ書くのは面倒だ。具体的な値は定めず、引数で外部から受け取る。そして引数を2倍して返す。引数は汎用的なコードを任意の値に対して対応させるための機能だ。</p>
<h2 id="関数のテンプレート引数">関数のテンプレート引数</h2>
<p>twiceを様々な型に対応させるにはどうすればいいだろう。例えばint型とdouble型に対応させてみよう。</p>
<div class="sourceCode" id="cb812"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb812-1" data-line-number="1"><span class="dt">int</span> twice( <span class="dt">int</span> n )</a>
<a class="sourceLine" id="cb812-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb812-3" data-line-number="3">    <span class="cf">return</span> n * <span class="dv">2</span> ;</a>
<a class="sourceLine" id="cb812-4" data-line-number="4">}</a>
<a class="sourceLine" id="cb812-5" data-line-number="5"></a>
<a class="sourceLine" id="cb812-6" data-line-number="6"><span class="dt">double</span> twice( <span class="dt">double</span> n )</a>
<a class="sourceLine" id="cb812-7" data-line-number="7">{</a>
<a class="sourceLine" id="cb812-8" data-line-number="8">    <span class="cf">return</span> n * <span class="fl">2.0</span> ;</a>
<a class="sourceLine" id="cb812-9" data-line-number="9">}</a></code></pre></div>
<p>整数型にはintの他にも、short, long, long longといった型がある。浮動小数点数型にはfloatとlong doubleもある。ということは以下のような関数も必要だ。</p>
<div class="sourceCode" id="cb813"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb813-1" data-line-number="1"><span class="dt">short</span> twice( <span class="dt">short</span> n )</a>
<a class="sourceLine" id="cb813-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb813-3" data-line-number="3">    <span class="cf">return</span> n * <span class="dv">2</span> ;</a>
<a class="sourceLine" id="cb813-4" data-line-number="4">}</a>
<a class="sourceLine" id="cb813-5" data-line-number="5"></a>
<a class="sourceLine" id="cb813-6" data-line-number="6"><span class="dt">long</span> twice( <span class="dt">long</span> n )</a>
<a class="sourceLine" id="cb813-7" data-line-number="7">{</a>
<a class="sourceLine" id="cb813-8" data-line-number="8">    <span class="cf">return</span> n * <span class="dv">2</span> ;</a>
<a class="sourceLine" id="cb813-9" data-line-number="9">}</a>
<a class="sourceLine" id="cb813-10" data-line-number="10"></a>
<a class="sourceLine" id="cb813-11" data-line-number="11"><span class="dt">long</span> <span class="dt">long</span> twice( <span class="dt">long</span> <span class="dt">long</span> n )</a>
<a class="sourceLine" id="cb813-12" data-line-number="12">{</a>
<a class="sourceLine" id="cb813-13" data-line-number="13">    <span class="cf">return</span> n * <span class="dv">2</span> ;</a>
<a class="sourceLine" id="cb813-14" data-line-number="14">}</a>
<a class="sourceLine" id="cb813-15" data-line-number="15"></a>
<a class="sourceLine" id="cb813-16" data-line-number="16"><span class="dt">float</span> twice( <span class="dt">float</span> n )</a>
<a class="sourceLine" id="cb813-17" data-line-number="17">{</a>
<a class="sourceLine" id="cb813-18" data-line-number="18">    <span class="cf">return</span> n * <span class="dv">2</span> ;</a>
<a class="sourceLine" id="cb813-19" data-line-number="19">}</a>
<a class="sourceLine" id="cb813-20" data-line-number="20"></a>
<a class="sourceLine" id="cb813-21" data-line-number="21"><span class="dt">long</span> <span class="dt">double</span> twice( <span class="dt">long</span> <span class="dt">double</span> n )</a>
<a class="sourceLine" id="cb813-22" data-line-number="22">{</a>
<a class="sourceLine" id="cb813-23" data-line-number="23">    <span class="cf">return</span> n * <span class="dv">2</span> ;</a>
<a class="sourceLine" id="cb813-24" data-line-number="24">}</a></code></pre></div>
<p>ところで、整数型には符号付きと符号なしの2種類があるということは覚えているだろうか？</p>
<div class="sourceCode" id="cb814"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb814-1" data-line-number="1"><span class="dt">int</span> twice( <span class="dt">int</span> n )</a>
<a class="sourceLine" id="cb814-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb814-3" data-line-number="3">    <span class="cf">return</span> n * <span class="dv">2</span> ;</a>
<a class="sourceLine" id="cb814-4" data-line-number="4">}</a>
<a class="sourceLine" id="cb814-5" data-line-number="5"></a>
<a class="sourceLine" id="cb814-6" data-line-number="6"><span class="dt">unsigned</span> <span class="dt">int</span> twice( <span class="dt">unsigned</span> <span class="dt">int</span> n )</a>
<a class="sourceLine" id="cb814-7" data-line-number="7">{</a>
<a class="sourceLine" id="cb814-8" data-line-number="8">    <span class="cf">return</span> n * <span class="dv">2</span> ;</a>
<a class="sourceLine" id="cb814-9" data-line-number="9">}</a>
<a class="sourceLine" id="cb814-10" data-line-number="10"></a>
<a class="sourceLine" id="cb814-11" data-line-number="11"><span class="co">// short, long, long longに対しても同様</span></a></code></pre></div>
<p>C++ではユーザーが整数型のように振る舞うクラスを作ることができる。整数型を複数使って巨大な整数を表現できるクラスも作ることができる。</p>
<div class="sourceCode" id="cb815"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb815-1" data-line-number="1"><span class="co">// 多倍長整数クラス</span></a>
<a class="sourceLine" id="cb815-2" data-line-number="2"><span class="co">// unsigned long longが256個分の整数の実装</span></a>
<a class="sourceLine" id="cb815-3" data-line-number="3"><span class="kw">struct</span> bigint</a>
<a class="sourceLine" id="cb815-4" data-line-number="4">{</a>
<a class="sourceLine" id="cb815-5" data-line-number="5">    <span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span> storage[<span class="dv">256</span>] ;</a>
<a class="sourceLine" id="cb815-6" data-line-number="6">} ;</a>
<a class="sourceLine" id="cb815-7" data-line-number="7"></a>
<a class="sourceLine" id="cb815-8" data-line-number="8">bigint <span class="kw">operator</span> * ( bigint <span class="at">const</span> &amp; right, <span class="dt">int</span> )</a>
<a class="sourceLine" id="cb815-9" data-line-number="9">{</a>
<a class="sourceLine" id="cb815-10" data-line-number="10">    <span class="cf">return</span> <span class="co">// 実装</span></a>
<a class="sourceLine" id="cb815-11" data-line-number="11">}</a></code></pre></div>
<p>このクラスに対応するには当然、以下のように書かなければならない。</p>
<div class="sourceCode" id="cb816"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb816-1" data-line-number="1">bigint twice( bigint n )</a>
<a class="sourceLine" id="cb816-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb816-3" data-line-number="3">    <span class="cf">return</span> n * <span class="dv">2</span> ;</a>
<a class="sourceLine" id="cb816-4" data-line-number="4">}</a></code></pre></div>
<p>そろそろ怠惰と短気を美徳とするプログラマー読者は耐えられなくなってきただろう。これまでのコードは、単にある型Tに対して、</p>
<div class="sourceCode" id="cb817"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb817-1" data-line-number="1">T twice( T n )</a>
<a class="sourceLine" id="cb817-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb817-3" data-line-number="3">    <span class="cf">return</span> n * <span class="dv">2</span> ;</a>
<a class="sourceLine" id="cb817-4" data-line-number="4">}</a></code></pre></div>
<p>と書いているだけだ。型Tがコピーと<code>operator *(T, int)</code>に対応していればいい。型Tの具体的な型について知る必要はない。</p>
<p>関数が具体的な値を知らなくても引数によって汎用的なコードをかけるように、具体的な型を知らなくても汎用的なコードを書けるようになりたい。その怠惰と短気に答えるのが<code>テンプレート</code>だ。</p>
<h2 id="テンプレート-1">テンプレート</h2>
<p>通常の関数が値を引数に取ることができるように、テンプレートは型を引数に取ることができる。</p>
<p>テンプレートは以下のように宣言する</p>
<div class="sourceCode" id="cb818"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb818-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;</a>
<a class="sourceLine" id="cb818-2" data-line-number="2">    宣言 </a></code></pre></div>
<p>テンプレートを関数に使う<code>関数テンプレート</code>は以下のように書く。</p>
<div class="sourceCode" id="cb819"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb819-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;</a>
<a class="sourceLine" id="cb819-2" data-line-number="2">T twice( T n )</a>
<a class="sourceLine" id="cb819-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb819-4" data-line-number="4">    <span class="cf">return</span> n * <span class="dv">2</span> ;</a>
<a class="sourceLine" id="cb819-5" data-line-number="5">}</a>
<a class="sourceLine" id="cb819-6" data-line-number="6"></a>
<a class="sourceLine" id="cb819-7" data-line-number="7"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb819-8" data-line-number="8">{</a>
<a class="sourceLine" id="cb819-9" data-line-number="9">    twice( <span class="dv">123</span> ) ;  <span class="co">// int</span></a>
<a class="sourceLine" id="cb819-10" data-line-number="10">    twice( <span class="fl">1.23</span> ) ; <span class="co">// double </span></a>
<a class="sourceLine" id="cb819-11" data-line-number="11">}</a></code></pre></div>
<p><code>template &lt; typename T &gt;</code>は型<code>T</code>を<code>テンプレート引数</code>に取る。テンプレートを使った宣言の中では、<code>T</code>が型として扱える。</p>
<div class="sourceCode" id="cb820"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb820-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;</a>
<a class="sourceLine" id="cb820-2" data-line-number="2">T f( T n )</a>
<a class="sourceLine" id="cb820-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb820-4" data-line-number="4">    T x = n ;</a>
<a class="sourceLine" id="cb820-5" data-line-number="5">}</a></code></pre></div>
<p><code>関数</code>が<code>引数</code>をとるように、<code>テンプレート</code>は<code>テンプレート引数</code>を取る。</p>
<div class="sourceCode" id="cb821"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb821-1" data-line-number="1"><span class="co">// テンプレートはテンプレート引数template_parameterを取る</span></a>
<a class="sourceLine" id="cb821-2" data-line-number="2"><span class="kw">template</span> &lt; <span class="kw">typename</span> template_parameter &gt;</a>
<a class="sourceLine" id="cb821-3" data-line-number="3"><span class="co">// 関数は引数function_parameterを取る</span></a>
<a class="sourceLine" id="cb821-4" data-line-number="4"><span class="co">// 引数の型はtemplate_parameter</span></a>
<a class="sourceLine" id="cb821-5" data-line-number="5"><span class="dt">void</span> f( template_parameter function_parameter )</a>
<a class="sourceLine" id="cb821-6" data-line-number="6">{</a>
<a class="sourceLine" id="cb821-7" data-line-number="7">}</a></code></pre></div>
<p><code>テンプレート</code>が「使われる」ときに、<code>テンプレート引数</code>に対する具体的な型が決定する。</p>
<div class="sourceCode" id="cb822"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb822-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;</a>
<a class="sourceLine" id="cb822-2" data-line-number="2"><span class="dt">void</span> f( T <span class="at">const</span> &amp; x )</a>
<a class="sourceLine" id="cb822-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb822-4" data-line-number="4">    <span class="bu">std::</span>cout &lt;&lt; x ;</a>
<a class="sourceLine" id="cb822-5" data-line-number="5">}</a>
<a class="sourceLine" id="cb822-6" data-line-number="6"></a>
<a class="sourceLine" id="cb822-7" data-line-number="7"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb822-8" data-line-number="8">{</a>
<a class="sourceLine" id="cb822-9" data-line-number="9">    <span class="co">// Tはint</span></a>
<a class="sourceLine" id="cb822-10" data-line-number="10">    f( <span class="dv">0</span> ) ;</a>
<a class="sourceLine" id="cb822-11" data-line-number="11">    <span class="co">// Tはdouble</span></a>
<a class="sourceLine" id="cb822-12" data-line-number="12">    f( <span class="fl">0.0</span> ) ;</a>
<a class="sourceLine" id="cb822-13" data-line-number="13">    <span class="co">// Tはstd::string</span></a>
<a class="sourceLine" id="cb822-14" data-line-number="14">    f( <span class="st">&quot;hello&quot;</span>s ) ;</a>
<a class="sourceLine" id="cb822-15" data-line-number="15">}</a></code></pre></div>
<p><code>テンプレート</code>を使うときに自動で<code>テンプレート引数</code>を推定してくれるが、<code>&lt;T&gt;</code>を使うことで明示的に<code>テンプレート引数</code>をT型に指定することもできる。</p>
<div class="sourceCode" id="cb823"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb823-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;</a>
<a class="sourceLine" id="cb823-2" data-line-number="2"><span class="dt">void</span> f( T <span class="at">const</span> &amp; x )</a>
<a class="sourceLine" id="cb823-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb823-4" data-line-number="4">    <span class="bu">std::</span>cout &lt;&lt; x ;</a>
<a class="sourceLine" id="cb823-5" data-line-number="5">}</a>
<a class="sourceLine" id="cb823-6" data-line-number="6"></a>
<a class="sourceLine" id="cb823-7" data-line-number="7"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb823-8" data-line-number="8">{</a>
<a class="sourceLine" id="cb823-9" data-line-number="9">    <span class="co">// Tはint</span></a>
<a class="sourceLine" id="cb823-10" data-line-number="10">    f&lt;<span class="dt">int</span>&gt;(<span class="dv">0</span>) ;</a>
<a class="sourceLine" id="cb823-11" data-line-number="11"></a>
<a class="sourceLine" id="cb823-12" data-line-number="12">    <span class="co">// Tはdouble</span></a>
<a class="sourceLine" id="cb823-13" data-line-number="13">    <span class="co">// int型0からdouble型0.0への変換が行われる</span></a>
<a class="sourceLine" id="cb823-14" data-line-number="14">    f&lt;<span class="dt">double</span>&gt;( <span class="dv">0</span> ) ;</a>
<a class="sourceLine" id="cb823-15" data-line-number="15">}</a></code></pre></div>
<p><code>テンプレート引数</code>は型ではなく整数型の値を渡すこともできる。</p>
<div class="sourceCode" id="cb824"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb824-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="dt">int</span> N &gt;</a>
<a class="sourceLine" id="cb824-2" data-line-number="2"><span class="dt">void</span> f()</a>
<a class="sourceLine" id="cb824-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb824-4" data-line-number="4">    <span class="bu">std::</span>cout &lt;&lt; N ;</a>
<a class="sourceLine" id="cb824-5" data-line-number="5">}</a>
<a class="sourceLine" id="cb824-6" data-line-number="6"></a>
<a class="sourceLine" id="cb824-7" data-line-number="7"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb824-8" data-line-number="8">{</a>
<a class="sourceLine" id="cb824-9" data-line-number="9">    <span class="co">// Nは0</span></a>
<a class="sourceLine" id="cb824-10" data-line-number="10">    f&lt;<span class="dv">0</span>&gt;() ;</a>
<a class="sourceLine" id="cb824-11" data-line-number="11">    <span class="co">// Nは123</span></a>
<a class="sourceLine" id="cb824-12" data-line-number="12">    f&lt;<span class="dv">123</span>&gt;() ;</a>
<a class="sourceLine" id="cb824-13" data-line-number="13">}</a></code></pre></div>
<p>ただし、<code>テンプレート引数</code>はコンパイル時にすべてが決定される。なので<code>テンプレート引数</code>に渡せる値はコンパイル時に決定できるものでなければならない。</p>
<div class="sourceCode" id="cb825"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb825-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="dt">int</span> N &gt;</a>
<a class="sourceLine" id="cb825-2" data-line-number="2"><span class="dt">void</span> f() { }</a>
<a class="sourceLine" id="cb825-3" data-line-number="3"></a>
<a class="sourceLine" id="cb825-4" data-line-number="4"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb825-5" data-line-number="5">{</a>
<a class="sourceLine" id="cb825-6" data-line-number="6">    <span class="co">// OK</span></a>
<a class="sourceLine" id="cb825-7" data-line-number="7">    f&lt;<span class="dv">1+1</span>&gt;() ;</a>
<a class="sourceLine" id="cb825-8" data-line-number="8"></a>
<a class="sourceLine" id="cb825-9" data-line-number="9">    <span class="dt">int</span> x{} ;</a>
<a class="sourceLine" id="cb825-10" data-line-number="10">    <span class="bu">std::</span>cin &gt;&gt; x ;</a>
<a class="sourceLine" id="cb825-11" data-line-number="11">    <span class="co">// エラー</span></a>
<a class="sourceLine" id="cb825-12" data-line-number="12">    f&lt;x&gt;() ;</a>
<a class="sourceLine" id="cb825-13" data-line-number="13">}</a></code></pre></div>
<p><code>テンプレート引数</code>がコンパイル時に決定されるということは、配列のサイズのようなコンパイル時に決定されなければならない場面でも使えるということだ。</p>
<div class="sourceCode" id="cb826"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb826-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="bu">std::</span>size_t N &gt;</a>
<a class="sourceLine" id="cb826-2" data-line-number="2"><span class="dt">void</span> f()</a>
<a class="sourceLine" id="cb826-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb826-4" data-line-number="4">    <span class="dt">int</span> buffer[N] ;</a>
<a class="sourceLine" id="cb826-5" data-line-number="5">}</a>
<a class="sourceLine" id="cb826-6" data-line-number="6"></a>
<a class="sourceLine" id="cb826-7" data-line-number="7"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb826-8" data-line-number="8">{</a>
<a class="sourceLine" id="cb826-9" data-line-number="9">    <span class="co">// 配列bufferのサイズは10</span></a>
<a class="sourceLine" id="cb826-10" data-line-number="10">    f&lt;<span class="dv">10</span>&gt;() ;</a>
<a class="sourceLine" id="cb826-11" data-line-number="11">    <span class="co">// サイズは12</span></a>
<a class="sourceLine" id="cb826-12" data-line-number="12">    f&lt;<span class="dv">12</span>&gt;() ;</a>
<a class="sourceLine" id="cb826-13" data-line-number="13">}</a></code></pre></div>
<p>テンプレートを使ったコードは、与えられた<code>テンプレート引数</code>に対して妥当でなければならない。</p>
<div class="sourceCode" id="cb827"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb827-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> vec &gt;</a>
<a class="sourceLine" id="cb827-2" data-line-number="2"><span class="dt">void</span> f( vec &amp; v )</a>
<a class="sourceLine" id="cb827-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb827-4" data-line-number="4">    v.push_back(<span class="dv">0</span>) ;</a>
<a class="sourceLine" id="cb827-5" data-line-number="5">}</a>
<a class="sourceLine" id="cb827-6" data-line-number="6"></a>
<a class="sourceLine" id="cb827-7" data-line-number="7"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb827-8" data-line-number="8">{</a>
<a class="sourceLine" id="cb827-9" data-line-number="9">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; a ;</a>
<a class="sourceLine" id="cb827-10" data-line-number="10">    <span class="co">// OK</span></a>
<a class="sourceLine" id="cb827-11" data-line-number="11">    f( a ) ;</a>
<a class="sourceLine" id="cb827-12" data-line-number="12">    <span class="bu">std::</span>vector&lt;<span class="dt">double</span>&gt; b ;</a>
<a class="sourceLine" id="cb827-13" data-line-number="13">    <span class="co">// OK</span></a>
<a class="sourceLine" id="cb827-14" data-line-number="14">    <span class="co">// intからdoubleへの変換</span></a>
<a class="sourceLine" id="cb827-15" data-line-number="15">    f( b ) ;</a>
<a class="sourceLine" id="cb827-16" data-line-number="16"></a>
<a class="sourceLine" id="cb827-17" data-line-number="17">    <span class="bu">std::</span>vector&lt;<span class="bu">std::</span>string&gt; c ;</a>
<a class="sourceLine" id="cb827-18" data-line-number="18">    <span class="co">// エラー</span></a>
<a class="sourceLine" id="cb827-19" data-line-number="19">    <span class="co">// intからstd::stringに変換はできない</span></a>
<a class="sourceLine" id="cb827-20" data-line-number="20">    f( c ) ;</a>
<a class="sourceLine" id="cb827-21" data-line-number="21"></a>
<a class="sourceLine" id="cb827-22" data-line-number="22">    <span class="co">// エラー</span></a>
<a class="sourceLine" id="cb827-23" data-line-number="23">    <span class="co">// int型はメンバー関数push_backを持っていない</span></a>
<a class="sourceLine" id="cb827-24" data-line-number="24">    f( <span class="dv">0</span> ) ;</a>
<a class="sourceLine" id="cb827-25" data-line-number="25">}</a></code></pre></div>
<h2 id="クラステンプレート">クラステンプレート</h2>
<p><code>テンプレート</code>は<code>クラス</code>にも使える。<code>関数テンプレート</code>は<code>関数</code>の前に<code>テンプレート</code>を書くように、</p>
<div class="sourceCode" id="cb828"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb828-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt; <span class="co">// テンプレート</span></a>
<a class="sourceLine" id="cb828-2" data-line-number="2"><span class="dt">void</span> f( ) ; <span class="co">// 関数</span></a></code></pre></div>
<p><code>クラステンプレート</code>は<code>クラス</code>の前に<code>テンプレート</code>を書く。</p>
<div class="sourceCode" id="cb829"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb829-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt; <span class="co">// テンプレート</span></a>
<a class="sourceLine" id="cb829-2" data-line-number="2"><span class="kw">struct</span> S { } ; <span class="co">// クラス</span></a></code></pre></div>
<p>関数の中でテンプレート引数名を型や値として使えるように。</p>
<div class="sourceCode" id="cb830"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb830-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> T, T N &gt;</a>
<a class="sourceLine" id="cb830-2" data-line-number="2">T value()</a>
<a class="sourceLine" id="cb830-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb830-4" data-line-number="4">    <span class="cf">return</span> N :</a>
<a class="sourceLine" id="cb830-5" data-line-number="5">}</a>
<a class="sourceLine" id="cb830-6" data-line-number="6"></a>
<a class="sourceLine" id="cb830-7" data-line-number="7"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb830-8" data-line-number="8">{</a>
<a class="sourceLine" id="cb830-9" data-line-number="9">    value&lt;<span class="dt">int</span>, <span class="dv">1</span>&gt;() ;</a>
<a class="sourceLine" id="cb830-10" data-line-number="10">    value&lt;<span class="dt">short</span>, <span class="dv">1</span>&gt;() ;</a>
<a class="sourceLine" id="cb830-11" data-line-number="11">}</a></code></pre></div>
<p>クラスの中でもテンプレート引数名を型や値として使える。</p>
<div class="sourceCode" id="cb831"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb831-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> T, <span class="bu">std::</span>size_t N &gt;</a>
<a class="sourceLine" id="cb831-2" data-line-number="2"><span class="kw">struct</span> array</a>
<a class="sourceLine" id="cb831-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb831-4" data-line-number="4">    T storage[N] ;</a>
<a class="sourceLine" id="cb831-5" data-line-number="5"></a>
<a class="sourceLine" id="cb831-6" data-line-number="6">    T &amp; <span class="kw">operator</span> [] ( <span class="bu">std::</span>size_t i )</a>
<a class="sourceLine" id="cb831-7" data-line-number="7">    {</a>
<a class="sourceLine" id="cb831-8" data-line-number="8">        <span class="cf">return</span> storage[i] ;</a>
<a class="sourceLine" id="cb831-9" data-line-number="9">    }</a>
<a class="sourceLine" id="cb831-10" data-line-number="10">} ;</a></code></pre></div>
<p>なんと、もう’std::array’が完成してしまった。</p>
<h1 id="arrayをさらに実装">arrayをさらに実装</h1>
<p>’std::array’をもっと実装していこう。前回、以下のような簡単な’array’を実装した。</p>
<div class="sourceCode" id="cb832"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb832-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> T, <span class="bu">std::</span>size_t N &gt;</a>
<a class="sourceLine" id="cb832-2" data-line-number="2"><span class="kw">struct</span> array</a>
<a class="sourceLine" id="cb832-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb832-4" data-line-number="4">    T storage[N] ;</a>
<a class="sourceLine" id="cb832-5" data-line-number="5"></a>
<a class="sourceLine" id="cb832-6" data-line-number="6">    T &amp; <span class="kw">operator</span> [] ( <span class="bu">std::</span>size_t i )</a>
<a class="sourceLine" id="cb832-7" data-line-number="7">    {</a>
<a class="sourceLine" id="cb832-8" data-line-number="8">        <span class="cf">return</span> storage[i] ;</a>
<a class="sourceLine" id="cb832-9" data-line-number="9">    }</a>
<a class="sourceLine" id="cb832-10" data-line-number="10">} ;</a></code></pre></div>
<p>実は<code>std::array</code>はこのように書かれていない。この章では、’array’の実装を’std::array’に近づけていく。</p>
<h2 id="ネストされた型名">ネストされた型名</h2>
<p>エイリアス宣言を覚えているだろうか。型名に別名をつける機能だ。</p>
<div class="sourceCode" id="cb833"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb833-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb833-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb833-3" data-line-number="3">    <span class="kw">using</span> number = <span class="dt">int</span> ;</a>
<a class="sourceLine" id="cb833-4" data-line-number="4">    number x = <span class="dv">123</span> ;</a>
<a class="sourceLine" id="cb833-5" data-line-number="5">}</a></code></pre></div>
<p>エイリアス宣言はクラスの中でも使うことができる。</p>
<div class="sourceCode" id="cb834"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb834-1" data-line-number="1"><span class="kw">struct</span> S</a>
<a class="sourceLine" id="cb834-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb834-3" data-line-number="3">    <span class="kw">using</span> number = <span class="dt">int</span> ;</a>
<a class="sourceLine" id="cb834-4" data-line-number="4">    number data ;</a>
<a class="sourceLine" id="cb834-5" data-line-number="5">} ;</a>
<a class="sourceLine" id="cb834-6" data-line-number="6"></a>
<a class="sourceLine" id="cb834-7" data-line-number="7"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb834-8" data-line-number="8">{</a>
<a class="sourceLine" id="cb834-9" data-line-number="9">    S s{<span class="dv">123</span>} ;</a>
<a class="sourceLine" id="cb834-10" data-line-number="10"></a>
<a class="sourceLine" id="cb834-11" data-line-number="11">    S::number x = s.data ;</a>
<a class="sourceLine" id="cb834-12" data-line-number="12">}</a></code></pre></div>
<p>クラスの中で宣言されたエイリアス宣言による型名を、<code>ネストされた型名</code>という。<code>std::array</code>ではテンプレート引数を直接使う代わりに、<code>ネストされた型名</code>が使われている。</p>
<div class="sourceCode" id="cb835"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb835-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> T, <span class="bu">std::</span>size_t N &gt;</a>
<a class="sourceLine" id="cb835-2" data-line-number="2"><span class="kw">struct</span> array</a>
<a class="sourceLine" id="cb835-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb835-4" data-line-number="4">    <span class="kw">using</span> <span class="dt">value_type</span> = T ;</a>
<a class="sourceLine" id="cb835-5" data-line-number="5">    <span class="kw">using</span> reference = T &amp; ;</a>
<a class="sourceLine" id="cb835-6" data-line-number="6"></a>
<a class="sourceLine" id="cb835-7" data-line-number="7">    <span class="kw">using</span> <span class="dt">size_type</span> = <span class="bu">std::</span>size_t</a>
<a class="sourceLine" id="cb835-8" data-line-number="8"></a>
<a class="sourceLine" id="cb835-9" data-line-number="9">    <span class="dt">value_type</span> storage[N] ;</a>
<a class="sourceLine" id="cb835-10" data-line-number="10"></a>
<a class="sourceLine" id="cb835-11" data-line-number="11">    reference <span class="kw">operator</span> [] ( <span class="dt">size_type</span> i )</a>
<a class="sourceLine" id="cb835-12" data-line-number="12">    {</a>
<a class="sourceLine" id="cb835-13" data-line-number="13">        <span class="cf">return</span> storage[i] ;</a>
<a class="sourceLine" id="cb835-14" data-line-number="14">    }</a>
<a class="sourceLine" id="cb835-15" data-line-number="15">} ;</a></code></pre></div>
<p>こうすると、<code>T &amp;</code>のようなわかりにくい型ではなく<code>reference</code>のようにわかりやすい名前を使える。さらに、クラス外部から使うこともできる。</p>
<div class="sourceCode" id="cb836"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb836-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb836-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb836-3" data-line-number="3">    <span class="kw">using</span> <span class="dt">array_type</span> = <span class="bu">std::</span>array&lt;<span class="dt">int</span>, <span class="dv">5</span>&gt; ;</a>
<a class="sourceLine" id="cb836-4" data-line-number="4">    <span class="dt">array_type</span> a = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</a>
<a class="sourceLine" id="cb836-5" data-line-number="5">    <span class="dt">array_type</span>::<span class="dt">value_type</span> x = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb836-6" data-line-number="6">    <span class="dt">array_type</span>::reference ref = a[<span class="dv">0</span>] ;</a>
<a class="sourceLine" id="cb836-7" data-line-number="7">}</a></code></pre></div>
<p>もちろんこれは<code>auto</code>で書くこともできるが、</p>
<div class="sourceCode" id="cb837"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb837-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb837-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb837-3" data-line-number="3">    <span class="kw">using</span> <span class="dt">array_type</span> = <span class="bu">std::</span>array&lt;<span class="dt">int</span>, <span class="dv">5</span>&gt; ;</a>
<a class="sourceLine" id="cb837-4" data-line-number="4">    <span class="dt">array_type</span> a = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</a>
<a class="sourceLine" id="cb837-5" data-line-number="5">    <span class="kw">auto</span> x = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb837-6" data-line-number="6">    <span class="kw">auto</span> ref = a[<span class="dv">0</span>] ;</a>
<a class="sourceLine" id="cb837-7" data-line-number="7">}</a></code></pre></div>
<p>信じられないことに昔のC++には<code>auto</code>がなかったのだ。その他、様々な利点があるのだが、そのすべてを理解するには、まだ読者のC++力が足りない。</p>
<h2 id="要素数の取得-size">要素数の取得: size()</h2>
<p><code>std::array&lt;T,N&gt;</code>には<code>size()</code>というメンバー関数がある。要素数をかえす。</p>
<p><code>array</code>の場合、<code>N</code>を返せばよい。</p>
<div class="sourceCode" id="cb838"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb838-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb838-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb838-3" data-line-number="3">    <span class="bu">std::</span>array&lt;<span class="dt">int</span>, <span class="dv">5</span>&gt; a ;</a>
<a class="sourceLine" id="cb838-4" data-line-number="4">    a.size() ; <span class="co">// 5</span></a>
<a class="sourceLine" id="cb838-5" data-line-number="5"></a>
<a class="sourceLine" id="cb838-6" data-line-number="6">    <span class="bu">std::</span>array&lt;<span class="dt">int</span>, <span class="dv">10</span>&gt; b ;</a>
<a class="sourceLine" id="cb838-7" data-line-number="7">    b.size() ; <span class="co">// 10</span></a>
<a class="sourceLine" id="cb838-8" data-line-number="8">}</a></code></pre></div>
<p>早速実装しよう。</p>
<div class="sourceCode" id="cb839"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb839-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> T, <span class="bu">std::</span>size_t N &gt;</a>
<a class="sourceLine" id="cb839-2" data-line-number="2"><span class="kw">struct</span> array</a>
<a class="sourceLine" id="cb839-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb839-4" data-line-number="4">    <span class="kw">using</span> <span class="dt">size_type</span> = <span class="bu">std::</span>size_t ;</a>
<a class="sourceLine" id="cb839-5" data-line-number="5"></a>
<a class="sourceLine" id="cb839-6" data-line-number="6">    <span class="dt">size_type</span> size() ;</a>
<a class="sourceLine" id="cb839-7" data-line-number="7">    <span class="co">// ... 省略</span></a>
<a class="sourceLine" id="cb839-8" data-line-number="8">} ;</a></code></pre></div>
<p>ここでは<code>size</code>の宣言だけをしている。</p>
<p>関数は宣言と定義が分割できる。</p>
<div class="sourceCode" id="cb840"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb840-1" data-line-number="1"><span class="co">// 関数の宣言</span></a>
<a class="sourceLine" id="cb840-2" data-line-number="2"><span class="dt">void</span> f() ;</a>
<a class="sourceLine" id="cb840-3" data-line-number="3"><span class="co">// 関数の定義</span></a>
<a class="sourceLine" id="cb840-4" data-line-number="4"><span class="dt">void</span> f() { }</a></code></pre></div>
<p>メンバー関数も宣言と定義が分割できる。</p>
<div class="sourceCode" id="cb841"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb841-1" data-line-number="1"><span class="co">// クラスの宣言</span></a>
<a class="sourceLine" id="cb841-2" data-line-number="2"><span class="kw">struct</span> S</a>
<a class="sourceLine" id="cb841-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb841-4" data-line-number="4">    <span class="co">// メンバー関数の宣言</span></a>
<a class="sourceLine" id="cb841-5" data-line-number="5">    <span class="dt">void</span> f() ;</a>
<a class="sourceLine" id="cb841-6" data-line-number="6">} ;</a>
<a class="sourceLine" id="cb841-7" data-line-number="7"></a>
<a class="sourceLine" id="cb841-8" data-line-number="8"><span class="co">// メンバー関数の定義</span></a>
<a class="sourceLine" id="cb841-9" data-line-number="9"><span class="dt">void</span> S::f() { }</a></code></pre></div>
<p>メンバー関数の定義をクラス宣言の外で書くには、関数名がどのクラスに属するのかを指定しなければならない。これには<code>クラス名::</code>を使う。この場合、<code>S::f</code>だ。</p>
<h2 id="メンバー関数のconst修飾">メンバー関数のconst修飾</h2>
<p><code>const</code>をつけた変数は値を変更できなくなることはすでに学んだ。</p>
<div class="sourceCode" id="cb842"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb842-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb842-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb842-3" data-line-number="3">    <span class="dt">int</span> x = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb842-4" data-line-number="4">    x = <span class="dv">1</span> ;</a>
<a class="sourceLine" id="cb842-5" data-line-number="5">    <span class="dt">int</span> <span class="at">const</span> cx = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb842-6" data-line-number="6">    cx = <span class="dv">0</span> ; <span class="co">// エラー</span></a>
<a class="sourceLine" id="cb842-7" data-line-number="7">}</a></code></pre></div>
<p><code>const</code>は変更する必要のない場面でうっかり変更することを防いでくれるとても便利な機能だ。’array’は大きいので関数の引数として渡すときにコピーするのは非効率的だ。なのでコピーを防ぐリファレンスで渡したい。</p>
<p><code>std::array&lt;T,N&gt;</code>を受け取って要素をすべて出力する関数を書いてみよう。</p>
<div class="sourceCode" id="cb843"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb843-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> Array &gt;</a>
<a class="sourceLine" id="cb843-2" data-line-number="2"><span class="dt">void</span> print( Array &amp; c )</a>
<a class="sourceLine" id="cb843-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb843-4" data-line-number="4">    <span class="cf">for</span> ( <span class="bu">std::</span>size_t i = <span class="dv">0</span> ; i != c.size() ; ++i )</a>
<a class="sourceLine" id="cb843-5" data-line-number="5">    {</a>
<a class="sourceLine" id="cb843-6" data-line-number="6">        <span class="bu">std::</span>cout &lt;&lt; c[i] ;</a>
<a class="sourceLine" id="cb843-7" data-line-number="7">    }</a>
<a class="sourceLine" id="cb843-8" data-line-number="8">}</a>
<a class="sourceLine" id="cb843-9" data-line-number="9"></a>
<a class="sourceLine" id="cb843-10" data-line-number="10"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb843-11" data-line-number="11">{</a>
<a class="sourceLine" id="cb843-12" data-line-number="12">    <span class="bu">std::</span>array&lt;<span class="dt">int</span>, <span class="dv">5</span>&gt; a = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</a>
<a class="sourceLine" id="cb843-13" data-line-number="13">    print( a ) ;</a>
<a class="sourceLine" id="cb843-14" data-line-number="14">}</a></code></pre></div>
<p>関数<code>print</code>がテンプレートなのは任意の<code>T</code>と<code>N</code>を使った<code>std::array&lt;T,N&gt;</code>を受け取れるようにするためだ。</p>
<p>関数のリファレンスを引数として渡すと、関数の中で変更できてしまう。しかし、上の例のような関数<code>print</code>では、引数を書き換える必要はない。この関数を使う人間も、引数を勝手に書き換えないことを期待している。この場合、<code>const</code>をつけることで値の変更を防ぐことができる。</p>
<div class="sourceCode" id="cb844"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb844-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> Container &gt;</a>
<a class="sourceLine" id="cb844-2" data-line-number="2"><span class="dt">void</span> print( Container <span class="at">const</span> &amp; c )</a>
<a class="sourceLine" id="cb844-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb844-4" data-line-number="4">    <span class="cf">for</span> ( <span class="bu">std::</span>size_t i = <span class="dv">0</span> ; i != c.size() ; ++i )</a>
<a class="sourceLine" id="cb844-5" data-line-number="5">    {</a>
<a class="sourceLine" id="cb844-6" data-line-number="6">        <span class="bu">std::</span>cout &lt;&lt; c[i] ;</a>
<a class="sourceLine" id="cb844-7" data-line-number="7">    }</a>
<a class="sourceLine" id="cb844-8" data-line-number="8">}</a></code></pre></div>
<p>ではさっそくこれまで実装してきた自作の<code>array</code>クラスを使ってみよう。</p>
<div class="sourceCode" id="cb845"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb845-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb845-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb845-3" data-line-number="3">    array&lt;<span class="dt">int</span>, <span class="dv">5</span>&gt; a = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</a>
<a class="sourceLine" id="cb845-4" data-line-number="4"></a>
<a class="sourceLine" id="cb845-5" data-line-number="5">    print( a ) ; <span class="co">// エラー</span></a>
<a class="sourceLine" id="cb845-6" data-line-number="6">}</a></code></pre></div>
<p>なぜかエラーになってしまう。</p>
<p>この理由はメンバー関数を呼び出しているからだ。</p>
<p>クラスのメンバー関数はデータメンバーを変更できる。</p>
<div class="sourceCode" id="cb846"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb846-1" data-line-number="1"><span class="kw">struct</span> S</a>
<a class="sourceLine" id="cb846-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb846-3" data-line-number="3">    <span class="dt">int</span> data {} ;</a>
<a class="sourceLine" id="cb846-4" data-line-number="4">    <span class="dt">void</span> f()</a>
<a class="sourceLine" id="cb846-5" data-line-number="5">    {</a>
<a class="sourceLine" id="cb846-6" data-line-number="6">        ++data ;</a>
<a class="sourceLine" id="cb846-7" data-line-number="7">    }</a>
<a class="sourceLine" id="cb846-8" data-line-number="8">} ;</a>
<a class="sourceLine" id="cb846-9" data-line-number="9"></a>
<a class="sourceLine" id="cb846-10" data-line-number="10"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb846-11" data-line-number="11">{</a>
<a class="sourceLine" id="cb846-12" data-line-number="12">    S s ;</a>
<a class="sourceLine" id="cb846-13" data-line-number="13">    s.f() ; <span class="co">// s.dataを変更</span></a>
<a class="sourceLine" id="cb846-14" data-line-number="14">}</a></code></pre></div>
<p>ということは、<code>const S</code>はメンバー関数<code>f()</code>を呼び出すことができない。</p>
<div class="sourceCode" id="cb847"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb847-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb847-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb847-3" data-line-number="3">    S s ;</a>
<a class="sourceLine" id="cb847-4" data-line-number="4">    S <span class="at">const</span> &amp; ref = s ;</a>
<a class="sourceLine" id="cb847-5" data-line-number="5"></a>
<a class="sourceLine" id="cb847-6" data-line-number="6">    ++ref.data ;  <span class="co">// エラー</span></a>
<a class="sourceLine" id="cb847-7" data-line-number="7">    ref.f() ;     <span class="co">// エラー</span></a>
<a class="sourceLine" id="cb847-8" data-line-number="8">}</a></code></pre></div>
<p>ではメンバー関数<code>f()</code>がデータメンバーを変更しなければいいのだろうか。試してみよう。</p>
<div class="sourceCode" id="cb848"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb848-1" data-line-number="1"><span class="kw">struct</span> S</a>
<a class="sourceLine" id="cb848-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb848-3" data-line-number="3">    <span class="dt">int</span> data {} ;</a>
<a class="sourceLine" id="cb848-4" data-line-number="4">    <span class="dt">void</span> f()</a>
<a class="sourceLine" id="cb848-5" data-line-number="5">    {</a>
<a class="sourceLine" id="cb848-6" data-line-number="6">        <span class="co">// 何もしない</span></a>
<a class="sourceLine" id="cb848-7" data-line-number="7">    }</a>
<a class="sourceLine" id="cb848-8" data-line-number="8">} ;</a>
<a class="sourceLine" id="cb848-9" data-line-number="9"></a>
<a class="sourceLine" id="cb848-10" data-line-number="10"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb848-11" data-line-number="11">{</a>
<a class="sourceLine" id="cb848-12" data-line-number="12">    S <span class="at">const</span> s ;</a>
<a class="sourceLine" id="cb848-13" data-line-number="13">    s.f() ; <span class="co">// エラー</span></a>
<a class="sourceLine" id="cb848-14" data-line-number="14">}</a></code></pre></div>
<p>まだエラーになる。この理由を完全に理解するためには、まだ説明していない<code>ポインター</code>という機能について学ばなければならない。ポインターの説明はこの次の章で行うとして、今はさしあたり必要な機能である<code>メンバー関数のconst修飾</code>を説明する。</p>
<p>constをつけていないメンバー関数をconstなクラスのオブジェクトから呼び出せない理由は、メンバー関数がデータメンバーを変更しない保証がないからだ。その保証をつけるのが<code>メンバー関数のconst修飾</code>だ。</p>
<p>メンバー関数は関数の引数のあと、関数の本体の前にconstを書くことでconst修飾できる。</p>
<div class="sourceCode" id="cb849"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb849-1" data-line-number="1"><span class="kw">struct</span> S</a>
<a class="sourceLine" id="cb849-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb849-3" data-line-number="3">    <span class="dt">void</span> f() <span class="at">const</span></a>
<a class="sourceLine" id="cb849-4" data-line-number="4">    { }</a>
<a class="sourceLine" id="cb849-5" data-line-number="5">} ;</a>
<a class="sourceLine" id="cb849-6" data-line-number="6"></a>
<a class="sourceLine" id="cb849-7" data-line-number="7"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb849-8" data-line-number="8">{</a>
<a class="sourceLine" id="cb849-9" data-line-number="9">    S s ;</a>
<a class="sourceLine" id="cb849-10" data-line-number="10">    s.f() ; <span class="co">// OK</span></a>
<a class="sourceLine" id="cb849-11" data-line-number="11"></a>
<a class="sourceLine" id="cb849-12" data-line-number="12">    S <span class="at">const</span> cs ;</a>
<a class="sourceLine" id="cb849-13" data-line-number="13">    cs.f() ; <span class="co">// OK</span></a>
<a class="sourceLine" id="cb849-14" data-line-number="14"></a>
<a class="sourceLine" id="cb849-15" data-line-number="15">}</a></code></pre></div>
<p>const修飾されたメンバー関数はconstなクラスのオブジェクトからでも呼び出すことができる。</p>
<p>const修飾されたメンバー関数と、const修飾されていないメンバー関数が両方ある場合、クラスのオブジェクトのconstの有無によって適切なメンバー関数が呼び出される。</p>
<div class="sourceCode" id="cb850"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb850-1" data-line-number="1"><span class="kw">struct</span> S</a>
<a class="sourceLine" id="cb850-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb850-3" data-line-number="3">    <span class="dt">void</span> f() { }        <span class="co">// 1</span></a>
<a class="sourceLine" id="cb850-4" data-line-number="4">    <span class="dt">void</span> f() <span class="at">const</span> { }  <span class="co">// 2</span></a>
<a class="sourceLine" id="cb850-5" data-line-number="5">} ;</a>
<a class="sourceLine" id="cb850-6" data-line-number="6"></a>
<a class="sourceLine" id="cb850-7" data-line-number="7"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb850-8" data-line-number="8">{</a>
<a class="sourceLine" id="cb850-9" data-line-number="9">    S s ;</a>
<a class="sourceLine" id="cb850-10" data-line-number="10">    s.f() ;     <span class="co">// 1</span></a>
<a class="sourceLine" id="cb850-11" data-line-number="11"></a>
<a class="sourceLine" id="cb850-12" data-line-number="12">    S <span class="at">const</span> cs ;</a>
<a class="sourceLine" id="cb850-13" data-line-number="13">    cs.f() ;    <span class="co">// 2</span></a>
<a class="sourceLine" id="cb850-14" data-line-number="14">}</a></code></pre></div>
<p>そしてもう一つ重要なのは、const修飾されたメンバー関数がデータメンバーへのリファレンスを返す場合、</p>
<div class="sourceCode" id="cb851"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb851-1" data-line-number="1"><span class="kw">struct</span> S</a>
<a class="sourceLine" id="cb851-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb851-3" data-line-number="3">    <span class="dt">int</span> data {} ;</a>
<a class="sourceLine" id="cb851-4" data-line-number="4">    <span class="co">// データメンバーへのリファレンスを返す</span></a>
<a class="sourceLine" id="cb851-5" data-line-number="5">    <span class="dt">int</span> &amp; get()</a>
<a class="sourceLine" id="cb851-6" data-line-number="6">    {</a>
<a class="sourceLine" id="cb851-7" data-line-number="7">        <span class="cf">return</span> data ;</a>
<a class="sourceLine" id="cb851-8" data-line-number="8">    }</a>
<a class="sourceLine" id="cb851-9" data-line-number="9">} ;</a></code></pre></div>
<p>const修飾されたメンバー関数は自分のデータメンバーを変更できないので、データメンバーの値を変更可能なリファレンスを返すことはできない。そのため以下のようになる。</p>
<div class="sourceCode" id="cb852"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb852-1" data-line-number="1"><span class="kw">struct</span> S</a>
<a class="sourceLine" id="cb852-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb852-3" data-line-number="3">    <span class="dt">int</span> data {} ;</a>
<a class="sourceLine" id="cb852-4" data-line-number="4">    <span class="dt">int</span> &amp; get()</a>
<a class="sourceLine" id="cb852-5" data-line-number="5">    {</a>
<a class="sourceLine" id="cb852-6" data-line-number="6">        <span class="cf">return</span> data ;</a>
<a class="sourceLine" id="cb852-7" data-line-number="7">    }</a>
<a class="sourceLine" id="cb852-8" data-line-number="8"></a>
<a class="sourceLine" id="cb852-9" data-line-number="9">    <span class="co">// const版</span></a>
<a class="sourceLine" id="cb852-10" data-line-number="10">    <span class="co">// constリファレンスを返すので変更不可</span></a>
<a class="sourceLine" id="cb852-11" data-line-number="11">    <span class="dt">int</span> <span class="at">const</span> &amp; get() <span class="at">const</span></a>
<a class="sourceLine" id="cb852-12" data-line-number="12">    {</a>
<a class="sourceLine" id="cb852-13" data-line-number="13">        <span class="cf">return</span> data ;</a>
<a class="sourceLine" id="cb852-14" data-line-number="14">    }</a>
<a class="sourceLine" id="cb852-15" data-line-number="15">} ;</a></code></pre></div>
<p>自作の’array’の<code>operator []</code>をconstに対応させよう。’std::array’はconstなリファレンスを<code>const_reference</code>というネストされた型名にしている。</p>
<div class="sourceCode" id="cb853"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb853-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> T, <span class="bu">std::</span>size_t N &gt;</a>
<a class="sourceLine" id="cb853-2" data-line-number="2"><span class="kw">struct</span> array</a>
<a class="sourceLine" id="cb853-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb853-4" data-line-number="4">    T storage[N] ;</a>
<a class="sourceLine" id="cb853-5" data-line-number="5"></a>
<a class="sourceLine" id="cb853-6" data-line-number="6">    <span class="kw">using</span> reference = T &amp; ;</a>
<a class="sourceLine" id="cb853-7" data-line-number="7">    <span class="kw">using</span> const_reference = T <span class="at">const</span> &amp; ;</a>
<a class="sourceLine" id="cb853-8" data-line-number="8"></a>
<a class="sourceLine" id="cb853-9" data-line-number="9">    <span class="co">// 非const版</span></a>
<a class="sourceLine" id="cb853-10" data-line-number="10">    reference <span class="kw">operator</span> [] ( <span class="bu">std::</span>size_t i )</a>
<a class="sourceLine" id="cb853-11" data-line-number="11">    {</a>
<a class="sourceLine" id="cb853-12" data-line-number="12">        <span class="cf">return</span> storage[i] ;</a>
<a class="sourceLine" id="cb853-13" data-line-number="13">    }</a>
<a class="sourceLine" id="cb853-14" data-line-number="14">    <span class="co">// const版</span></a>
<a class="sourceLine" id="cb853-15" data-line-number="15">    const_reference <span class="kw">operator</span> [] ( <span class="bu">std::</span>size_t i ) <span class="at">const</span></a>
<a class="sourceLine" id="cb853-16" data-line-number="16">    {</a>
<a class="sourceLine" id="cb853-17" data-line-number="17">        <span class="cf">return</span> storage[i] ;</a>
<a class="sourceLine" id="cb853-18" data-line-number="18">    }</a>
<a class="sourceLine" id="cb853-19" data-line-number="19">} ;</a></code></pre></div>
<p>これで<code>const array</code>にも対応できるようになった。</p>
<h2 id="先頭と末尾の要素frontback">先頭と末尾の要素：front/back</h2>
<p>メンバー関数<code>front</code>は最初の要素へのリファレンスを返す。<code>back</code>は最後の要素へのリファレンスを返す。</p>
<div class="sourceCode" id="cb854"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb854-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb854-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb854-3" data-line-number="3">    <span class="bu">std::</span>array&lt;<span class="dt">int</span>, <span class="dv">5</span>&gt; a = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</a>
<a class="sourceLine" id="cb854-4" data-line-number="4"></a>
<a class="sourceLine" id="cb854-5" data-line-number="5">    <span class="dt">int</span> &amp; f = a.front() ;   <span class="co">// 1</span></a>
<a class="sourceLine" id="cb854-6" data-line-number="6">    <span class="dt">int</span> &amp; b = a.back() ;    <span class="co">// 5</span></a>
<a class="sourceLine" id="cb854-7" data-line-number="7">}</a></code></pre></div>
<p><code>front/back</code>には<code>reference</code>を返すバージョンと<code>const_reference</code>を返すバージョンがある。</p>
<div class="sourceCode" id="cb855"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb855-1" data-line-number="1"></a>
<a class="sourceLine" id="cb855-2" data-line-number="2"><span class="kw">template</span> &lt; <span class="kw">typename</span> T, <span class="bu">std::</span>size_t N &gt;</a>
<a class="sourceLine" id="cb855-3" data-line-number="3"><span class="kw">struct</span> array</a>
<a class="sourceLine" id="cb855-4" data-line-number="4">{</a>
<a class="sourceLine" id="cb855-5" data-line-number="5">    T storage[N] ;</a>
<a class="sourceLine" id="cb855-6" data-line-number="6"></a>
<a class="sourceLine" id="cb855-7" data-line-number="7">    <span class="kw">using</span> reference = T &amp; ;</a>
<a class="sourceLine" id="cb855-8" data-line-number="8">    <span class="kw">using</span> const_reference = T <span class="at">const</span> &amp; ;</a>
<a class="sourceLine" id="cb855-9" data-line-number="9"></a>
<a class="sourceLine" id="cb855-10" data-line-number="10">    reference front()</a>
<a class="sourceLine" id="cb855-11" data-line-number="11">    { <span class="cf">return</span> storage[<span class="dv">0</span>] ; }</a>
<a class="sourceLine" id="cb855-12" data-line-number="12">    const_reference front() <span class="at">const</span></a>
<a class="sourceLine" id="cb855-13" data-line-number="13">    { <span class="cf">return</span> storage[<span class="dv">0</span>] ; }</a>
<a class="sourceLine" id="cb855-14" data-line-number="14"></a>
<a class="sourceLine" id="cb855-15" data-line-number="15">    reference back()</a>
<a class="sourceLine" id="cb855-16" data-line-number="16">    { <span class="cf">return</span> storage[N<span class="dv">-1</span>] ; }</a>
<a class="sourceLine" id="cb855-17" data-line-number="17">    const_reference back() <span class="at">const</span></a>
<a class="sourceLine" id="cb855-18" data-line-number="18">    { <span class="cf">return</span> storage[N<span class="dv">-1</span>] ; }</a>
<a class="sourceLine" id="cb855-19" data-line-number="19"></a>
<a class="sourceLine" id="cb855-20" data-line-number="20">} ;</a></code></pre></div>
<h2 id="全要素に値を代入-fill">全要素に値を代入: fill</h2>
<div class="sourceCode" id="cb856"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb856-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb856-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb856-3" data-line-number="3">    <span class="bu">std::</span>array&lt;<span class="dt">int</span>, <span class="dv">5</span>&gt; a = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</a>
<a class="sourceLine" id="cb856-4" data-line-number="4">    a.fill(<span class="dv">0</span>) ;</a>
<a class="sourceLine" id="cb856-5" data-line-number="5">    <span class="co">// aは{0,0,0,0,0}</span></a>
<a class="sourceLine" id="cb856-6" data-line-number="6">}</a></code></pre></div>
<p>すでにアルゴリズムで実装した’std::fill’と同じだ。</p>
<div class="sourceCode" id="cb857"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb857-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> T, <span class="bu">std::</span>size_t N &gt;</a>
<a class="sourceLine" id="cb857-2" data-line-number="2"><span class="kw">struct</span> array</a>
<a class="sourceLine" id="cb857-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb857-4" data-line-number="4">    T storage[N] ;</a>
<a class="sourceLine" id="cb857-5" data-line-number="5"></a>
<a class="sourceLine" id="cb857-6" data-line-number="6">    <span class="dt">void</span> fill( T <span class="at">const</span> &amp; u )</a>
<a class="sourceLine" id="cb857-7" data-line-number="7">    {</a>
<a class="sourceLine" id="cb857-8" data-line-number="8">        <span class="cf">for</span> ( <span class="bu">std::</span>size_t i = <span class="dv">0</span> ; i != N ; ++i )</a>
<a class="sourceLine" id="cb857-9" data-line-number="9">        {</a>
<a class="sourceLine" id="cb857-10" data-line-number="10">            storage[i] = u ;</a>
<a class="sourceLine" id="cb857-11" data-line-number="11">        }</a>
<a class="sourceLine" id="cb857-12" data-line-number="12">    }</a>
<a class="sourceLine" id="cb857-13" data-line-number="13"></a>
<a class="sourceLine" id="cb857-14" data-line-number="14">} ;</a></code></pre></div>
<p>しかし、せっかく<code>std::fill</code>があるのだから以下のように書きたい。</p>
<div class="sourceCode" id="cb858"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb858-1" data-line-number="1"><span class="dt">void</span> fill( T <span class="at">const</span> &amp; u )</a>
<a class="sourceLine" id="cb858-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb858-3" data-line-number="3">    <span class="bu">std::</span>fill( begin(), end(), u ) ;</a>
<a class="sourceLine" id="cb858-4" data-line-number="4">}</a></code></pre></div>
<p>残念ながらこれは動かない。なぜならば、自作の<code>array</code>はまだ<code>begin()/end()</code>と<code>イテレーター</code>に対応していないからだ。これは次の章で学ぶ。</p>
<h1 id="arrayのイテレーター">arrayのイテレーター</h1>
<h2 id="イテレーターの中身">イテレーターの中身</h2>
<p>自作の<code>array</code>をイテレーターに対応させる前に、まず’std::array’のイテレーターについて一通り調べよう。</p>
<p>イテレーターは<code>std::begin/std::end</code>で取得する</p>
<div class="sourceCode" id="cb859"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb859-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb859-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb859-3" data-line-number="3">    <span class="bu">std::</span>array&lt;<span class="dt">int</span>, <span class="dv">5</span>&gt; a = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</a>
<a class="sourceLine" id="cb859-4" data-line-number="4"></a>
<a class="sourceLine" id="cb859-5" data-line-number="5">    <span class="kw">auto</span> first = <span class="bu">std::</span>begin(a) ;</a>
<a class="sourceLine" id="cb859-6" data-line-number="6">    <span class="kw">auto</span> last = <span class="bu">std::</span>end(a) ;</a>
<a class="sourceLine" id="cb859-7" data-line-number="7">}</a></code></pre></div>
<p><code>std::begin/std::end</code>は何をしているのか見てみよう。</p>
<div class="sourceCode" id="cb860"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb860-1" data-line-number="1"><span class="kw">namespace</span> std</a>
<a class="sourceLine" id="cb860-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb860-3" data-line-number="3">    <span class="kw">template</span> &lt; <span class="kw">typename</span> C &gt;</a>
<a class="sourceLine" id="cb860-4" data-line-number="4">    <span class="kw">auto</span> begin( C &amp; c )</a>
<a class="sourceLine" id="cb860-5" data-line-number="5">    { <span class="cf">return</span> c.begin() ; }</a>
<a class="sourceLine" id="cb860-6" data-line-number="6"></a>
<a class="sourceLine" id="cb860-7" data-line-number="7">    <span class="kw">template</span> &lt; <span class="kw">typename</span> C &gt;</a>
<a class="sourceLine" id="cb860-8" data-line-number="8">    <span class="kw">auto</span> begin( C <span class="at">const</span> &amp; c )</a>
<a class="sourceLine" id="cb860-9" data-line-number="9">    { <span class="cf">return</span> c.begin() ; }</a>
<a class="sourceLine" id="cb860-10" data-line-number="10"></a>
<a class="sourceLine" id="cb860-11" data-line-number="11">    <span class="kw">template</span> &lt; <span class="kw">typename</span> C &gt;</a>
<a class="sourceLine" id="cb860-12" data-line-number="12">    <span class="kw">auto</span> end( C &amp; c )</a>
<a class="sourceLine" id="cb860-13" data-line-number="13">    { <span class="cf">return</span> c.end() ;}</a>
<a class="sourceLine" id="cb860-14" data-line-number="14"></a>
<a class="sourceLine" id="cb860-15" data-line-number="15">    <span class="kw">template</span> &lt; <span class="kw">typename</span> C &gt;</a>
<a class="sourceLine" id="cb860-16" data-line-number="16">    <span class="kw">auto</span> begin( C <span class="at">const</span> &amp; c )</a>
<a class="sourceLine" id="cb860-17" data-line-number="17">    { <span class="cf">return</span> c.end() ;}</a>
<a class="sourceLine" id="cb860-18" data-line-number="18">}</a></code></pre></div>
<p>なんと、単に引数に対してメンバー関数<code>begin/end</code>を呼び出してその結果を返しているだけだ。</p>
<p>早速確かめてみよう。</p>
<div class="sourceCode" id="cb861"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb861-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb861-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb861-3" data-line-number="3">    <span class="bu">std::</span>array&lt;<span class="dt">int</span>, <span class="dv">5</span>&gt; a = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</a>
<a class="sourceLine" id="cb861-4" data-line-number="4"></a>
<a class="sourceLine" id="cb861-5" data-line-number="5">    <span class="kw">auto</span> iter = a.begin() ;</a>
<a class="sourceLine" id="cb861-6" data-line-number="6">    <span class="bu">std::</span>cout &lt;&lt; *iter ; <span class="co">// 1</span></a>
<a class="sourceLine" id="cb861-7" data-line-number="7">    ++iter ;</a>
<a class="sourceLine" id="cb861-8" data-line-number="8">    <span class="bu">std::</span>cout &lt;&lt; *iter ; <span class="co">// 2</span></a>
<a class="sourceLine" id="cb861-9" data-line-number="9">}</a></code></pre></div>
<p>確かに動くようだ。</p>
<p>すると自作の<code>array</code>でイテレーターに対応する方法がわかってきた。</p>
<div class="sourceCode" id="cb862"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb862-1" data-line-number="1"><span class="co">// イテレーターを表現するクラス</span></a>
<a class="sourceLine" id="cb862-2" data-line-number="2"><span class="kw">struct</span> array_iterator { }</a>
<a class="sourceLine" id="cb862-3" data-line-number="3"></a>
<a class="sourceLine" id="cb862-4" data-line-number="4"><span class="kw">template</span> &lt; <span class="kw">typename</span> T, <span class="bu">std::</span>size_t N &gt;</a>
<a class="sourceLine" id="cb862-5" data-line-number="5"><span class="kw">struct</span> array</a>
<a class="sourceLine" id="cb862-6" data-line-number="6">{</a>
<a class="sourceLine" id="cb862-7" data-line-number="7">    <span class="co">// イテレーター型</span></a>
<a class="sourceLine" id="cb862-8" data-line-number="8">    <span class="kw">using</span> iterator = array_iterator ;</a>
<a class="sourceLine" id="cb862-9" data-line-number="9"></a>
<a class="sourceLine" id="cb862-10" data-line-number="10">    <span class="co">// イテレーターを返すメンバー関数</span></a>
<a class="sourceLine" id="cb862-11" data-line-number="11">    iterator begin() ;</a>
<a class="sourceLine" id="cb862-12" data-line-number="12">    iterator end() ;</a>
<a class="sourceLine" id="cb862-13" data-line-number="13"></a>
<a class="sourceLine" id="cb862-14" data-line-number="14">    <span class="co">// その他のメンバー</span></a>
<a class="sourceLine" id="cb862-15" data-line-number="15">} ;</a></code></pre></div>
<p>イテレーターに対応するには、おおむねこのような実装になるとみていいだろう。おそらく細かい部分で微調整が必要になるが、今はこれでよしとしよう。ではイテレーターが具体的に何をするかを見ていこう。</p>
<p>すでに学んだように、イテレーターは<code>operator *</code>で参照する要素の値を取得できる。また書き込みもできる。</p>
<div class="sourceCode" id="cb863"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb863-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb863-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb863-3" data-line-number="3">    <span class="bu">std::</span>array&lt;<span class="dt">int</span>, <span class="dv">5</span>&gt; a = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</a>
<a class="sourceLine" id="cb863-4" data-line-number="4"></a>
<a class="sourceLine" id="cb863-5" data-line-number="5">    <span class="kw">auto</span> iter = a.begin() ;</a>
<a class="sourceLine" id="cb863-6" data-line-number="6">    <span class="dt">int</span> x = *iter ; <span class="co">// 1</span></a>
<a class="sourceLine" id="cb863-7" data-line-number="7">    *iter = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb863-8" data-line-number="8">    <span class="co">// aは{0,2,3,4,5}</span></a>
<a class="sourceLine" id="cb863-9" data-line-number="9">}</a></code></pre></div>
<p>問題を簡単にするために、これまでに作った自作の<code>array</code>で最初の要素にアクセスする方法を考えてみよう</p>
<div class="sourceCode" id="cb864"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb864-1" data-line-number="1">array&lt;<span class="dt">int</span>, <span class="dv">5</span>&gt; a = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</a>
<a class="sourceLine" id="cb864-2" data-line-number="2"><span class="dt">int</span> x = a[<span class="dv">0</span>] ; <span class="co">// 1</span></a>
<a class="sourceLine" id="cb864-3" data-line-number="3">a[<span class="dv">0</span>] = <span class="dv">0</span> ;</a></code></pre></div>
<p>このことから考えると、先頭要素を指すイテレーターは<code>operator *</code>をオーバーロードして先頭要素をリファレンスで返せば良い。</p>
<div class="sourceCode" id="cb865"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb865-1" data-line-number="1"><span class="kw">struct</span> array_iterator_int_5_begin</a>
<a class="sourceLine" id="cb865-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb865-3" data-line-number="3">    array&lt;<span class="dt">int</span>, <span class="dv">5</span>&gt; &amp; a ;</a>
<a class="sourceLine" id="cb865-4" data-line-number="4"></a>
<a class="sourceLine" id="cb865-5" data-line-number="5">    array&lt;<span class="dt">int</span>, <span class="dv">5</span>&gt;::reference <span class="kw">operator</span> *()</a>
<a class="sourceLine" id="cb865-6" data-line-number="6">    {</a>
<a class="sourceLine" id="cb865-7" data-line-number="7">        <span class="cf">return</span> a[<span class="dv">0</span>] ;</a>
<a class="sourceLine" id="cb865-8" data-line-number="8">    }</a>
<a class="sourceLine" id="cb865-9" data-line-number="9">} ;</a></code></pre></div>
<p>しかし、この実装では<code>array&lt;int,5&gt;</code>にしか対応できない。<code>array&lt;int,7&gt;</code>や<code>array&lt;double, 10&gt;</code>には対応できない。なぜなら、<code>array</code>に渡すテンプレート実引数が違うと、別の型になるからだ。</p>
<p><code>array_iterator</code>で様々な<code>array</code>を扱うにはどうすればいいのか。テンプレートを使う。</p>
<div class="sourceCode" id="cb866"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb866-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> Array &gt;</a>
<a class="sourceLine" id="cb866-2" data-line-number="2"><span class="kw">struct</span> array_iterator_begin</a>
<a class="sourceLine" id="cb866-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb866-4" data-line-number="4">    Array &amp; a ;</a>
<a class="sourceLine" id="cb866-5" data-line-number="5"></a>
<a class="sourceLine" id="cb866-6" data-line-number="6">    array_iterator_begin( Array &amp; a )</a>
<a class="sourceLine" id="cb866-7" data-line-number="7">        : a( a ) { }</a>
<a class="sourceLine" id="cb866-8" data-line-number="8"></a>
<a class="sourceLine" id="cb866-9" data-line-number="9">    <span class="co">// エラー</span></a>
<a class="sourceLine" id="cb866-10" data-line-number="10">    <span class="co">// Array::referenceは型ではない</span></a>
<a class="sourceLine" id="cb866-11" data-line-number="11">    Array::reference <span class="kw">operator</span> *()</a>
<a class="sourceLine" id="cb866-12" data-line-number="12">    {</a>
<a class="sourceLine" id="cb866-13" data-line-number="13">        <span class="cf">return</span> a[<span class="dv">0</span>] ;</a>
<a class="sourceLine" id="cb866-14" data-line-number="14">    }</a>
<a class="sourceLine" id="cb866-15" data-line-number="15">} ;</a></code></pre></div>
<p>しかしなぜかエラーだとコンパイラーに怒られる。この理由を説明するのはとても難しい。気になる読者は近所のC++グルに教えを乞おう。ここでは答えだけを教える。</p>
<p><code>T::Y</code>において、<code>T</code>がテンプレート引数に依存する名前で、<code>Y</code>がネストされた型名の場合、<code>typename</code>キーワードをつけなければならない。</p>
<div class="sourceCode" id="cb867"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb867-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;</a>
<a class="sourceLine" id="cb867-2" data-line-number="2"><span class="dt">void</span> f()</a>
<a class="sourceLine" id="cb867-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb867-4" data-line-number="4">    <span class="co">// typenameが必要</span></a>
<a class="sourceLine" id="cb867-5" data-line-number="5">    <span class="kw">typename</span> T::Y x = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb867-6" data-line-number="6">}</a>
<a class="sourceLine" id="cb867-7" data-line-number="7"></a>
<a class="sourceLine" id="cb867-8" data-line-number="8"><span class="kw">struct</span> S</a>
<a class="sourceLine" id="cb867-9" data-line-number="9">{</a>
<a class="sourceLine" id="cb867-10" data-line-number="10">    <span class="kw">using</span> Y = <span class="dt">int</span> ;</a>
<a class="sourceLine" id="cb867-11" data-line-number="11">} ;</a>
<a class="sourceLine" id="cb867-12" data-line-number="12"></a>
<a class="sourceLine" id="cb867-13" data-line-number="13"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb867-14" data-line-number="14">{</a>
<a class="sourceLine" id="cb867-15" data-line-number="15">    <span class="co">// T = S</span></a>
<a class="sourceLine" id="cb867-16" data-line-number="16">    <span class="co">// T::Y = int</span></a>
<a class="sourceLine" id="cb867-17" data-line-number="17">    f&lt;S&gt;() ;</a>
<a class="sourceLine" id="cb867-18" data-line-number="18">}</a></code></pre></div>
<p>わかっただろうか。わからなくても無理はない。この問題を理解するにはテンプレートに対する深い理解が必要だ。理解した暁には読者はC++グルとして崇拝されているだろう。</p>
<p>さしあたって必要なのは<code>Array::reference</code>の前に<code>typename</code>キーワードをつけることだ。</p>
<div class="sourceCode" id="cb868"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb868-1" data-line-number="1"><span class="kw">typename</span> Array::reference</a>
<a class="sourceLine" id="cb868-2" data-line-number="2">array_iterator_begin::<span class="kw">operator</span> * ()</a>
<a class="sourceLine" id="cb868-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb868-4" data-line-number="4">    <span class="cf">return</span> a[<span class="dv">0</span>] ;</a>
<a class="sourceLine" id="cb868-5" data-line-number="5">}</a></code></pre></div>
<p>どうやら最初の要素を読み書きするイテレーターはできたようだ。<code>array</code>側も実装して試してみよう。</p>
<p>array側の実装にはまだ現時点では完全に理解できない黒魔術が必要だ。</p>
<pre class="cp"><code>template &lt; typename T, std::size_t N &gt;
struct array
{
    T storage[N] ;
    // 黒魔術1: array
    using iterator = array_iterator_begin&lt;array&gt; ;
    iterator begin()
    // 黒魔術2: *this
    // 黒魔術3: iterator(*this)
    { return iterator(*this) ; }
}</code></pre>
<p>黒魔術1は<code>array_iterator_begin&lt;array&gt;</code>の中にある。この<code>array</code>は<code>array&lt;T,N&gt;</code>と同じ意味になる。つまり全体としては、<code>array_iterator_begin&lt;array&lt;T,N&gt;&gt;</code>と書いたものと同じだ。クラステンプレートの中でクラス名を使うと、テンプレート実引数をそれぞれ指定したものと同じになる。</p>
<div class="sourceCode" id="cb870"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb870-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> A, <span class="kw">typename</span> B, <span class="kw">typename</span> C &gt;</a>
<a class="sourceLine" id="cb870-2" data-line-number="2"><span class="kw">struct</span> S</a>
<a class="sourceLine" id="cb870-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb870-4" data-line-number="4">    <span class="dt">void</span> f()</a>
<a class="sourceLine" id="cb870-5" data-line-number="5">    {</a>
<a class="sourceLine" id="cb870-6" data-line-number="6">        <span class="co">// S&lt;A,B,C&gt;と同じ</span></a>
<a class="sourceLine" id="cb870-7" data-line-number="7">        S s ;</a>
<a class="sourceLine" id="cb870-8" data-line-number="8">    }</a>
<a class="sourceLine" id="cb870-9" data-line-number="9">} ;</a></code></pre></div>
<p>黒魔術2は<code>*this</code>だ。<code>*this</code>はメンバー関数を呼んだクラスのオブジェクトへのリファレンスだ。</p>
<div class="sourceCode" id="cb871"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb871-1" data-line-number="1"><span class="kw">struct</span> S</a>
<a class="sourceLine" id="cb871-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb871-3" data-line-number="3">    <span class="dt">int</span> data {} ;</a>
<a class="sourceLine" id="cb871-4" data-line-number="4">    <span class="co">// *thisはメンバー関数が呼ばれたSのオブジェクト</span></a>
<a class="sourceLine" id="cb871-5" data-line-number="5">    S &amp; THIS() { <span class="cf">return</span> *<span class="kw">this</span> ; } </a>
<a class="sourceLine" id="cb871-6" data-line-number="6">} ;</a>
<a class="sourceLine" id="cb871-7" data-line-number="7"></a>
<a class="sourceLine" id="cb871-8" data-line-number="8"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb871-9" data-line-number="9">{</a>
<a class="sourceLine" id="cb871-10" data-line-number="10">    S s1 ;</a>
<a class="sourceLine" id="cb871-11" data-line-number="11">    </a>
<a class="sourceLine" id="cb871-12" data-line-number="12">    s1.THIS().data = <span class="dv">123</span> ;</a>
<a class="sourceLine" id="cb871-13" data-line-number="13">    <span class="co">// 123</span></a>
<a class="sourceLine" id="cb871-14" data-line-number="14">    <span class="bu">std::</span>cout &lt;&lt; s1.data ;</a>
<a class="sourceLine" id="cb871-15" data-line-number="15"></a>
<a class="sourceLine" id="cb871-16" data-line-number="16">    S s2 ;</a>
<a class="sourceLine" id="cb871-17" data-line-number="17">    s2.THIS().data = <span class="dv">456</span> ;</a>
<a class="sourceLine" id="cb871-18" data-line-number="18">    <span class="co">// 456</span></a>
<a class="sourceLine" id="cb871-19" data-line-number="19">    <span class="bu">std::</span>cout &lt;&lt; s2.data ;</a>
<a class="sourceLine" id="cb871-20" data-line-number="20">}</a></code></pre></div>
<p>クラスのメンバー関数は対応するクラスのオブジェクトに対して呼ばれる。本来ならばクラスのオブジェクトをリファレンスで取るような形になる。</p>
<div class="sourceCode" id="cb872"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb872-1" data-line-number="1"><span class="kw">struct</span> S</a>
<a class="sourceLine" id="cb872-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb872-3" data-line-number="3">    <span class="dt">int</span> data {} ;</a>
<a class="sourceLine" id="cb872-4" data-line-number="4">    <span class="dt">void</span> set(<span class="dt">int</span> x)</a>
<a class="sourceLine" id="cb872-5" data-line-number="5">    {</a>
<a class="sourceLine" id="cb872-6" data-line-number="6">        data = x ;</a>
<a class="sourceLine" id="cb872-7" data-line-number="7">    }</a>
<a class="sourceLine" id="cb872-8" data-line-number="8">} ;</a>
<a class="sourceLine" id="cb872-9" data-line-number="9"></a>
<a class="sourceLine" id="cb872-10" data-line-number="10"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb872-11" data-line-number="11">{</a>
<a class="sourceLine" id="cb872-12" data-line-number="12">    S object ;</a>
<a class="sourceLine" id="cb872-13" data-line-number="13">    object.set(<span class="dv">42</span>) ;</a>
<a class="sourceLine" id="cb872-14" data-line-number="14">}</a></code></pre></div>
<p>というコードは、ほぼ同じことを以下のようにも書ける。</p>
<div class="sourceCode" id="cb873"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb873-1" data-line-number="1"><span class="kw">struct</span> S</a>
<a class="sourceLine" id="cb873-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb873-3" data-line-number="3">    <span class="dt">int</span> data {} ;</a>
<a class="sourceLine" id="cb873-4" data-line-number="4">} ;</a>
<a class="sourceLine" id="cb873-5" data-line-number="5"></a>
<a class="sourceLine" id="cb873-6" data-line-number="6"><span class="dt">void</span> set( S &amp; object, <span class="dt">int</span> x )</a>
<a class="sourceLine" id="cb873-7" data-line-number="7">{</a>
<a class="sourceLine" id="cb873-8" data-line-number="8">    object.data = x ;</a>
<a class="sourceLine" id="cb873-9" data-line-number="9">}</a>
<a class="sourceLine" id="cb873-10" data-line-number="10"></a>
<a class="sourceLine" id="cb873-11" data-line-number="11"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb873-12" data-line-number="12">{</a>
<a class="sourceLine" id="cb873-13" data-line-number="13">    S ojbect ;</a>
<a class="sourceLine" id="cb873-14" data-line-number="14">    set( object, <span class="dv">42</span> ) ;</a>
<a class="sourceLine" id="cb873-15" data-line-number="15">}</a></code></pre></div>
<p>クラスの意義は変数と関数を結びつけることだ。このように変数と関数がバラバラではわかりにくいので、メンバー関数という形で<code>object.set(...)</code>のようにわかりやすく呼び出せるし、その際クラス<code>S</code>のオブジェクトは変数<code>object</code>であることが文法上わかるので、わざわざ関数の実引数の形で書くことは省略できるようにしている。</p>
<p>メンバー関数の中で、メンバー関数が呼ばれているクラスのオブジェクトを参照する方法が<code>*this</code>だ。</p>
<p>しかしなぜ<code>*this</code>なのか。もっとわかりやすいキーワードでもいいのではないか。なぜ<code>*</code>がついているのか。この謎を理解するためには、これまたポインターの理解が必要になるが、それは次の章で学ぶ。</p>
<p>黒魔術3は<code>iterator(*this)</code>だ。クラス名に<code>()</code>や<code>{}</code>を続けると、コンストラクターを呼び出した結果のクラスの値を得ることができる。</p>
<div class="sourceCode" id="cb874"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb874-1" data-line-number="1"><span class="kw">struct</span> S</a>
<a class="sourceLine" id="cb874-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb874-3" data-line-number="3">    S() { }</a>
<a class="sourceLine" id="cb874-4" data-line-number="4">    S( <span class="dt">int</span> ) { }</a>
<a class="sourceLine" id="cb874-5" data-line-number="5">    S( <span class="dt">int</span>, <span class="dt">int</span> ) { }</a>
<a class="sourceLine" id="cb874-6" data-line-number="6">} ;</a>
<a class="sourceLine" id="cb874-7" data-line-number="7"></a>
<a class="sourceLine" id="cb874-8" data-line-number="8"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb874-9" data-line-number="9">{</a>
<a class="sourceLine" id="cb874-10" data-line-number="10">    S a = S() ;</a>
<a class="sourceLine" id="cb874-11" data-line-number="11">    S b = S(<span class="dv">0</span>) ;</a>
<a class="sourceLine" id="cb874-12" data-line-number="12">    S c = S(<span class="dv">1</span>,<span class="dv">2</span>) ;</a>
<a class="sourceLine" id="cb874-13" data-line-number="13"></a>
<a class="sourceLine" id="cb874-14" data-line-number="14">    S d = S{} ;</a>
<a class="sourceLine" id="cb874-15" data-line-number="15">    S e = S{<span class="dv">0</span>} ;</a>
<a class="sourceLine" id="cb874-16" data-line-number="16">    S f = S{<span class="dv">1</span>,<span class="dv">2</span>} ;</a>
<a class="sourceLine" id="cb874-17" data-line-number="17">}</a></code></pre></div>
<p>黒魔術の解説が長くなった。本題に戻ろう。</p>
<p><code>array_iterator_begin</code>は先頭の要素しか扱えない。イテレーターで先頭以外の別の要素を扱う方法を思い出してみよう。</p>
<p>イテレーターは<code>operator ++</code>で次の要素を参照する。<code>operator --</code>で前の要素を参照する。</p>
<div class="sourceCode" id="cb875"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb875-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb875-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb875-3" data-line-number="3">    <span class="bu">std::</span>array&lt;<span class="dt">int</span>, <span class="dv">5</span>&gt; a = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</a>
<a class="sourceLine" id="cb875-4" data-line-number="4"></a>
<a class="sourceLine" id="cb875-5" data-line-number="5">    <span class="kw">auto</span> iter = a.begin() ;</a>
<a class="sourceLine" id="cb875-6" data-line-number="6">    *iter ; <span class="co">// 1</span></a>
<a class="sourceLine" id="cb875-7" data-line-number="7">    ++iter ;</a>
<a class="sourceLine" id="cb875-8" data-line-number="8">    *iter ; <span class="co">// 2</span></a>
<a class="sourceLine" id="cb875-9" data-line-number="9">    --iter ;</a>
<a class="sourceLine" id="cb875-10" data-line-number="10">    *iter ; <span class="co">// 1</span></a>
<a class="sourceLine" id="cb875-11" data-line-number="11">}</a></code></pre></div>
<p>この<code>operator ++</code>と<code>operator --</code>はイテレーターへのリファレンスを返す。なぜならば、以下のように書けるからだ。</p>
<div class="sourceCode" id="cb876"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb876-1" data-line-number="1">*++iter ;</a>
<a class="sourceLine" id="cb876-2" data-line-number="2">*++++iter ;</a></code></pre></div>
<p>以上を踏まえて、自作の<code>array_iterator</code>の宣言を書いてみよう。</p>
<div class="sourceCode" id="cb877"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb877-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> Array &gt;</a>
<a class="sourceLine" id="cb877-2" data-line-number="2"><span class="kw">struct</span> array_iterator</a>
<a class="sourceLine" id="cb877-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb877-4" data-line-number="4">    Array &amp; a ;</a>
<a class="sourceLine" id="cb877-5" data-line-number="5"></a>
<a class="sourceLine" id="cb877-6" data-line-number="6">    array_iterator_begin( Array &amp; a )</a>
<a class="sourceLine" id="cb877-7" data-line-number="7">        : a( a ) { }</a>
<a class="sourceLine" id="cb877-8" data-line-number="8"></a>
<a class="sourceLine" id="cb877-9" data-line-number="9">    <span class="co">// 次の要素を指す</span></a>
<a class="sourceLine" id="cb877-10" data-line-number="10">    array_iterator &amp; <span class="kw">operator</span> ++() ;</a>
<a class="sourceLine" id="cb877-11" data-line-number="11">    <span class="co">// 前の要素を指す</span></a>
<a class="sourceLine" id="cb877-12" data-line-number="12">    array_iterator &amp; <span class="kw">operator</span> --() ;</a>
<a class="sourceLine" id="cb877-13" data-line-number="13">    </a>
<a class="sourceLine" id="cb877-14" data-line-number="14">    <span class="co">//いま参照している要素へのリファレンスを返す</span></a>
<a class="sourceLine" id="cb877-15" data-line-number="15">    Array::reference <span class="kw">operator</span> *() ;</a>
<a class="sourceLine" id="cb877-16" data-line-number="16">} ;</a></code></pre></div>
<p>イテレーターの実装で先頭の要素を参照するのは<code>a[0]</code>だった。その次の要素を参照するには<code>a[1]</code>だ。その次の要素は<code>a[2]</code>となり、その前の要素は<code>a[1]</code>だ。</p>
<div class="sourceCode" id="cb878"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb878-1" data-line-number="1">array&lt;<span class="dt">int</span>, <span class="dv">5</span>&gt; a = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</a>
<a class="sourceLine" id="cb878-2" data-line-number="2"></a>
<a class="sourceLine" id="cb878-3" data-line-number="3"><span class="kw">auto</span> iter = a.begin() ; <span class="co">// 最初の要素</span></a>
<a class="sourceLine" id="cb878-4" data-line-number="4">*iter ; <span class="co">// 1</span></a>
<a class="sourceLine" id="cb878-5" data-line-number="5">++iter ; <span class="co">// 次の要素</span></a>
<a class="sourceLine" id="cb878-6" data-line-number="6">*iter ; <span class="co">// 2</span></a>
<a class="sourceLine" id="cb878-7" data-line-number="7">--iter ; <span class="co">// 前の要素、つまり最初の要素</span></a>
<a class="sourceLine" id="cb878-8" data-line-number="8">*iter ; <span class="co">// 1</span></a></code></pre></div>
<p>では最初の要素の前の要素や、最後の要素の次の要素を参照しようとするとどうなるのか。</p>
<div class="sourceCode" id="cb879"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb879-1" data-line-number="1"><span class="kw">auto</span> first = a.begin() ;</a>
<a class="sourceLine" id="cb879-2" data-line-number="2">--first ;</a>
<a class="sourceLine" id="cb879-3" data-line-number="3">*first ; <span class="co">// 最初の前の要素？</span></a>
<a class="sourceLine" id="cb879-4" data-line-number="4"><span class="kw">auto</span> last = a.end() ;</a>
<a class="sourceLine" id="cb879-5" data-line-number="5">++last ; <span class="co">//</span></a>
<a class="sourceLine" id="cb879-6" data-line-number="6">*last ; <span class="co">// 最後の次の要素？</span></a></code></pre></div>
<p>これはエラーになる。このようなエラーを起こさないように務めるのはユーザーの責任で、イテレーター実装者の責任ではない。しかし、必要であればイテレーターの実装者はこのようなエラーを防ぐような実装もできる。それは後の章で学ぶ。ここでは、こういう場合が起こることは考えなくてもよいとしよう。</p>
<p>これを考えていくと、イテレーターの実装をどうすればいいのかがわかってくる。</p>
<p>array_iteratorの<code>operator *</code>は<code>a[i]</code>を返す。</p>
<div class="sourceCode" id="cb880"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb880-1" data-line-number="1"><span class="kw">typename</span> Array::reference array_iterator::<span class="kw">operator</span> *()</a>
<a class="sourceLine" id="cb880-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb880-3" data-line-number="3">    <span class="cf">return</span> a[i] ;</a>
<a class="sourceLine" id="cb880-4" data-line-number="4">}</a></code></pre></div>
<p><code>i</code>は<code>std::size_t</code>型のデータメンバーで、イテレーターが現在参照している<code>i</code>番目の要素を記録している。</p>
<p>ということは先程の<code>array_iterator</code>の宣言にはデータメンバー<code>i</code>を追加する修正が必要だ。</p>
<div class="sourceCode" id="cb881"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb881-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> Array &gt;</a>
<a class="sourceLine" id="cb881-2" data-line-number="2"><span class="kw">struct</span> array_iterator</a>
<a class="sourceLine" id="cb881-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb881-4" data-line-number="4">    Array &amp; a ;</a>
<a class="sourceLine" id="cb881-5" data-line-number="5">    <span class="bu">std::</span>size_t i ;</a>
<a class="sourceLine" id="cb881-6" data-line-number="6"></a>
<a class="sourceLine" id="cb881-7" data-line-number="7">    array_iterator( Array &amp; a, <span class="bu">std::</span>size_t i )</a>
<a class="sourceLine" id="cb881-8" data-line-number="8">        : a( a ), i(i) { }</a>
<a class="sourceLine" id="cb881-9" data-line-number="9"></a>
<a class="sourceLine" id="cb881-10" data-line-number="10">    <span class="co">//いま参照している要素へのリファレンスを返す</span></a>
<a class="sourceLine" id="cb881-11" data-line-number="11">    Array::reference <span class="kw">operator</span> *()</a>
<a class="sourceLine" id="cb881-12" data-line-number="12">    {</a>
<a class="sourceLine" id="cb881-13" data-line-number="13">        <span class="cf">return</span> a[i] ;</a>
<a class="sourceLine" id="cb881-14" data-line-number="14">    }</a>
<a class="sourceLine" id="cb881-15" data-line-number="15"></a>
<a class="sourceLine" id="cb881-16" data-line-number="16">    <span class="co">// その他のメンバー</span></a>
<a class="sourceLine" id="cb881-17" data-line-number="17">} ;</a></code></pre></div>
<p>そして、<code>array</code>側にも新しい<code>array_iterator</code>への対応が必要になる。</p>
<div class="sourceCode" id="cb882"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb882-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> T, <span class="bu">std::</span>size_t N &gt;</a>
<a class="sourceLine" id="cb882-2" data-line-number="2"><span class="kw">struct</span> array</a>
<a class="sourceLine" id="cb882-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb882-4" data-line-number="4">    <span class="kw">using</span> iterator = array_iterator&lt;array&gt; ;</a>
<a class="sourceLine" id="cb882-5" data-line-number="5"></a>
<a class="sourceLine" id="cb882-6" data-line-number="6">    <span class="co">// 先頭要素のイテレーター</span></a>
<a class="sourceLine" id="cb882-7" data-line-number="7">    iterator begin()</a>
<a class="sourceLine" id="cb882-8" data-line-number="8">    {</a>
<a class="sourceLine" id="cb882-9" data-line-number="9">        <span class="cf">return</span> array_iterator( *<span class="kw">this</span>, <span class="dv">0</span> ) ;</a>
<a class="sourceLine" id="cb882-10" data-line-number="10">    }</a>
<a class="sourceLine" id="cb882-11" data-line-number="11"></a>
<a class="sourceLine" id="cb882-12" data-line-number="12">    <span class="co">// 末尾要素へのイテレーター</span></a>
<a class="sourceLine" id="cb882-13" data-line-number="13">    iterator end()</a>
<a class="sourceLine" id="cb882-14" data-line-number="14">    {</a>
<a class="sourceLine" id="cb882-15" data-line-number="15">        <span class="cf">return</span> array_iterator( *<span class="kw">this</span>, N<span class="dv">-1</span> ) ;</a>
<a class="sourceLine" id="cb882-16" data-line-number="16">    }</a>
<a class="sourceLine" id="cb882-17" data-line-number="17">} ;</a></code></pre></div>
<p>何度も書くように、インデックスは0から始まる。要素がN個ある場合、最初の要素は0番目で、最後の要素はN-1番目だ。</p>
<p>インクリメント演算子<code>operator ++</code>にも対応しよう。</p>
<div class="sourceCode" id="cb883"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb883-1" data-line-number="1">array_iterator &amp; array_iterator::<span class="kw">operator</span> ++()</a>
<a class="sourceLine" id="cb883-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb883-3" data-line-number="3">    ++i ;</a>
<a class="sourceLine" id="cb883-4" data-line-number="4">    <span class="cf">return</span> *<span class="kw">this</span> ;</a>
<a class="sourceLine" id="cb883-5" data-line-number="5">}</a></code></pre></div>
<p>これで最低限のイテレーターは実装できた。早速試してみよう。</p>
<div class="sourceCode" id="cb884"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb884-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb884-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb884-3" data-line-number="3">    array&lt;<span class="dt">int</span>,<span class="dv">5</span>&gt; a = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</a>
<a class="sourceLine" id="cb884-4" data-line-number="4"></a>
<a class="sourceLine" id="cb884-5" data-line-number="5">    <span class="kw">auto</span> iter = a.begin() ;</a>
<a class="sourceLine" id="cb884-6" data-line-number="6"></a>
<a class="sourceLine" id="cb884-7" data-line-number="7">    <span class="bu">std::</span>cout &lt;&lt; *iter ; <span class="co">// 1</span></a>
<a class="sourceLine" id="cb884-8" data-line-number="8">    ++iter ;</a>
<a class="sourceLine" id="cb884-9" data-line-number="9">    <span class="bu">std::</span>cout &lt;&lt; *iter ; <span class="co">// 2</span></a>
<a class="sourceLine" id="cb884-10" data-line-number="10">}</a></code></pre></div>
<p>実は<code>operator ++</code>は2種類ある。前置演算子と後置演算子だ。</p>
<div class="sourceCode" id="cb885"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb885-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb885-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb885-3" data-line-number="3">    <span class="dt">int</span> i = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb885-4" data-line-number="4"></a>
<a class="sourceLine" id="cb885-5" data-line-number="5">    <span class="co">// 前置</span></a>
<a class="sourceLine" id="cb885-6" data-line-number="6">    <span class="bu">std::</span>cout &lt;&lt; ++i ;  <span class="co">// 1</span></a>
<a class="sourceLine" id="cb885-7" data-line-number="7">    <span class="co">// 後置</span></a>
<a class="sourceLine" id="cb885-8" data-line-number="8">    <span class="bu">std::</span>cout &lt;&lt; i++ ;  <span class="co">// 1</span></a>
<a class="sourceLine" id="cb885-9" data-line-number="9">    <span class="bu">std::</span>cout &lt;&lt; i      <span class="co">// 2</span></a>
<a class="sourceLine" id="cb885-10" data-line-number="10">}</a></code></pre></div>
<p>int型では、前置<code>operator ++</code>はオペランドの値を1加算した値にする。後置<code>operator ++</code>はオペランドの値を1加算するが、式を評価した結果は前のオペランドの値になる。</p>
<div class="sourceCode" id="cb886"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb886-1" data-line-number="1">++i ; <span class="co">// i+1</span></a>
<a class="sourceLine" id="cb886-2" data-line-number="2">i++ ; <span class="co">// i、ただしiの値はi+1</span></a></code></pre></div>
<p>後置<code>operator ++</code>のオーバーロードは以下のように書く。</p>
<div class="sourceCode" id="cb887"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb887-1" data-line-number="1"><span class="kw">struct</span> IntLike</a>
<a class="sourceLine" id="cb887-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb887-3" data-line-number="3">    <span class="dt">int</span> data {} ;</a>
<a class="sourceLine" id="cb887-4" data-line-number="4"></a>
<a class="sourceLine" id="cb887-5" data-line-number="5">    <span class="co">// 前置</span></a>
<a class="sourceLine" id="cb887-6" data-line-number="6">    IntLike &amp; <span class="kw">operator</span> ++()</a>
<a class="sourceLine" id="cb887-7" data-line-number="7">    {</a>
<a class="sourceLine" id="cb887-8" data-line-number="8">        ++data ;</a>
<a class="sourceLine" id="cb887-9" data-line-number="9">        <span class="cf">return</span> *<span class="kw">this</span> ;</a>
<a class="sourceLine" id="cb887-10" data-line-number="10">    }</a>
<a class="sourceLine" id="cb887-11" data-line-number="11">    <span class="co">// 後置</span></a>
<a class="sourceLine" id="cb887-12" data-line-number="12">    IntLike <span class="kw">operator</span> ++(<span class="dt">int</span>)</a>
<a class="sourceLine" id="cb887-13" data-line-number="13">    {</a>
<a class="sourceLine" id="cb887-14" data-line-number="14">        IntLike copy = *<span class="kw">this</span> ;</a>
<a class="sourceLine" id="cb887-15" data-line-number="15">        ++*<span class="kw">this</span> ;</a>
<a class="sourceLine" id="cb887-16" data-line-number="16">        <span class="cf">return</span> copy ;</a>
<a class="sourceLine" id="cb887-17" data-line-number="17">    }</a>
<a class="sourceLine" id="cb887-18" data-line-number="18">} ;</a></code></pre></div>
<p>このコードは慣れないとわかりにくいが、妥当な理由のあるコードだ。順番に説明しよう。</p>
<p>まず演算子オーバーロードの宣言だ。</p>
<div class="sourceCode" id="cb888"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb888-1" data-line-number="1"><span class="co">// 前置</span></a>
<a class="sourceLine" id="cb888-2" data-line-number="2">IntLike &amp; <span class="kw">operator</span> ++() ;</a>
<a class="sourceLine" id="cb888-3" data-line-number="3"><span class="co">// 後置</span></a>
<a class="sourceLine" id="cb888-4" data-line-number="4">IntLike <span class="kw">operator</span> ++(<span class="dt">int</span>) ;</a></code></pre></div>
<p>前置はリファレンスを返す。前置演算子の適用結果は更に変更できるようにするためだ。</p>
<div class="sourceCode" id="cb889"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb889-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb889-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb889-3" data-line-number="3">    <span class="dt">int</span> i { } ;</a>
<a class="sourceLine" id="cb889-4" data-line-number="4"></a>
<a class="sourceLine" id="cb889-5" data-line-number="5">    ++++i ;</a>
<a class="sourceLine" id="cb889-6" data-line-number="6">}</a></code></pre></div>
<p>もちろん、リファレンスを返さない実装は可能だ。そもそも何も値を返さないvoidを使うことも可能だ。</p>
<div class="sourceCode" id="cb890"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb890-1" data-line-number="1"><span class="kw">struct</span> S</a>
<a class="sourceLine" id="cb890-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb890-3" data-line-number="3">    <span class="dt">void</span> <span class="kw">operator</span> ++() { }</a>
<a class="sourceLine" id="cb890-4" data-line-number="4">} ;</a></code></pre></div>
<p>ただし、その場合<code>operator ++</code>に対して通常期待されるコードが書けなくなる。理由がない限り演算子の自然な挙動を目指すべきだ。</p>
<p>前置と後置は区別できる必要がある。C++はその区別の方法として、<code>int</code>型の仮引数をひとつとる<code>operator ++</code>を後置演算子だと認識する文法を採用した。この<code>int</code>型の実引数は前置と後置を区別するためだけのもので、値に意味はない。</p>
<div class="sourceCode" id="cb891"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb891-1" data-line-number="1"><span class="kw">struct</span> S</a>
<a class="sourceLine" id="cb891-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb891-3" data-line-number="3">    <span class="dt">void</span> <span class="kw">operator</span> ++( <span class="dt">int</span> x )</a>
<a class="sourceLine" id="cb891-4" data-line-number="4">    {</a>
<a class="sourceLine" id="cb891-5" data-line-number="5">        <span class="co">// 値に意味はない。</span></a>
<a class="sourceLine" id="cb891-6" data-line-number="6">        <span class="bu">std::</span>cout &lt;&lt; x ;</a>
<a class="sourceLine" id="cb891-7" data-line-number="7">    }</a>
<a class="sourceLine" id="cb891-8" data-line-number="8">} ;</a>
<a class="sourceLine" id="cb891-9" data-line-number="9"></a>
<a class="sourceLine" id="cb891-10" data-line-number="10"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb891-11" data-line-number="11">{</a>
<a class="sourceLine" id="cb891-12" data-line-number="12">    S s ;</a>
<a class="sourceLine" id="cb891-13" data-line-number="13">    <span class="co">// 演算子としての使用</span></a>
<a class="sourceLine" id="cb891-14" data-line-number="14">    s++ ;</a>
<a class="sourceLine" id="cb891-15" data-line-number="15">    <span class="co">// メンバー関数としての使用</span></a>
<a class="sourceLine" id="cb891-16" data-line-number="16">    s.<span class="kw">operator</span>++(<span class="dv">123</span>) ;</a>
<a class="sourceLine" id="cb891-17" data-line-number="17">}</a></code></pre></div>
<p>値に意味はないが、演算子として使用した場合、値は0になるというどうでもいい仕様がある。メンバー関数として使用すると好きな値を渡せるというこれまたどうでもいい仕様がある。テストには出ないので覚える必要はない。</p>
<p>前置は自然な挙動のためにリファレンスを返すが、後置はリファレンスではなくコピーした値を返す。</p>
<div class="sourceCode" id="cb892"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb892-1" data-line-number="1"><span class="co">// 後置</span></a>
<a class="sourceLine" id="cb892-2" data-line-number="2">IntLike IntLike::<span class="kw">operator</span> ++(<span class="dt">int</span>)</a>
<a class="sourceLine" id="cb892-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb892-4" data-line-number="4">    <span class="co">// コピーを作る</span></a>
<a class="sourceLine" id="cb892-5" data-line-number="5">    IntLike copy = *<span class="kw">this</span> ;</a>
<a class="sourceLine" id="cb892-6" data-line-number="6">    <span class="co">// 演算子が呼ばれたオブジェクトをインクリメントする</span></a>
<a class="sourceLine" id="cb892-7" data-line-number="7">    <span class="co">// 前置インクリメント演算子を呼んでいる</span></a>
<a class="sourceLine" id="cb892-8" data-line-number="8">    ++*<span class="kw">this</span> ;</a>
<a class="sourceLine" id="cb892-9" data-line-number="9">    <span class="co">// 値が変更されていないコピーを返す</span></a>
<a class="sourceLine" id="cb892-10" data-line-number="10">    <span class="cf">return</span> copy ;</a>
<a class="sourceLine" id="cb892-11" data-line-number="11">}</a></code></pre></div>
<p>このように実装すると、後置として自然な挙動が実装できる。</p>
<p><code>++*this</code>は後置インクリメント演算子が呼ばれたオブジェクトに対して前置インクリメント演算子を使用している。わかりにくければ前置インクリメントと同じ処理を書いてもいい。</p>
<div class="sourceCode" id="cb893"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb893-1" data-line-number="1">IntLike IntLike::<span class="kw">operator</span> ++(<span class="dt">int</span>)</a>
<a class="sourceLine" id="cb893-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb893-3" data-line-number="3">    IntLike copy = *<span class="kw">this</span> ;</a>
<a class="sourceLine" id="cb893-4" data-line-number="4">    <span class="co">// 同じ処理</span></a>
<a class="sourceLine" id="cb893-5" data-line-number="5">    ++data ;</a>
<a class="sourceLine" id="cb893-6" data-line-number="6">    <span class="cf">return</span> copy ;</a>
<a class="sourceLine" id="cb893-7" data-line-number="7">}</a></code></pre></div>
<p>IntLikeのように簡単な処理であればこれでもいいが、もっと複雑な何行もある処理の場合は、すでに実装した前置インクリメントを呼び出したほうが楽だ。コードの重複を省けるのでインクリメントの処理を変更するときに、二箇所に同じ変更をしなくても済む。</p>
<p>以上を踏まえて、array_iteratorに後置インクリメント演算子を実装しよう。</p>
<div class="sourceCode" id="cb894"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb894-1" data-line-number="1">array_iterator array_iterator::<span class="kw">operator</span> ++(<span class="dt">int</span>)</a>
<a class="sourceLine" id="cb894-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb894-3" data-line-number="3">    array_iterator copy = *<span class="kw">this</span> ;</a>
<a class="sourceLine" id="cb894-4" data-line-number="4">    ++*<span class="kw">this</span> ;</a>
<a class="sourceLine" id="cb894-5" data-line-number="5">    <span class="cf">return</span> copy ;</a>
<a class="sourceLine" id="cb894-6" data-line-number="6">}</a></code></pre></div>
<p>デクリメント演算子<code>operator --</code>の実装はインクリメント演算子<code>operator ++</code>と同じだ。ただ処理がインクリメントではなくデクリメントになっているだけだ。</p>
<div class="sourceCode" id="cb895"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb895-1" data-line-number="1"><span class="co">// 前置</span></a>
<a class="sourceLine" id="cb895-2" data-line-number="2">array_iterator &amp; array_iterator::<span class="kw">operator</span> --()</a>
<a class="sourceLine" id="cb895-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb895-4" data-line-number="4">    -- i ;</a>
<a class="sourceLine" id="cb895-5" data-line-number="5">    <span class="cf">return</span> *<span class="kw">this</span> ;</a>
<a class="sourceLine" id="cb895-6" data-line-number="6">}</a>
<a class="sourceLine" id="cb895-7" data-line-number="7"><span class="co">// 後置</span></a>
<a class="sourceLine" id="cb895-8" data-line-number="8">array_iterator array_iterator::<span class="kw">operator</span> --(<span class="dt">int</span>)</a>
<a class="sourceLine" id="cb895-9" data-line-number="9">{</a>
<a class="sourceLine" id="cb895-10" data-line-number="10">    array_iterator copy = *<span class="kw">this</span> ;</a>
<a class="sourceLine" id="cb895-11" data-line-number="11">    --*<span class="kw">this</span> ;</a>
<a class="sourceLine" id="cb895-12" data-line-number="12">    <span class="cf">return</span> copy ;</a>
<a class="sourceLine" id="cb895-13" data-line-number="13">}</a></code></pre></div>
<p>ここまでくればイテレーターに必要な操作はあと一つ。比較だ。</p>
<p>イテレーターは同じ要素を指している場合に等しい。つまり、オペレーター<code>a</code>と<code>b</code>が同じ要素を指しているならば、<code>a == b</code>は<code>true</code>で<code>a != b</code>は<code>false</code>だ。違う要素を指しているならば<code>a == b</code>は<code>false</code>で<code>a != b</code>は<code>true</code>だ。</p>
<div class="sourceCode" id="cb896"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb896-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb896-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb896-3" data-line-number="3">    <span class="bu">std::</span>array&lt;<span class="dt">int</span>, <span class="dv">5</span>&gt; a = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</a>
<a class="sourceLine" id="cb896-4" data-line-number="4"></a>
<a class="sourceLine" id="cb896-5" data-line-number="5">    <span class="kw">auto</span> a = a.begin() ;</a>
<a class="sourceLine" id="cb896-6" data-line-number="6">    <span class="kw">auto</span> b = a.begin() ;</a>
<a class="sourceLine" id="cb896-7" data-line-number="7"></a>
<a class="sourceLine" id="cb896-8" data-line-number="8">    <span class="co">// true</span></a>
<a class="sourceLine" id="cb896-9" data-line-number="9">    <span class="dt">bool</span> b1 = (a == b) ;</a>
<a class="sourceLine" id="cb896-10" data-line-number="10">    <span class="co">// false</span></a>
<a class="sourceLine" id="cb896-11" data-line-number="11">    <span class="dt">bool</span> b2 = (a != b) ;</a>
<a class="sourceLine" id="cb896-12" data-line-number="12">    ++a ;</a>
<a class="sourceLine" id="cb896-13" data-line-number="13">    <span class="co">// false</span></a>
<a class="sourceLine" id="cb896-14" data-line-number="14">    <span class="dt">bool</span> b3 = (a == b) ;</a>
<a class="sourceLine" id="cb896-15" data-line-number="15">    <span class="co">// true</span></a>
<a class="sourceLine" id="cb896-16" data-line-number="16">    <span class="dt">bool</span> b4 = (a != b) ;</a>
<a class="sourceLine" id="cb896-17" data-line-number="17">}</a></code></pre></div>
<p>イテレーターは比較ができるので、イテレーターが終端に到達するまでループを回すことができる。</p>
<div class="sourceCode" id="cb897"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb897-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb897-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb897-3" data-line-number="3">    <span class="bu">std::</span>array&lt;<span class="dt">int</span>,<span class="dv">5</span>&gt; a = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</a>
<a class="sourceLine" id="cb897-4" data-line-number="4"></a>
<a class="sourceLine" id="cb897-5" data-line-number="5">            <span class="co">// 変数宣言</span></a>
<a class="sourceLine" id="cb897-6" data-line-number="6">    <span class="cf">for</span> (   <span class="kw">auto</span> iter = <span class="bu">std::</span>begin(a),</a>
<a class="sourceLine" id="cb897-7" data-line-number="7">            last = <span class="bu">std::</span>end(a) ;</a>
<a class="sourceLine" id="cb897-8" data-line-number="8">            <span class="co">// 終了条件</span></a>
<a class="sourceLine" id="cb897-9" data-line-number="9">            iter != last ;</a>
<a class="sourceLine" id="cb897-10" data-line-number="10">            <span class="co">// ループごとの処理</span></a>
<a class="sourceLine" id="cb897-11" data-line-number="11">            ++iter )</a>
<a class="sourceLine" id="cb897-12" data-line-number="12">    {</a>
<a class="sourceLine" id="cb897-13" data-line-number="13">        <span class="bu">std::</span>cout &lt;&lt; *iter ;</a>
<a class="sourceLine" id="cb897-14" data-line-number="14">    }</a>
<a class="sourceLine" id="cb897-15" data-line-number="15">}</a></code></pre></div>
<p>イテレーターは比較ができるので、各種アルゴリズムに渡すことができる。</p>
<p>array_iteratorの比較は、単にデータメンバー<code>i</code>の比較でよい。</p>
<div class="sourceCode" id="cb898"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb898-1" data-line-number="1"><span class="dt">bool</span> array_iterator::<span class="kw">operator</span> ==( array_iterator <span class="at">const</span> &amp; right )</a>
<a class="sourceLine" id="cb898-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb898-3" data-line-number="3">    <span class="cf">return</span> i == right.i ;</a>
<a class="sourceLine" id="cb898-4" data-line-number="4">}</a>
<a class="sourceLine" id="cb898-5" data-line-number="5"><span class="dt">bool</span> array_iterator::<span class="kw">operator</span> !=( array_iterator <span class="at">const</span> &amp; right )</a>
<a class="sourceLine" id="cb898-6" data-line-number="6">{</a>
<a class="sourceLine" id="cb898-7" data-line-number="7">    <span class="cf">return</span> i != right.i ;</a>
<a class="sourceLine" id="cb898-8" data-line-number="8">}</a></code></pre></div>
<p>これで自作の<code>array</code>と<code>array_iterator</code>はアルゴリズムに渡せるようになった。</p>
<div class="sourceCode" id="cb899"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb899-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb899-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb899-3" data-line-number="3">    array&lt;<span class="dt">int</span>, <span class="dv">5</span>&gt; a = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</a>
<a class="sourceLine" id="cb899-4" data-line-number="4"></a>
<a class="sourceLine" id="cb899-5" data-line-number="5">    <span class="bu">std::</span>for_each( <span class="bu">std::</span>begin(a), <span class="bu">std::</span>end(a),</a>
<a class="sourceLine" id="cb899-6" data-line-number="6">        [](<span class="kw">auto</span> x){ <span class="bu">std::</span>cout &lt;&lt; x ; } ) ;</a>
<a class="sourceLine" id="cb899-7" data-line-number="7">}</a></code></pre></div>
<h2 id="残りのイテレーターの実装">残りのイテレーターの実装</h2>
<p><code>std::array</code>や<code>std::vector</code>のイテレーターはとても柔軟にできている。</p>
<p>例えばイテレーター<code>i</code>の参照する要素を3つ進めたい場合を考えよう。</p>
<div class="sourceCode" id="cb900"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb900-1" data-line-number="1">++i ; <span class="co">// 1</span></a>
<a class="sourceLine" id="cb900-2" data-line-number="2">++i ; <span class="co">// 2</span></a>
<a class="sourceLine" id="cb900-3" data-line-number="3">++i ; <span class="co">// 3</span></a></code></pre></div>
<p>これは非効率的だ。もっと効率的なイテレーターの進め方として、<code>operator +=</code>がある。</p>
<div class="sourceCode" id="cb901"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb901-1" data-line-number="1">i += <span class="dv">3</span> ;</a></code></pre></div>
<p><code>i += n</code>はイテレーター<code>i</code>をn回進める。</p>
<p><code>operator +</code>もある</p>
<div class="sourceCode" id="cb902"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb902-1" data-line-number="1"><span class="kw">auto</span> j = i + <span class="dv">3</span> ;</a></code></pre></div>
<p>イテレーター<code>j</code>の値はイテレーター<code>i</code>を3つ進めた値になる。イテレーター<code>i</code>の値は変わらない。</p>
<p>実装は簡単だ。データメンバー<code>i</code>に対して同じ計算をする。</p>
<div class="sourceCode" id="cb903"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb903-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> Array &gt;</a>
<a class="sourceLine" id="cb903-2" data-line-number="2"><span class="kw">struct</span> array_iterator</a>
<a class="sourceLine" id="cb903-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb903-4" data-line-number="4">    Array &amp; a ;</a>
<a class="sourceLine" id="cb903-5" data-line-number="5">    <span class="bu">std::</span>size_t i ;</a>
<a class="sourceLine" id="cb903-6" data-line-number="6"></a>
<a class="sourceLine" id="cb903-7" data-line-number="7">    array_iterator &amp; <span class="kw">operator</span> += ( <span class="bu">std::</span>size_t n )</a>
<a class="sourceLine" id="cb903-8" data-line-number="8">    {</a>
<a class="sourceLine" id="cb903-9" data-line-number="9">        i += n ;</a>
<a class="sourceLine" id="cb903-10" data-line-number="10">        <span class="cf">return</span> *<span class="kw">this</span> ;</a>
<a class="sourceLine" id="cb903-11" data-line-number="11">    }</a>
<a class="sourceLine" id="cb903-12" data-line-number="12"></a>
<a class="sourceLine" id="cb903-13" data-line-number="13">    array_iterator <span class="kw">operator</span> + ( <span class="bu">std::</span>size_t n ) <span class="at">const</span></a>
<a class="sourceLine" id="cb903-14" data-line-number="14">    {</a>
<a class="sourceLine" id="cb903-15" data-line-number="15">        <span class="kw">auto</span> copy = *<span class="kw">this</span> ;</a>
<a class="sourceLine" id="cb903-16" data-line-number="16">        copy += n ;</a>
<a class="sourceLine" id="cb903-17" data-line-number="17">        <span class="cf">return</span> copy ;</a>
<a class="sourceLine" id="cb903-18" data-line-number="18">    }</a>
<a class="sourceLine" id="cb903-19" data-line-number="19">} ;</a></code></pre></div>
<p><code>operator +</code>はオペランドの値を変更しないので<code>const</code>にできる。</p>
<p>同様に、<code>operator -=</code>とoperator <code>-</code>もある。上を参考に自分で実装してみよう。</p>
<p><code>operator +</code>によって任意のn個先の要素を使うことができるようになったので、イテレーターiのn個先の要素を参照したければ、以下のように<code>*(i+n)</code>も書ける。</p>
<div class="sourceCode" id="cb904"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb904-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb904-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb904-3" data-line-number="3">    <span class="bu">std::</span>array&lt;<span class="dt">int</span>, <span class="dv">5</span>&gt; a = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</a>
<a class="sourceLine" id="cb904-4" data-line-number="4"></a>
<a class="sourceLine" id="cb904-5" data-line-number="5">    <span class="bu">std::</span>cout &lt;&lt; a[<span class="dv">3</span>] ; <span class="co">// 4</span></a>
<a class="sourceLine" id="cb904-6" data-line-number="6"></a>
<a class="sourceLine" id="cb904-7" data-line-number="7">    <span class="kw">auto</span> i = a.begin() ;</a>
<a class="sourceLine" id="cb904-8" data-line-number="8"></a>
<a class="sourceLine" id="cb904-9" data-line-number="9">    <span class="bu">std::</span>cout &lt;&lt; *(i + <span class="dv">3</span>) ; <span class="co">// 4</span></a>
<a class="sourceLine" id="cb904-10" data-line-number="10">}</a></code></pre></div>
<p>カッコが必要なのは、演算子の評価順序の都合だ。<code>*i + 3</code>は<code>(*i) + 3</code>であり、<code>i</code>の指す要素に対して<code>+3</code>される。<code>*(i+3)</code>は<code>i</code>の指す要素の3つ先の要素の値を読む。</p>
<p>イテレーターiのn個先の要素を読み書きするのにいちいち<code>*(i+n)</code>と書くのは面倒なので、<code>std::array</code>や<code>std::vector</code>のイテレーターには<code>operator []</code>がある。これを使うと<code>i[n]</code>と書ける。</p>
<div class="sourceCode" id="cb905"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb905-1" data-line-number="1"></a>
<a class="sourceLine" id="cb905-2" data-line-number="2"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb905-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb905-4" data-line-number="4">    <span class="bu">std::</span>array&lt;<span class="dt">int</span>, <span class="dv">5</span>&gt; a = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</a>
<a class="sourceLine" id="cb905-5" data-line-number="5"></a>
<a class="sourceLine" id="cb905-6" data-line-number="6">    <span class="bu">std::</span>cout &lt;&lt; a[<span class="dv">3</span>] ; <span class="co">// 4</span></a>
<a class="sourceLine" id="cb905-7" data-line-number="7"></a>
<a class="sourceLine" id="cb905-8" data-line-number="8">    <span class="kw">auto</span> i = a.begin() ;</a>
<a class="sourceLine" id="cb905-9" data-line-number="9"></a>
<a class="sourceLine" id="cb905-10" data-line-number="10">    <span class="bu">std::</span>cout &lt;&lt; *(i + <span class="dv">3</span>) ; <span class="co">// 4</span></a>
<a class="sourceLine" id="cb905-11" data-line-number="11">}</a></code></pre></div>
<p><code>operator []</code>の実装は文字通り<code>*(i+n)</code>と同じことをするだけでよい。</p>
<div class="sourceCode" id="cb906"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb906-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> Array &gt;</a>
<a class="sourceLine" id="cb906-2" data-line-number="2"><span class="kw">struct</span> array_iterator</a>
<a class="sourceLine" id="cb906-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb906-4" data-line-number="4">    <span class="kw">typename</span> Array::reference</a>
<a class="sourceLine" id="cb906-5" data-line-number="5">    <span class="kw">operator</span> [] ( <span class="bu">std::</span>size_t n ) <span class="at">const</span></a>
<a class="sourceLine" id="cb906-6" data-line-number="6">    {</a>
<a class="sourceLine" id="cb906-7" data-line-number="7">        <span class="cf">return</span> *( *<span class="kw">this</span> + n ) ;</a>
<a class="sourceLine" id="cb906-8" data-line-number="8">    }</a>
<a class="sourceLine" id="cb906-9" data-line-number="9"></a>
<a class="sourceLine" id="cb906-10" data-line-number="10">    <span class="co">// その他のメンバー</span></a>
<a class="sourceLine" id="cb906-11" data-line-number="11">} ;</a></code></pre></div>
<p>この<code>operator []</code>は、<code>array_iterator</code>のデータメンバーを変更しないのでconst修飾できる。</p>
<p><code>*this</code>というのはこのイテレーターのオブジェクトなので、それに対してすでに実装済みの<code>operator +</code>を適用し、その結果に<code>operator *</code>を適用している。既存の実装を使わない場合、return文は以下のようになる。</p>
<div class="sourceCode" id="cb907"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb907-1" data-line-number="1"><span class="cf">return</span> a[i+n] ;</a></code></pre></div>
<p>こちらのほうが一見簡単なように見えるが、<code>operator +</code>や<code>operator *</code>の実装が複雑な場合、この方法では同じコードを複数の箇所に書かなければならず、コードを修正するときは同じ変更を複数の箇所に行わなければならない。すでに実装したメンバー関数は積極的に使って楽をしていこう。</p>
<p>イテレーターは大小比較ができる。</p>
<div class="sourceCode" id="cb908"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb908-1" data-line-number="1">a &lt;  b ;</a>
<a class="sourceLine" id="cb908-2" data-line-number="2">a &lt;= b ;</a>
<a class="sourceLine" id="cb908-3" data-line-number="3">a &gt;  b ;</a>
<a class="sourceLine" id="cb908-4" data-line-number="4">a &gt;= b ;</a></code></pre></div>
<p>イテレーターの大小はどういう意味を持つのか。<code>array</code>のようにイテレーターが線形に順序のある要素を参照している場合で、前の要素を参照しているイテレーターはあとの要素を参照しているイテレーターより小さい。</p>
<div class="sourceCode" id="cb909"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb909-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb909-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb909-3" data-line-number="3">    <span class="bu">std::</span>array&lt;<span class="dt">int</span>, <span class="dv">5</span>&gt; a = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</a>
<a class="sourceLine" id="cb909-4" data-line-number="4"></a>
<a class="sourceLine" id="cb909-5" data-line-number="5">    <span class="kw">auto</span> a = <span class="bu">std::</span>begin(a) ;</a>
<a class="sourceLine" id="cb909-6" data-line-number="6">    <span class="kw">auto</span> b = a + <span class="dv">1</span> ;</a>
<a class="sourceLine" id="cb909-7" data-line-number="7"></a>
<a class="sourceLine" id="cb909-8" data-line-number="8">    a &lt;  b ; <span class="co">// true</span></a>
<a class="sourceLine" id="cb909-9" data-line-number="9">    a &lt;= b ; <span class="co">// true</span></a>
<a class="sourceLine" id="cb909-10" data-line-number="10">    a &gt;  b ; <span class="co">// false</span></a>
<a class="sourceLine" id="cb909-11" data-line-number="11">    a &gt;= b ; <span class="co">// false</span></a>
<a class="sourceLine" id="cb909-12" data-line-number="12">}</a></code></pre></div>
<p>自作の<code>array</code>の場合、単にデータメンバー<code>i</code>を比較する。</p>
<div class="sourceCode" id="cb910"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb910-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> Array &gt;</a>
<a class="sourceLine" id="cb910-2" data-line-number="2"><span class="kw">struct</span> array_iterator</a>
<a class="sourceLine" id="cb910-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb910-4" data-line-number="4">    Array &amp; a ;</a>
<a class="sourceLine" id="cb910-5" data-line-number="5">    <span class="bu">std::</span>size_t i ;</a>
<a class="sourceLine" id="cb910-6" data-line-number="6"></a>
<a class="sourceLine" id="cb910-7" data-line-number="7">    <span class="dt">bool</span> <span class="kw">operator</span> &lt; ( array_iterator <span class="at">const</span> &amp; right ) <span class="at">const</span></a>
<a class="sourceLine" id="cb910-8" data-line-number="8">    {</a>
<a class="sourceLine" id="cb910-9" data-line-number="9">        <span class="cf">return</span> i &lt; right ;</a>
<a class="sourceLine" id="cb910-10" data-line-number="10">    }</a>
<a class="sourceLine" id="cb910-11" data-line-number="11">}</a></code></pre></div>
<p>残りの演算子も同様に実装できる。</p>
<h2 id="constなイテレーター-const_iterator">constなイテレーター: const_iterator</h2>
<p><code>std::array&lt;T,N&gt;</code>は通常のイテレーターである<code>std::array&lt;T,N&gt;::iterator</code>の他に、constなイテレーターである<code>std::array&lt;T,N&gt;::const_iterator</code>を提供している。</p>
<div class="sourceCode" id="cb911"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb911-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb911-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb911-3" data-line-number="3">    <span class="bu">std::</span>array&lt;<span class="dt">int</span>,<span class="dv">5</span>&gt; a = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</a>
<a class="sourceLine" id="cb911-4" data-line-number="4"></a>
<a class="sourceLine" id="cb911-5" data-line-number="5">    <span class="co">// iterator</span></a>
<a class="sourceLine" id="cb911-6" data-line-number="6">    <span class="bu">std::</span>array&lt;<span class="dt">int</span>,<span class="dv">5</span>&gt;::iterator iter = a.begin() ;</a>
<a class="sourceLine" id="cb911-7" data-line-number="7">    <span class="co">// const_iterator</span></a>
<a class="sourceLine" id="cb911-8" data-line-number="8">    <span class="bu">std::</span>array&lt;<span class="dt">int</span>,<span class="dv">5</span>&gt;::const_iterator const_iter = a.cbegin() ;</a>
<a class="sourceLine" id="cb911-9" data-line-number="9">}</a></code></pre></div>
<p><code>const_iterator</code>は<code>const iterator</code>ではない。<code>const_iterator</code>とはそれ自体が型名だ。<code>const</code>というのは型名を修飾する別の機能だ。</p>
<p>そのため、constの有無の2種類の状態と、<code>iterator</code>, <code>const_iterator</code>の2つの型をかけ合わせた、以下の型が存在する。</p>
<ul>
<li><code>iterator</code></li>
<li><code>const iterator</code></li>
<li><code>const_iterator</code></li>
<li><code>const const_iterator</code></li>
</ul>
<div class="sourceCode" id="cb912"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb912-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb912-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb912-3" data-line-number="3">    <span class="kw">using</span> Array = <span class="bu">std::</span>array&lt;<span class="dt">int</span>,<span class="dv">5</span>&gt; ;</a>
<a class="sourceLine" id="cb912-4" data-line-number="4"></a>
<a class="sourceLine" id="cb912-5" data-line-number="5">    <span class="co">// iterator </span></a>
<a class="sourceLine" id="cb912-6" data-line-number="6">    Array::iterator i ;</a>
<a class="sourceLine" id="cb912-7" data-line-number="7">    <span class="co">// const iterator</span></a>
<a class="sourceLine" id="cb912-8" data-line-number="8">    <span class="at">const</span> Array::iterator c_i ;</a>
<a class="sourceLine" id="cb912-9" data-line-number="9">    <span class="co">// const_iterator</span></a>
<a class="sourceLine" id="cb912-10" data-line-number="10">    Array::const_iterator ci ;</a>
<a class="sourceLine" id="cb912-11" data-line-number="11">    <span class="co">// const const_iterator</span></a>
<a class="sourceLine" id="cb912-12" data-line-number="12">    <span class="at">const</span> Array::const_iterator c_ci ;</a>
<a class="sourceLine" id="cb912-13" data-line-number="13">}</a></code></pre></div>
<p><code>const_iterator</code>は<code>iterator</code>とは別の型だ。自作の<code>array</code>に実装するならば以下のようになる。</p>
<div class="sourceCode" id="cb913"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb913-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> T, <span class="bu">std::</span>size_t N &gt;</a>
<a class="sourceLine" id="cb913-2" data-line-number="2"><span class="kw">struct</span> array</a>
<a class="sourceLine" id="cb913-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb913-4" data-line-number="4">    <span class="kw">using</span> iterator          = array_iterator&lt;array&gt; ;</a>
<a class="sourceLine" id="cb913-5" data-line-number="5">    <span class="kw">using</span> const_iterator   = array_const_iterator&lt;array&gt; ;</a>
<a class="sourceLine" id="cb913-6" data-line-number="6">} ;</a></code></pre></div>
<p>それぞれの型に対して、constキーワードをつけた型とそうでない型が存在する。</p>
<p><code>const_iterator</code>を得る方法はいくつかある。</p>
<ul>
<li>constなarrayの<code>begin/end</code>を呼び出す</li>
</ul>
<div class="sourceCode" id="cb914"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb914-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb914-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb914-3" data-line-number="3">    <span class="co">// constなarray</span></a>
<a class="sourceLine" id="cb914-4" data-line-number="4">    <span class="at">const</span> <span class="bu">std::</span>array&lt;<span class="dt">int</span>, <span class="dv">5</span>&gt; a = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</a>
<a class="sourceLine" id="cb914-5" data-line-number="5"></a>
<a class="sourceLine" id="cb914-6" data-line-number="6">    <span class="co">// const_iterator</span></a>
<a class="sourceLine" id="cb914-7" data-line-number="7">    <span class="kw">auto</span> i = a.begin() ;</a>
<a class="sourceLine" id="cb914-8" data-line-number="8">}</a></code></pre></div>
<ul>
<li><code>cbegin/cend</code>を呼び出す</li>
</ul>
<div class="sourceCode" id="cb915"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb915-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb915-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb915-3" data-line-number="3">    <span class="bu">std::</span>array&lt;<span class="dt">int</span>, <span class="dv">5</span>&gt; a = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</a>
<a class="sourceLine" id="cb915-4" data-line-number="4"></a>
<a class="sourceLine" id="cb915-5" data-line-number="5">    <span class="co">// const_iterator</span></a>
<a class="sourceLine" id="cb915-6" data-line-number="6">    <span class="kw">auto</span> i = a.cbegin() ;</a>
<a class="sourceLine" id="cb915-7" data-line-number="7">}</a></code></pre></div>
<ul>
<li><code>iterator</code>から<code>const_iterator</code>への変換</li>
</ul>
<div class="sourceCode" id="cb916"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb916-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb916-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb916-3" data-line-number="3">    <span class="kw">using</span> Array = <span class="bu">std::</span>array&lt;<span class="dt">int</span>,<span class="dv">5</span>&gt; ;</a>
<a class="sourceLine" id="cb916-4" data-line-number="4">    Array a = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</a>
<a class="sourceLine" id="cb916-5" data-line-number="5"></a>
<a class="sourceLine" id="cb916-6" data-line-number="6">    <span class="co">// iterator</span></a>
<a class="sourceLine" id="cb916-7" data-line-number="7">    Array::iterator i = a.begin() ;</a>
<a class="sourceLine" id="cb916-8" data-line-number="8">    <span class="co">// iteratorからconst_iteratorへの変換</span></a>
<a class="sourceLine" id="cb916-9" data-line-number="9">    Array::const_iterator j = i ;</a>
<a class="sourceLine" id="cb916-10" data-line-number="10">}</a></code></pre></div>
<p>constキーワードはすでに学んだように、オブジェクトの値を変更できないようにする機能だ。</p>
<p>なぜ<code>const_iterator</code>が存在するのか。<code>const iterator</code>ではだめなのか。その理由は、<code>const iterator</code>は値の変更ができないためだ。</p>
<div class="sourceCode" id="cb917"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb917-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb917-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb917-3" data-line-number="3">    <span class="kw">using</span> Array = <span class="bu">std::</span>array&lt;<span class="dt">int</span>,<span class="dv">5</span>&gt; ;</a>
<a class="sourceLine" id="cb917-4" data-line-number="4">    Array a = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</a>
<a class="sourceLine" id="cb917-5" data-line-number="5"></a>
<a class="sourceLine" id="cb917-6" data-line-number="6">    <span class="co">// const iterator</span></a>
<a class="sourceLine" id="cb917-7" data-line-number="7">    <span class="at">const</span> Array::iterator iter = a.begin() ;</a>
<a class="sourceLine" id="cb917-8" data-line-number="8"></a>
<a class="sourceLine" id="cb917-9" data-line-number="9">    <span class="co">// エラー</span></a>
<a class="sourceLine" id="cb917-10" data-line-number="10">    <span class="co">// constなオブジェクトは変更できない</span></a>
<a class="sourceLine" id="cb917-11" data-line-number="11">    ++iter ;</a>
<a class="sourceLine" id="cb917-12" data-line-number="12"></a>
<a class="sourceLine" id="cb917-13" data-line-number="13">    <span class="co">// Ok</span></a>
<a class="sourceLine" id="cb917-14" data-line-number="14">    <span class="co">// iterは変更していない</span></a>
<a class="sourceLine" id="cb917-15" data-line-number="15">    <span class="kw">auto</span> next_iter = iter + <span class="dv">1</span> ;</a>
<a class="sourceLine" id="cb917-16" data-line-number="16">}</a></code></pre></div>
<p><code>const_iterator</code>ならばイテレーター自体の変更はできる。イテレーターが参照する要素の変更はできない。</p>
<div class="sourceCode" id="cb918"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb918-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb918-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb918-3" data-line-number="3">    <span class="kw">using</span> Array = <span class="bu">std::</span>array&lt;<span class="dt">int</span>,<span class="dv">5</span>&gt; ;</a>
<a class="sourceLine" id="cb918-4" data-line-number="4">    Array a = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</a>
<a class="sourceLine" id="cb918-5" data-line-number="5"></a>
<a class="sourceLine" id="cb918-6" data-line-number="6">    <span class="kw">auto</span> citer = a.begin() ;</a>
<a class="sourceLine" id="cb918-7" data-line-number="7"></a>
<a class="sourceLine" id="cb918-8" data-line-number="8">    <span class="co">// OK</span></a>
<a class="sourceLine" id="cb918-9" data-line-number="9">    <span class="co">// イテレーター自体の変更</span></a>
<a class="sourceLine" id="cb918-10" data-line-number="10">    ++citer ;</a>
<a class="sourceLine" id="cb918-11" data-line-number="11"></a>
<a class="sourceLine" id="cb918-12" data-line-number="12">    <span class="co">// OK</span></a>
<a class="sourceLine" id="cb918-13" data-line-number="13">    <span class="co">// 要素を変更しない</span></a>
<a class="sourceLine" id="cb918-14" data-line-number="14">    <span class="bu">std::</span>cout &lt;&lt; *citer ;</a>
<a class="sourceLine" id="cb918-15" data-line-number="15"></a>
<a class="sourceLine" id="cb918-16" data-line-number="16">    <span class="co">// エラー</span></a>
<a class="sourceLine" id="cb918-17" data-line-number="17">    <span class="co">// 要素を変更してる</span></a>
<a class="sourceLine" id="cb918-18" data-line-number="18">    *citer = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb918-19" data-line-number="19">}</a></code></pre></div>
<p><code>const const_iterator</code>は<code>const_iterator</code>の<code>const</code>だ。<code>const const_iterator</code>は<code>const iterator</code>と同じく、イテレーター自体の変更ができない。</p>
<div class="sourceCode" id="cb919"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb919-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb919-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb919-3" data-line-number="3">    <span class="kw">using</span> Array = <span class="bu">std::</span>array&lt;<span class="dt">int</span>,<span class="dv">5</span>&gt; ;</a>
<a class="sourceLine" id="cb919-4" data-line-number="4">    Array a = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</a>
<a class="sourceLine" id="cb919-5" data-line-number="5"></a>
<a class="sourceLine" id="cb919-6" data-line-number="6">    <span class="co">// const const_iterator</span></a>
<a class="sourceLine" id="cb919-7" data-line-number="7">    <span class="kw">auto</span> <span class="at">const</span> iter = a.begin() ;</a>
<a class="sourceLine" id="cb919-8" data-line-number="8"></a>
<a class="sourceLine" id="cb919-9" data-line-number="9">    <span class="co">// エラー</span></a>
<a class="sourceLine" id="cb919-10" data-line-number="10">    <span class="co">// constなオブジェクトは変更できない</span></a>
<a class="sourceLine" id="cb919-11" data-line-number="11">    ++iter ;</a>
<a class="sourceLine" id="cb919-12" data-line-number="12"></a>
<a class="sourceLine" id="cb919-13" data-line-number="13">    <span class="co">// Ok</span></a>
<a class="sourceLine" id="cb919-14" data-line-number="14">    <span class="co">// iterは変更していない</span></a>
<a class="sourceLine" id="cb919-15" data-line-number="15">    <span class="kw">auto</span> next_iter = iter + <span class="dv">1</span> ;</a>
<a class="sourceLine" id="cb919-16" data-line-number="16">}</a></code></pre></div>
<p><code>auto const</code>もしくは<code>const auto</code>を使うと、変数の型を自動で推定してくれるが、constがつくようになる。</p>
<p><code>const_iterator</code>はどう実装するのか。まず<code>array</code>にネストされた型名<code>const_iterator</code>を追加する。</p>
<div class="sourceCode" id="cb920"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb920-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> T, <span class="bu">std::</span>size_t N &gt;</a>
<a class="sourceLine" id="cb920-2" data-line-number="2"><span class="kw">struct</span> array</a>
<a class="sourceLine" id="cb920-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb920-4" data-line-number="4">    <span class="kw">using</span> iterator = array_iterator&lt;array&gt; ;</a>
<a class="sourceLine" id="cb920-5" data-line-number="5">    <span class="kw">using</span> const_iterator = array_const_iterator&lt;array&gt; ;</a>
<a class="sourceLine" id="cb920-6" data-line-number="6">} ;</a></code></pre></div>
<p><code>array</code>に<code>const_iterator</code>を返す<code>cbegin/cend</code>と、<code>const array</code>のときに<code>const_iterator</code>を返す<code>begin/end</code>を追加する。</p>
<div class="sourceCode" id="cb921"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb921-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> T, <span class="bu">std::</span>size_t N &gt;</a>
<a class="sourceLine" id="cb921-2" data-line-number="2"><span class="kw">struct</span> array</a>
<a class="sourceLine" id="cb921-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb921-4" data-line-number="4">    <span class="kw">using</span> iterator = array_iterator&lt;array&gt; ;</a>
<a class="sourceLine" id="cb921-5" data-line-number="5">    <span class="kw">using</span> const_iterator = array_const_iterator&lt;array&gt; ;</a>
<a class="sourceLine" id="cb921-6" data-line-number="6"></a>
<a class="sourceLine" id="cb921-7" data-line-number="7">    <span class="co">// const arrayのときにconst_iteratorを返す</span></a>
<a class="sourceLine" id="cb921-8" data-line-number="8">    const_iterator begin() <span class="at">const</span></a>
<a class="sourceLine" id="cb921-9" data-line-number="9">    { <span class="cf">return</span> const_iterator(*<span class="kw">this</span>, <span class="dv">0</span>) ; }</a>
<a class="sourceLine" id="cb921-10" data-line-number="10">    const_iterator end() <span class="at">const</span></a>
<a class="sourceLine" id="cb921-11" data-line-number="11">    { <span class="cf">return</span> const_iterator(*<span class="kw">this</span>, N<span class="dv">-1</span>) ; }</a>
<a class="sourceLine" id="cb921-12" data-line-number="12"></a>
<a class="sourceLine" id="cb921-13" data-line-number="13">    <span class="co">// 常にconst_iteratorを返す</span></a>
<a class="sourceLine" id="cb921-14" data-line-number="14">    const_iterator cbegin() <span class="at">const</span></a>
<a class="sourceLine" id="cb921-15" data-line-number="15">    { <span class="cf">return</span> const_iterator(*<span class="kw">this</span>, <span class="dv">0</span>) ; }</a>
<a class="sourceLine" id="cb921-16" data-line-number="16">    const_iterator cend() <span class="at">const</span></a>
<a class="sourceLine" id="cb921-17" data-line-number="17">    { <span class="cf">return</span> const_iterator(*<span class="kw">this</span>, N<span class="dv">-1</span>) ; }</a>
<a class="sourceLine" id="cb921-18" data-line-number="18"></a>
<a class="sourceLine" id="cb921-19" data-line-number="19">    <span class="co">// その他のメンバー</span></a>
<a class="sourceLine" id="cb921-20" data-line-number="20">} ;</a></code></pre></div>
<p>あとは<code>array_const_iterator&lt;array&gt;</code>を実装する。その実装は<code>array_iterator&lt;array&gt;</code>とほぼ同じだ。</p>
<div class="sourceCode" id="cb922"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb922-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> Array &gt;</a>
<a class="sourceLine" id="cb922-2" data-line-number="2"><span class="kw">struct</span> array_const_iterator</a>
<a class="sourceLine" id="cb922-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb922-4" data-line-number="4">    Array <span class="at">const</span> &amp; a ;</a>
<a class="sourceLine" id="cb922-5" data-line-number="5">    <span class="bu">std::</span>size_t i ;</a>
<a class="sourceLine" id="cb922-6" data-line-number="6"></a>
<a class="sourceLine" id="cb922-7" data-line-number="7">    <span class="co">// コンストラクター</span></a>
<a class="sourceLine" id="cb922-8" data-line-number="8">    array_const_iterator( Array <span class="at">const</span> &amp; a, <span class="bu">std::</span>size_t i )</a>
<a class="sourceLine" id="cb922-9" data-line-number="9">        a(a), i(i) { }</a>
<a class="sourceLine" id="cb922-10" data-line-number="10">} ;</a></code></pre></div>
<p>ただし、<code>const_iterator</code>は<code>iterator</code>から変換できるので、</p>
<div class="sourceCode" id="cb923"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb923-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb923-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb923-3" data-line-number="3">    <span class="kw">using</span> Array = <span class="bu">std::</span>array&lt;<span class="dt">int</span>,<span class="dv">5</span>&gt; ;</a>
<a class="sourceLine" id="cb923-4" data-line-number="4">    Array a = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</a>
<a class="sourceLine" id="cb923-5" data-line-number="5"></a>
<a class="sourceLine" id="cb923-6" data-line-number="6">    <span class="co">// iterator</span></a>
<a class="sourceLine" id="cb923-7" data-line-number="7">    <span class="kw">auto</span> i = a.begin() ;</a>
<a class="sourceLine" id="cb923-8" data-line-number="8"></a>
<a class="sourceLine" id="cb923-9" data-line-number="9">    <span class="co">// iteratorからconst_iteratorへの変換</span></a>
<a class="sourceLine" id="cb923-10" data-line-number="10">    Array::const_iterator j = i ;</a>
<a class="sourceLine" id="cb923-11" data-line-number="11">}</a></code></pre></div>
<p>これに対応するために、<code>const_iterator</code>のコンストラクターは<code>iterator</code>から変換するためのコンストラクターも持つ。</p>
<div class="sourceCode" id="cb924"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb924-1" data-line-number="1"></a>
<a class="sourceLine" id="cb924-2" data-line-number="2"><span class="kw">template</span> &lt; <span class="kw">typename</span> Array &gt;</a>
<a class="sourceLine" id="cb924-3" data-line-number="3"><span class="kw">struct</span> array_const_iterator</a>
<a class="sourceLine" id="cb924-4" data-line-number="4">{</a>
<a class="sourceLine" id="cb924-5" data-line-number="5">    Array <span class="at">const</span> &amp; a ;</a>
<a class="sourceLine" id="cb924-6" data-line-number="6">    <span class="bu">std::</span>size_t i ;</a>
<a class="sourceLine" id="cb924-7" data-line-number="7"></a>
<a class="sourceLine" id="cb924-8" data-line-number="8">    <span class="co">// array_iteratorからの変換コンストラクター</span></a>
<a class="sourceLine" id="cb924-9" data-line-number="9">    array_const_iterator( <span class="kw">typename</span> array_iterator&lt;Array&gt;::iterator <span class="at">const</span> &amp; iter )</a>
<a class="sourceLine" id="cb924-10" data-line-number="10">        a( iter.a ), i( iter.i ) { }</a>
<a class="sourceLine" id="cb924-11" data-line-number="11">} ;</a></code></pre></div>
<p>残りのメンバー関数は<code>iterator</code>とほぼ同じだ。</p>
<p>例えば<code>operator ++</code>は完全に同じだ。</p>
<div class="sourceCode" id="cb925"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb925-1" data-line-number="1"><span class="co">// iterator版</span></a>
<a class="sourceLine" id="cb925-2" data-line-number="2">array_iterator &amp; array_iterator::<span class="kw">operator</span>++()</a>
<a class="sourceLine" id="cb925-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb925-4" data-line-number="4">    ++i ;</a>
<a class="sourceLine" id="cb925-5" data-line-number="5">    <span class="cf">return</span> *<span class="kw">this</span> ;</a>
<a class="sourceLine" id="cb925-6" data-line-number="6">}</a>
<a class="sourceLine" id="cb925-7" data-line-number="7"><span class="co">// const_iterator版</span></a>
<a class="sourceLine" id="cb925-8" data-line-number="8">array_const_iterator &amp; array_const_iterator::<span class="kw">operator</span> ++()</a>
<a class="sourceLine" id="cb925-9" data-line-number="9">{</a>
<a class="sourceLine" id="cb925-10" data-line-number="10">    ++i ;</a>
<a class="sourceLine" id="cb925-11" data-line-number="11">    <span class="cf">return</span> *<span class="kw">this</span> ;</a>
<a class="sourceLine" id="cb925-12" data-line-number="12">}</a></code></pre></div>
<p><code>operator *</code>や<code>operator []</code>はconstなリファレンスを返す。</p>
<div class="sourceCode" id="cb926"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb926-1" data-line-number="1"><span class="kw">typename</span> Array::const_reference <span class="kw">operator</span> *() <span class="at">const</span></a>
<a class="sourceLine" id="cb926-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb926-3" data-line-number="3">    <span class="cf">return</span> a[i] ;</a>
<a class="sourceLine" id="cb926-4" data-line-number="4">}</a>
<a class="sourceLine" id="cb926-5" data-line-number="5"></a>
<a class="sourceLine" id="cb926-6" data-line-number="6"><span class="kw">typename</span> Array::const_reference <span class="kw">operator</span> []( <span class="bu">std::</span>size_t i ) <span class="at">const</span></a>
<a class="sourceLine" id="cb926-7" data-line-number="7">{</a>
<a class="sourceLine" id="cb926-8" data-line-number="8">    <span class="cf">return</span> *(*<span class="kw">this</span> + i) ;</a>
<a class="sourceLine" id="cb926-9" data-line-number="9">}</a></code></pre></div>
<p>このために、<code>array</code>クラスにもネストされた型名<code>const_reference</code>を宣言しておく。</p>
<div class="sourceCode" id="cb927"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb927-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> T, <span class="bu">std::</span>size_t N &gt;</a>
<a class="sourceLine" id="cb927-2" data-line-number="2"><span class="kw">struct</span> array</a>
<a class="sourceLine" id="cb927-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb927-4" data-line-number="4">    <span class="kw">using</span> const_reference = T <span class="at">const</span> &amp; ;</a>
<a class="sourceLine" id="cb927-5" data-line-number="5">} ;</a></code></pre></div>
<p>残りは<code>iterator</code>の実装を参考に読者が自分で実装してみよう。</p>
<h1 id="傲慢なエラー処理-例外">傲慢なエラー処理: 例外</h1>
<h2 id="例外を投げる">例外を投げる</h2>
<p><code>std::array</code>の実装方法はほとんど解説した。読者は<code>std::array</code>の実装方法を知り、確固たる自信のもとに<code>std::array</code>を使えるようになった。ただし、ひとつだけ問題がある。</p>
<p>“std::array”のユーザーはあらかじめ設定した要素数を超える範囲の要素にアクセスすることができてしまう。</p>
<div class="sourceCode" id="cb928"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb928-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb928-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb928-3" data-line-number="3">    <span class="co">// 妥当な要素はa[0]のみ</span></a>
<a class="sourceLine" id="cb928-4" data-line-number="4">    <span class="bu">std::</span>array&lt;<span class="dt">int</span>, <span class="dv">1</span>&gt; a = {<span class="dv">1</span>} ;</a>
<a class="sourceLine" id="cb928-5" data-line-number="5"></a>
<a class="sourceLine" id="cb928-6" data-line-number="6">    <span class="co">// エラー、範囲外</span></a>
<a class="sourceLine" id="cb928-7" data-line-number="7">    a[<span class="dv">1000</span>] = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb928-8" data-line-number="8">}</a></code></pre></div>
<p><code>array</code>を自力で実装できる傲慢な読者としては、ユーザーごときが間違った使い方をできるのが許せない。間違いを起こした時点でエラーを発生させ、問題を知らしめ、対処できるようにしたい。</p>
<p><code>operator []</code>に範囲外チェックを入れるのは簡単だ。問題は、エラーをユーザーに通知する方法がない。</p>
<div class="sourceCode" id="cb929"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb929-1" data-line-number="1">reference array::<span class="kw">operator</span> [] ( <span class="bu">std::</span>size_t i )</a>
<a class="sourceLine" id="cb929-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb929-3" data-line-number="3">    <span class="co">// 範囲外チェック</span></a>
<a class="sourceLine" id="cb929-4" data-line-number="4">    <span class="cf">if</span> ( i &gt;= size() )</a>
<a class="sourceLine" id="cb929-5" data-line-number="5">    {</a>
<a class="sourceLine" id="cb929-6" data-line-number="6">        <span class="co">// エラー検出</span></a>
<a class="sourceLine" id="cb929-7" data-line-number="7">        <span class="co">// しかし何をreturnすればいいのだろう。</span></a>
<a class="sourceLine" id="cb929-8" data-line-number="8">    }</a>
<a class="sourceLine" id="cb929-9" data-line-number="9"></a>
<a class="sourceLine" id="cb929-10" data-line-number="10">    <span class="cf">return</span> storage[i] ;</a>
<a class="sourceLine" id="cb929-11" data-line-number="11">}</a></code></pre></div>
<p><code>operator []</code>は伝統的にエラーチェックをしない要素アクセスをするものだ。</p>
<p><code>vector</code>で一番最初に説明した要素アクセスの方法であるメンバー関数<code>at</code>を覚えているだろうか。実はメンバー関数<code>at</code>はエラーチェックをする。試してみよう。</p>
<div class="sourceCode" id="cb930"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb930-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb930-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb930-3" data-line-number="3">    <span class="bu">std::</span>array&lt;<span class="dt">int</span>, <span class="dv">1</span>&gt; a = {<span class="dv">1</span>} ;</a>
<a class="sourceLine" id="cb930-4" data-line-number="4"></a>
<a class="sourceLine" id="cb930-5" data-line-number="5">    <span class="bu">std::</span>cout &lt;&lt; a.at(<span class="dv">1000</span>) = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb930-6" data-line-number="6">}</a></code></pre></div>
<p>以下が実行結果だ。</p>
<pre><code>terminate called after throwing an instance of &#39;std::out_of_range&#39;
  what():  array::at: __n (which is 1000) &gt;= _Nm (which is 1)</code></pre>
<p>何やらよくわからないがエラーのようだ。以下のような意味であることがわかる。</p>
<pre><code>`std::out_of_range`がthrowされたあとにterminateが呼ばれた
  what(): array_at: __n(値は1000) &gt;= _Nm (値は1)</code></pre>
<p>どうやらエラーメッセージのようだ。わかりづらいメッセージだが、なんとなく言わんとすることはわかる。<code>_Nm</code>がarrayの要素数で、<code>__n</code>がメンバー関数<code>at</code>に渡した実引数だ。要素数<code>_Nm</code>よりも<code>__n</code>が大きい。</p>
<p>このエラー処理は、「例外」を使って行われる。</p>
<p>例外は通常の処理をすっ飛ばして特別なエラー処理をする機能だ。何もエラー処理をしない場合、プログラムは終了する。例外を発生させることを、「例外を投げる」という。</p>
<p>例外は文字通り投げるという意味の<code>throw</code>キーワードを使い、何らかの値を投げる(throw)。</p>
<div class="sourceCode" id="cb933"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb933-1" data-line-number="1"><span class="co">// int型の値123を投げる</span></a>
<a class="sourceLine" id="cb933-2" data-line-number="2"><span class="cf">throw</span> <span class="dv">123</span> ;</a>
<a class="sourceLine" id="cb933-3" data-line-number="3"></a>
<a class="sourceLine" id="cb933-4" data-line-number="4"><span class="co">// double型の値3.14を投げる</span></a>
<a class="sourceLine" id="cb933-5" data-line-number="5"><span class="cf">throw</span> <span class="fl">3.14</span> ;</a>
<a class="sourceLine" id="cb933-6" data-line-number="6"></a>
<a class="sourceLine" id="cb933-7" data-line-number="7"><span class="bu">std::</span>array&lt;<span class="dt">int</span>, <span class="dv">5</span>&gt; value = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</a>
<a class="sourceLine" id="cb933-8" data-line-number="8"></a>
<a class="sourceLine" id="cb933-9" data-line-number="9"><span class="co">// std::array&lt;int,5&gt;型の変数valueの値を投げる</span></a>
<a class="sourceLine" id="cb933-10" data-line-number="10"><span class="cf">throw</span> value ;</a></code></pre></div>
<p>この例では、int型、double型、<code>std::array&lt;int,5&gt;</code>型の値を投げている。</p>
<p>一度例外が投げられると、通常の実行はすっ飛ばされる。</p>
<p>以下は0を入力すると例外を投げるプログラムだ。</p>
<div class="sourceCode" id="cb934"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb934-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb934-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb934-3" data-line-number="3">    <span class="co">// 0を入力するなよ、絶対するなよ</span></a>
<a class="sourceLine" id="cb934-4" data-line-number="4">    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Don&#39;t type 0. &gt;&quot;</span>s ;</a>
<a class="sourceLine" id="cb934-5" data-line-number="5"></a>
<a class="sourceLine" id="cb934-6" data-line-number="6">    <span class="dt">int</span> input {} ;</a>
<a class="sourceLine" id="cb934-7" data-line-number="7">    <span class="bu">std::</span>cin &gt;&gt; input ;</a>
<a class="sourceLine" id="cb934-8" data-line-number="8"></a>
<a class="sourceLine" id="cb934-9" data-line-number="9">    <span class="co">/// 入力が0なら例外を投げる</span></a>
<a class="sourceLine" id="cb934-10" data-line-number="10">    <span class="cf">if</span> ( input == <span class="dv">0</span> )</a>
<a class="sourceLine" id="cb934-11" data-line-number="11">        <span class="cf">throw</span> <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb934-12" data-line-number="12"></a>
<a class="sourceLine" id="cb934-13" data-line-number="13">    <span class="co">// 通常の処理</span></a>
<a class="sourceLine" id="cb934-14" data-line-number="14">    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Succcess!</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb934-15" data-line-number="15">}</a></code></pre></div>
<p>このプログラムを実行すると、非0を入力した場合、“Success!”が出力される。0を入力した場合、例外が投げられる。例外が投げられると、通常の実行はすっ飛ばされる。エラー処理はしていないので、プログラムは終了する。</p>
<p><code>std::array</code>や<code>std::vector</code>のメンバー関数<code>at(n)</code>は<code>n</code>が要素数を超える場合、例外を投げている。</p>
<div class="sourceCode" id="cb935"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb935-1" data-line-number="1">array::reference array::at( <span class="bu">std::</span>size_t n )</a>
<a class="sourceLine" id="cb935-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb935-3" data-line-number="3">    <span class="cf">if</span> ( n &gt;= size() )</a>
<a class="sourceLine" id="cb935-4" data-line-number="4">        <span class="cf">throw</span> 何らかの値</a>
<a class="sourceLine" id="cb935-5" data-line-number="5"></a>
<a class="sourceLine" id="cb935-6" data-line-number="6">    <span class="cf">return</span> storage[n] ;</a>
<a class="sourceLine" id="cb935-7" data-line-number="7">}</a></code></pre></div>
<p>投げる例外は、<code>std::out_of_range</code>というクラスの値だ。このクラスを完全に説明するのは現時点では難しいが、以下のように振る舞うと考えておこう。</p>
<div class="sourceCode" id="cb936"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb936-1" data-line-number="1"><span class="kw">namespace</span> std {</a>
<a class="sourceLine" id="cb936-2" data-line-number="2"></a>
<a class="sourceLine" id="cb936-3" data-line-number="3"><span class="kw">struct</span> out_of_range</a>
<a class="sourceLine" id="cb936-4" data-line-number="4">{</a>
<a class="sourceLine" id="cb936-5" data-line-number="5">    <span class="co">// エラー内容の文字列を受け取るコンストラクター</span></a>
<a class="sourceLine" id="cb936-6" data-line-number="6">    out_of_range( <span class="bu">std::</span>string <span class="at">const</span> &amp; ) ;</a>
<a class="sourceLine" id="cb936-7" data-line-number="7">    <span class="co">// エラー内容の文字列を返すメンバー関数</span></a>
<a class="sourceLine" id="cb936-8" data-line-number="8">    <span class="kw">auto</span> what() ;</a>
<a class="sourceLine" id="cb936-9" data-line-number="9">} ;</a>
<a class="sourceLine" id="cb936-10" data-line-number="10"></a>
<a class="sourceLine" id="cb936-11" data-line-number="11">}</a></code></pre></div>
<p>とりあえず使ってみよう。</p>
<div class="sourceCode" id="cb937"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb937-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb937-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb937-3" data-line-number="3">    <span class="bu">std::</span>out_of_range err(<span class="st">&quot;I am error.&quot;</span>) ;</a>
<a class="sourceLine" id="cb937-4" data-line-number="4"></a>
<a class="sourceLine" id="cb937-5" data-line-number="5">    <span class="co">// I am error.</span></a>
<a class="sourceLine" id="cb937-6" data-line-number="6">    <span class="bu">std::</span>cout &lt;&lt; err.what() ;</a>
<a class="sourceLine" id="cb937-7" data-line-number="7">}</a></code></pre></div>
<p>コンストラクターでエラー内容を表現した文字列を受け取り、メンバー関数<code>what</code>でエラー内容の文字列を取得する。</p>
<p>必要な情報は全て学んだ。あとはメンバー関数<code>at</code>を実装するだけだ。</p>
<div class="sourceCode" id="cb938"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb938-1" data-line-number="1">array::reference array::at( <span class="bu">std::</span>size_t n )</a>
<a class="sourceLine" id="cb938-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb938-3" data-line-number="3">    <span class="cf">if</span> ( n &gt;= size() )</a>
<a class="sourceLine" id="cb938-4" data-line-number="4">        <span class="cf">throw</span> <span class="bu">std::</span>out_of_range(<span class="st">&quot;Error: Out of Range&quot;</span>) ;</a>
<a class="sourceLine" id="cb938-5" data-line-number="5"></a>
<a class="sourceLine" id="cb938-6" data-line-number="6">    <span class="cf">return</span> storage[n] ;</a>
<a class="sourceLine" id="cb938-7" data-line-number="7">}</a></code></pre></div>
<h2 id="例外を捕まえる">例外を捕まえる</h2>
<p>現状では、エラーを発見して例外を投げたら即座にプログラムが終了してしまう。投げた例外を途中で捕まえて、プログラムを通常の実行に戻す機能がほしい。その機能が「例外のキャッチ」だ。</p>
<p>例外のキャッチには<code>try</code>キーワードと<code>catch</code>キーワードを使う。</p>
<div class="sourceCode" id="cb939"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb939-1" data-line-number="1"><span class="cf">try</span> {</a>
<a class="sourceLine" id="cb939-2" data-line-number="2">    <span class="co">// 例外を投げるコード</span></a>
<a class="sourceLine" id="cb939-3" data-line-number="3">} <span class="cf">catch</span>( 型 名前 )</a>
<a class="sourceLine" id="cb939-4" data-line-number="4">{</a>
<a class="sourceLine" id="cb939-5" data-line-number="5">    エラー処理</a>
<a class="sourceLine" id="cb939-6" data-line-number="6">}</a></code></pre></div>
<p><code>try {}</code>ブロックの中で投げられた例外は、<code>catch</code>で型が一致する場合にキャッチされる。例外がキャッチされた場合、<code>catch</code>のブロックが実行される。そして実行が再開される。</p>
<div class="sourceCode" id="cb940"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb940-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb940-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb940-3" data-line-number="3"></a>
<a class="sourceLine" id="cb940-4" data-line-number="4">    <span class="cf">try</span> {</a>
<a class="sourceLine" id="cb940-5" data-line-number="5">        <span class="cf">throw</span> <span class="dv">123</span> ; <span class="co">// int型</span></a>
<a class="sourceLine" id="cb940-6" data-line-number="6">    }</a>
<a class="sourceLine" id="cb940-7" data-line-number="7">    <span class="co">// キャッチする</span></a>
<a class="sourceLine" id="cb940-8" data-line-number="8">    <span class="cf">catch</span>( <span class="dt">int</span> e )</a>
<a class="sourceLine" id="cb940-9" data-line-number="9">    {</a>
<a class="sourceLine" id="cb940-10" data-line-number="10">        <span class="bu">std::</span>cout &lt;&lt; e ;</a>
<a class="sourceLine" id="cb940-11" data-line-number="11">    }</a>
<a class="sourceLine" id="cb940-12" data-line-number="12"></a>
<a class="sourceLine" id="cb940-13" data-line-number="13">    <span class="co">// 実行される</span></a>
<a class="sourceLine" id="cb940-14" data-line-number="14">    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;resumed.</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb940-15" data-line-number="15">}</a></code></pre></div>
<p><code>catch</code>の型と投げられた例外の型が一致しない場合は、キャッチしない。</p>
<div class="sourceCode" id="cb941"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb941-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb941-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb941-3" data-line-number="3">    <span class="cf">try</span> {</a>
<a class="sourceLine" id="cb941-4" data-line-number="4">        <span class="cf">throw</span> <span class="fl">3.14</span> ; <span class="co">// double型</span></a>
<a class="sourceLine" id="cb941-5" data-line-number="5">    }</a>
<a class="sourceLine" id="cb941-6" data-line-number="6">    <span class="co">// キャッチしない</span></a>
<a class="sourceLine" id="cb941-7" data-line-number="7">    <span class="cf">catch</span>( <span class="dt">int</span> e ) { }</a>
<a class="sourceLine" id="cb941-8" data-line-number="8"></a>
<a class="sourceLine" id="cb941-9" data-line-number="9">    <span class="co">// 実行されない</span></a>
<a class="sourceLine" id="cb941-10" data-line-number="10">    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;You won&#39;t read this.</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb941-11" data-line-number="11">}</a></code></pre></div>
<p><code>catch</code>は複数書くことができる。</p>
<div class="sourceCode" id="cb942"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb942-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb942-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb942-3" data-line-number="3">    <span class="cf">try</span> {</a>
<a class="sourceLine" id="cb942-4" data-line-number="4">        <span class="cf">throw</span> <span class="st">&quot;error&quot;</span>s ; <span class="co">// std::string型</span></a>
<a class="sourceLine" id="cb942-5" data-line-number="5">    }</a>
<a class="sourceLine" id="cb942-6" data-line-number="6">    <span class="co">// キャッチしない</span></a>
<a class="sourceLine" id="cb942-7" data-line-number="7">    <span class="cf">catch</span>( <span class="dt">int</span> e ) { }</a>
<a class="sourceLine" id="cb942-8" data-line-number="8">    <span class="co">// キャッチしない</span></a>
<a class="sourceLine" id="cb942-9" data-line-number="9">    <span class="cf">catch</span>( <span class="dt">double</span> e ) { }</a>
<a class="sourceLine" id="cb942-10" data-line-number="10">    <span class="co">// キャッチする</span></a>
<a class="sourceLine" id="cb942-11" data-line-number="11">    <span class="cf">catch</span>( <span class="bu">std::</span>string &amp; e )</a>
<a class="sourceLine" id="cb942-12" data-line-number="12">    {</a>
<a class="sourceLine" id="cb942-13" data-line-number="13">        <span class="bu">std::</span>cout &lt;&lt; e ;</a>
<a class="sourceLine" id="cb942-14" data-line-number="14">    }</a>
<a class="sourceLine" id="cb942-15" data-line-number="15">}</a></code></pre></div>
<p><code>tryブロック</code>の中で投げられた例外は、たとえ複雑な関数呼び出しの奥底にある例外でもあますところなくキャッチされる。</p>
<div class="sourceCode" id="cb943"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb943-1" data-line-number="1"><span class="dt">void</span> f()</a>
<a class="sourceLine" id="cb943-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb943-3" data-line-number="3">    <span class="cf">throw</span> <span class="dv">123</span> ;</a>
<a class="sourceLine" id="cb943-4" data-line-number="4">}</a>
<a class="sourceLine" id="cb943-5" data-line-number="5"></a>
<a class="sourceLine" id="cb943-6" data-line-number="6"><span class="dt">void</span> g() { f() ; } </a>
<a class="sourceLine" id="cb943-7" data-line-number="7"><span class="dt">void</span> h() { g() ; }</a>
<a class="sourceLine" id="cb943-8" data-line-number="8"></a>
<a class="sourceLine" id="cb943-9" data-line-number="9"></a>
<a class="sourceLine" id="cb943-10" data-line-number="10"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb943-11" data-line-number="11">{</a>
<a class="sourceLine" id="cb943-12" data-line-number="12">    <span class="cf">try</span> {</a>
<a class="sourceLine" id="cb943-13" data-line-number="13">        h() ;</a>
<a class="sourceLine" id="cb943-14" data-line-number="14">    }</a>
<a class="sourceLine" id="cb943-15" data-line-number="15">    <span class="co">// キャッチされる</span></a>
<a class="sourceLine" id="cb943-16" data-line-number="16">    <span class="cf">catch</span>( <span class="dt">int</span> e ) { }</a>
<a class="sourceLine" id="cb943-17" data-line-number="17">}</a></code></pre></div>
<p>関数<code>h</code>は関数<code>g</code>を呼び出し、関数<code>g</code>は関数<code>f</code>を呼び出し、関数<code>f</code>は例外を投げる。このように複雑な関数呼び出しの結果として投げられる例外もキャッチできる。</p>
<p>すでに学んだように、<code>std::array&lt;T&gt;::at</code>に範囲外のインデックスを渡したときは<code>std::out_of_range</code>クラスが例外として投げられる。これをキャッチしてみよう。</p>
<div class="sourceCode" id="cb944"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb944-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb944-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb944-3" data-line-number="3">    <span class="bu">std::</span>array&lt;<span class="dt">int</span>, <span class="dv">1</span>&gt; a = {<span class="dv">0</span>} ;</a>
<a class="sourceLine" id="cb944-4" data-line-number="4"></a>
<a class="sourceLine" id="cb944-5" data-line-number="5">    <span class="cf">try</span> { a[<span class="dv">1000</span>] ; }</a>
<a class="sourceLine" id="cb944-6" data-line-number="6">    <span class="cf">catch</span>( <span class="bu">std::</span>out_of_range &amp; e )</a>
<a class="sourceLine" id="cb944-7" data-line-number="7">    {</a>
<a class="sourceLine" id="cb944-8" data-line-number="8">        <span class="co">// エラー内容を示す文字列</span></a>
<a class="sourceLine" id="cb944-9" data-line-number="9">        <span class="bu">std::</span>cout &lt;&lt; e.what() ;</a>
<a class="sourceLine" id="cb944-10" data-line-number="10">    }</a>
<a class="sourceLine" id="cb944-11" data-line-number="11">}</a></code></pre></div>
<h2 id="例外による巻き戻し">例外による巻き戻し</h2>
<p>例外が投げられた場合、その例外が投げられた場所を囲むtryブロックと対応するcatchに到達するまで、関数呼び出しが巻き戻される。これを<code>スタックアンワインディング</code>(stack unwinding)という。</p>
<div class="sourceCode" id="cb945"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb945-1" data-line-number="1"><span class="dt">void</span> f() { <span class="cf">throw</span> <span class="dv">0</span> ; } </a>
<a class="sourceLine" id="cb945-2" data-line-number="2"><span class="dt">void</span> g() { f() ; }</a>
<a class="sourceLine" id="cb945-3" data-line-number="3"><span class="dt">void</span> h() { g() ; }</a>
<a class="sourceLine" id="cb945-4" data-line-number="4"></a>
<a class="sourceLine" id="cb945-5" data-line-number="5"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb945-6" data-line-number="6">{</a>
<a class="sourceLine" id="cb945-7" data-line-number="7">    <span class="cf">try</span> { h() ; }</a>
<a class="sourceLine" id="cb945-8" data-line-number="8">    <span class="cf">catch</span>( <span class="dt">int</span> e ) { }</a>
<a class="sourceLine" id="cb945-9" data-line-number="9"></a>
<a class="sourceLine" id="cb945-10" data-line-number="10">}</a></code></pre></div>
<p>この例では、関数<code>main</code>が関数<code>h</code>を呼び出し、その結果として最終的に関数<code>f</code>の中で例外が投げられる。投げられた例外は関数呼び出しを巻き戻して関数<code>main</code>の中のtryブロックまで到達し、対応するcatchに捕まる。</p>
<p>もし関数<code>main</code>を抜けてもなお対応するcatchがない場合はどうなるのか。</p>
<div class="sourceCode" id="cb946"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb946-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb946-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb946-3" data-line-number="3">    <span class="cf">throw</span> <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb946-4" data-line-number="4">    <span class="co">// 対応するcatchがない</span></a>
<a class="sourceLine" id="cb946-5" data-line-number="5">}</a></code></pre></div>
<p>その場合、<code>std::terminate()</code>という関数が呼ばれる。この関数が呼ばれた場合、プログラムは終了する。</p>
<div class="sourceCode" id="cb947"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb947-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb947-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb947-3" data-line-number="3">    <span class="co">// プログラムは終了する</span></a>
<a class="sourceLine" id="cb947-4" data-line-number="4">    <span class="bu">std::</span>terminate() ;</a>
<a class="sourceLine" id="cb947-5" data-line-number="5">}</a></code></pre></div>
<p><code>tryブロック</code>はネストできる。その場合、対応するcatchが見つかるまで巻き戻しが起こる。</p>
<div class="sourceCode" id="cb948"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb948-1" data-line-number="1"><span class="dt">void</span> f()</a>
<a class="sourceLine" id="cb948-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb948-3" data-line-number="3">    <span class="cf">try</span> { <span class="cf">throw</span> <span class="dv">0</span> ; }</a>
<a class="sourceLine" id="cb948-4" data-line-number="4">    <span class="cf">catch</span> ( <span class="dt">double</span> e ) { }</a>
<a class="sourceLine" id="cb948-5" data-line-number="5">}</a>
<a class="sourceLine" id="cb948-6" data-line-number="6"></a>
<a class="sourceLine" id="cb948-7" data-line-number="7"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb948-8" data-line-number="8">{</a>
<a class="sourceLine" id="cb948-9" data-line-number="9">    <span class="cf">try</span> { <span class="co">// try 1</span></a>
<a class="sourceLine" id="cb948-10" data-line-number="10">        <span class="cf">try</span> { <span class="co">// try 2</span></a>
<a class="sourceLine" id="cb948-11" data-line-number="11">            f() ;</a>
<a class="sourceLine" id="cb948-12" data-line-number="12">        } <span class="cf">catch</span>( <span class="bu">std::</span>string &amp; e ) { }</a>
<a class="sourceLine" id="cb948-13" data-line-number="13">    } <span class="cf">catch</span> ( <span class="dt">int</span> e )</a>
<a class="sourceLine" id="cb948-14" data-line-number="14">    {</a>
<a class="sourceLine" id="cb948-15" data-line-number="15">        <span class="co">// ここで捕まる</span></a>
<a class="sourceLine" id="cb948-16" data-line-number="16">    }</a>
<a class="sourceLine" id="cb948-17" data-line-number="17">}</a></code></pre></div>
<p>上のコードは複雑な<code>tryブロック</code>のネストが行われている。プログラムがどのように実行されるのかを考えてみよう。</p>
<p>まず関数<code>main</code>が関数<code>f</code>を呼び出す。関数<code>f</code>は例外を投げる。関数<code>f</code>の中のtryブロックは対応するcatchがないので関数<code>main</code>に巻き戻る。関数<code>main</code>の内側のtryブロック、ソースコードでは<code>// try 2</code> とコメントをしているtryブロックのcatchには対応しない。更に上のtryブロックに巻き戻る。<code>// try 1</code>の<code>tryブロック</code>のcatchはint型なので、このcatchに捕まる。</p>
<p>例外が投げられ、<code>スタックアンワインディング</code>による巻き戻しが発生した場合、通常のプログラムの実行は行われない。例えば以下のプログラムは何も出力しない。</p>
<div class="sourceCode" id="cb949"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb949-1" data-line-number="1"><span class="dt">void</span> f()</a>
<a class="sourceLine" id="cb949-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb949-3" data-line-number="3">    <span class="cf">throw</span> <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb949-4" data-line-number="4">    <span class="co">// 例外を投げたあとの実行</span></a>
<a class="sourceLine" id="cb949-5" data-line-number="5">    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;function f</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb949-6" data-line-number="6">}</a>
<a class="sourceLine" id="cb949-7" data-line-number="7"></a>
<a class="sourceLine" id="cb949-8" data-line-number="8"><span class="dt">void</span> g()</a>
<a class="sourceLine" id="cb949-9" data-line-number="9">{</a>
<a class="sourceLine" id="cb949-10" data-line-number="10">    f() ;</a>
<a class="sourceLine" id="cb949-11" data-line-number="11">    <span class="co">// 関数fを呼んだあとの実行</span></a>
<a class="sourceLine" id="cb949-12" data-line-number="12">    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;function g</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb949-13" data-line-number="13">}</a>
<a class="sourceLine" id="cb949-14" data-line-number="14"></a>
<a class="sourceLine" id="cb949-15" data-line-number="15"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb949-16" data-line-number="16">{</a>
<a class="sourceLine" id="cb949-17" data-line-number="17">    g() ;</a>
<a class="sourceLine" id="cb949-18" data-line-number="18">    <span class="co">// 関数gを呼んだあとの実行</span></a>
<a class="sourceLine" id="cb949-19" data-line-number="19">    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;function main</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb949-20" data-line-number="20">}</a></code></pre></div>
<p><code>スタックアンワインディング</code>中に通常の実行は行われないが、変数の破棄は行われる。これはとても重要だ。変数が破棄されるとき、デストラクターが実行されるのを覚えているだろうか。</p>
<div class="sourceCode" id="cb950"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb950-1" data-line-number="1"><span class="kw">struct</span> Object</a>
<a class="sourceLine" id="cb950-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb950-3" data-line-number="3">    <span class="bu">std::</span>string name ;</a>
<a class="sourceLine" id="cb950-4" data-line-number="4">    <span class="co">// コンストラクター</span></a>
<a class="sourceLine" id="cb950-5" data-line-number="5">    Object( <span class="bu">std::</span>string <span class="at">const</span> &amp; name ) : name(name) </a>
<a class="sourceLine" id="cb950-6" data-line-number="6">    { <span class="bu">std::</span>cout &lt;&lt; name &lt;&lt; <span class="st">&quot; is constructed.</span><span class="sc">\n</span><span class="st">&quot;</span>s ; }</a>
<a class="sourceLine" id="cb950-7" data-line-number="7"></a>
<a class="sourceLine" id="cb950-8" data-line-number="8">    <span class="co">// デストラクター</span></a>
<a class="sourceLine" id="cb950-9" data-line-number="9">    ~Object()</a>
<a class="sourceLine" id="cb950-10" data-line-number="10">    { <span class="bu">std::</span>cout &lt;&lt; name &lt;&lt; <span class="st">&quot; is destructed.</span><span class="sc">\n</span><span class="st">&quot;</span>s ; }</a>
<a class="sourceLine" id="cb950-11" data-line-number="11">} ;</a>
<a class="sourceLine" id="cb950-12" data-line-number="12"></a>
<a class="sourceLine" id="cb950-13" data-line-number="13"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb950-14" data-line-number="14">{</a>
<a class="sourceLine" id="cb950-15" data-line-number="15">    <span class="co">// 変数objが構築される</span></a>
<a class="sourceLine" id="cb950-16" data-line-number="16">    Object obj(<span class="st">&quot;obj&quot;</span>s) ;</a>
<a class="sourceLine" id="cb950-17" data-line-number="17"></a>
<a class="sourceLine" id="cb950-18" data-line-number="18">    <span class="co">// 変数objが破棄される</span></a>
<a class="sourceLine" id="cb950-19" data-line-number="19">}</a></code></pre></div>
<p>実行結果</p>
<pre><code>obj is constructed.
obj is destructed.</code></pre>
<p>例外のスタックアンワインディングでは関数内の変数が破棄される。つまりデストラクターが実行される。</p>
<div class="sourceCode" id="cb952"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb952-1" data-line-number="1"><span class="dt">void</span> f()</a>
<a class="sourceLine" id="cb952-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb952-3" data-line-number="3">    Object obj(<span class="st">&quot;f&quot;</span>s) ;</a>
<a class="sourceLine" id="cb952-4" data-line-number="4">    <span class="cf">throw</span> <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb952-5" data-line-number="5">}</a>
<a class="sourceLine" id="cb952-6" data-line-number="6"></a>
<a class="sourceLine" id="cb952-7" data-line-number="7"><span class="dt">void</span> g()</a>
<a class="sourceLine" id="cb952-8" data-line-number="8">{</a>
<a class="sourceLine" id="cb952-9" data-line-number="9">    Object obj(<span class="st">&quot;g&quot;</span>s) ;</a>
<a class="sourceLine" id="cb952-10" data-line-number="10">    f() ;</a>
<a class="sourceLine" id="cb952-11" data-line-number="11">}</a>
<a class="sourceLine" id="cb952-12" data-line-number="12"></a>
<a class="sourceLine" id="cb952-13" data-line-number="13"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb952-14" data-line-number="14">{</a>
<a class="sourceLine" id="cb952-15" data-line-number="15">    Object obj(<span class="st">&quot;main&quot;</span>s) ;</a>
<a class="sourceLine" id="cb952-16" data-line-number="16"></a>
<a class="sourceLine" id="cb952-17" data-line-number="17">    <span class="cf">try</span> {</a>
<a class="sourceLine" id="cb952-18" data-line-number="18">        g() ;</a>
<a class="sourceLine" id="cb952-19" data-line-number="19">    } <span class="cf">catch</span>( <span class="dt">int</span> e )</a>
<a class="sourceLine" id="cb952-20" data-line-number="20">    {</a>
<a class="sourceLine" id="cb952-21" data-line-number="21">        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;caught.</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb952-22" data-line-number="22">    }</a>
<a class="sourceLine" id="cb952-23" data-line-number="23"></a>
<a class="sourceLine" id="cb952-24" data-line-number="24">}</a></code></pre></div>
<p>このプログラムを実行した結果は以下のようになる。</p>
<pre><code>main is constructed.
g is constructed.
f is constructed.
f is destructed.
g is destructed.
caught.
main is destructed.</code></pre>
<p>なぜこの順番に出力されるか考えてみよう。</p>
<ol type="1">
<li>プログラムの実行は関数mainから始まる。そのためまずmainが構築される。</li>
<li>関数mainは関数gを呼ぶ。gが構築される。</li>
<li>関数gは関数fを呼ぶ。fが構築される。</li>
<li>関数fは例外を投げるので、fは破棄される。</li>
<li>関数gに巻き戻ったがcatchがないのでさらに巻き戻る。gが破棄される。</li>
<li>関数mainに巻き戻ったところ対応するcatchがあるのでスタックアンワインディングは停止する。</li>
<li><code>caught.</code>が出力される。</li>
<li>mainが破棄される。</li>
</ol>
<p>例外が投げられると通常の実行は飛ばされるので、例外が投げられるかもしれない処理のあとに、例外の有無にかかわらず絶対に実行したい処理がある場合は、クラスのデストラクターに書くとよい。</p>
<h1 id="ポインター">ポインター</h1>
<p>ポインターは難しいとよく言われる。世の中にはポインターのためにC言語とC++を挫折し、他の軟弱な言語に逃げるプログラマーがいる。ポインターしか解説していない本が出版される。Joel Spolskyがエッセイを書く。</p>
<p>ポインターの理解は優秀なプログラマーとなるために必須である。ポインターを理解できない人間は優秀なプログラマーにはなれない。もし、本書を読んでポインターが理解できない場合、プログラマーには向いていないということだ。</p>
<p>ポインターを難しくしている原因には、意味上のポインターと、文法上のポインターと、ポインターの内部実装がある。いずれも難しいが、本書を読めばポインターは完全に理解できる。</p>
<h2 id="意味上のポインター">意味上のポインター</h2>
<h3 id="リファレンスと同じ機能">リファレンスと同じ機能</h3>
<p>ポインターはオブジェクトを参照するための機能だ。この点ではリファレンスと同じ機能を提供している。</p>
<p>リファレンスを覚えているだろうか。T型へのリファレンスはT型のオブジェクトそのものではなく、T型のオブジェクトへの参照だ。リファレンスへの操作は、参照したオブジェクトへの操作になる。</p>
<div class="sourceCode" id="cb954"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb954-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb954-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb954-3" data-line-number="3">    <span class="co">// int型のオブジェクト</span></a>
<a class="sourceLine" id="cb954-4" data-line-number="4">    <span class="dt">int</span> object = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb954-5" data-line-number="5"></a>
<a class="sourceLine" id="cb954-6" data-line-number="6">    <span class="co">// オブジェクトを変更</span></a>
<a class="sourceLine" id="cb954-7" data-line-number="7">    object = <span class="dv">123</span> ;</a>
<a class="sourceLine" id="cb954-8" data-line-number="8"></a>
<a class="sourceLine" id="cb954-9" data-line-number="9">    <span class="co">// 123</span></a>
<a class="sourceLine" id="cb954-10" data-line-number="10">    <span class="bu">std::</span>cout &lt;&lt; object ;</a>
<a class="sourceLine" id="cb954-11" data-line-number="11"></a>
<a class="sourceLine" id="cb954-12" data-line-number="12">    <span class="co">// T型へのリファレンス</span></a>
<a class="sourceLine" id="cb954-13" data-line-number="13">    <span class="co">// objectを参照する</span></a>
<a class="sourceLine" id="cb954-14" data-line-number="14">    <span class="dt">int</span> &amp; reference = object ;</a>
<a class="sourceLine" id="cb954-15" data-line-number="15"></a>
<a class="sourceLine" id="cb954-16" data-line-number="16">    <span class="co">// objectが変更される</span></a>
<a class="sourceLine" id="cb954-17" data-line-number="17">    reference = <span class="dv">456</span> ;</a>
<a class="sourceLine" id="cb954-18" data-line-number="18"></a>
<a class="sourceLine" id="cb954-19" data-line-number="19">    <span class="co">// 456</span></a>
<a class="sourceLine" id="cb954-20" data-line-number="20">    <span class="bu">std::</span>cout &lt;&lt; object ;</a>
<a class="sourceLine" id="cb954-21" data-line-number="21"></a>
<a class="sourceLine" id="cb954-22" data-line-number="22">    <span class="co">// referenceはobjectを参照している</span></a>
<a class="sourceLine" id="cb954-23" data-line-number="23">    object = <span class="dv">789</span> ;</a>
<a class="sourceLine" id="cb954-24" data-line-number="24"></a>
<a class="sourceLine" id="cb954-25" data-line-number="25">    <span class="co">// 参照するobjectの値</span></a>
<a class="sourceLine" id="cb954-26" data-line-number="26">    <span class="co">// 789</span></a>
<a class="sourceLine" id="cb954-27" data-line-number="27">    <span class="bu">std::</span>cout &lt;&lt; reference ;</a>
<a class="sourceLine" id="cb954-28" data-line-number="28">}</a></code></pre></div>
<p>リファレンスは宣言と同時に初期化する。リファレンスの参照先をあとから返ることはできない。</p>
<div class="sourceCode" id="cb955"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb955-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb955-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb955-3" data-line-number="3">    <span class="dt">int</span> x = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb955-4" data-line-number="4"></a>
<a class="sourceLine" id="cb955-5" data-line-number="5">    <span class="co">// rはxを参照する</span></a>
<a class="sourceLine" id="cb955-6" data-line-number="6">    <span class="dt">int</span> r = x ;</a>
<a class="sourceLine" id="cb955-7" data-line-number="7"></a>
<a class="sourceLine" id="cb955-8" data-line-number="8">    <span class="dt">int</span> y = <span class="dv">1</span> ;</a>
<a class="sourceLine" id="cb955-9" data-line-number="9"></a>
<a class="sourceLine" id="cb955-10" data-line-number="10">    <span class="co">// xに1が代入される</span></a>
<a class="sourceLine" id="cb955-11" data-line-number="11">    r = y ;</a>
<a class="sourceLine" id="cb955-12" data-line-number="12">}</a></code></pre></div>
<p>最後の<code>r = y ;</code>はリファレンスrの参照先をyに変えるという意味ではない。リファレンスrの参照先にyの値を代入するという意味だ。</p>
<p>ポインターはリファレンスに似ている。並べてみるとほとんど同じ意味だ。</p>
<ul>
<li>T型へのリファレンスはT型のオブジェクトを参照する</li>
<li>T型へのポインターはT型のオブジェクトを参照する</li>
</ul>
<p>T型へのリファレンス型が<code>T &amp;</code>であるのに対し、T型へのポインター型は<code>T *</code>だ。</p>
<div class="sourceCode" id="cb956"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb956-1" data-line-number="1"><span class="co">// intへのリファレンス型</span></a>
<a class="sourceLine" id="cb956-2" data-line-number="2"><span class="kw">using</span> <span class="dt">ref_type</span> = <span class="dt">int</span> &amp; ;</a>
<a class="sourceLine" id="cb956-3" data-line-number="3"><span class="co">// intへのポインター型</span></a>
<a class="sourceLine" id="cb956-4" data-line-number="4"><span class="kw">using</span> <span class="dt">ptr_type</span> = <span class="dt">int</span> * ;</a></code></pre></div>
<p>リファレンスの初期化は、単に参照したい変数名をそのまま書けばよかった。</p>
<div class="sourceCode" id="cb957"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb957-1" data-line-number="1"><span class="dt">int</span> object { } ;</a>
<a class="sourceLine" id="cb957-2" data-line-number="2"><span class="dt">int</span> &amp; reference = object ;</a></code></pre></div>
<p>ポインターの場合、参照したい変数名に、<code>&amp;</code>をつける必要がある。</p>
<div class="sourceCode" id="cb958"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb958-1" data-line-number="1"><span class="dt">int</span> object { } ;</a>
<a class="sourceLine" id="cb958-2" data-line-number="2"><span class="dt">int</span> * pointer = &amp;object ;</a></code></pre></div>
<p>リファレンスを経由してリファレンスが参照するオブジェクトを操作するには、単にリファレンス名を使えばよかった。</p>
<div class="sourceCode" id="cb959"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb959-1" data-line-number="1"><span class="co">// 書き込み</span></a>
<a class="sourceLine" id="cb959-2" data-line-number="2">reference = <span class="dv">0</span></a>
<a class="sourceLine" id="cb959-3" data-line-number="3"><span class="co">// 読み込み</span></a>
<a class="sourceLine" id="cb959-4" data-line-number="4"><span class="dt">int</span> read = reference ;  </a></code></pre></div>
<p>ポインターの場合、ポインター名に<code>*</code>をつける必要がある。</p>
<div class="sourceCode" id="cb960"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb960-1" data-line-number="1"><span class="co">// 書き込み</span></a>
<a class="sourceLine" id="cb960-2" data-line-number="2">*pointer = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb960-3" data-line-number="3"><span class="co">// 読み込み</span></a>
<a class="sourceLine" id="cb960-4" data-line-number="4"><span class="dt">int</span> read = *pointer ;</a></code></pre></div>
<p>ポインター名をそのまま使った場合、それは参照先のオブジェクトの値ではなく、ポインターという値になる。</p>
<div class="sourceCode" id="cb961"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb961-1" data-line-number="1"><span class="co">// オブジェクト</span></a>
<a class="sourceLine" id="cb961-2" data-line-number="2"><span class="dt">int</span> object { } ;</a>
<a class="sourceLine" id="cb961-3" data-line-number="3"></a>
<a class="sourceLine" id="cb961-4" data-line-number="4"><span class="co">// オブジェクトのポインター値で初期化</span></a>
<a class="sourceLine" id="cb961-5" data-line-number="5"><span class="dt">int</span> * p1 = &amp;object</a>
<a class="sourceLine" id="cb961-6" data-line-number="6"></a>
<a class="sourceLine" id="cb961-7" data-line-number="7"><span class="co">// p1のポインター値で代入</span></a>
<a class="sourceLine" id="cb961-8" data-line-number="8"><span class="co">// つまりobjectを参照する</span></a>
<a class="sourceLine" id="cb961-9" data-line-number="9"><span class="dt">int</span> * p2 = p1 ;</a></code></pre></div>
<p>このように比較すると、ポインターはリファレンスと同じ機能を提供していることがわかる。実際、リファレンスというのはポインターのシンタックスシュガーにすぎない。ポインターの機能を制限して、文法をわかりやすくしたものだ。</p>
<h3 id="リファレンスと違う機能">リファレンスと違う機能</h3>
<p>リファレンスがポインターの機能制限版だというのであれば、ポインターにあってリファレンスにはない機能はなんだろうか。代入と、何も参照しない状態だ。</p>
<h3 id="代入">代入</h3>
<p>リファレンスは代入ができないが、ポインターは代入ができる。</p>
<div class="sourceCode" id="cb962"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb962-1" data-line-number="1"><span class="dt">int</span> x { } ;</a>
<a class="sourceLine" id="cb962-2" data-line-number="2"><span class="dt">int</span> y { } ;</a>
<a class="sourceLine" id="cb962-3" data-line-number="3"></a>
<a class="sourceLine" id="cb962-4" data-line-number="4"><span class="dt">int</span> &amp; reference = x ;</a>
<a class="sourceLine" id="cb962-5" data-line-number="5"><span class="co">// xにyの値を代入</span></a>
<a class="sourceLine" id="cb962-6" data-line-number="6"><span class="co">// リファレンスの参照先は変わらない</span></a>
<a class="sourceLine" id="cb962-7" data-line-number="7">reference = y ;</a>
<a class="sourceLine" id="cb962-8" data-line-number="8"></a>
<a class="sourceLine" id="cb962-9" data-line-number="9"><span class="dt">int</span> * pointer = &amp;x ;</a>
<a class="sourceLine" id="cb962-10" data-line-number="10"><span class="co">// pointerの参照先をyに変更</span></a>
<a class="sourceLine" id="cb962-11" data-line-number="11">pointer = &amp;y ;</a></code></pre></div>
<h3 id="何も参照しない状態">何も参照しない状態</h3>
<p>リファレンスは必ず初期化しなければならない。</p>
<div class="sourceCode" id="cb963"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb963-1" data-line-number="1"><span class="co">// エラー、初期化されていない</span></a>
<a class="sourceLine" id="cb963-2" data-line-number="2"><span class="dt">int</span> &amp; reference ; </a></code></pre></div>
<p>そのため、リファレンスは常にオブジェクトを参照している。</p>
<p>ポインターは初期化しなくてもよい。</p>
<div class="sourceCode" id="cb964"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb964-1" data-line-number="1"><span class="dt">int</span> * pointer ;</a></code></pre></div>
<p>この場合、具体的に何かを参照していない状態になる。この場合にポインターの値はどうなるかはわからない。初期化のない整数の値がわからないのと同じだ。</p>
<div class="sourceCode" id="cb965"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb965-1" data-line-number="1"><span class="co">// 値はわからない</span></a>
<a class="sourceLine" id="cb965-2" data-line-number="2"><span class="dt">int</span> data ;</a></code></pre></div>
<p>このわからない値が発生することを、専門用語では「未規定の挙動」という。</p>
<p>わからない値の整数を読むことは推奨できない。書くことはできる。</p>
<div class="sourceCode" id="cb966"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb966-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb966-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb966-3" data-line-number="3">    <span class="co">// 値はわからない</span></a>
<a class="sourceLine" id="cb966-4" data-line-number="4">    <span class="dt">int</span> data ; </a>
<a class="sourceLine" id="cb966-5" data-line-number="5"></a>
<a class="sourceLine" id="cb966-6" data-line-number="6">    <span class="co">// 推奨できない</span></a>
<a class="sourceLine" id="cb966-7" data-line-number="7">    <span class="bu">std::</span>cout &lt;&lt; data ;</a>
<a class="sourceLine" id="cb966-8" data-line-number="8"></a>
<a class="sourceLine" id="cb966-9" data-line-number="9">    <span class="co">// OK</span></a>
<a class="sourceLine" id="cb966-10" data-line-number="10">    data = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb966-11" data-line-number="11">}</a></code></pre></div>
<p>このプログラムは何らかの値を出力するはずだが、具体的にどういう値を出力するのかはわからない。</p>
<p>そしてここからがポインターの恐ろしいところだが、ポインターの場合にもこのわからない値は発生する。わからない値を持ったポインターの参照先への読み書きは、「未定義の挙動」を引き起こす。</p>
<div class="sourceCode" id="cb967"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb967-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb967-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb967-3" data-line-number="3">    <span class="dt">int</span> * pointer ;</a>
<a class="sourceLine" id="cb967-4" data-line-number="4"></a>
<a class="sourceLine" id="cb967-5" data-line-number="5">    <span class="co">// 未定義の挙動</span></a>
<a class="sourceLine" id="cb967-6" data-line-number="6">    <span class="bu">std::</span>cout &lt;&lt; *pointer ;</a>
<a class="sourceLine" id="cb967-7" data-line-number="7"></a>
<a class="sourceLine" id="cb967-8" data-line-number="8">    <span class="co">// 未定義の挙動</span></a>
<a class="sourceLine" id="cb967-9" data-line-number="9">    *pointer = <span class="dv">123</span> ;</a>
<a class="sourceLine" id="cb967-10" data-line-number="10">}</a></code></pre></div>
<p>なぜ未定義の挙動になるかというと、わからない値のポインターは、たまたまどこかの妥当なオブジェクトを参照してしまっているかもしれないからだ。</p>
<p>未定義の挙動は恐ろしい。未定義の挙動が発生した場合、何が起こっても文句は言えない。なぜならばその挙動は本来存在するはずがないのだから。上のプログラムはコンパイル時にエラーになるかもしれないし、実行時にエラーになるかもしれない。いや、もっとひどいことにはエラーにならないかもしれない。そして人生、宇宙、すべてのものの答えと、あろうことか答えに対する質問まで出力するかもしれない。</p>
<h3 id="明示的に何も参照しないポインター-nullptr">明示的に何も参照しないポインター: nullptr</h3>
<p>ポインターを未初期化にしていると、よくわからない値になってしまう。そのため、何も参照していないことを明示的に示すためのポインターの値、nullポインター値がある。<code>nullptr</code>だ。</p>
<div class="sourceCode" id="cb968"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb968-1" data-line-number="1"><span class="dt">int</span> * pointer = <span class="kw">nullptr</span> ;</a></code></pre></div>
<p>nullptrはどんな型へのポインターに対しても、何も参照していない値となる。</p>
<div class="sourceCode" id="cb969"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb969-1" data-line-number="1"><span class="co">// doubleへのポインター</span></a>
<a class="sourceLine" id="cb969-2" data-line-number="2"><span class="dt">double</span> * p1 = <span class="kw">nullptr</span> ;</a>
<a class="sourceLine" id="cb969-3" data-line-number="3"></a>
<a class="sourceLine" id="cb969-4" data-line-number="4"><span class="co">// std::stringへのポインター</span></a>
<a class="sourceLine" id="cb969-5" data-line-number="5"><span class="bu">std::</span>string p2 = <span class="kw">nullptr</span> ;</a></code></pre></div>
<p>C言語とC++では歴史的な理由で、<code>nullptr</code>の他にも<code>NULL</code>もnullポインター値</p>
<div class="sourceCode" id="cb970"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb970-1" data-line-number="1"><span class="dt">int</span> * pointer = NULL ;</a></code></pre></div>
<p>C++ではさらに歴史的な理由で、<code>0</code>もnullポインター値として扱う。</p>
<div class="sourceCode" id="cb971"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb971-1" data-line-number="1"><span class="dt">int</span> * pointer = <span class="dv">0</span> ;</a></code></pre></div>
<p>ただし、nullポインター値が実際に0である保証はない。ポインターの値についてはあとで詳しく扱う。</p>
<h3 id="無効な参照先の作り方">無効な参照先の作り方</h3>
<p>ポインターやリファレンスによって参照先が参照される時点では有効だったが、後に無効になる参照先を作ることができてしまう。</p>
<p>例えば以下のコードだ。</p>
<div class="sourceCode" id="cb972"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb972-1" data-line-number="1"><span class="dt">int</span> * f()</a>
<a class="sourceLine" id="cb972-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb972-3" data-line-number="3">    <span class="co">// 寿命は関数</span></a>
<a class="sourceLine" id="cb972-4" data-line-number="4">    <span class="dt">int</span> variable {} ;</a>
<a class="sourceLine" id="cb972-5" data-line-number="5"></a>
<a class="sourceLine" id="cb972-6" data-line-number="6">    <span class="cf">return</span> &amp;variable ;</a>
<a class="sourceLine" id="cb972-7" data-line-number="7">}</a>
<a class="sourceLine" id="cb972-8" data-line-number="8"></a>
<a class="sourceLine" id="cb972-9" data-line-number="9"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb972-10" data-line-number="10">{</a>
<a class="sourceLine" id="cb972-11" data-line-number="11">    <span class="dt">int</span> * ptr = f() ;</a>
<a class="sourceLine" id="cb972-12" data-line-number="12">    <span class="co">// エラー</span></a>
<a class="sourceLine" id="cb972-13" data-line-number="13">    <span class="dt">int</span> read = *ptr ;</a>
<a class="sourceLine" id="cb972-14" data-line-number="14">}</a></code></pre></div>
<p>このコードの問題は、関数fの中の変数variableの寿命は関数fの中だけで、呼び出し元に戻ったときには寿命が尽きるというところにある。変数variableへのポインターは変数variableの寿命が尽きたあとも存在してしまうので、存在しないオブジェクトにポインター経由でアクセスしようとしてエラーになる。</p>
<p>同じ問題はリファレンスでも起きるが、ポインターのほうがこの問題を起こしやすい。</p>
<div class="sourceCode" id="cb973"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb973-1" data-line-number="1"><span class="dt">int</span> &amp; f()</a>
<a class="sourceLine" id="cb973-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb973-3" data-line-number="3">    <span class="dt">int</span> variable {} ;</a>
<a class="sourceLine" id="cb973-4" data-line-number="4">    <span class="cf">return</span> variable ;</a>
<a class="sourceLine" id="cb973-5" data-line-number="5">}</a></code></pre></div>
<h2 id="文法上のポインター">文法上のポインター</h2>
<p>ポインターが難しいと言われる理由の一つに、ポインターの文法が難しい問題がある。</p>
<h3 id="ポインターとconstの関係">ポインターとconstの関係</h3>
<p>型としてのポインターは、ある型Tがあるときに、Tへのポインター型となる。</p>
<p>Tへのポインター型は<code>T *</code>と書く。</p>
<div class="sourceCode" id="cb974"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb974-1" data-line-number="1"><span class="co">// intへのポインター型</span></a>
<a class="sourceLine" id="cb974-2" data-line-number="2"><span class="kw">using</span> t1 = <span class="dt">int</span> * ;</a>
<a class="sourceLine" id="cb974-3" data-line-number="3"><span class="co">// doubleへのポインター型</span></a>
<a class="sourceLine" id="cb974-4" data-line-number="4"><span class="kw">using</span> t2 = <span class="dt">double</span> * ;</a>
<a class="sourceLine" id="cb974-5" data-line-number="5"><span class="co">// std::stringへのポインター型</span></a>
<a class="sourceLine" id="cb974-6" data-line-number="6"><span class="kw">using</span> t3 = <span class="bu">std::</span>string * ;</a>
<a class="sourceLine" id="cb974-7" data-line-number="7"><span class="co">// std::array&lt;int,5&gt;へのポインター型</span></a>
<a class="sourceLine" id="cb974-8" data-line-number="8"><span class="kw">using</span> t4 = <span class="bu">std::</span>array&lt;<span class="dt">int</span>,<span class="dv">5</span>&gt; * ;</a>
<a class="sourceLine" id="cb974-9" data-line-number="9"><span class="co">// std::array&lt;double,10&gt;へのポインター型</span></a>
<a class="sourceLine" id="cb974-10" data-line-number="10"><span class="kw">using</span> t5 = <span class="bu">std::</span>array&lt;<span class="dt">double</span>,<span class="dv">10</span>&gt; * ;</a></code></pre></div>
<p>リファレンスやconstも同じだ。</p>
<div class="sourceCode" id="cb975"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb975-1" data-line-number="1"><span class="co">// int型へのポインター型</span></a>
<a class="sourceLine" id="cb975-2" data-line-number="2"><span class="kw">using</span> t1 = <span class="dt">int</span> * ;</a>
<a class="sourceLine" id="cb975-3" data-line-number="3"><span class="co">// int型へのリファレンス型</span></a>
<a class="sourceLine" id="cb975-4" data-line-number="4"><span class="kw">using</span> t2 = <span class="dt">int</span> &amp; ;</a>
<a class="sourceLine" id="cb975-5" data-line-number="5"><span class="co">// どちらも同じconstなint型</span></a>
<a class="sourceLine" id="cb975-6" data-line-number="6"><span class="kw">using</span> t3 = <span class="at">const</span> <span class="dt">int</span> ;</a>
<a class="sourceLine" id="cb975-7" data-line-number="7"><span class="kw">using</span> t4 = <span class="dt">int</span> <span class="at">const</span> ;</a></code></pre></div>
<p><code>const int</code>と<code>int const</code>は同じ型だ。この場合、constはint型のあとにつけても前につけても同じ意味になる。</p>
<p>すると当然の疑問が生じる。組み合わせるとどうなるのかということだ。</p>
<p>ポインター型へのリファレンス型はできる。</p>
<div class="sourceCode" id="cb976"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb976-1" data-line-number="1"><span class="co">// int *型へのリファレンス</span></a>
<a class="sourceLine" id="cb976-2" data-line-number="2"><span class="kw">using</span> type = <span class="dt">int</span> * &amp; ;</a></code></pre></div>
<p>リファレンス型へのポインター型はできない。</p>
<div class="sourceCode" id="cb977"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb977-1" data-line-number="1"><span class="co">// エラー、できない</span></a>
<a class="sourceLine" id="cb977-2" data-line-number="2"><span class="kw">using</span> error = <span class="dt">int</span> &amp; * ;</a></code></pre></div>
<p>理由は、リファレンスへのポインターというのは意味がないからだ。ポインターへのリファレンスは意味がある。</p>
<p>リファレンスからポインターの値を得るには、参照先のオブジェクトと同じく<code>&amp;</code>を使う。</p>
<div class="sourceCode" id="cb978"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb978-1" data-line-number="1"><span class="dt">int</span> data { } ;</a>
<a class="sourceLine" id="cb978-2" data-line-number="2"><span class="dt">int</span> ref = data ;</a>
<a class="sourceLine" id="cb978-3" data-line-number="3"><span class="co">// &amp;dataと同じ</span></a>
<a class="sourceLine" id="cb978-4" data-line-number="4"><span class="dt">int</span> * ptr = &amp;ref ;</a></code></pre></div>
<p>リファレンスは参照先のオブジェクトと全く同じように振る舞うのでリファレンス自体のポインターの値を得ることはできない。</p>
<p>ポインターのリファレンスを得るのは、ポインター以外の値と全く同じだ。</p>
<div class="sourceCode" id="cb979"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb979-1" data-line-number="1"><span class="dt">int</span> * ptr = <span class="kw">nullptr</span> ;</a>
<a class="sourceLine" id="cb979-2" data-line-number="2"><span class="co">// ptrを参照する</span></a>
<a class="sourceLine" id="cb979-3" data-line-number="3"><span class="dt">int</span> * &amp; ref = ptr ;</a>
<a class="sourceLine" id="cb979-4" data-line-number="4"></a>
<a class="sourceLine" id="cb979-5" data-line-number="5"><span class="dt">int</span> data { } ;</a>
<a class="sourceLine" id="cb979-6" data-line-number="6"><span class="co">// ptrの値が&amp;dataになる。</span></a>
<a class="sourceLine" id="cb979-7" data-line-number="7">ref = &amp;data ;</a></code></pre></div>
<p>constとポインターの組み合わせは難しい。</p>
<p>まず型Tとそのconst版がある。</p>
<div class="sourceCode" id="cb980"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb980-1" data-line-number="1"><span class="kw">using</span> T = <span class="dt">int</span> ;</a>
<a class="sourceLine" id="cb980-2" data-line-number="2"><span class="kw">using</span> const_T = <span class="at">const</span> T ;</a></code></pre></div>
<p>そして型Tとそのポインター版がある。</p>
<div class="sourceCode" id="cb981"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb981-1" data-line-number="1"><span class="kw">using</span> T = <span class="dt">int</span> ;</a>
<a class="sourceLine" id="cb981-2" data-line-number="2"><span class="kw">using</span> T_pointer = T * ;</a></code></pre></div>
<p>これを組みわせると、以下のようになる。</p>
<div class="sourceCode" id="cb982"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb982-1" data-line-number="1"><span class="co">// 型T</span></a>
<a class="sourceLine" id="cb982-2" data-line-number="2"><span class="kw">using</span> T = <span class="dt">int</span> ;</a>
<a class="sourceLine" id="cb982-3" data-line-number="3"><span class="co">// どちらもconstなT</span></a>
<a class="sourceLine" id="cb982-4" data-line-number="4"><span class="kw">using</span> const_T_1 = <span class="at">const</span> T ;</a>
<a class="sourceLine" id="cb982-5" data-line-number="5"><span class="kw">using</span> const_T_2 = T <span class="at">const</span> ;</a>
<a class="sourceLine" id="cb982-6" data-line-number="6"><span class="co">// Tへのポインター</span></a>
<a class="sourceLine" id="cb982-7" data-line-number="7"><span class="kw">using</span> T_pointer = T * ;</a>
<a class="sourceLine" id="cb982-8" data-line-number="8"></a>
<a class="sourceLine" id="cb982-9" data-line-number="9"><span class="co">// どちらもconstなTへのポインター</span></a>
<a class="sourceLine" id="cb982-10" data-line-number="10"><span class="kw">using</span> const_T_pointer_1 = <span class="at">const</span> T * ;</a>
<a class="sourceLine" id="cb982-11" data-line-number="11"><span class="kw">using</span> const_T_pointer_2 = T <span class="at">const</span> * ;</a>
<a class="sourceLine" id="cb982-12" data-line-number="12"></a>
<a class="sourceLine" id="cb982-13" data-line-number="13"><span class="co">// Tへのconstなポインター</span></a>
<a class="sourceLine" id="cb982-14" data-line-number="14"><span class="kw">using</span> T_const_pointer = T * <span class="at">const</span> ;</a>
<a class="sourceLine" id="cb982-15" data-line-number="15"></a>
<a class="sourceLine" id="cb982-16" data-line-number="16"><span class="co">// どちらもconstなTへのconstなポインター</span></a>
<a class="sourceLine" id="cb982-17" data-line-number="17"><span class="kw">using</span> const_T_const_pointer_1 = <span class="at">const</span> T * <span class="at">const</span> ;</a>
<a class="sourceLine" id="cb982-18" data-line-number="18"><span class="kw">using</span> const_T_const_pointer_2 = T <span class="at">const</span> * <span class="at">const</span> ;</a></code></pre></div>
<p>順番に見ていこう。まずは組み合わせない型から。</p>
<div class="sourceCode" id="cb983"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb983-1" data-line-number="1"><span class="kw">using</span> T = <span class="dt">int</span> ;</a>
<a class="sourceLine" id="cb983-2" data-line-number="2"><span class="co">// どちらもconstなT</span></a>
<a class="sourceLine" id="cb983-3" data-line-number="3"><span class="kw">using</span> const_T_1 = <span class="at">const</span> T ;</a>
<a class="sourceLine" id="cb983-4" data-line-number="4"><span class="kw">using</span> const_T_2 = T <span class="at">const</span> ;</a>
<a class="sourceLine" id="cb983-5" data-line-number="5"><span class="co">// Tへのポインター</span></a>
<a class="sourceLine" id="cb983-6" data-line-number="6"><span class="kw">using</span> T_pointer = T * ;</a></code></pre></div>
<p>Tはここではint型だ。T型はどんな型でもよい。</p>
<p><code>const T</code>と<code>T const</code>が同じ型であることを思い出せば、<code>const_T_1</code>と<code>const_T_2</code>は同じ型であることがわかるだろう。</p>
<p><code>T_pointer</code>はTへのポインターだ。</p>
<p>次を見ていこう。</p>
<div class="sourceCode" id="cb984"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb984-1" data-line-number="1"><span class="co">// どちらもconstなTへのポインター</span></a>
<a class="sourceLine" id="cb984-2" data-line-number="2"><span class="kw">using</span> const_T_pointer_1 = <span class="at">const</span> T * ;</a>
<a class="sourceLine" id="cb984-3" data-line-number="3"><span class="kw">using</span> const_T_pointer_2 = T <span class="at">const</span> * ;</a></code></pre></div>
<p>これはどちらも同じ型だ。constなTへのポインターとなる。わかりにくければ以下のように書いてもよい。</p>
<div class="sourceCode" id="cb985"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb985-1" data-line-number="1"><span class="co">// constなT</span></a>
<a class="sourceLine" id="cb985-2" data-line-number="2"><span class="kw">using</span> const_T = <span class="at">const</span> <span class="dt">int</span> ;</a>
<a class="sourceLine" id="cb985-3" data-line-number="3"><span class="co">// constなTへのポインター</span></a>
<a class="sourceLine" id="cb985-4" data-line-number="4"><span class="kw">using</span> const_T_pointer = const_T * ;</a></code></pre></div>
<p>実際に使ってみよう。</p>
<div class="sourceCode" id="cb986"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb986-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb986-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb986-3" data-line-number="3">    <span class="at">const</span> <span class="dt">int</span> data = <span class="dv">123</span> ;</a>
<a class="sourceLine" id="cb986-4" data-line-number="4">    <span class="co">// int const *でもよい</span></a>
<a class="sourceLine" id="cb986-5" data-line-number="5">    <span class="at">const</span> <span class="dt">int</span> * ptr = &amp;data ;</a>
<a class="sourceLine" id="cb986-6" data-line-number="6"></a>
<a class="sourceLine" id="cb986-7" data-line-number="7">    <span class="co">// 読み込み</span></a>
<a class="sourceLine" id="cb986-8" data-line-number="8">    <span class="dt">int</span> read = *ptr ;</a>
<a class="sourceLine" id="cb986-9" data-line-number="9">}</a></code></pre></div>
<p>constなintへのポインターなので、このポインターの参照先を変更することはできない。ポインターは変更できる。</p>
<div class="sourceCode" id="cb987"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb987-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb987-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb987-3" data-line-number="3">    <span class="at">const</span> <span class="dt">int</span> x {} ;</a>
<a class="sourceLine" id="cb987-4" data-line-number="4">    <span class="at">const</span> <span class="dt">int</span> * ptr = &amp;x ;</a>
<a class="sourceLine" id="cb987-5" data-line-number="5"></a>
<a class="sourceLine" id="cb987-6" data-line-number="6">    <span class="co">// エラー</span></a>
<a class="sourceLine" id="cb987-7" data-line-number="7">    <span class="co">// constな参照先を変更できない</span></a>
<a class="sourceLine" id="cb987-8" data-line-number="8">    *ptr = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb987-9" data-line-number="9"></a>
<a class="sourceLine" id="cb987-10" data-line-number="10">    <span class="dt">int</span> y {} ;</a>
<a class="sourceLine" id="cb987-11" data-line-number="11">    <span class="co">// OK</span></a>
<a class="sourceLine" id="cb987-12" data-line-number="12">    <span class="co">// ポインターはconstではないので値が変更できる</span></a>
<a class="sourceLine" id="cb987-13" data-line-number="13">    ptr = &amp;y ;</a>
<a class="sourceLine" id="cb987-14" data-line-number="14">}</a></code></pre></div>
<p>constなのはintであってポインターではない。<code>const int *</code>、もしくは<code>int const *</code>は参照先のintがconstなので、参照先を変更することができない。ポインターはconstではないので、ポインターの値は変更できる。</p>
<p>constなT型へのリファレンスでconstではないT型のオブジェクトを参照できるように、constなT型へのポインターからconstではないT型のオブジェクトを参照できる。</p>
<div class="sourceCode" id="cb988"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb988-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb988-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb988-3" data-line-number="3">    <span class="co">// constではない</span></a>
<a class="sourceLine" id="cb988-4" data-line-number="4">    <span class="dt">int</span> data { } ;</a>
<a class="sourceLine" id="cb988-5" data-line-number="5"></a>
<a class="sourceLine" id="cb988-6" data-line-number="6">    <span class="co">// OK</span></a>
<a class="sourceLine" id="cb988-7" data-line-number="7">    <span class="at">const</span> <span class="dt">int</span> &amp; ref = data ;</a>
<a class="sourceLine" id="cb988-8" data-line-number="8">    <span class="co">// OK</span></a>
<a class="sourceLine" id="cb988-9" data-line-number="9">    <span class="at">const</span> <span class="dt">int</span> * ptr = &amp;data ;</a>
<a class="sourceLine" id="cb988-10" data-line-number="10">}</a></code></pre></div>
<p>この場合、リファレンスやポインターは<code>const int</code>扱いなので、リファレンスやポインターを経由して読むことはできるが変更はできない。</p>
<div class="sourceCode" id="cb989"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb989-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb989-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb989-3" data-line-number="3">    <span class="dt">int</span> data = <span class="dv">123</span> ;</a>
<a class="sourceLine" id="cb989-4" data-line-number="4">    <span class="at">const</span> <span class="dt">int</span> * ptr = &amp;data ;</a>
<a class="sourceLine" id="cb989-5" data-line-number="5">    <span class="co">// エラー</span></a>
<a class="sourceLine" id="cb989-6" data-line-number="6">    <span class="co">// 変更できない</span></a>
<a class="sourceLine" id="cb989-7" data-line-number="7">    *ptr = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb989-8" data-line-number="8"></a>
<a class="sourceLine" id="cb989-9" data-line-number="9">    <span class="co">// 変更できる</span></a>
<a class="sourceLine" id="cb989-10" data-line-number="10">    data = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb989-11" data-line-number="11">}</a></code></pre></div>
<p>その次はconstなポインターだ。</p>
<div class="sourceCode" id="cb990"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb990-1" data-line-number="1"><span class="co">// Tへのconstなポインター</span></a>
<a class="sourceLine" id="cb990-2" data-line-number="2"><span class="kw">using</span> T_const_pointer = T * <span class="at">const</span> ;</a></code></pre></div>
<p>これはポインターがconstなのであって、Tはconstではない。したがってポインターを経由して参照先を変更することはできるが、ポインターの値自体は変更できない型だ。</p>
<div class="sourceCode" id="cb991"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb991-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb991-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb991-3" data-line-number="3">    <span class="dt">int</span> data { } ;</a>
<a class="sourceLine" id="cb991-4" data-line-number="4"></a>
<a class="sourceLine" id="cb991-5" data-line-number="5">    <span class="co">// constなポインター</span></a>
<a class="sourceLine" id="cb991-6" data-line-number="6">    <span class="dt">int</span> * <span class="at">const</span> ptr = &amp;data ;</a>
<a class="sourceLine" id="cb991-7" data-line-number="7"></a>
<a class="sourceLine" id="cb991-8" data-line-number="8">    <span class="co">// OK、参照先は変更できる</span></a>
<a class="sourceLine" id="cb991-9" data-line-number="9">    *ptr = <span class="dv">1</span> ;</a>
<a class="sourceLine" id="cb991-10" data-line-number="10"></a>
<a class="sourceLine" id="cb991-11" data-line-number="11">    <span class="co">// エラー、値は変更できない</span></a>
<a class="sourceLine" id="cb991-12" data-line-number="12">    ptr = <span class="kw">nullptr</span> ;</a>
<a class="sourceLine" id="cb991-13" data-line-number="13">}</a></code></pre></div>
<p>最後はconstなTへのconstなポインターだ。</p>
<div class="sourceCode" id="cb992"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb992-1" data-line-number="1"><span class="co">// どちらもconstなTへのconstなポインター</span></a>
<a class="sourceLine" id="cb992-2" data-line-number="2"><span class="kw">using</span> const_T_const_pointer_1 = <span class="at">const</span> T * <span class="at">const</span> ;</a>
<a class="sourceLine" id="cb992-3" data-line-number="3"><span class="kw">using</span> const_T_const_pointer_2 = T <span class="at">const</span> * <span class="at">const</span> ;</a></code></pre></div>
<p>これはconstなTなので、ポインターを経由して参照先を変更できないし、constなポインターなのでポインターの値も変更できない。</p>
<div class="sourceCode" id="cb993"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb993-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb993-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb993-3" data-line-number="3">    <span class="dt">int</span> data = <span class="dv">123</span> ;</a>
<a class="sourceLine" id="cb993-4" data-line-number="4"></a>
<a class="sourceLine" id="cb993-5" data-line-number="5">    <span class="dt">int</span> <span class="at">const</span> * <span class="at">const</span> ptr = &amp;data ;</a>
<a class="sourceLine" id="cb993-6" data-line-number="6"></a>
<a class="sourceLine" id="cb993-7" data-line-number="7">    <span class="co">// OK、参照先は読める</span></a>
<a class="sourceLine" id="cb993-8" data-line-number="8">    <span class="dt">int</span> read = *ptr ;</a>
<a class="sourceLine" id="cb993-9" data-line-number="9">    <span class="co">// エラー、参照先は変更できない</span></a>
<a class="sourceLine" id="cb993-10" data-line-number="10">    *ptr = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb993-11" data-line-number="11">    <span class="co">// エラー、ポインターは変更できない</span></a>
<a class="sourceLine" id="cb993-12" data-line-number="12">    ptr = <span class="kw">nullptr</span> ;</a>
<a class="sourceLine" id="cb993-13" data-line-number="13">}</a></code></pre></div>
<h3 id="ポインターのポインター">ポインターのポインター</h3>
<p>ポインター型というのは、「ある型Tへのポインター」という形で表現できる。この型Tにはどんな型でも使うことができる。ところで、ポインターというのは型だ。もしTがポインター型の場合はどうなるのだろう。</p>
<p>例えば、「T型へのポインター型」で、型Tが「U型へのポインター型」の場合、全体としては「U型へのポインター型へのポインター型」になる。これはC++の文法では<code>U **</code>となる。</p>
<p>C++のコードで確認しよう。</p>
<div class="sourceCode" id="cb994"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb994-1" data-line-number="1"><span class="co">// 適当なU型</span></a>
<a class="sourceLine" id="cb994-2" data-line-number="2"><span class="kw">using</span> U = <span class="dt">int</span> ;</a>
<a class="sourceLine" id="cb994-3" data-line-number="3"><span class="co">// ポインターとしてのT型</span></a>
<a class="sourceLine" id="cb994-4" data-line-number="4"><span class="kw">using</span> T = U * ;</a>
<a class="sourceLine" id="cb994-5" data-line-number="5"><span class="co">// T型へのポインター型</span></a>
<a class="sourceLine" id="cb994-6" data-line-number="6"><span class="co">// つまりU型へのポインター型へのポインター型</span></a>
<a class="sourceLine" id="cb994-7" data-line-number="7"><span class="co">// つまりU **</span></a>
<a class="sourceLine" id="cb994-8" data-line-number="8"><span class="kw">using</span> type = T * ;</a></code></pre></div>
<p>具体的に書いてみよう。</p>
<div class="sourceCode" id="cb995"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb995-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb995-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb995-3" data-line-number="3">    <span class="co">// int</span></a>
<a class="sourceLine" id="cb995-4" data-line-number="4">    <span class="dt">int</span> x = <span class="dv">123</span> ;</a>
<a class="sourceLine" id="cb995-5" data-line-number="5">    <span class="co">// intへのポインター</span></a>
<a class="sourceLine" id="cb995-6" data-line-number="6">    <span class="dt">int</span> * p = &amp;x ;</a>
<a class="sourceLine" id="cb995-7" data-line-number="7">    <span class="co">// intへのポインターのポインター</span></a>
<a class="sourceLine" id="cb995-8" data-line-number="8">    <span class="dt">int</span> ** pp = &amp;p ;</a>
<a class="sourceLine" id="cb995-9" data-line-number="9"></a>
<a class="sourceLine" id="cb995-10" data-line-number="10"></a>
<a class="sourceLine" id="cb995-11" data-line-number="11">    <span class="co">// 123</span></a>
<a class="sourceLine" id="cb995-12" data-line-number="12">    <span class="co">// ポインターを経由したポインターを経由したxの読み込み</span></a>
<a class="sourceLine" id="cb995-13" data-line-number="13">    <span class="dt">int</span> value1 = **pp ; </a>
<a class="sourceLine" id="cb995-14" data-line-number="14"></a>
<a class="sourceLine" id="cb995-15" data-line-number="15">    <span class="dt">int</span> y = <span class="dv">456</span> ;</a>
<a class="sourceLine" id="cb995-16" data-line-number="16">    <span class="co">// ポインターを経由した変数pの変更</span></a>
<a class="sourceLine" id="cb995-17" data-line-number="17">    *pp = &amp;y ;</a>
<a class="sourceLine" id="cb995-18" data-line-number="18"></a>
<a class="sourceLine" id="cb995-19" data-line-number="19">    <span class="co">// 456</span></a>
<a class="sourceLine" id="cb995-20" data-line-number="20">    <span class="co">// ポインターを経由したポインターを経由したyの読み込み</span></a>
<a class="sourceLine" id="cb995-21" data-line-number="21">    <span class="dt">int</span> value2 = **pp ;</a>
<a class="sourceLine" id="cb995-22" data-line-number="22">}</a></code></pre></div>
<p>xはintだ。pはintへのポインターだ。ここまでは今までどおりだ。</p>
<p>ppは<code>int **</code>という型で、「intへのポインターへのポインター」型だ。このポインターの値のためには「intへのポインターのポインター」が必要だ。変数pのポインターは<code>&amp;p</code>で得られる。この場合、変数pは「intへのポインター」でなければならない。そうした場合、変数pのポインターは「intへのポインターのポインター」型の値になる。</p>
<p>変数ppは「intへのポインターのポインター」だ。変数ppの参照先の変数pを読み書きするには、<code>*pp</code>と書く。これはまだ「intへのポインター」だ。ここからさらに参照先のint型のオブジェクトにアクセスするには、その結果にさらに<code>*</code>を書く。結果として<code>**pp</code>となる。</p>
<p>わかりにくければ変数に代入するとよい。</p>
<div class="sourceCode" id="cb996"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb996-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb996-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb996-3" data-line-number="3">    <span class="dt">int</span> object { } ;</a>
<a class="sourceLine" id="cb996-4" data-line-number="4"></a>
<a class="sourceLine" id="cb996-5" data-line-number="5">    <span class="dt">int</span> *   a = &amp;object ;</a>
<a class="sourceLine" id="cb996-6" data-line-number="6">    <span class="dt">int</span> **  b = &amp;a ;</a>
<a class="sourceLine" id="cb996-7" data-line-number="7"></a>
<a class="sourceLine" id="cb996-8" data-line-number="8">    <span class="co">// cとaは同じ値</span></a>
<a class="sourceLine" id="cb996-9" data-line-number="9">    <span class="dt">int</span> * c = *pointer_to_pointer_to_object ;</a>
<a class="sourceLine" id="cb996-10" data-line-number="10"></a>
<a class="sourceLine" id="cb996-11" data-line-number="11">    <span class="co">// objectに1が代入される</span></a>
<a class="sourceLine" id="cb996-12" data-line-number="12">    *c = <span class="dv">1</span> ;</a>
<a class="sourceLine" id="cb996-13" data-line-number="13">    <span class="co">// objectに2が代入される</span></a>
<a class="sourceLine" id="cb996-14" data-line-number="14">    **b = <span class="dv">2</span> ;</a>
<a class="sourceLine" id="cb996-15" data-line-number="15">}</a></code></pre></div>
<p>リファレンスを使うという手もある。</p>
<div class="sourceCode" id="cb997"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb997-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb997-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb997-3" data-line-number="3">    <span class="dt">int</span> object { } ;</a>
<a class="sourceLine" id="cb997-4" data-line-number="4"></a>
<a class="sourceLine" id="cb997-5" data-line-number="5">    <span class="dt">int</span> *   a = &amp;object ;</a>
<a class="sourceLine" id="cb997-6" data-line-number="6">    <span class="dt">int</span> **  b = &amp;a ;</a>
<a class="sourceLine" id="cb997-7" data-line-number="7"></a>
<a class="sourceLine" id="cb997-8" data-line-number="8">    <span class="dt">int</span> &amp; r1 = *a ;</a>
<a class="sourceLine" id="cb997-9" data-line-number="9"></a>
<a class="sourceLine" id="cb997-10" data-line-number="10">    <span class="co">// objectに1が代入される</span></a>
<a class="sourceLine" id="cb997-11" data-line-number="11">    r1 = <span class="dv">1</span> ;</a>
<a class="sourceLine" id="cb997-12" data-line-number="12"></a>
<a class="sourceLine" id="cb997-13" data-line-number="13">    <span class="dt">int</span> &amp;r2 = **b ;</a>
<a class="sourceLine" id="cb997-14" data-line-number="14"></a>
<a class="sourceLine" id="cb997-15" data-line-number="15">    <span class="co">// objectに2が代入される</span></a>
<a class="sourceLine" id="cb997-16" data-line-number="16">    r2 = <span class="dv">2</span> ;</a>
<a class="sourceLine" id="cb997-17" data-line-number="17">}</a></code></pre></div>
<p>「ポインターへのポインター」があるということは、「ポインターへのポインターへのポインター」もあるということだろうか。もちろんある。</p>
<div class="sourceCode" id="cb998"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb998-1" data-line-number="1"><span class="co">// intへのポインターへのポインターへのポインター型</span></a>
<a class="sourceLine" id="cb998-2" data-line-number="2"><span class="kw">using</span> type = <span class="dt">int</span> *** ;</a>
<a class="sourceLine" id="cb998-3" data-line-number="3"></a>
<a class="sourceLine" id="cb998-4" data-line-number="4"><span class="co">// intへのポインターへのポインターへのポインターへのポインター型</span></a>
<a class="sourceLine" id="cb998-5" data-line-number="5"><span class="co">// int ****</span></a>
<a class="sourceLine" id="cb998-6" data-line-number="6"><span class="kw">using</span> <span class="dt">pointer_to_type</span> = type * ;</a></code></pre></div>
<p>もちろんconstもつけられる。</p>
<div class="sourceCode" id="cb999"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb999-1" data-line-number="1"><span class="kw">using</span> type = <span class="dt">int</span> <span class="at">const</span> * <span class="at">const</span> * <span class="at">const</span> * <span class="at">const</span> ;</a></code></pre></div>
<h3 id="関数へのポインター">関数へのポインター</h3>
<p>関数へのポインターを説明する前に、まず型としての関数を説明しなければならない。</p>
<p>関数にも型がある。例えば以下のような関数、</p>
<div class="sourceCode" id="cb1000"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1000-1" data-line-number="1"><span class="dt">int</span> f( <span class="dt">int</span> ) ;</a>
<a class="sourceLine" id="cb1000-2" data-line-number="2"><span class="dt">double</span> g( <span class="dt">double</span>, <span class="dt">double</span> ) ;</a></code></pre></div>
<p>の型は、</p>
<div class="sourceCode" id="cb1001"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1001-1" data-line-number="1"><span class="kw">using</span> <span class="dt">f_type</span> = <span class="dt">int</span> ( <span class="dt">int</span> ) ;</a>
<a class="sourceLine" id="cb1001-2" data-line-number="2"><span class="kw">using</span> <span class="va">g_type</span> = <span class="dt">double</span> ( <span class="dt">double</span>, <span class="dt">double</span> ) ;</a></code></pre></div>
<p>となる。関数から関数名を取り除いたものが関数の型だ。すると関数へのポインター型は以下のようになる。</p>
<div class="sourceCode" id="cb1002"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1002-1" data-line-number="1"><span class="kw">using</span> f_pointer = <span class="dt">f_type</span> * ;</a>
<a class="sourceLine" id="cb1002-2" data-line-number="2"><span class="kw">using</span> <span class="va">g_pointer</span> = <span class="va">g_type</span> * ;</a></code></pre></div>
<p>早速試してみよう。</p>
<div class="sourceCode" id="cb1003"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1003-1" data-line-number="1"><span class="co">// 実引数を出力して返す関数</span></a>
<a class="sourceLine" id="cb1003-2" data-line-number="2"><span class="dt">int</span> f( <span class="dt">int</span> x )</a>
<a class="sourceLine" id="cb1003-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb1003-4" data-line-number="4">    <span class="bu">std::</span>cout &lt;&lt; x ;</a>
<a class="sourceLine" id="cb1003-5" data-line-number="5">    <span class="cf">return</span> x ;</a>
<a class="sourceLine" id="cb1003-6" data-line-number="6">}</a>
<a class="sourceLine" id="cb1003-7" data-line-number="7"></a>
<a class="sourceLine" id="cb1003-8" data-line-number="8"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1003-9" data-line-number="9">{</a>
<a class="sourceLine" id="cb1003-10" data-line-number="10">    <span class="kw">using</span> <span class="dt">f_type</span> = <span class="dt">int</span> ( <span class="dt">int</span> ) ;</a>
<a class="sourceLine" id="cb1003-11" data-line-number="11">    <span class="kw">using</span> f_pointer = <span class="dt">f_type</span> * ;</a>
<a class="sourceLine" id="cb1003-12" data-line-number="12"></a>
<a class="sourceLine" id="cb1003-13" data-line-number="13">    f_pointer ptr = &amp;f ;</a>
<a class="sourceLine" id="cb1003-14" data-line-number="14"></a>
<a class="sourceLine" id="cb1003-15" data-line-number="15">    <span class="co">// 関数へのポインターを経由した関数呼び出し</span></a>
<a class="sourceLine" id="cb1003-16" data-line-number="16">    (*ptr)(<span class="dv">123</span>) ;</a>
<a class="sourceLine" id="cb1003-17" data-line-number="17">}</a></code></pre></div>
<p>動くようだ。最後の関数呼び出しはまず参照先を得て<code>(*ptr)</code>、その後に関数呼び出し<code>(123)</code>をしている。これは面倒なので、C++では特別に関数へのポインターはそのまま関数呼び出しすることができるようになっている。</p>
<div class="sourceCode" id="cb1004"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1004-1" data-line-number="1"><span class="co">// 関数へのポインターを経由した関数呼び出し</span></a>
<a class="sourceLine" id="cb1004-2" data-line-number="2">ptr(<span class="dv">123</span>) ;</a></code></pre></div>
<p>ところで、変数ptrの宣言を、f_pointerというエイリアス宣言を使わずに書くと、以下のようになる。</p>
<div class="sourceCode" id="cb1005"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1005-1" data-line-number="1"><span class="co">// 適当な関数</span></a>
<a class="sourceLine" id="cb1005-2" data-line-number="2"><span class="dt">int</span> f( <span class="dt">int</span> ) { <span class="cf">return</span> <span class="dv">0</span> ; }</a>
<a class="sourceLine" id="cb1005-3" data-line-number="3"></a>
<a class="sourceLine" id="cb1005-4" data-line-number="4"><span class="co">// 変数ptrの宣言</span></a>
<a class="sourceLine" id="cb1005-5" data-line-number="5"><span class="co">// int (int)へのポインター</span></a>
<a class="sourceLine" id="cb1005-6" data-line-number="6"><span class="dt">int</span> (*ptr)(<span class="dt">int</span>) = &amp;f ;</a></code></pre></div>
<p>なぜこうなるのか。これを完全に理解するためにはC++の宣言子(declarator)という文法の詳細な理解が必要だ。</p>
<p>ここでは詳細を飛ばして重要な部分だけ伝えるが、型名のうちポインターであることを指定する<code>*</code>は、名前にかかる。</p>
<div class="sourceCode" id="cb1006"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1006-1" data-line-number="1"><span class="co">// この *はnameにかかる</span></a>
<a class="sourceLine" id="cb1006-2" data-line-number="2"><span class="dt">int</span> * name ;</a></code></pre></div>
<p>つまり以下のような意味だ。</p>
<div class="sourceCode" id="cb1007"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1007-1" data-line-number="1"><span class="dt">int</span> (*name) ;</a></code></pre></div>
<p>型名だけを指定する場合、名前が省略される。</p>
<div class="sourceCode" id="cb1008"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1008-1" data-line-number="1"><span class="co">// 名前が省略されている</span></a>
<a class="sourceLine" id="cb1008-2" data-line-number="2"><span class="kw">using</span> type = <span class="dt">int</span> * ;</a></code></pre></div>
<p>つまり以下のような意味だ。</p>
<div class="sourceCode" id="cb1009"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1009-1" data-line-number="1"><span class="kw">using</span> type = <span class="dt">int</span> (*) ;</a></code></pre></div>
<p>そのため、<code>int * name( int )</code>と書いた場合、これは「int型の引数を取り、int型へのポインターを戻り値として返す関数」となる。</p>
<div class="sourceCode" id="cb1010"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1010-1" data-line-number="1"><span class="dt">int</span> * f( <span class="dt">int</span> ){ <span class="cf">return</span> <span class="kw">nullptr</span> ; }</a></code></pre></div>
<p>そうではなく、「int型の引数をとりint型の戻り値を返す関数へのポインター」を書きたい場合は、</p>
<div class="sourceCode" id="cb1011"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1011-1" data-line-number="1"><span class="kw">using</span> type = <span class="dt">int</span> (*)(<span class="dt">int</span>) ;</a></code></pre></div>
<p>としなければならない。</p>
<p>変数の名前を入れる場所は以下の通り</p>
<div class="sourceCode" id="cb1012"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1012-1" data-line-number="1"><span class="kw">using</span> type =</a>
<a class="sourceLine" id="cb1012-2" data-line-number="2"><span class="dt">int</span></a>
<a class="sourceLine" id="cb1012-3" data-line-number="3">( * <span class="co">// ポインター</span></a>
<a class="sourceLine" id="cb1012-4" data-line-number="4"><span class="co">// ここに変数が省略されている</span></a>
<a class="sourceLine" id="cb1012-5" data-line-number="5">)(<span class="dt">int</span>) ;</a></code></pre></div>
<p>なので、</p>
<div class="sourceCode" id="cb1013"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1013-1" data-line-number="1"><span class="dt">int</span> (*ptr)(<span class="dt">int</span>) = <span class="kw">nullptr</span> ;</a></code></pre></div>
<p>となる。あるいは以下のように書いてもいい。</p>
<div class="sourceCode" id="cb1014"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1014-1" data-line-number="1"><span class="kw">using</span> <span class="dt">function_type</span> = <span class="dt">int</span> (<span class="dt">int</span>) ;</a>
<a class="sourceLine" id="cb1014-2" data-line-number="2"><span class="kw">using</span> <span class="dt">function_pointer_type</span> = <span class="dt">function_type</span> * ;</a>
<a class="sourceLine" id="cb1014-3" data-line-number="3"></a>
<a class="sourceLine" id="cb1014-4" data-line-number="4"><span class="dt">function_pointer_type</span> ptr = <span class="kw">nullptr</span> ;</a></code></pre></div>
<p>関数へのポインターは型であり、値でもある。値であるということは、関数は引数として関数へのポインターを受け取ったり、関数へのポインターを返したりできるということだ。</p>
<p>早速書いてみよう。</p>
<div class="sourceCode" id="cb1015"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1015-1" data-line-number="1"><span class="dt">int</span> f( <span class="dt">int</span> x ) { <span class="cf">return</span> x ; }</a>
<a class="sourceLine" id="cb1015-2" data-line-number="2"><span class="kw">using</span> f_ptr = <span class="dt">int</span> (*) (<span class="dt">int</span> ) ;</a>
<a class="sourceLine" id="cb1015-3" data-line-number="3"><span class="co">// 関数へのポインターを引数にとり</span></a>
<a class="sourceLine" id="cb1015-4" data-line-number="4"><span class="co">// 関数へのポインターを戻り値として返す</span></a>
<a class="sourceLine" id="cb1015-5" data-line-number="5"><span class="co">// 関数g</span></a>
<a class="sourceLine" id="cb1015-6" data-line-number="6">f_ptr g( f_ptr p )</a>
<a class="sourceLine" id="cb1015-7" data-line-number="7">{</a>
<a class="sourceLine" id="cb1015-8" data-line-number="8">    p(<span class="dv">0</span>) ;</a>
<a class="sourceLine" id="cb1015-9" data-line-number="9">    <span class="cf">return</span> p ;</a>
<a class="sourceLine" id="cb1015-10" data-line-number="10">}</a>
<a class="sourceLine" id="cb1015-11" data-line-number="11"></a>
<a class="sourceLine" id="cb1015-12" data-line-number="12"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1015-13" data-line-number="13">{</a>
<a class="sourceLine" id="cb1015-14" data-line-number="14">    g(&amp;f) ;</a>
<a class="sourceLine" id="cb1015-15" data-line-number="15">}</a></code></pre></div>
<p>これは動く。ところでこの関数gへのポインターはどう書けばいいのだろうか。つまり、</p>
<pre><code>auto ptr = &amp;g ;</code></pre>
<p>を<code>auto</code>を使わずに書くとどうなるのだろうか。</p>
<p>以下のようになる。</p>
<div class="sourceCode" id="cb1017"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1017-1" data-line-number="1"><span class="dt">int</span> (*(*ptr)(<span class="dt">int</span> (*)(<span class="dt">int</span>)))(<span class="dt">int</span>) = &amp;g ;</a></code></pre></div>
<p>なぜこうなるのか。分解すると以下のようになる。</p>
<div class="sourceCode" id="cb1018"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1018-1" data-line-number="1"><span class="dt">int</span> (* <span class="co">// 戻り値型前半</span></a>
<a class="sourceLine" id="cb1018-2" data-line-number="2">    (*ptr) <span class="co">// 変数名</span></a>
<a class="sourceLine" id="cb1018-3" data-line-number="3">    (<span class="co">// 関数の引数</span></a>
<a class="sourceLine" id="cb1018-4" data-line-number="4">        <span class="dt">int</span> (*)(<span class="dt">int</span>) <span class="co">// 引数としての関数へのポインター</span></a>
<a class="sourceLine" id="cb1018-5" data-line-number="5">    )<span class="co">// 関数の引数</span></a>
<a class="sourceLine" id="cb1018-6" data-line-number="6"></a>
<a class="sourceLine" id="cb1018-7" data-line-number="7">)(<span class="dt">int</span>) <span class="co">// 戻り値の型後半</span></a>
<a class="sourceLine" id="cb1018-8" data-line-number="8"></a>
<a class="sourceLine" id="cb1018-9" data-line-number="9"> = &amp;g ; <span class="co">// 初期化子</span></a></code></pre></div>
<p>これはわかりにくい。戻り値の型を後ろに書く文法を使うと少し読みやすくなる。</p>
<div class="sourceCode" id="cb1019"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1019-1" data-line-number="1"><span class="kw">auto</span> (*ptr)( <span class="dt">int</span> (*)(<span class="dt">int</span>) ) -&gt; <span class="dt">int</span> (*)(<span class="dt">int</span>) = &amp;g ;</a></code></pre></div>
<p>これを分解すると以下のようになる。</p>
<div class="sourceCode" id="cb1020"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1020-1" data-line-number="1"><span class="kw">auto</span> <span class="co">// プレイスホルダー</span></a>
<a class="sourceLine" id="cb1020-2" data-line-number="2">(*ptr) <span class="co">// 変数名</span></a>
<a class="sourceLine" id="cb1020-3" data-line-number="3">( <span class="dt">int</span> (*)(<span class="dt">int</span>) ) <span class="co">// 引数</span></a>
<a class="sourceLine" id="cb1020-4" data-line-number="4">-&gt; <span class="dt">int</span> (*)(<span class="dt">int</span>) <span class="co">// 戻り値の型</span></a>
<a class="sourceLine" id="cb1020-5" data-line-number="5">= &amp;g ; <span class="co">// 初期化子</span></a></code></pre></div>
<p>もちろん、これでもまだわかりにくいので、エイリアス宣言を使ったほうがよい。</p>
<div class="sourceCode" id="cb1021"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1021-1" data-line-number="1"><span class="kw">using</span> func_ptr = <span class="dt">int</span>(*)(<span class="dt">int</span>) ;</a>
<a class="sourceLine" id="cb1021-2" data-line-number="2"></a>
<a class="sourceLine" id="cb1021-3" data-line-number="3"><span class="kw">auto</span> (*ptr)(func_ptr) -&gt; func_ptr = &amp;g ;</a></code></pre></div>
<h3 id="配列へのポインター">配列へのポインター</h3>
<p>配列へのポインターについて学ぶ前に、配列の型について学ぶ必要がある。</p>
<p>配列の型は、要素の型をT、要素数をNとすると、<code>T [N]</code>となる。</p>
<div class="sourceCode" id="cb1022"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1022-1" data-line-number="1"><span class="co">// 要素型int、要素数5の配列型</span></a>
<a class="sourceLine" id="cb1022-2" data-line-number="2"><span class="kw">using</span> int5 = <span class="dt">int</span> [<span class="dv">5</span>] ;</a>
<a class="sourceLine" id="cb1022-3" data-line-number="3"><span class="co">// 要素型double、要素数10の配列型</span></a>
<a class="sourceLine" id="cb1022-4" data-line-number="4"><span class="kw">using</span> double10 = <span class="dt">double</span> [<span class="dv">10</span>] ;</a></code></pre></div>
<p>関数型と同じく、ポインター宣言子である<code>*</code>は名前につく。</p>
<div class="sourceCode" id="cb1023"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1023-1" data-line-number="1"><span class="co">// 要素型int、要素数5の配列へのポインター型</span></a>
<a class="sourceLine" id="cb1023-2" data-line-number="2"><span class="kw">using</span> <span class="dt">pointer_to_array_type</span> = <span class="dt">int</span> (*)[<span class="dv">5</span>] ;</a>
<a class="sourceLine" id="cb1023-3" data-line-number="3"></a>
<a class="sourceLine" id="cb1023-4" data-line-number="4"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1023-5" data-line-number="5">{</a>
<a class="sourceLine" id="cb1023-6" data-line-number="6">    <span class="dt">int</span> a[<span class="dv">5</span>] ;</a>
<a class="sourceLine" id="cb1023-7" data-line-number="7">    <span class="dt">pointer_to_function_type</span> = &amp;a ;</a>
<a class="sourceLine" id="cb1023-8" data-line-number="8">}</a></code></pre></div>
<p>エイリアス宣言を使わない変数の宣言は以下のようになる。</p>
<div class="sourceCode" id="cb1024"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1024-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1024-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1024-3" data-line-number="3">    <span class="dt">int</span> a[<span class="dv">5</span>] ;</a>
<a class="sourceLine" id="cb1024-4" data-line-number="4">    <span class="dt">int</span> (*p)[<span class="dv">5</span>] = &amp;a ;</a>
<a class="sourceLine" id="cb1024-5" data-line-number="5">}</a></code></pre></div>
<p>配列とポインターは密接に関係している。そのため、配列名は配列の先頭要素へのポインターに暗黙に変換される。</p>
<div class="sourceCode" id="cb1025"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1025-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1025-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1025-3" data-line-number="3">    <span class="dt">int</span> a[<span class="dv">5</span>] = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</a>
<a class="sourceLine" id="cb1025-4" data-line-number="4"></a>
<a class="sourceLine" id="cb1025-5" data-line-number="5">    <span class="co">// &amp;a[0]と同じ</span></a>
<a class="sourceLine" id="cb1025-6" data-line-number="6">    <span class="dt">int</span> * ptr = a ;</a>
<a class="sourceLine" id="cb1025-7" data-line-number="7">}</a></code></pre></div>
<p>配列とポインターの関係については、ポインターの詳細で詳しく説明する。</p>
<h3 id="ポインター型の作り方">ポインター型の作り方</h3>
<p>T型へのポインター型は<code>T *</code>で作ることができる。</p>
<p>ただし、Tが<code>int (int)</code>のような関数型である場合は、<code>int (*)(int)</code>になる。配列型の場合は要素数Nまで必要で<code>T (*)[N]</code>になる。</p>
<p>エイリアス宣言で型に別名をつけると<code>T *</code>でよくなる。</p>
<div class="sourceCode" id="cb1026"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1026-1" data-line-number="1"><span class="kw">using</span> <span class="dt">function_type</span> = <span class="dt">int</span> (<span class="dt">int</span>) ;</a>
<a class="sourceLine" id="cb1026-2" data-line-number="2"><span class="kw">using</span> <span class="dt">pointer_to_function_type</span> = <span class="dt">function_type</span> * ;</a></code></pre></div>
<p>ポインターの型を書く際に、このようなことをいちいち考えるのは面倒だ。ここで必要のなのは、ある型<code>T</code>を受け取ったときに型<code>T *</code>を得るような方法だ。ところで、物覚えのいい読者は前にも似たような文章を読んだことに気がつくだろう。そう、テンプレートだ。</p>
<p>テンプレートは型を引数化できる機能だ。今まではクラスや関数にしか使っていなかったが、実はエイリアス宣言にも使えるのだ。</p>
<div class="sourceCode" id="cb1027"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1027-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;</a>
<a class="sourceLine" id="cb1027-2" data-line-number="2"><span class="kw">using</span> type = T ;</a></code></pre></div>
<p>これは引数と同じ型になるエイリアステンプレートだ。使ってみよう。</p>
<div class="sourceCode" id="cb1028"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1028-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt; <span class="kw">using</span> type = T ;</a>
<a class="sourceLine" id="cb1028-2" data-line-number="2"></a>
<a class="sourceLine" id="cb1028-3" data-line-number="3"><span class="co">// aはint</span></a>
<a class="sourceLine" id="cb1028-4" data-line-number="4">type&lt;<span class="dt">int</span>&gt; a = <span class="dv">123</span> ;</a>
<a class="sourceLine" id="cb1028-5" data-line-number="5"><span class="co">// bはdouble</span></a>
<a class="sourceLine" id="cb1028-6" data-line-number="6">type&lt;<span class="dt">double</span>&gt; b = <span class="fl">1.23</span> ;</a>
<a class="sourceLine" id="cb1028-7" data-line-number="7"><span class="co">// cはstd::vector&lt;int&gt;</span></a>
<a class="sourceLine" id="cb1028-8" data-line-number="8">type&lt;<span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt;&gt; c = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</a></code></pre></div>
<p><code>using type = int ;</code>というエイリアス宣言があるとき<code>type</code>の型はintだ。エイリアス宣言は新しい<code>type</code>という型を作るわけではない。</p>
<p>同様に、上のエイリアステンプレートtypeによる<code>type&lt;int&gt;</code>の型は<code>int</code>だ。新しい<code>type&lt;int&gt;</code>という型ができるわけではない。</p>
<p>もう少し複雑な使い方もしてみよう。</p>
<div class="sourceCode" id="cb1029"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1029-1" data-line-number="1"><span class="co">// int</span></a>
<a class="sourceLine" id="cb1029-2" data-line-number="2">type&lt;type&lt;<span class="dt">int</span>&gt;&gt; a = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb1029-3" data-line-number="3"><span class="co">// int</span></a>
<a class="sourceLine" id="cb1029-4" data-line-number="4">type&lt;type&lt;type&lt;<span class="dt">int</span>&gt;&gt;&gt; b = <span class="dv">0</span> ;</a></code></pre></div>
<p><code>type&lt;int&gt;</code>の型は<code>int</code>なので、それを引数に渡した<code>type&lt; type&lt;int&gt; &gt;</code>も<code>int</code>だ。<code>type&lt;T&gt;</code>をいくつネストしようとも<code>int</code>になる。</p>
<div class="sourceCode" id="cb1030"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1030-1" data-line-number="1"><span class="co">// std::vector&lt;int&gt;</span></a>
<a class="sourceLine" id="cb1030-2" data-line-number="2"><span class="bu">std::</span>vector&lt; type&lt;<span class="dt">int</span>&gt; &gt; a = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</a>
<a class="sourceLine" id="cb1030-3" data-line-number="3"><span class="co">// std::vector&lt;int&gt;</span></a>
<a class="sourceLine" id="cb1030-4" data-line-number="4">type&lt;<span class="bu">std::</span>vector&lt;type&lt;<span class="dt">int</span>&gt;&gt;&gt; b = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</a></code></pre></div>
<p><code>type&lt;int&gt;</code>は<code>int</code>なので、<code>std::vector&lt;type&lt;int&gt;&gt;</code>は<code>std::vector&lt;int&gt;</code>になる。それを更に<code>type&lt;T&gt;</code>で囲んでも同じ型だ。</p>
<p><code>type&lt;T&gt;</code>は面白いがなんの役に立つのだろうか。<code>type&lt;T&gt;</code>は型として使える。つまり<code>type&lt;T&gt; *</code>はポインターとして機能するのだ。</p>
<div class="sourceCode" id="cb1031"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1031-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt; <span class="kw">using</span> type = T ;</a>
<a class="sourceLine" id="cb1031-2" data-line-number="2"></a>
<a class="sourceLine" id="cb1031-3" data-line-number="3"><span class="co">// int *</span></a>
<a class="sourceLine" id="cb1031-4" data-line-number="4">type&lt;<span class="dt">int</span>&gt; * a = <span class="kw">nullptr</span> ;</a>
<a class="sourceLine" id="cb1031-5" data-line-number="5"><span class="co">// int (*)(int)</span></a>
<a class="sourceLine" id="cb1031-6" data-line-number="6">type&lt;<span class="dt">int</span>(<span class="dt">int</span>)&gt; * b = <span class="kw">nullptr</span> ;</a>
<a class="sourceLine" id="cb1031-7" data-line-number="7"><span class="co">// int (*) [5]</span></a>
<a class="sourceLine" id="cb1031-8" data-line-number="8">type&lt;<span class="dt">int</span> [<span class="dv">5</span>]&gt; * c = <span class="kw">nullptr</span> ;</a></code></pre></div>
<p><code>type&lt;int&gt; *</code>は<code>int *</code>型だ。<code>type&lt;int(int)&gt; *</code>は<code>int(*)(int)</code>型だ。<code>type&lt;int [5]&gt; *</code>は<code>int (*) [5]</code>型だ。これでもう<code>*</code>をどこに書くかという問題に悩まされることはなくなった。</p>
<p>しかしわざわざ<code>type&lt;T&gt; *</code>と書くのは依然として面倒だ。T型は引数で受け取っているのだから、最初からポインターを返してどうだろうか。</p>
<div class="sourceCode" id="cb1032"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1032-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;</a>
<a class="sourceLine" id="cb1032-2" data-line-number="2"><span class="kw">using</span> <span class="dt">add_pointer_t</span> = T * ;</a></code></pre></div>
<p>さっそく試してみよう。</p>
<div class="sourceCode" id="cb1033"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1033-1" data-line-number="1"><span class="co">// int *</span></a>
<a class="sourceLine" id="cb1033-2" data-line-number="2"><span class="dt">add_pointer_t</span>&lt;<span class="dt">int</span>&gt; a = <span class="kw">nullptr</span> ;</a>
<a class="sourceLine" id="cb1033-3" data-line-number="3"><span class="co">// int **</span></a>
<a class="sourceLine" id="cb1033-4" data-line-number="4"><span class="dt">add_pointer_t</span>&lt;<span class="dt">int</span> *&gt; b = <span class="kw">nullptr</span> ;</a>
<a class="sourceLine" id="cb1033-5" data-line-number="5"><span class="co">// int(*)(int)</span></a>
<a class="sourceLine" id="cb1033-6" data-line-number="6"><span class="dt">add_pointer_t</span>&lt;<span class="dt">int</span>(<span class="dt">int</span>)&gt; c = <span class="kw">nullptr</span> ;</a>
<a class="sourceLine" id="cb1033-7" data-line-number="7"><span class="co">// int(*)[5]</span></a>
<a class="sourceLine" id="cb1033-8" data-line-number="8"><span class="dt">add_pointer_t</span>&lt;<span class="dt">int</span> [<span class="dv">5</span>]&gt; d = <span class="kw">nullptr</span> ;</a></code></pre></div>
<p>どうやら動くようだ。もっと複雑な例も試してみよう。</p>
<div class="sourceCode" id="cb1034"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1034-1" data-line-number="1"><span class="co">// int **</span></a>
<a class="sourceLine" id="cb1034-2" data-line-number="2"><span class="dt">add_pointer_t</span>&lt;<span class="dt">add_pointer_t</span>&lt;<span class="dt">int</span>&gt;&gt; a = <span class="kw">nullptr</span> ;</a></code></pre></div>
<p><code>add_pointer_t&lt;int&gt;</code>は<code>int *</code>なので、その型を<code>add_pointer_t&lt;T&gt;</code>で囲むとその型へのポインターになる。結果として<code>int **</code>になる。</p>
<p>ここで実装した<code>add_pointer_t&lt;T&gt;</code>は<code>T</code>がリファレンスのときにエラーになる。</p>
<div class="sourceCode" id="cb1035"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1035-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt; <span class="kw">using</span> <span class="dt">add_pointer_t</span> = T * ;</a>
<a class="sourceLine" id="cb1035-2" data-line-number="2"><span class="co">// エラー</span></a>
<a class="sourceLine" id="cb1035-3" data-line-number="3"><span class="dt">add_pointer_t</span>&lt;<span class="dt">int</span> &amp;&gt; ptr = <span class="kw">nullptr</span> ;</a></code></pre></div>
<p>実は標準ライブラリにも<code>std::add_pointer_t&lt;T&gt;</code>があり、こちらはリファレンス<code>U &amp;</code>を渡しても、<code>U *</code>になる。</p>
<div class="sourceCode" id="cb1036"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1036-1" data-line-number="1"><span class="co">// OK</span></a>
<a class="sourceLine" id="cb1036-2" data-line-number="2"><span class="co">// int *</span></a>
<a class="sourceLine" id="cb1036-3" data-line-number="3"><span class="bu">std::</span>add_pointer_t&lt;<span class="dt">int</span> &amp;&gt; ptr = <span class="kw">nullptr</span> ;</a></code></pre></div>
<p>標準ライブラリ<code>std::add_pointer_t&lt;T&gt;</code>は、<code>T</code>がリファレンス型の場合、リファレンスは剥がしてポインターを付与するという実装になっている。これをどうやって実装するかについてだが、まだ読者の知識では実装できない。テンプレートについて深く学ぶ必要がある。今は標準ライブラリに頼っておこう。</p>
<p>標準ライブラリには他にも、ポインターを取り除く<code>std::remove_pointer_t&lt;T&gt;</code>もある。</p>
<div class="sourceCode" id="cb1037"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1037-1" data-line-number="1"><span class="co">// int</span></a>
<a class="sourceLine" id="cb1037-2" data-line-number="2"><span class="bu">std::</span>remove_pointer_t&lt;<span class="dt">int</span> * &gt; a = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb1037-3" data-line-number="3"><span class="co">// int</span></a>
<a class="sourceLine" id="cb1037-4" data-line-number="4"><span class="bu">std::</span>remove_pointer_t&lt;</a>
<a class="sourceLine" id="cb1037-5" data-line-number="5">    <span class="bu">std::</span>add_pointer_t&lt;<span class="dt">int</span>&gt;</a>
<a class="sourceLine" id="cb1037-6" data-line-number="6">    &gt; b = <span class="dv">0</span> ;</a></code></pre></div>
<h3 id="クラスへのポインター">クラスへのポインター</h3>
<p>クラスへのポインターは今までに学んだものと同じ文法だ。</p>
<div class="sourceCode" id="cb1038"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1038-1" data-line-number="1"><span class="kw">struct</span> C { } ;</a>
<a class="sourceLine" id="cb1038-2" data-line-number="2"></a>
<a class="sourceLine" id="cb1038-3" data-line-number="3"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1038-4" data-line-number="4">{</a>
<a class="sourceLine" id="cb1038-5" data-line-number="5">    C object ;</a>
<a class="sourceLine" id="cb1038-6" data-line-number="6">    C * pointer = &amp;object ;</a>
<a class="sourceLine" id="cb1038-7" data-line-number="7">} </a></code></pre></div>
<p>ただし、ポインターを経由してメンバーにアクセスするのが曲者だ。</p>
<p>以下のようなメンバーにアクセスするコードがある。</p>
<div class="sourceCode" id="cb1039"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1039-1" data-line-number="1"><span class="kw">struct</span> C</a>
<a class="sourceLine" id="cb1039-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1039-3" data-line-number="3">    <span class="dt">int</span> data_member ;</a>
<a class="sourceLine" id="cb1039-4" data-line-number="4">    <span class="dt">void</span> member_function() {}</a>
<a class="sourceLine" id="cb1039-5" data-line-number="5">} ;</a>
<a class="sourceLine" id="cb1039-6" data-line-number="6"></a>
<a class="sourceLine" id="cb1039-7" data-line-number="7"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1039-8" data-line-number="8">{</a>
<a class="sourceLine" id="cb1039-9" data-line-number="9">    C object ;</a>
<a class="sourceLine" id="cb1039-10" data-line-number="10"></a>
<a class="sourceLine" id="cb1039-11" data-line-number="11">    object.data_member = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb1039-12" data-line-number="12">    object.member_function() ;</a>
<a class="sourceLine" id="cb1039-13" data-line-number="13">}</a></code></pre></div>
<p>これをポインターを経由して書いてみよう。</p>
<p>以下のように書くとエラーだ。</p>
<div class="sourceCode" id="cb1040"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1040-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1040-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1040-3" data-line-number="3">    C object ;</a>
<a class="sourceLine" id="cb1040-4" data-line-number="4">    C * pointer = &amp;object ;</a>
<a class="sourceLine" id="cb1040-5" data-line-number="5"></a>
<a class="sourceLine" id="cb1040-6" data-line-number="6">    <span class="co">// エラー</span></a>
<a class="sourceLine" id="cb1040-7" data-line-number="7">    *pointer.data_member = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb1040-8" data-line-number="8">    <span class="co">// エラー</span></a>
<a class="sourceLine" id="cb1040-9" data-line-number="9">    *pointer.member_function() ;</a>
<a class="sourceLine" id="cb1040-10" data-line-number="10">}</a></code></pre></div>
<p>この理由は演算子の優先順位の問題だ。上の式は以下のように解釈される。</p>
<div class="sourceCode" id="cb1041"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1041-1" data-line-number="1">*(pointer.data_member) = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb1041-2" data-line-number="2">*(pointer.member_function()) ;</a></code></pre></div>
<p>ポインターを参照する演算子<code>*</code>よりも、演算子ドット(‘.’)のほうが演算子の優先順位が高い。</p>
<p>このような式を可能にする変数pointerとは以下のようなものだ。</p>
<div class="sourceCode" id="cb1042"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1042-1" data-line-number="1"><span class="kw">struct</span> Pointer</a>
<a class="sourceLine" id="cb1042-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1042-3" data-line-number="3">    <span class="dt">int</span> data  = <span class="dv">42</span> ;</a>
<a class="sourceLine" id="cb1042-4" data-line-number="4">    <span class="dt">int</span> * data_member = &amp;data ;</a>
<a class="sourceLine" id="cb1042-5" data-line-number="5">    <span class="dt">int</span> * member_function()</a>
<a class="sourceLine" id="cb1042-6" data-line-number="6">    {</a>
<a class="sourceLine" id="cb1042-7" data-line-number="7">        <span class="cf">return</span> &amp;data ;</a>
<a class="sourceLine" id="cb1042-8" data-line-number="8">    }</a>
<a class="sourceLine" id="cb1042-9" data-line-number="9">} ;</a>
<a class="sourceLine" id="cb1042-10" data-line-number="10"></a>
<a class="sourceLine" id="cb1042-11" data-line-number="11"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1042-12" data-line-number="12">{</a>
<a class="sourceLine" id="cb1042-13" data-line-number="13">    Pointer pointer ;</a>
<a class="sourceLine" id="cb1042-14" data-line-number="14"></a>
<a class="sourceLine" id="cb1042-15" data-line-number="15">    *pointer.data_member = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb1042-16" data-line-number="16">    *pointer.member_function() ;</a>
<a class="sourceLine" id="cb1042-17" data-line-number="17">}</a></code></pre></div>
<p><code>pointer.data_member</code>はポインターなのでそれに演算子<code>*</code>を適用して参照した上で0を代入している。</p>
<p><code>pointer.member_function()</code>は関数呼び出しで戻り値としてポインターを返すのでそれに演算子<code>*</code>を適用している。</p>
<p>演算子<code>*</code>を先にポインターの値である<code>pointer</code>に適用するには、括弧を使う。</p>
<div class="sourceCode" id="cb1043"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1043-1" data-line-number="1">(*pointer).data_member = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb1043-2" data-line-number="2">(*pointer).member_function() ;</a></code></pre></div>
<p>リファレンスを使ってポインターを参照した結果をリファレンスに束縛して使うこともできる。</p>
<div class="sourceCode" id="cb1044"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1044-1" data-line-number="1">C &amp; ref = *pointer ;</a>
<a class="sourceLine" id="cb1044-2" data-line-number="2">ref.data_member = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb1044-3" data-line-number="3">ref.member_function() ;</a></code></pre></div>
<p>ただし、ポインターを介してクラスを扱う際に、毎回括弧を使ったりリファレンスを使ったりするのは面倒なので、簡単なシンタックスシュガーとして演算子<code>-&gt;</code>が用意されている。</p>
<div class="sourceCode" id="cb1045"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1045-1" data-line-number="1">pointer-&gt;data_member = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb1045-2" data-line-number="2">pointer-&gt;member_function() ;</a></code></pre></div>
<p><code>a-&gt;b</code>は、<code>(*(a))-&gt;b</code>と同じ意味になる。そのため、上は以下のコードと同じ意味になる。</p>
<div class="sourceCode" id="cb1046"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1046-1" data-line-number="1"></a>
<a class="sourceLine" id="cb1046-2" data-line-number="2">(*(pointer)).data_member = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb1046-3" data-line-number="3">(*(pointer)).member_function() ;</a></code></pre></div>
<h3 id="thisポインター">thisポインター</h3>
<p>メンバー関数はクラスのデータメンバーにアクセスできる。このときのデータメンバーはメンバー関数が呼ばれたクラスのオブジェクトのサブオブジェクトになる。</p>
<div class="sourceCode" id="cb1047"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1047-1" data-line-number="1"><span class="kw">struct</span> C</a>
<a class="sourceLine" id="cb1047-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1047-3" data-line-number="3">    <span class="dt">int</span> data { } ;</a>
<a class="sourceLine" id="cb1047-4" data-line-number="4"></a>
<a class="sourceLine" id="cb1047-5" data-line-number="5">    <span class="dt">void</span> set( <span class="dt">int</span> n )</a>
<a class="sourceLine" id="cb1047-6" data-line-number="6">    {</a>
<a class="sourceLine" id="cb1047-7" data-line-number="7">        data = n ;</a>
<a class="sourceLine" id="cb1047-8" data-line-number="8">    }</a>
<a class="sourceLine" id="cb1047-9" data-line-number="9">} ;</a>
<a class="sourceLine" id="cb1047-10" data-line-number="10"></a>
<a class="sourceLine" id="cb1047-11" data-line-number="11"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1047-12" data-line-number="12">{</a>
<a class="sourceLine" id="cb1047-13" data-line-number="13">    C a ;</a>
<a class="sourceLine" id="cb1047-14" data-line-number="14">    C b ;</a>
<a class="sourceLine" id="cb1047-15" data-line-number="15"></a>
<a class="sourceLine" id="cb1047-16" data-line-number="16">    <span class="co">// a.dataを変更</span></a>
<a class="sourceLine" id="cb1047-17" data-line-number="17">    a.set(<span class="dv">1</span>) ;</a>
<a class="sourceLine" id="cb1047-18" data-line-number="18">    <span class="co">// b.dataを変更</span></a>
<a class="sourceLine" id="cb1047-19" data-line-number="19">    b.set(<span class="dv">2</span>) ;</a>
<a class="sourceLine" id="cb1047-20" data-line-number="20">}</a></code></pre></div>
<p>すでに説明したように、メンバー関数が自分を呼びだしたクラスのオブジェクトのサブオブジェクトを参照できるのは、クラスのオブジェクトへの参照を知っているからだ。内部的には以下のような隠し引数を持つコードが生成されたかのような挙動になる。</p>
<div class="sourceCode" id="cb1048"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1048-1" data-line-number="1"><span class="co">// コンパイラーが生成するコードのたとえ</span></a>
<a class="sourceLine" id="cb1048-2" data-line-number="2"><span class="kw">struct</span> C</a>
<a class="sourceLine" id="cb1048-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb1048-4" data-line-number="4">    <span class="dt">int</span> data { } ;</a>
<a class="sourceLine" id="cb1048-5" data-line-number="5">} ;</a>
<a class="sourceLine" id="cb1048-6" data-line-number="6"></a>
<a class="sourceLine" id="cb1048-7" data-line-number="7"><span class="co">// 隠し引数</span></a>
<a class="sourceLine" id="cb1048-8" data-line-number="8"><span class="dt">void</span> set( C &amp; obj, <span class="dt">int</span> n )</a>
<a class="sourceLine" id="cb1048-9" data-line-number="9">{</a>
<a class="sourceLine" id="cb1048-10" data-line-number="10">    obj.data = n ;</a>
<a class="sourceLine" id="cb1048-11" data-line-number="11">}</a></code></pre></div>
<p>つまり、メンバー関数は自分を呼び出したクラスのオブジェクトへの参照を知っている。その参照にアクセスする方法が<code>this</code>キーワードだ。</p>
<p><code>this</code>キーワードはクラスのメンバー関数の中で使うと、メンバー関数を呼び出したクラスのオブジェクトへのポインターとして扱われる。</p>
<div class="sourceCode" id="cb1049"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1049-1" data-line-number="1"><span class="kw">struct</span> C</a>
<a class="sourceLine" id="cb1049-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1049-3" data-line-number="3">    <span class="dt">int</span> data { } ;</a>
<a class="sourceLine" id="cb1049-4" data-line-number="4"></a>
<a class="sourceLine" id="cb1049-5" data-line-number="5">    <span class="dt">void</span> set( <span class="dt">int</span> n )</a>
<a class="sourceLine" id="cb1049-6" data-line-number="6">    {</a>
<a class="sourceLine" id="cb1049-7" data-line-number="7">        <span class="co">// このメンバー関数を呼び出したクラスのオブジェクトへのポインター</span></a>
<a class="sourceLine" id="cb1049-8" data-line-number="8">        C * pointer = <span class="kw">this</span> ;</a>
<a class="sourceLine" id="cb1049-9" data-line-number="9">        <span class="kw">this</span>-&gt;data = n ;</a>
<a class="sourceLine" id="cb1049-10" data-line-number="10">    }</a>
<a class="sourceLine" id="cb1049-11" data-line-number="11">} ;</a></code></pre></div>
<p>さきほど、関数<code>C::set</code>の中で<code>data = n ;</code>と書いたのは、<code>this-&gt;data = n ;</code>と書いたのと同じ意味になる。</p>
<p><code>this</code>はリファレンスではなくてポインターだ。この理由は歴史的なものだ。本来ならばリファレンスのほうがよいのだが、今更変更できないのでポインターになっている。わかりにくければリファレンスに束縛してもよい。</p>
<div class="sourceCode" id="cb1050"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1050-1" data-line-number="1"><span class="kw">struct</span> S</a>
<a class="sourceLine" id="cb1050-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1050-3" data-line-number="3">    <span class="dt">void</span> f()</a>
<a class="sourceLine" id="cb1050-4" data-line-number="4">    {</a>
<a class="sourceLine" id="cb1050-5" data-line-number="5">        <span class="kw">auto</span> &amp; this_ref = *<span class="kw">this</span> ;</a>
<a class="sourceLine" id="cb1050-6" data-line-number="6">    }</a>
<a class="sourceLine" id="cb1050-7" data-line-number="7">} ;</a></code></pre></div>
<p>constなメンバー関数の中では、<code>this</code>の型もconstなクラス型へのポインターになる。</p>
<div class="sourceCode" id="cb1051"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1051-1" data-line-number="1"><span class="kw">struct</span> S</a>
<a class="sourceLine" id="cb1051-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1051-3" data-line-number="3">    <span class="dt">void</span> f()</a>
<a class="sourceLine" id="cb1051-4" data-line-number="4">    {</a>
<a class="sourceLine" id="cb1051-5" data-line-number="5">        <span class="co">// thisの型はS *</span></a>
<a class="sourceLine" id="cb1051-6" data-line-number="6">        S * pointer = <span class="kw">this</span> ;</a>
<a class="sourceLine" id="cb1051-7" data-line-number="7">    }</a>
<a class="sourceLine" id="cb1051-8" data-line-number="8"></a>
<a class="sourceLine" id="cb1051-9" data-line-number="9">    <span class="dt">void</span> f() <span class="at">const</span></a>
<a class="sourceLine" id="cb1051-10" data-line-number="10">    {</a>
<a class="sourceLine" id="cb1051-11" data-line-number="11">        <span class="co">// thisの型はS const *</span></a>
<a class="sourceLine" id="cb1051-12" data-line-number="12">        S <span class="at">const</span> * pointer = <span class="kw">this</span> ;</a>
<a class="sourceLine" id="cb1051-13" data-line-number="13">    }</a>
<a class="sourceLine" id="cb1051-14" data-line-number="14">} ;</a></code></pre></div>
<p>この理由は、constなメンバー関数はクラスのオブジェクトへの参照としてconstなリファレンスを隠し引数として持つからだ。</p>
<div class="sourceCode" id="cb1052"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1052-1" data-line-number="1"><span class="co">// コンパイラーが生成するコードのたとえ</span></a>
<a class="sourceLine" id="cb1052-2" data-line-number="2"><span class="kw">struct</span> S { } ;</a>
<a class="sourceLine" id="cb1052-3" data-line-number="3"></a>
<a class="sourceLine" id="cb1052-4" data-line-number="4"><span class="co">// 非constなメンバー関数</span></a>
<a class="sourceLine" id="cb1052-5" data-line-number="5"><span class="dt">void</span> f( S &amp; obj ) ;</a>
<a class="sourceLine" id="cb1052-6" data-line-number="6"></a>
<a class="sourceLine" id="cb1052-7" data-line-number="7"><span class="co">// constなメンバー関数</span></a>
<a class="sourceLine" id="cb1052-8" data-line-number="8"><span class="dt">void</span> f( S <span class="at">const</span> &amp; obj ) ;</a></code></pre></div>
<h3 id="メンバーへのポインター">メンバーへのポインター</h3>
<p>メンバーへのポインターはかなり文法的にややこしい。そもそも、通常のポインターとは概念でも実装でも異なる。</p>
<p>ここで取り扱うのはメンバーへのポインターという概念で、クラスのオブジェクトのサブオブジェクトへのポインターではない。サブオブジェクトへのポインターは通常のポインターと同じだ。</p>
<div class="sourceCode" id="cb1053"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1053-1" data-line-number="1"><span class="kw">struct</span> Object</a>
<a class="sourceLine" id="cb1053-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1053-3" data-line-number="3">    <span class="co">// サブオブジェクト</span></a>
<a class="sourceLine" id="cb1053-4" data-line-number="4">    <span class="dt">int</span> subobject ;</a>
<a class="sourceLine" id="cb1053-5" data-line-number="5">} ;</a>
<a class="sourceLine" id="cb1053-6" data-line-number="6"></a>
<a class="sourceLine" id="cb1053-7" data-line-number="7"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1053-8" data-line-number="8">{</a>
<a class="sourceLine" id="cb1053-9" data-line-number="9">    <span class="co">// クラスのオブジェクト</span></a>
<a class="sourceLine" id="cb1053-10" data-line-number="10">    Object object ;</a>
<a class="sourceLine" id="cb1053-11" data-line-number="11"></a>
<a class="sourceLine" id="cb1053-12" data-line-number="12">    <span class="co">// サブオブジェクトへのポインター</span></a>
<a class="sourceLine" id="cb1053-13" data-line-number="13">    <span class="dt">int</span> * pointer = &amp;object.subobject ;</a>
<a class="sourceLine" id="cb1053-14" data-line-number="14"></a>
<a class="sourceLine" id="cb1053-15" data-line-number="15">    *pointer = <span class="dv">123</span> ;</a>
<a class="sourceLine" id="cb1053-16" data-line-number="16">    <span class="dt">int</span> read = object.subobject ;</a>
<a class="sourceLine" id="cb1053-17" data-line-number="17">}</a></code></pre></div>
<p>メンバーへのポインターとは、クラスのデータメンバーやメンバー関数を参照するもので、クラスのオブジェクトとともに使うことでそのデータメンバーやメンバー関数を参照できるものだ。</p>
<p>細かい文法の解説はあとにして例を見せよう。</p>
<div class="sourceCode" id="cb1054"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1054-1" data-line-number="1"><span class="kw">struct</span> Object</a>
<a class="sourceLine" id="cb1054-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1054-3" data-line-number="3">    <span class="dt">int</span> data_member ;</a>
<a class="sourceLine" id="cb1054-4" data-line-number="4">    <span class="dt">void</span> member_function()</a>
<a class="sourceLine" id="cb1054-5" data-line-number="5">    { <span class="bu">std::</span>cout &lt;&lt; data_member ; }</a>
<a class="sourceLine" id="cb1054-6" data-line-number="6">} ;</a>
<a class="sourceLine" id="cb1054-7" data-line-number="7"></a>
<a class="sourceLine" id="cb1054-8" data-line-number="8"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1054-9" data-line-number="9">{</a>
<a class="sourceLine" id="cb1054-10" data-line-number="10">    <span class="co">// Object::data_memberメンバーへのポインター</span></a>
<a class="sourceLine" id="cb1054-11" data-line-number="11">    <span class="dt">int</span> Object::* int_ptr = &amp;Object::data_member ;</a>
<a class="sourceLine" id="cb1054-12" data-line-number="12">    <span class="co">// Object::member_functionメンバーへのポインター</span></a>
<a class="sourceLine" id="cb1054-13" data-line-number="13">    <span class="dt">void</span> (Object::* func_ptr)() = &amp;Object::member_function ;</a>
<a class="sourceLine" id="cb1054-14" data-line-number="14"></a>
<a class="sourceLine" id="cb1054-15" data-line-number="15">    <span class="co">// クラスのオブジェクト</span></a>
<a class="sourceLine" id="cb1054-16" data-line-number="16">    Object object ;</a>
<a class="sourceLine" id="cb1054-17" data-line-number="17"></a>
<a class="sourceLine" id="cb1054-18" data-line-number="18">    <span class="co">// objectに対するメンバーポインターを介した参照</span></a>
<a class="sourceLine" id="cb1054-19" data-line-number="19">    object.*int_ptr = <span class="dv">123</span> ;</a>
<a class="sourceLine" id="cb1054-20" data-line-number="20">    <span class="co">// objectに対するメンバーポインターを介した参照</span></a>
<a class="sourceLine" id="cb1054-21" data-line-number="21">    <span class="co">// 123</span></a>
<a class="sourceLine" id="cb1054-22" data-line-number="22">    (object.*func_ptr)() ;</a>
<a class="sourceLine" id="cb1054-23" data-line-number="23"></a>
<a class="sourceLine" id="cb1054-24" data-line-number="24">    <span class="co">// 別のオブジェクト</span></a>
<a class="sourceLine" id="cb1054-25" data-line-number="25">    Object another_object ;</a>
<a class="sourceLine" id="cb1054-26" data-line-number="26">    another_object.data_member = <span class="dv">456</span> ;</a>
<a class="sourceLine" id="cb1054-27" data-line-number="27">    <span class="co">// 456</span></a>
<a class="sourceLine" id="cb1054-28" data-line-number="28">    (another_object.*func_ptr)() ;</a>
<a class="sourceLine" id="cb1054-29" data-line-number="29">}</a></code></pre></div>
<p>細かい文法はあとで学ぶとして、肝心の機能としてはこうだ。クラスのオブジェクトからは独立したデータメンバーやメンバー関数自体へのポインターを取得する。</p>
<div class="sourceCode" id="cb1055"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1055-1" data-line-number="1"><span class="kw">struct</span> Object</a>
<a class="sourceLine" id="cb1055-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1055-3" data-line-number="3">    <span class="dt">int</span> data_member ;</a>
<a class="sourceLine" id="cb1055-4" data-line-number="4">} ;</a>
<a class="sourceLine" id="cb1055-5" data-line-number="5"></a>
<a class="sourceLine" id="cb1055-6" data-line-number="6"><span class="co">// メンバーへのポインター</span></a>
<a class="sourceLine" id="cb1055-7" data-line-number="7"><span class="dt">int</span> Object::*int_ptr = &amp;Object::data_member ; </a></code></pre></div>
<p>このポインターをクラスのオブジェクトと組み合わせることで、ポインターが参照するクラスのメンバーで、かつオブジェクトのサブオブジェクトの部分を参照できる。</p>
<div class="sourceCode" id="cb1056"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1056-1" data-line-number="1">Object object ;</a>
<a class="sourceLine" id="cb1056-2" data-line-number="2"></a>
<a class="sourceLine" id="cb1056-3" data-line-number="3"><span class="co">// メンバーへのポインターをオブジェクトに適用してサブオブジェクトを参照する</span></a>
<a class="sourceLine" id="cb1056-4" data-line-number="4">object.*int_ptr = <span class="dv">123</span> ;</a></code></pre></div>
<p>では文法の説明に入ろう。</p>
<p>メンバーへのポインターは文法がややこしい。</p>
<p>あるクラス名Cの型名Tのメンバーへのポインター型は以下のようになる。</p>
<div class="sourceCode" id="cb1057"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1057-1" data-line-number="1">型名 クラス名:::*</a>
<a class="sourceLine" id="cb1057-2" data-line-number="2">T C::*</a></code></pre></div>
<p>以下のクラスの各データメンバーへの型はそれぞれコメントのとおりになる。</p>
<div class="sourceCode" id="cb1058"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1058-1" data-line-number="1"><span class="kw">struct</span> ABC</a>
<a class="sourceLine" id="cb1058-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1058-3" data-line-number="3">    <span class="co">// int ABC::*</span></a>
<a class="sourceLine" id="cb1058-4" data-line-number="4">    <span class="dt">int</span> x ;</a>
<a class="sourceLine" id="cb1058-5" data-line-number="5">    <span class="co">// int ABC::*</span></a>
<a class="sourceLine" id="cb1058-6" data-line-number="6">    <span class="dt">int</span> y ;</a>
<a class="sourceLine" id="cb1058-7" data-line-number="7">    <span class="co">// double ABC::*</span></a>
<a class="sourceLine" id="cb1058-8" data-line-number="8">    <span class="dt">double</span> d ;</a>
<a class="sourceLine" id="cb1058-9" data-line-number="9">    <span class="co">// int * ABC::*</span></a>
<a class="sourceLine" id="cb1058-10" data-line-number="10">    <span class="dt">int</span> * ptr ;</a>
<a class="sourceLine" id="cb1058-11" data-line-number="11">} ;</a>
<a class="sourceLine" id="cb1058-12" data-line-number="12"></a>
<a class="sourceLine" id="cb1058-13" data-line-number="13"><span class="kw">struct</span> DEF</a>
<a class="sourceLine" id="cb1058-14" data-line-number="14">{</a>
<a class="sourceLine" id="cb1058-15" data-line-number="15">    <span class="co">// ABC * DEF::*</span></a>
<a class="sourceLine" id="cb1058-16" data-line-number="16">    ABC * abc ;</a>
<a class="sourceLine" id="cb1058-17" data-line-number="17">} ;</a></code></pre></div>
<p>順を追って説明していこう。まずクラスABCのメンバー、</p>
<div class="sourceCode" id="cb1059"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1059-1" data-line-number="1"><span class="co">// int ABC::*</span></a>
<a class="sourceLine" id="cb1059-2" data-line-number="2"><span class="dt">int</span> x ;</a>
<a class="sourceLine" id="cb1059-3" data-line-number="3"><span class="co">// int ABC::*</span></a>
<a class="sourceLine" id="cb1059-4" data-line-number="4"><span class="dt">int</span> y ;</a></code></pre></div>
<p>このメンバーへのポインターの型はどちらも<code>int ABC::*</code>になる。データメンバーの型はintで、クラス名がABCなので、<code>型名 クラス名::*</code>に当てはめると<code>int ABC::*</code>になる。</p>
<div class="sourceCode" id="cb1060"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1060-1" data-line-number="1"><span class="co">// double ABC::*</span></a>
<a class="sourceLine" id="cb1060-2" data-line-number="2"><span class="dt">double</span> d ;</a></code></pre></div>
<p>このメンバーへのポインターの型は<code>double ABC::*</code>になる。</p>
<p>最後のクラスABCのメンバー、</p>
<div class="sourceCode" id="cb1061"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1061-1" data-line-number="1"><span class="co">// int * ABC::*</span></a>
<a class="sourceLine" id="cb1061-2" data-line-number="2"><span class="dt">int</span> * ptr ;</a></code></pre></div>
<p>これが<code>int * ABC::*</code>になる理由も、最初に説明した<code>型名 クラス名::*</code>のルールに従っている。型名が<code>int *</code>、クラス名が<code>ABC</code>なので、<code>int * ABC::*</code>だ。</p>
<p>最後の例はクラスDEFのメンバーとしてクラスABCのポインター型のメンバーだ。<code>ABC DEF::*</code>になる。</p>
<p>クラス名Cのメンバー名Mのメンバーへのポインターを得るには以下の文法を使う。</p>
<div class="sourceCode" id="cb1062"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1062-1" data-line-number="1">&amp;クラス名::メンバー名</a>
<a class="sourceLine" id="cb1062-2" data-line-number="2">&amp;C::M</a></code></pre></div>
<p>具体的な例を見てみよう。</p>
<div class="sourceCode" id="cb1063"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1063-1" data-line-number="1"><span class="kw">struct</span> C</a>
<a class="sourceLine" id="cb1063-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1063-3" data-line-number="3">    <span class="dt">int</span> x = <span class="dv">1</span> ;</a>
<a class="sourceLine" id="cb1063-4" data-line-number="4">    <span class="dt">int</span> y = <span class="dv">2</span> ;</a>
<a class="sourceLine" id="cb1063-5" data-line-number="5">} ;</a>
<a class="sourceLine" id="cb1063-6" data-line-number="6"></a>
<a class="sourceLine" id="cb1063-7" data-line-number="7"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1063-8" data-line-number="8">{</a>
<a class="sourceLine" id="cb1063-9" data-line-number="9">    <span class="dt">int</span> C::* x_ptr = &amp;C::x ;</a>
<a class="sourceLine" id="cb1063-10" data-line-number="10">    <span class="dt">int</span> C::* y_ptr = &amp;C::y ;</a>
<a class="sourceLine" id="cb1063-11" data-line-number="11"></a>
<a class="sourceLine" id="cb1063-12" data-line-number="12">    C object ;</a>
<a class="sourceLine" id="cb1063-13" data-line-number="13"></a>
<a class="sourceLine" id="cb1063-14" data-line-number="14">    <span class="co">// 1</span></a>
<a class="sourceLine" id="cb1063-15" data-line-number="15">    <span class="bu">std::</span>cout &lt;&lt; object.*x_ptr ;</a>
<a class="sourceLine" id="cb1063-16" data-line-number="16">    <span class="co">// 2 </span></a>
<a class="sourceLine" id="cb1063-17" data-line-number="17">    <span class="bu">std::</span>cout &lt;&lt; object.*y_ptr ;</a>
<a class="sourceLine" id="cb1063-18" data-line-number="18">}</a></code></pre></div>
<p>分かりづらければエイリアス宣言を使うとよい。</p>
<div class="sourceCode" id="cb1064"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1064-1" data-line-number="1"><span class="kw">using</span> type = <span class="dt">int</span> C::* ;</a>
<a class="sourceLine" id="cb1064-2" data-line-number="2">type x_ptr = &amp;C::x ;</a></code></pre></div>
<p>あるいはauto使うという手もある。</p>
<div class="sourceCode" id="cb1065"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1065-1" data-line-number="1"><span class="co">// int C::*</span></a>
<a class="sourceLine" id="cb1065-2" data-line-number="2"><span class="kw">auto</span> x_ptr = &amp;C::x ;</a></code></pre></div>
<p>メンバー関数へのポインターは、メンバーへのポインターと関数へのポインターを組み合わせた複雑な文法となるので、とてもわかりづらい。</p>
<p>復習すると、int型の引数を一つ受け取りint型の戻り値を返す関数へのポインターの型は<code>int (*)(int)</code>だ。</p>
<div class="sourceCode" id="cb1066"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1066-1" data-line-number="1"><span class="dt">int</span> f(<span class="dt">int</span>) { <span class="cf">return</span> <span class="dv">0</span> ; }</a>
<a class="sourceLine" id="cb1066-2" data-line-number="2"><span class="dt">int</span> (*ptr)(<span class="dt">int</span>) = &amp;f ;</a></code></pre></div>
<p>この関数がクラスCのメンバー関数の場合、以下のようになる。</p>
<div class="sourceCode" id="cb1067"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1067-1" data-line-number="1"><span class="kw">struct</span> C</a>
<a class="sourceLine" id="cb1067-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1067-3" data-line-number="3">    <span class="dt">int</span> f(<span class="dt">int</span>) { <span class="cf">return</span> <span class="dv">0</span> ; }</a>
<a class="sourceLine" id="cb1067-4" data-line-number="4">} ;</a></code></pre></div>
<p>ところで、メンバーへのポインターは<code>型名 クラス名::*</code>だった。この2つを組み合わせると、以下のように書ける。</p>
<div class="sourceCode" id="cb1068"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1068-1" data-line-number="1"><span class="kw">struct</span> C</a>
<a class="sourceLine" id="cb1068-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1068-3" data-line-number="3">    <span class="dt">int</span> f(<span class="dt">int</span>) { <span class="cf">return</span> <span class="dv">0</span> ; }</a>
<a class="sourceLine" id="cb1068-4" data-line-number="4">} ;</a>
<a class="sourceLine" id="cb1068-5" data-line-number="5"></a>
<a class="sourceLine" id="cb1068-6" data-line-number="6"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1068-7" data-line-number="7">{</a>
<a class="sourceLine" id="cb1068-8" data-line-number="8">    <span class="co">// メンバー関数へのポインター</span></a>
<a class="sourceLine" id="cb1068-9" data-line-number="9">    <span class="dt">int</span> (C::*ptr)(<span class="dt">int</span>) = &amp;C::f ;</a>
<a class="sourceLine" id="cb1068-10" data-line-number="10">    <span class="co">// クラスのオブジェクト</span></a>
<a class="sourceLine" id="cb1068-11" data-line-number="11">    C object ;</a>
<a class="sourceLine" id="cb1068-12" data-line-number="12"></a>
<a class="sourceLine" id="cb1068-13" data-line-number="13">    <span class="co">// オブジェクトを指定したメンバー関数へのポインターを介した関数呼び出し</span></a>
<a class="sourceLine" id="cb1068-14" data-line-number="14">    (object.*ptr)( <span class="dv">123</span> ) ;</a>
<a class="sourceLine" id="cb1068-15" data-line-number="15">}</a></code></pre></div>
<p>メンバー関数へのポインターは難しい。</p>
<p>関数fの型は<code>int (int)</code>で、そのポインターの型は<code>int (*)(int)</code>だ。するとクラス名Cのメンバー関数fへのポインターの型は、<code>int (C::*)(int)</code>になる。</p>
<p>メンバー関数へのポインター型の変数を宣言してその値を<code>C::f</code>へのポインターに初期化しているのが以下の行だ。</p>
<div class="sourceCode" id="cb1069"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1069-1" data-line-number="1"><span class="co">// メンバー関数へのポインター</span></a>
<a class="sourceLine" id="cb1069-2" data-line-number="2"><span class="dt">int</span> (C::*ptr)(<span class="dt">int</span>) = &amp;C::f ;</a></code></pre></div>
<p>この<code>ptr</code>を経由したメンバー関数fの呼び出し方だが、まずクラスのオブジェクトが必要になるので作る。</p>
<div class="sourceCode" id="cb1070"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1070-1" data-line-number="1">C object ;</a></code></pre></div>
<p>そして演算子の<code>operator .*</code>を使う。</p>
<div class="sourceCode" id="cb1071"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1071-1" data-line-number="1">(object.*ptr)(<span class="dv">123</span>) ;</a></code></pre></div>
<p><code>object.*ptr</code>を括弧で囲んでいるのは、演算子の優先順位のためだ。もしこれを以下のように書くと、</p>
<div class="sourceCode" id="cb1072"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1072-1" data-line-number="1">object.*ptr(<span class="dv">123</span>)</a></code></pre></div>
<p>これは<code>ptr(123)</code>という式を評価した結果をメンバーへのポインターと解釈してクラスのオブジェクトを介して参照していることになる。例えば以下のようなコードだ。</p>
<div class="sourceCode" id="cb1073"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1073-1" data-line-number="1"><span class="kw">struct</span> C { <span class="dt">int</span> data { } ; } ;</a>
<a class="sourceLine" id="cb1073-2" data-line-number="2"></a>
<a class="sourceLine" id="cb1073-3" data-line-number="3"><span class="kw">auto</span> ptr( <span class="dt">int</span> ) -&gt; <span class="dt">int</span> C::*</a>
<a class="sourceLine" id="cb1073-4" data-line-number="4">{ <span class="cf">return</span> &amp;C::data ; }</a>
<a class="sourceLine" id="cb1073-5" data-line-number="5"></a>
<a class="sourceLine" id="cb1073-6" data-line-number="6"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1073-7" data-line-number="7">{</a>
<a class="sourceLine" id="cb1073-8" data-line-number="8">    C object ;</a>
<a class="sourceLine" id="cb1073-9" data-line-number="9">    object.*ptr(<span class="dv">123</span>) ;</a>
<a class="sourceLine" id="cb1073-10" data-line-number="10">}</a></code></pre></div>
<p>演算子の優先順位の問題のために、<code>(object.*ptr)</code>と括弧で包んで先に評価させ、その後に関数呼び出し式である<code>(123)</code>を評価させる。</p>
<p>実は演算子<code>operator .*</code>の他に、<code>operator -&gt;*</code>という演算子がある。</p>
<p><code>.*</code>はクラスのオブジェクトがリファレンスの場合の演算子だが、`-&gt;*はクラスのオブジェクトがポインターの場合の演算子だ。</p>
<div class="sourceCode" id="cb1074"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1074-1" data-line-number="1"><span class="kw">struct</span> C{ <span class="dt">int</span> data { } : } ;</a>
<a class="sourceLine" id="cb1074-2" data-line-number="2"></a>
<a class="sourceLine" id="cb1074-3" data-line-number="3"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1074-4" data-line-number="4">{</a>
<a class="sourceLine" id="cb1074-5" data-line-number="5">    <span class="kw">auto</span> data_ptr = &amp;C::data ;</a>
<a class="sourceLine" id="cb1074-6" data-line-number="6"></a>
<a class="sourceLine" id="cb1074-7" data-line-number="7">    C object ;</a>
<a class="sourceLine" id="cb1074-8" data-line-number="8">    <span class="kw">auto</span> c_ptr = &amp;object ;</a>
<a class="sourceLine" id="cb1074-9" data-line-number="9"></a>
<a class="sourceLine" id="cb1074-10" data-line-number="10">    c_ptr-&gt;*object = <span class="dv">123</span> ;</a>
<a class="sourceLine" id="cb1074-11" data-line-number="11">}</a></code></pre></div>
<p>演算子<code>a-&gt;b</code>が<code>(*(a)).b</code>となるように、演算子<code>a-&gt;*b</code>も<code>(*(a)).*b</code>と置き換えられるシンタックスシュガーだ。</p>
<p>上の例で、</p>
<div class="sourceCode" id="cb1075"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1075-1" data-line-number="1">c_ptr-&gt;*object = <span class="dv">123</span> ;</a></code></pre></div>
<p>は、以下と同じだ。</p>
<div class="sourceCode" id="cb1076"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1076-1" data-line-number="1">(*(c_ptr)).*object = <span class="dv">123</span> ;</a></code></pre></div>
<p><code>.*</code>や<code>-&gt;*</code>の文法を覚えるのが面倒な場合、標準ライブラリに<code>std::invoke( f, t1, ... )</code>という便利な関数が用意されている。</p>
<p>fがデータメンバーへのポインターで、t1がクラスのオブジェクトの場合、<code>std::invoke(f, t1)</code>は以下のような関数になる。</p>
<div class="sourceCode" id="cb1077"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1077-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> F, <span class="kw">typename</span> T1 &gt;</a>
<a class="sourceLine" id="cb1077-2" data-line-number="2">適切な戻り値の型 <span class="bu">std::</span>invoke( F f, T1 t1 )</a>
<a class="sourceLine" id="cb1077-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb1077-4" data-line-number="4">    <span class="cf">return</span> t1.*f ;</a>
<a class="sourceLine" id="cb1077-5" data-line-number="5">}</a></code></pre></div>
<p>なので以下のように書ける。</p>
<div class="sourceCode" id="cb1078"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1078-1" data-line-number="1"><span class="kw">struct</span> C { <span class="dt">int</span> data { } ; } ;</a>
<a class="sourceLine" id="cb1078-2" data-line-number="2"></a>
<a class="sourceLine" id="cb1078-3" data-line-number="3"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1078-4" data-line-number="4">{</a>
<a class="sourceLine" id="cb1078-5" data-line-number="5">    <span class="kw">auto</span> data_ptr = &amp;C::data ;</a>
<a class="sourceLine" id="cb1078-6" data-line-number="6"></a>
<a class="sourceLine" id="cb1078-7" data-line-number="7">    C object ;</a>
<a class="sourceLine" id="cb1078-8" data-line-number="8"></a>
<a class="sourceLine" id="cb1078-9" data-line-number="9">    <span class="co">// どちらも同じ意味</span></a>
<a class="sourceLine" id="cb1078-10" data-line-number="10">    object.*data_ptr = <span class="dv">123</span> ;</a>
<a class="sourceLine" id="cb1078-11" data-line-number="11">    <span class="bu">std::</span>invoke( data_ptr, object ) = <span class="dv">123</span> ;</a>
<a class="sourceLine" id="cb1078-12" data-line-number="12">}</a></code></pre></div>
<p>便利なことにt1がポインターの場合は、</p>
<div class="sourceCode" id="cb1079"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1079-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> F, <span class="kw">typename</span> T1 &gt;</a>
<a class="sourceLine" id="cb1079-2" data-line-number="2">適切な戻り値の型 <span class="bu">std::</span>invoke( F f, T1 t1 )</a>
<a class="sourceLine" id="cb1079-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb1079-4" data-line-number="4">    <span class="cf">return</span> (*(t1)).*f ;</a>
<a class="sourceLine" id="cb1079-5" data-line-number="5">}</a></code></pre></div>
<p>という関数として振る舞う。そのため、リファレンスでもポインターでも気にせずに使うことができる。</p>
<div class="sourceCode" id="cb1080"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1080-1" data-line-number="1">C * c_ptr = &amp;object ;</a>
<a class="sourceLine" id="cb1080-2" data-line-number="2"></a>
<a class="sourceLine" id="cb1080-3" data-line-number="3"><span class="co">// どちらも同じ意味</span></a>
<a class="sourceLine" id="cb1080-4" data-line-number="4">c_ptr-&gt;*data_ptr = <span class="dv">123</span> ;</a>
<a class="sourceLine" id="cb1080-5" data-line-number="5"><span class="bu">std::</span>invoke( data_ptr, c_ptr ) = <span class="dv">123</span> ;</a></code></pre></div>
<p><code>std::invoke</code>が更に凄いことに、メンバー関数へのポインターにも対応している。</p>
<p><code>std::invoke( f, t1, ... )</code>で、fがメンバー関数へのポインターで、t1がクラスのオブジェクトへのリファレンスで、<code>...</code>が関数呼び出しの際の引数の場合、以下のような関数として振る舞う。</p>
<div class="sourceCode" id="cb1081"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1081-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> F, <span class="kw">typename</span> T1,</a>
<a class="sourceLine" id="cb1081-2" data-line-number="2">    <span class="co">// まだ知らない機能</span></a>
<a class="sourceLine" id="cb1081-3" data-line-number="3">    <span class="kw">typename</span> ... Ts &gt;</a>
<a class="sourceLine" id="cb1081-4" data-line-number="4">適切な戻り値の型</a>
<a class="sourceLine" id="cb1081-5" data-line-number="5">invoke( F f, T1 t1,</a>
<a class="sourceLine" id="cb1081-6" data-line-number="6"><span class="co">// まだ知らない機能</span></a>
<a class="sourceLine" id="cb1081-7" data-line-number="7">Ts ... ts )</a>
<a class="sourceLine" id="cb1081-8" data-line-number="8">{</a>
<a class="sourceLine" id="cb1081-9" data-line-number="9">    <span class="cf">return</span> (t1.*f)(ts...)</a>
<a class="sourceLine" id="cb1081-10" data-line-number="10">}</a></code></pre></div>
<p>厳密にはこの宣言は間違っているのだが、まだ知らない機能を使っているので気にしなくてもよい。大事なことは、<code>std::invoke</code>の第三引数以降の実引数が、関数呼び出しの実引数として使われるということだ。</p>
<div class="sourceCode" id="cb1082"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1082-1" data-line-number="1"><span class="kw">struct</span> C</a>
<a class="sourceLine" id="cb1082-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1082-3" data-line-number="3">    <span class="dt">int</span> f0() { <span class="cf">return</span> <span class="dv">0</span> ; }</a>
<a class="sourceLine" id="cb1082-4" data-line-number="4">    <span class="dt">int</span> f1(<span class="dt">int</span>) { <span class="cf">return</span> <span class="dv">1</span> ; } </a>
<a class="sourceLine" id="cb1082-5" data-line-number="5">    <span class="dt">int</span> f2( <span class="dt">int</span>, <span class="dt">int</span> ) { <span class="cf">return</span> <span class="dv">2</span> ; }</a>
<a class="sourceLine" id="cb1082-6" data-line-number="6">} ;</a>
<a class="sourceLine" id="cb1082-7" data-line-number="7"></a>
<a class="sourceLine" id="cb1082-8" data-line-number="8"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1082-9" data-line-number="9">{</a>
<a class="sourceLine" id="cb1082-10" data-line-number="10">    C object ;</a>
<a class="sourceLine" id="cb1082-11" data-line-number="11"></a>
<a class="sourceLine" id="cb1082-12" data-line-number="12">    <span class="co">// 同じ</span></a>
<a class="sourceLine" id="cb1082-13" data-line-number="13">    (object.*&amp;C::f0)() ;</a>
<a class="sourceLine" id="cb1082-14" data-line-number="14">    <span class="bu">std::</span>invoke( &amp;C::f0, object ) ;</a>
<a class="sourceLine" id="cb1082-15" data-line-number="15">    <span class="co">// 同じ</span></a>
<a class="sourceLine" id="cb1082-16" data-line-number="16">    (object.*&amp;C::f1)(<span class="dv">1</span>) ;</a>
<a class="sourceLine" id="cb1082-17" data-line-number="17">    <span class="bu">std::</span>invoke( &amp;C::f1, object, <span class="dv">1</span>) ;</a>
<a class="sourceLine" id="cb1082-18" data-line-number="18">    <span class="co">// 同じ</span></a>
<a class="sourceLine" id="cb1082-19" data-line-number="19">    (object.*&amp;C::f2)(<span class="dv">1</span>,<span class="dv">2</span>) ;</a>
<a class="sourceLine" id="cb1082-20" data-line-number="20">    <span class="bu">std::</span>invoke( &amp;C::f2, object, <span class="dv">1</span>,<span class="dv">2</span>) ;</a>
<a class="sourceLine" id="cb1082-21" data-line-number="21">}</a></code></pre></div>
<p>この場合も、objectがCへのリファレンスではなく、Cへのポインターでも自動で認識していいように処理してくれる。</p>
<h2 id="ポインターの内部実装">ポインターの内部実装</h2>
<p>ポインターの意味上と文法上の解説は終えた。ここからはポインターの内部実装についてだ。ポインターの値とは外でもない、メモリー上のアドレスのことだ。</p>
<h3 id="キロバイトとキビバイト">キロバイトとキビバイト</h3>
<p>メモリとアドレスについて解説する前に、キロバイト(Kilo byte)とキビバイト(Kibi byte)の違いについて解説する。</p>
<p>キロ(Kilo)というのはSI接頭語で、<span class="math inline">\(1000^1\)</span>を意味する。1キロは1000だ。SI接頭語には他にもメガ(Mega, <span class="math inline">\(1000^2\)</span>)、ギガ(Giga, <span class="math inline">\(1000^3\)</span>)やテラ(Tera, <span class="math inline">\(1000^4\)</span>)などの接頭語もある。</p>
<p>長さ1キロメートルは1000メートルで、重さ1キログラムは1000グラムだ。</p>
<p>今「このCPUのクロック周波数は1GHzだ」と言ったとき、それは<span class="math inline">\(1000^3 Hz = 1000000000 Hz\)</span>のことだ。</p>
<p>しかし、メモリ容量だけは慣習的に<span class="math inline">\(1000^n\)</span>ではなく、<span class="math inline">\(1024^n\)</span>を使う。</p>
<p>一般人が「このメモリは1KBだ」と言ったとき、それは1024バイトのことだ。1GBのメモリは<span class="math inline">\(1024^3 バイト = 1073741824 バイト\)</span>だ。筆者が本書を執筆するのに使ったラップトップコンピューターは32GBのメモリを積んでいるがこれは34359738368バイトだ。</p>
<p>メモリの容量が10進数ではなく2進数で数えられているのは、メモリは2進数で扱うのがハードウェア的に都合がいいからだ。そのため、慣習的にキロは<span class="math inline">\(1000^1\)</span>ではなく<span class="math inline">\(1024^1\)</span>を意味するようになってしまった。</p>
<p>このため、IEEE 1541では10進SI接頭語と対になる2進接頭語を定義した。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">接頭語</th>
<th style="text-align: left;">値</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">キビ(kibi, Ki)</td>
<td style="text-align: left;"><span class="math inline">\(2^{10}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">メビ(mebi, Mi)</td>
<td style="text-align: left;"><span class="math inline">\(2^{20}\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">ギビ(gibi, Gi)</td>
<td style="text-align: left;"><span class="math inline">\(2^{30}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">テビ(tebi, Ti)</td>
<td style="text-align: left;"><span class="math inline">\(2^{40}\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">ペビ(pebi, Pi)</td>
<td style="text-align: left;"><span class="math inline">\(2^{50}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">エクスビ(exbi, Ei)</td>
<td style="text-align: left;"><span class="math inline">\(2^{60}\)</span></td>
</tr>
</tbody>
</table>
<p>本書では1KBは1000バイトで、1KiBが1024バイトを意味する。</p>
<h3 id="メモリとアドレス">メモリとアドレス</h3>
<p>コンピューターにはメモリーやストレージと呼ばれる記憶領域がある。情報の最小単位はすでに学んだようにビットだが、情報をビット単位で扱うのは不便なので、慣習的に複数の連続したビットを束ねたバイトという単位で扱っている。1バイトはほとんどのアーキテクチャで8ビットだ。メモリは複数の連続したバイト列で成り立っている。</p>
<p>この連続したバイト列の中の任意の1バイトを指し示すのがアドレスだ。メモリのバイト列の最初の1バイトのアドレスを0とし、次の1バイトアドレスを1とし、以降、その次を前のアドレスに1加えた値にしてみよう。</p>
<p>そのようなメモリーとアドレスのコンピューターでは、1バイトの符号なし整数で表現されたアドレスは、256バイトのメモリの中の任意の1バイトをアドレスとして参照することができる。</p>
<p>これはとても抽象化された計算機で、現実の計算機はもっと複雑な実装になっている。しかしC++の規格としては、メモリとはフラットな連続したバイト列であって、その任意の各バイトをアドレスから参照可能だという想定になっている。</p>
<p>アドレスが1バイトの符号なし整数で表現され、そのすべてのビットが使われる場合、256バイトの連続したメモリをアドレス可能だ。</p>
<p>アドレスが2バイトならば、64KiBのメモリをアドレス可能だ。</p>
<p>アドレスが4バイトならば、4GiBのメモリをアドレス可能だ。</p>
<p>アドレスが8バイトならば、16EiBのメモリをアドレス可能だ。</p>
<p>ポインターの値というのは、このアドレスの値のことだ。</p>
<h3 id="ポインターのサイズ">ポインターのサイズ</h3>
<p>ポインターの値というのはアドレスの値だ。ポインターの値を格納するのにもメモリが必要だ。ではポインターのサイズは何バイトあるのだろう。</p>
<p>型Tのサイズを調べるには<code>sizeof(T)</code>を使う。</p>
<div class="sourceCode" id="cb1083"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1083-1" data-line-number="1"><span class="kw">template</span> &lt;<span class="kw">typename</span> T &gt;</a>
<a class="sourceLine" id="cb1083-2" data-line-number="2"><span class="dt">void</span> print_size()</a>
<a class="sourceLine" id="cb1083-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb1083-4" data-line-number="4">    <span class="bu">std::</span>cout &lt;&lt; <span class="kw">sizeof</span>(T) &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb1083-5" data-line-number="5">}</a>
<a class="sourceLine" id="cb1083-6" data-line-number="6"></a>
<a class="sourceLine" id="cb1083-7" data-line-number="7"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1083-8" data-line-number="8">{</a>
<a class="sourceLine" id="cb1083-9" data-line-number="9">    print_size&lt;<span class="dt">int</span> *&gt;() ;</a>
<a class="sourceLine" id="cb1083-10" data-line-number="10">    print_size&lt;<span class="dt">double</span> *&gt;() ;</a>
<a class="sourceLine" id="cb1083-11" data-line-number="11"></a>
<a class="sourceLine" id="cb1083-12" data-line-number="12">    <span class="co">// ポインターへのポインター</span></a>
<a class="sourceLine" id="cb1083-13" data-line-number="13">    print_size&lt;<span class="dt">int</span> **&gt;() ; </a>
<a class="sourceLine" id="cb1083-14" data-line-number="14">}</a></code></pre></div>
<p>筆者の環境でこのプログラムを実行した結果は以下のようになった。</p>
<pre><code>8
8
8</code></pre>
<p>どうやら筆者の環境ではポインターのサイズはすべて8バイトらしい。</p>
<h3 id="ポインターの値">ポインターの値</h3>
<p>ポインターが8バイト、つまり64ビットの値であるならば、それを8バイトの符号なし整数として解釈した値はどうなるのだろう。</p>
<p>C++にはすべてのポインターの値を格納できるサイズの符号なし整数型が用意されている。<code>std::uintptr_t</code>だ。</p>
<div class="sourceCode" id="cb1085"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1085-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1085-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1085-3" data-line-number="3">    <span class="bu">std::</span>cout &lt;&lt; <span class="kw">sizeof</span>( <span class="bu">std::</span>uintptr_t ) ;</a>
<a class="sourceLine" id="cb1085-4" data-line-number="4">}</a></code></pre></div>
<p>筆者の環境でこのプログラムを実行した結果も8が出力される。</p>
<p>ポインターも<code>std::uintptr_t</code>も8バイトだ。ポインターのバイト列を<code>std::uintptr_t</code>として強引に解釈すれば、符号なし整数としての値を出力してみよう。</p>
<p>ある値fromのバイト列を、同じバイト数のある型toの値として強引に解釈するC++20で追加された標準ライブラリに、<code>std::bit_cast&lt;to&gt;(from)</code>がある。</p>
<div class="sourceCode" id="cb1086"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1086-1" data-line-number="1"><span class="pp">#include </span><span class="im">&lt;bit&gt;</span></a>
<a class="sourceLine" id="cb1086-2" data-line-number="2"></a>
<a class="sourceLine" id="cb1086-3" data-line-number="3"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1086-4" data-line-number="4">{</a>
<a class="sourceLine" id="cb1086-5" data-line-number="5">    <span class="dt">int</span> data {} ;</a>
<a class="sourceLine" id="cb1086-6" data-line-number="6">    <span class="bu">std::</span>cout &lt;&lt; <span class="bu">std::</span>bit_cast&lt;<span class="bu">std::</span>uintptr_t&gt;(&amp;data) ;</a>
<a class="sourceLine" id="cb1086-7" data-line-number="7">}</a></code></pre></div>
<p>このプログラムを何度か実行した結果、以下のような結果を得た。</p>
<pre><code>$ make run
140725678382588
$ make run
140721510940268
$ make run
140731669632396</code></pre>
<p>私の環境ではポインターの具体的な値は実行ごとに異なる。これは私の使っているOSがASLR(Address Space Layout Randomization)を実装しているためだ。興味のある読者は調べてみるとよい。</p>
<p>この値はint型の変数dataのポインターの整数としての値だ。このアドレスの場所に、int型のオブジェクトの最初の1バイトがあり、その次の場所に次の1バイトがある。</p>
<p>筆者の環境ではint型は4バイトだ。</p>
<div class="sourceCode" id="cb1088"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1088-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1088-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1088-3" data-line-number="3">    <span class="bu">std::</span>cout &lt;&lt; <span class="kw">sizeof</span>(<span class="dt">int</span>) ;</a>
<a class="sourceLine" id="cb1088-4" data-line-number="4">}</a></code></pre></div>
<p>int型のオブジェクトは4バイトの連続したメモリー上に構築されている。つまり、本質的には以下のようなコードと同等になる。</p>
<div class="sourceCode" id="cb1089"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1089-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1089-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1089-3" data-line-number="3">    <span class="bu">std::</span>byte data[<span class="dv">4</span>] ;</a>
<a class="sourceLine" id="cb1089-4" data-line-number="4">    <span class="bu">std::</span>cout &lt;&lt; <span class="bu">std::</span>bit_cast&lt;<span class="bu">std::</span>uintptr_t&gt;(&amp;data[<span class="dv">0</span>]) ;</a>
<a class="sourceLine" id="cb1089-5" data-line-number="5">}</a></code></pre></div>
<p><code>std::byte</code>というのは<code>sizeof(std::byte)</code>の結果が1になる、サイズが1バイトの符号なし整数型だ。</p>
<p><code>std::byte</code>はC++で1バイトの生の値を表現するために使うことができる。配列は連続したバイト列なので、4バイトのint型は、本質的には上のようなコードになる。ただし上のコードはアライメントという概念が欠けている。これについては後で説明する。</p>
<p>ところで、<code>std::bit_cast</code>は2020年に制定される国際標準規格C++20から入った。しかるに筆者がこの文章を書いているのは2018年だ。まだC++20を完全に実装したC++コンパイラーは存在しない。この本が出版されてしばらくは、読者の手元にもC++20コンパイラーは存在しないだろう。</p>
<h3 id="stdbit_castの実装"><code>std::bit_cast</code>の実装</h3>
<p>ないものは自分で実装すればいい。<code>std::bit_cast</code>に近いものを実装してみよう。</p>
<p>今回実装する<code>bit_cast</code>は以下のような関数テンプレートだ。</p>
<div class="sourceCode" id="cb1090"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1090-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> To, <span class="kw">typename</span> From &gt;</a>
<a class="sourceLine" id="cb1090-2" data-line-number="2">To bit_cast( From <span class="at">const</span> &amp; from )</a>
<a class="sourceLine" id="cb1090-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb1090-4" data-line-number="4">    <span class="co">// 値fromのバイト列をTo型の値として解釈して返す。</span></a>
<a class="sourceLine" id="cb1090-5" data-line-number="5">}</a></code></pre></div>
<p>bit_castの実装にはポインターが必要だ。Fromの値を表現するバイト列への先頭のポインターをとり、バイト単位でToの値を表現するバイト列にコピーすればよい。</p>
<p>標準ライブラリにはそのような処理を行ってくれる<code>std::memcpy(dest, src, n)</code>がある。ポインターsrcからnバイトをポインターdestからnバイトに書き込む関数だ。</p>
<div class="sourceCode" id="cb1091"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1091-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> To, <span class="kw">typename</span> From &gt;</a>
<a class="sourceLine" id="cb1091-2" data-line-number="2">To bit_cast( From <span class="at">const</span> &amp; from )</a>
<a class="sourceLine" id="cb1091-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb1091-4" data-line-number="4">    To to ;</a>
<a class="sourceLine" id="cb1091-5" data-line-number="5">    <span class="bu">std::</span>memcpy( &amp;to, &amp;from, <span class="kw">sizeof</span>(To) ) ;</a>
<a class="sourceLine" id="cb1091-6" data-line-number="6">    <span class="cf">return</span> to ;</a>
<a class="sourceLine" id="cb1091-7" data-line-number="7">}</a></code></pre></div>
<p>これで<code>std::bit_cast</code>の実装はできた。しかしこの実装は問題を<code>std::memcpy</code>にたらい回しにしただけだ。<code>std::memcpy</code>も実装できて初めて<code>std::bit_cast</code>を自前で実装できたと言える。</p>
<h3 id="stdmemcpyの実装"><code>std::memcpy</code>の実装</h3>
<p><code>std::memcpy</code>はC++コンパイラーによって効率の良いコードに置き換えられる。そのため自分で実装した<code>std::memcpy</code>を標準ライブラリと同じ効率にすることは難しいが、機能的にはほとんど同じものを作ることができる。</p>
<p><code>memcpy</code>の実装にはポインターの詳細な理解が必要だ。</p>
<p><code>std::memcpy</code>関数は以下のようになっている。</p>
<div class="sourceCode" id="cb1092"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1092-1" data-line-number="1"><span class="dt">void</span> * memcpy( <span class="dt">void</span> * dest, <span class="dt">void</span> <span class="at">const</span> * src, <span class="bu">std::</span>size_t n )</a>
<a class="sourceLine" id="cb1092-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1092-3" data-line-number="3">    <span class="co">// srcの先頭バイトからnバイトを</span></a>
<a class="sourceLine" id="cb1092-4" data-line-number="4">    <span class="co">// destの先頭バイトからのバイト列にコピーし</span></a>
<a class="sourceLine" id="cb1092-5" data-line-number="5">    <span class="co">// destを返す</span></a>
<a class="sourceLine" id="cb1092-6" data-line-number="6">}</a></code></pre></div>
<p>みなれない<code>void *</code>という型が出てきた。まずはこれについて学ぼう。</p>
<h4 id="void型">void型</h4>
<p><code>void</code>は特別な型だ。void型は何も値を持たない型という意味を持つ。例えば関数が戻り値を何も返さない場合、void型を返す関数として宣言される。</p>
<div class="sourceCode" id="cb1093"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1093-1" data-line-number="1"><span class="co">// 何も値を返さない関数</span></a>
<a class="sourceLine" id="cb1093-2" data-line-number="2"><span class="dt">void</span> f()</a>
<a class="sourceLine" id="cb1093-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb1093-4" data-line-number="4">    <span class="co">// 何も値を返さない</span></a>
<a class="sourceLine" id="cb1093-5" data-line-number="5">    <span class="cf">return</span> ;</a>
<a class="sourceLine" id="cb1093-6" data-line-number="6">}</a></code></pre></div>
<p>あらゆる値はvoid型に変換することができる。変換した結果は、何も値を持たない。</p>
<div class="sourceCode" id="cb1094"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1094-1" data-line-number="1"><span class="dt">void</span> f()</a>
<a class="sourceLine" id="cb1094-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1094-3" data-line-number="3">    <span class="cf">return</span> <span class="kw">static_cast</span>&lt;<span class="dt">void</span>&gt;(<span class="dv">123</span>) ;</a>
<a class="sourceLine" id="cb1094-4" data-line-number="4">}</a></code></pre></div>
<p>C++17では、void型の変数は作れない。</p>
<div class="sourceCode" id="cb1095"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1095-1" data-line-number="1"><span class="co">// エラー</span></a>
<a class="sourceLine" id="cb1095-2" data-line-number="2"><span class="dt">void</span> x ;</a></code></pre></div>
<p>ところで、読者が本書を読む頃には、C++規格ではvoid型の変数が作れるようになっているかもしれない。これはvoid型だけ変数を作れないのが面倒だからつくれるようになるだけで、具体的な値のない変数になる。</p>
<h4 id="void-型">void *型</h4>
<p><code>void *</code>型は「void型へのポインター型」だ。<code>int *</code>が「int型へのポインター型」であるのと同じだ。</p>
<p><code>void *</code>型の値は、ある型Tへのポインター型から型Tという情報が消え去ったポインターの値だ。ポインターの値というのはアドレスで、アドレスというのは単なるバイト単位のメモリを指す整数値だということを学んだ。<code>void *</code>型は特定の型を意味しないポインター型だ。</p>
<p>ある型Tへのポインター型の値は、<code>void *</code>型に変換できる。</p>
<div class="sourceCode" id="cb1096"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1096-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1096-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1096-3" data-line-number="3">    <span class="dt">int</span> data { } ;</a>
<a class="sourceLine" id="cb1096-4" data-line-number="4"></a>
<a class="sourceLine" id="cb1096-5" data-line-number="5">    <span class="co">// int *からvoid *への変換</span></a>
<a class="sourceLine" id="cb1096-6" data-line-number="6">    <span class="dt">void</span> * ptr = &amp;data ;</a>
<a class="sourceLine" id="cb1096-7" data-line-number="7">}</a></code></pre></div>
<p><code>void *</code>型の値eから元の型Tへのポインターに変換するには<code>static_cast&lt;T *&gt;(e)</code>が必要だ。</p>
<div class="sourceCode" id="cb1097"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1097-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1097-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1097-3" data-line-number="3">    <span class="dt">int</span> data { } ;</a>
<a class="sourceLine" id="cb1097-4" data-line-number="4">    <span class="dt">void</span> * void_ptr = &amp;data ;</a>
<a class="sourceLine" id="cb1097-5" data-line-number="5"></a>
<a class="sourceLine" id="cb1097-6" data-line-number="6">    <span class="dt">int</span> * int_ptr = <span class="kw">static_cast</span>&lt;<span class="dt">int</span> *&gt;(void_ptr) ;</a>
<a class="sourceLine" id="cb1097-7" data-line-number="7">}</a></code></pre></div>
<p>もし<code>static_cast&lt;T *&gt;(e)</code>のeが<code>T *</code>として妥当なアドレスの値であれば、変換後も正しく動く。</p>
<p><code>T const *</code>型は<code>void const *</code>型に変換できる。その逆変換もできる。</p>
<div class="sourceCode" id="cb1098"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1098-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1098-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1098-3" data-line-number="3">    <span class="dt">int</span> data {} ;</a>
<a class="sourceLine" id="cb1098-4" data-line-number="4">    <span class="dt">int</span> <span class="at">const</span> * int_const_ptr = &amp;data ;</a>
<a class="sourceLine" id="cb1098-5" data-line-number="5">    <span class="dt">void</span> <span class="at">const</span> * void_const_ptr = int_const_ptr ;</a>
<a class="sourceLine" id="cb1098-6" data-line-number="6">    <span class="dt">int</span> <span class="at">const</span> * original = <span class="kw">static_cast</span>&lt;<span class="dt">int</span> <span class="at">const</span> *&gt;(void_const_ptr) ;</a>
<a class="sourceLine" id="cb1098-7" data-line-number="7">}</a></code></pre></div>
<p>ポインター間の型変換でconstを消すことはできない。</p>
<p>memcpyは<code>void *</code>を使うことで、どんなポインターの値でも取れるようにしている。C++にはテンプレートがあるので以下のように宣言してもよいのだが、</p>
<div class="sourceCode" id="cb1099"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1099-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> Dest, <span class="kw">typename</span> Src &gt;</a>
<a class="sourceLine" id="cb1099-2" data-line-number="2">Dest * memcpy( Dest * dest, Src <span class="at">const</span> * src, <span class="bu">std::</span>size_t n ) ;</a></code></pre></div>
<p>memcpyはC++以前からあるC言語ライブラリなので、こうなっている。</p>
<h4 id="stdbyte型">std::byte型</h4>
<p><code>void *</code>型はアドレスだけを意味するポインター型なので、参照することができない。<code>memcpy</code>の実装にはポインターを経由して参照先を1バイトづつ読み書きする必要がある。そのための型としてstd::byteがある。</p>
<p><code>std::byte</code>型は1バイトを表現するための型だ。<code>sizeof(std::byte)</code>の結果は1になる。</p>
<p>1バイトというのは10進数で<span class="math inline">\(0 \leqq n \leqq 255\)</span>までの値を扱う。</p>
<p><code>std::byte</code>はとても厳格に1バイトの符号なし整数として振る舞うので、普通の整数で初期化や代入をすることができない。</p>
<div class="sourceCode" id="cb1100"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1100-1" data-line-number="1"><span class="co">// エラー</span></a>
<a class="sourceLine" id="cb1100-2" data-line-number="2"><span class="bu">std::</span>byte a = <span class="dv">123</span> ;</a>
<a class="sourceLine" id="cb1100-3" data-line-number="3"><span class="bu">std::</span>byte b(<span class="dv">123</span>) ;</a>
<a class="sourceLine" id="cb1100-4" data-line-number="4"></a>
<a class="sourceLine" id="cb1100-5" data-line-number="5"><span class="co">// これもエラー</span></a>
<a class="sourceLine" id="cb1100-6" data-line-number="6">a = <span class="dv">123</span> ;</a></code></pre></div>
<p>std::byteに具体的な値で初期化するには<code>{x}</code>を使う。</p>
<div class="sourceCode" id="cb1101"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1101-1" data-line-number="1"><span class="bu">std::</span>byte a{<span class="dv">123</span>} ;</a></code></pre></div>
<p>std::byteに値を代入するには<code>std::byte{x}</code>を使う</p>
<div class="sourceCode" id="cb1102"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1102-1" data-line-number="1"><span class="bu">std::</span>byte a ;</a>
<a class="sourceLine" id="cb1102-2" data-line-number="2">a = <span class="bu">std::</span>byte{<span class="dv">123</span>} ;</a></code></pre></div>
<p><code>static_cast&lt;std::byte&gt;(x)</code>や<code>std::byte(x)</code>はコンパイルできるが、使ってはならない。</p>
<div class="sourceCode" id="cb1103"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1103-1" data-line-number="1"><span class="co">// 使ってはならない</span></a>
<a class="sourceLine" id="cb1103-2" data-line-number="2"><span class="bu">std::</span>byte a = <span class="kw">static_cast</span>&lt;<span class="bu">std::</span>byte&gt;(<span class="dv">123</span>) ;</a>
<a class="sourceLine" id="cb1103-3" data-line-number="3"><span class="bu">std::</span>byte b = <span class="bu">std::</span>byte(<span class="dv">123</span>) ;</a></code></pre></div>
<p>何故使ってはならないかというと、範囲外の値を無理やり変換してしまうからだ。</p>
<div class="sourceCode" id="cb1104"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1104-1" data-line-number="1"><span class="bu">std::</span>byte a = <span class="kw">static_cast</span>&lt;<span class="bu">std::</span>byte&gt;(<span class="dv">256</span>) ;</a>
<a class="sourceLine" id="cb1104-2" data-line-number="2"><span class="bu">std::</span>byte b = <span class="bu">std::</span>byte(<span class="dv">-1</span>) ;</a></code></pre></div>
<h4 id="配列のメモリ上での表現">配列のメモリ上での表現</h4>
<p>配列は要素型を表現するバイト列をメモリ上に連続して配置する。</p>
<p>例えば<code>int [3]</code>という配列があり、<code>sizeof(int)</code>が4の場合、全体で12バイトのメモリが確保される。</p>
<div class="sourceCode" id="cb1105"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1105-1" data-line-number="1"><span class="dt">int</span> data[<span class="dv">3</span>] = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>} ;</a></code></pre></div>
<p>最初の4バイト（0バイト目から3バイトまで）の領域は0番目の要素である<code>data[0]</code>で、その値は1だ。</p>
<p>次の4バイト（4バイト目から7バイト目まで）の領域は1番目の要素である<code>data[1]</code>で、その値は2だ。</p>
<p>最後の4バイト（8バイト目から11バイト目まで）の領域は2番めの要素である<code>data[2]</code>で、その値は3だ。</p>
<pre><code>TODO: メモリの図示

   ↓最初の4バイト
&lt;-----&gt;
□-□-□-□-□-□-□-□-□-□-□-□
        &lt;-----&gt;
       　　↑次の4バイト
                &lt;-----&gt;
                   ↑最後の4バイト</code></pre>
<p>実際にアドレスの生の値を出力して確かめてみよう。</p>
<div class="sourceCode" id="cb1107"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1107-1" data-line-number="1"><span class="co">// 生のアドレスを出力する関数</span></a>
<a class="sourceLine" id="cb1107-2" data-line-number="2"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;</a>
<a class="sourceLine" id="cb1107-3" data-line-number="3"><span class="dt">void</span> print_raw_address( T ptr )</a>
<a class="sourceLine" id="cb1107-4" data-line-number="4">{</a>
<a class="sourceLine" id="cb1107-5" data-line-number="5">    <span class="bu">std::</span>cout &lt;&lt; <span class="bu">std::</span>bit_cast&lt;<span class="bu">std::</span>uintptr_t&gt;(ptr) &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb1107-6" data-line-number="6">}</a>
<a class="sourceLine" id="cb1107-7" data-line-number="7"></a>
<a class="sourceLine" id="cb1107-8" data-line-number="8"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1107-9" data-line-number="9">{</a>
<a class="sourceLine" id="cb1107-10" data-line-number="10">    <span class="dt">int</span> data[<span class="dv">3</span>] = {<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">2</span>} ;</a>
<a class="sourceLine" id="cb1107-11" data-line-number="11">    print_raw_address( &amp;data[<span class="dv">0</span>] ) ;</a>
<a class="sourceLine" id="cb1107-12" data-line-number="12">    print_raw_address( &amp;data[<span class="dv">1</span>] ) ;</a>
<a class="sourceLine" id="cb1107-13" data-line-number="13">    print_raw_address( &amp;data[<span class="dv">2</span>] ) ;</a>
<a class="sourceLine" id="cb1107-14" data-line-number="14">}</a></code></pre></div>
<p>このプログラムを筆者の環境で実行すると以下のように出力された。</p>
<pre><code>140736120015884
140736120015888
140736120015892</code></pre>
<p>筆者の環境では<code>sizeof(int)</code>は4だ。<code>&amp;data[0]</code>の生のアドレスに4を足した値が<code>&amp;data[1]</code>になっていることがわかる。</p>
<h4 id="ポインターと整数の演算">ポインターと整数の演算</h4>
<p>ポインターと整数を加減算することができる。</p>
<p>ポインター<code>T *</code>に整数nを足すと、ポインターのアドレスが<code>sizeof(T) * n</code>加算される。この結果、ポインターは要素が配列のように配置された場合にn個先の要素を指すようになる。</p>
<div class="sourceCode" id="cb1109"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1109-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;</a>
<a class="sourceLine" id="cb1109-2" data-line-number="2"><span class="dt">void</span> print_raw_address( T ptr )</a>
<a class="sourceLine" id="cb1109-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb1109-4" data-line-number="4">    <span class="bu">std::</span>cout &lt;&lt; <span class="bu">std::</span>bit_cast&lt;<span class="bu">std::</span>uintptr_t&gt;(ptr) &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb1109-5" data-line-number="5">}</a>
<a class="sourceLine" id="cb1109-6" data-line-number="6"></a>
<a class="sourceLine" id="cb1109-7" data-line-number="7"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1109-8" data-line-number="8">{</a>
<a class="sourceLine" id="cb1109-9" data-line-number="9">    <span class="dt">int</span> a[<span class="dv">4</span>] = {<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>} ;</a>
<a class="sourceLine" id="cb1109-10" data-line-number="10"></a>
<a class="sourceLine" id="cb1109-11" data-line-number="11">    <span class="co">// 0個目の要素へのポインター</span></a>
<a class="sourceLine" id="cb1109-12" data-line-number="12">    <span class="dt">int</span> * a0 = &amp;a[<span class="dv">0</span>] ;</a>
<a class="sourceLine" id="cb1109-13" data-line-number="13">    print_raw_address( a0 ) ;</a>
<a class="sourceLine" id="cb1109-14" data-line-number="14">    </a>
<a class="sourceLine" id="cb1109-15" data-line-number="15"></a>
<a class="sourceLine" id="cb1109-16" data-line-number="16">    <span class="co">// アドレスがsizeof(int) * 3加算される</span></a>
<a class="sourceLine" id="cb1109-17" data-line-number="17">    <span class="co">// a3は3個目の要素へのポインター</span></a>
<a class="sourceLine" id="cb1109-18" data-line-number="18">    <span class="dt">int</span> * a3 = a0 + <span class="dv">3</span> ;</a>
<a class="sourceLine" id="cb1109-19" data-line-number="19">    print_raw_address( a3 ) ;</a>
<a class="sourceLine" id="cb1109-20" data-line-number="20"></a>
<a class="sourceLine" id="cb1109-21" data-line-number="21">    <span class="co">// アドレスがsizeof(int) * 2減算される。</span></a>
<a class="sourceLine" id="cb1109-22" data-line-number="22">    <span class="co">// a1は1個目の要素へのポインター</span></a>
<a class="sourceLine" id="cb1109-23" data-line-number="23">    <span class="dt">int</span> * a1 = a3 - <span class="dv">2</span> ;</a>
<a class="sourceLine" id="cb1109-24" data-line-number="24">    print_raw_address( a1 ) ;</a>
<a class="sourceLine" id="cb1109-25" data-line-number="25">}</a></code></pre></div>
<p>これを筆者の環境で実行すると以下のように出力された。</p>
<pre><code>140722117900224
140722117900236
140722117900228</code></pre>
<p>最初の値がa0, 次の値がa3, 最後の値がa3だ。</p>
<p>筆者の環境では<code>sizeof(int)</code>は4だ。するとa3の値はa0の値より12多い値になっているはずだ。実際にそうなっている。a1はa3に対して8少ない値になっているはずだ。実際にそうなっている。</p>
<h4 id="いよいよmemcpyの実装">いよいよmemcpyの実装</h4>
<p>これまで学んできたことをすべて使い、ようやくmemcpyが実装できる。</p>
<ol type="1">
<li>destを<code>std::byte *</code>型に変換する</li>
<li>srcを<code>std::byte const *</code>型に変換する</li>
<li>srcの参照先からnバイトをdestの参照先にコピーする</li>
<li>destを返す</li>
</ol>
<div class="sourceCode" id="cb1111"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1111-1" data-line-number="1"><span class="dt">void</span> * memcpy( <span class="dt">void</span> * dest, <span class="dt">void</span> <span class="at">const</span> * src, <span class="bu">std::</span>size_t n )</a>
<a class="sourceLine" id="cb1111-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1111-3" data-line-number="3">    <span class="co">// destをstd::byte *型に変換</span></a>
<a class="sourceLine" id="cb1111-4" data-line-number="4">    <span class="kw">auto</span> d = <span class="kw">static_cast</span>&lt;<span class="bu">std::</span>byte *&gt;(dest) ;</a>
<a class="sourceLine" id="cb1111-5" data-line-number="5">    <span class="co">// srcをstd::byte const *型に変換する</span></a>
<a class="sourceLine" id="cb1111-6" data-line-number="6">    <span class="kw">auto</span> s = <span class="kw">static_cast</span>&lt;<span class="bu">std::</span>byte <span class="at">const</span> *&gt;(src) ;</a>
<a class="sourceLine" id="cb1111-7" data-line-number="7"></a>
<a class="sourceLine" id="cb1111-8" data-line-number="8">    <span class="co">// srcからnバイトコピーするのでnバイト先のアドレスを得る </span></a>
<a class="sourceLine" id="cb1111-9" data-line-number="9">    <span class="kw">auto</span> last = s + n ;</a>
<a class="sourceLine" id="cb1111-10" data-line-number="10"></a>
<a class="sourceLine" id="cb1111-11" data-line-number="11">    <span class="co">// nバイトコピーする</span></a>
<a class="sourceLine" id="cb1111-12" data-line-number="12">    <span class="cf">while</span> ( s != last )</a>
<a class="sourceLine" id="cb1111-13" data-line-number="13">    {</a>
<a class="sourceLine" id="cb1111-14" data-line-number="14">        *d = *s ;</a>
<a class="sourceLine" id="cb1111-15" data-line-number="15">        ++d ;</a>
<a class="sourceLine" id="cb1111-16" data-line-number="16">        ++s ;</a>
<a class="sourceLine" id="cb1111-17" data-line-number="17">    }</a>
<a class="sourceLine" id="cb1111-18" data-line-number="18"></a>
<a class="sourceLine" id="cb1111-19" data-line-number="19">    <span class="co">// destを返す</span></a>
<a class="sourceLine" id="cb1111-20" data-line-number="20">    <span class="cf">return</span> dest ;</a>
<a class="sourceLine" id="cb1111-21" data-line-number="21">}</a></code></pre></div>
<h4 id="memcpyの別の実装">memcpyの別の実装</h4>
<p>ポインターは<code>operator []</code>に対応している。</p>
<p>ポインターpと整数iに対して<code>p[i]</code>と書いたとき、<code>*(p + i)</code>という意味になる。</p>
<div class="sourceCode" id="cb1112"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1112-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1112-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1112-3" data-line-number="3">    <span class="dt">int</span> a[<span class="dv">5</span>] = {<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>} ;</a>
<a class="sourceLine" id="cb1112-4" data-line-number="4">    <span class="dt">int</span> * p = &amp;a[<span class="dv">0</span>] ;</a>
<a class="sourceLine" id="cb1112-5" data-line-number="5"></a>
<a class="sourceLine" id="cb1112-6" data-line-number="6">    p[<span class="dv">0</span>] ; <span class="co">// 0</span></a>
<a class="sourceLine" id="cb1112-7" data-line-number="7">    p[<span class="dv">2</span>] ; <span class="co">// 2</span></a>
<a class="sourceLine" id="cb1112-8" data-line-number="8"></a>
<a class="sourceLine" id="cb1112-9" data-line-number="9">    <span class="dt">int</span> * p2 = &amp;p[<span class="dv">2</span>] ;</a>
<a class="sourceLine" id="cb1112-10" data-line-number="10">    p2[<span class="dv">1</span>] ; <span class="co">// 3</span></a>
<a class="sourceLine" id="cb1112-11" data-line-number="11">}</a></code></pre></div>
<p><code>memcpy</code>は<code>operator []</code>を使って書くこともできる。</p>
<div class="sourceCode" id="cb1113"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1113-1" data-line-number="1"><span class="dt">void</span> * memcpy( <span class="dt">void</span> * dest, <span class="dt">void</span> <span class="at">const</span> * src, <span class="bu">std::</span>size_t n )</a>
<a class="sourceLine" id="cb1113-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1113-3" data-line-number="3">    <span class="kw">auto</span> d = <span class="kw">static_cast</span>&lt;<span class="bu">std::</span>byte *&gt;(dest) ;</a>
<a class="sourceLine" id="cb1113-4" data-line-number="4">    <span class="kw">auto</span> s = <span class="kw">static_cast</span>&lt;<span class="bu">std::</span>byte <span class="at">const</span> *&gt;(src) ;</a>
<a class="sourceLine" id="cb1113-5" data-line-number="5"></a>
<a class="sourceLine" id="cb1113-6" data-line-number="6">    <span class="cf">for</span> ( <span class="bu">std::</span>size_t i = <span class="dv">0</span> ; i != n ; ++i )</a>
<a class="sourceLine" id="cb1113-7" data-line-number="7">    {</a>
<a class="sourceLine" id="cb1113-8" data-line-number="8">        d[i] = s[i] ;</a>
<a class="sourceLine" id="cb1113-9" data-line-number="9">    }</a>
<a class="sourceLine" id="cb1113-10" data-line-number="10"></a>
<a class="sourceLine" id="cb1113-11" data-line-number="11">    <span class="cf">return</span> dest ;</a>
<a class="sourceLine" id="cb1113-12" data-line-number="12">}</a></code></pre></div>
<h3 id="データメンバーへのポインターの内部実装">データメンバーへのポインターの内部実装</h3>
<p>データメンバーへのポインターの整数としての値は少し変わっている。</p>
<p>ポインターの生の値は、メモリー上で値を表現しているバイト列の先頭アドレスだ。</p>
<p>データメンバーへのポインターは、具体的なクラスのオブジェクトへのポインターやリファレンスがあって初めて意味がある。</p>
<div class="sourceCode" id="cb1114"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1114-1" data-line-number="1"><span class="kw">struct</span> S { <span class="dt">int</span> x = <span class="dv">123</span> ; } ;</a>
<a class="sourceLine" id="cb1114-2" data-line-number="2"></a>
<a class="sourceLine" id="cb1114-3" data-line-number="3"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1114-4" data-line-number="4">{</a>
<a class="sourceLine" id="cb1114-5" data-line-number="5">    <span class="dt">int</span> data = <span class="dv">123</span> ;</a>
<a class="sourceLine" id="cb1114-6" data-line-number="6">    <span class="dt">int</span> * ptr = &amp;data ;</a>
<a class="sourceLine" id="cb1114-7" data-line-number="7">    <span class="co">// ptr単体で参照できる</span></a>
<a class="sourceLine" id="cb1114-8" data-line-number="8">    <span class="dt">int</span> read1 = *ptr ;</a>
<a class="sourceLine" id="cb1114-9" data-line-number="9"></a>
<a class="sourceLine" id="cb1114-10" data-line-number="10">    S object ;</a>
<a class="sourceLine" id="cb1114-11" data-line-number="11">    <span class="dt">int</span> S::* mem_ptr = &amp;S::x ;</a>
<a class="sourceLine" id="cb1114-12" data-line-number="12">    <span class="co">// objectとmem_ptrの2つで参照できる</span></a>
<a class="sourceLine" id="cb1114-13" data-line-number="13">    <span class="dt">int</span> read2 = object.*mem_ptr ;</a>
<a class="sourceLine" id="cb1114-14" data-line-number="14"></a>
<a class="sourceLine" id="cb1114-15" data-line-number="15">}</a></code></pre></div>
<p>配列が要素型のバイト列を連続して配置したメモリレイアウトをしているように、クラスもデータメンバーを連続して配置したメモリーレイアウトをしている。</p>
<p>たとえば以下のようなクラスObjectがある場合、</p>
<div class="sourceCode" id="cb1115"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1115-1" data-line-number="1"><span class="kw">struct</span> Object</a>
<a class="sourceLine" id="cb1115-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1115-3" data-line-number="3">    <span class="dt">int</span> x ;</a>
<a class="sourceLine" id="cb1115-4" data-line-number="4">    <span class="dt">int</span> y ;</a>
<a class="sourceLine" id="cb1115-5" data-line-number="5">    <span class="dt">int</span> z ;</a>
<a class="sourceLine" id="cb1115-6" data-line-number="6">} ;</a></code></pre></div>
<p>このクラスのサイズは<code>sizeof(Object)</code>だ。このクラスはint型のサブオブジェクトを3つ持っているので、そのサイズは少なくとも<code>size(int)*3</code>はある。</p>
<p>実際に確かめてみよう。</p>
<div class="sourceCode" id="cb1116"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1116-1" data-line-number="1"><span class="kw">struct</span> Object</a>
<a class="sourceLine" id="cb1116-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1116-3" data-line-number="3">    <span class="dt">int</span> x ;</a>
<a class="sourceLine" id="cb1116-4" data-line-number="4">    <span class="dt">int</span> y ;</a>
<a class="sourceLine" id="cb1116-5" data-line-number="5">    <span class="dt">int</span> z ;</a>
<a class="sourceLine" id="cb1116-6" data-line-number="6">} ;</a>
<a class="sourceLine" id="cb1116-7" data-line-number="7"></a>
<a class="sourceLine" id="cb1116-8" data-line-number="8"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1116-9" data-line-number="9">{</a>
<a class="sourceLine" id="cb1116-10" data-line-number="10">    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;sizeof(int): &quot;</span> &lt;&lt; <span class="kw">sizeof</span>(<span class="dt">int</span>) &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb1116-11" data-line-number="11"></a>
<a class="sourceLine" id="cb1116-12" data-line-number="12">    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;sizeof(Object): &quot;</span> &lt;&lt; <span class="kw">sizeof</span>(Object) &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb1116-13" data-line-number="13">}</a></code></pre></div>
<p>このプログラムを筆者の環境で実行すると以下のように出力された。</p>
<pre><code>sizeof(int): 4
sizeof(Object): 12</code></pre>
<p>int型のサイズが4で、Object型のサイズが12ということは、クラスObjectにはint型のサブオブジェクトが3つ、隙間なく連続して配置されているということだ。すべてのクラスがこうではないが、今回の私の環境ではそうなっている。</p>
<p>全体で12バイトということは、配列<code>int [3]</code>と同じように、最初の4バイトにx,y,zのどれかが、次の4バイトに残りのどちらかが、最後の4バイトに残りが配置されている。</p>
<p>データメンバーへのポインターというのは、このクラスのオブジェクトを表現するバイト列の先頭から何バイト目に配置されているかというオフセット値になっている。</p>
<p>具体的な値を見てみよう。</p>
<div class="sourceCode" id="cb1118"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1118-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;</a>
<a class="sourceLine" id="cb1118-2" data-line-number="2"><span class="dt">void</span> print_raw_address( T ptr )</a>
<a class="sourceLine" id="cb1118-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb1118-4" data-line-number="4">    <span class="bu">std::</span>cout &lt;&lt; bit_cast&lt;<span class="bu">std::</span>uintptr_t&gt;(ptr) &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb1118-5" data-line-number="5">}</a>
<a class="sourceLine" id="cb1118-6" data-line-number="6"></a>
<a class="sourceLine" id="cb1118-7" data-line-number="7"><span class="kw">struct</span> Object</a>
<a class="sourceLine" id="cb1118-8" data-line-number="8">{</a>
<a class="sourceLine" id="cb1118-9" data-line-number="9">    <span class="dt">int</span> x ;</a>
<a class="sourceLine" id="cb1118-10" data-line-number="10">    <span class="dt">int</span> y ;</a>
<a class="sourceLine" id="cb1118-11" data-line-number="11">    <span class="dt">int</span> z ;</a>
<a class="sourceLine" id="cb1118-12" data-line-number="12">} ;</a>
<a class="sourceLine" id="cb1118-13" data-line-number="13"></a>
<a class="sourceLine" id="cb1118-14" data-line-number="14"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1118-15" data-line-number="15">{</a>
<a class="sourceLine" id="cb1118-16" data-line-number="16">    print_raw_address( &amp;Object::x ) ;</a>
<a class="sourceLine" id="cb1118-17" data-line-number="17">    print_raw_address( &amp;Object::y ) ;</a>
<a class="sourceLine" id="cb1118-18" data-line-number="18">    print_raw_address( &amp;Object::z ) ;</a>
<a class="sourceLine" id="cb1118-19" data-line-number="19">}</a></code></pre></div>
<p>このプログラムを筆者の環境で実行すると以下のように出力される。</p>
<pre><code>0
4
8</code></pre>
<p>筆者の環境では、xはクラスの先頭アドレスからオフセット0バイトに、yはオフセット4バイトに、zはオフセット8バイトに配置されているようだ。</p>
<p>確かめてみよう。</p>
<div class="sourceCode" id="cb1120"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1120-1" data-line-number="1"></a>
<a class="sourceLine" id="cb1120-2" data-line-number="2"><span class="kw">struct</span> Object</a>
<a class="sourceLine" id="cb1120-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb1120-4" data-line-number="4">    <span class="dt">int</span> x = <span class="dv">123</span> ;</a>
<a class="sourceLine" id="cb1120-5" data-line-number="5">    <span class="dt">int</span> y = <span class="dv">456</span> ;</a>
<a class="sourceLine" id="cb1120-6" data-line-number="6">    <span class="dt">int</span> z = <span class="dv">789</span> ;</a>
<a class="sourceLine" id="cb1120-7" data-line-number="7">} ;</a>
<a class="sourceLine" id="cb1120-8" data-line-number="8"></a>
<a class="sourceLine" id="cb1120-9" data-line-number="9"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1120-10" data-line-number="10">{</a>
<a class="sourceLine" id="cb1120-11" data-line-number="11"></a>
<a class="sourceLine" id="cb1120-12" data-line-number="12">    Object object ;</a>
<a class="sourceLine" id="cb1120-13" data-line-number="13"></a>
<a class="sourceLine" id="cb1120-14" data-line-number="14">    <span class="co">// クラスのオブジェクトの先頭アドレス</span></a>
<a class="sourceLine" id="cb1120-15" data-line-number="15">    <span class="bu">std::</span>byte * start = bit_cast&lt;<span class="bu">std::</span>byte *&gt;(&amp;object) ;</a>
<a class="sourceLine" id="cb1120-16" data-line-number="16">    <span class="co">// オフセット0</span></a>
<a class="sourceLine" id="cb1120-17" data-line-number="17">    <span class="dt">int</span> * x = bit_cast&lt;<span class="dt">int</span> *&gt;(start + <span class="dv">0</span>) ;</a>
<a class="sourceLine" id="cb1120-18" data-line-number="18">    <span class="co">// オフセット4</span></a>
<a class="sourceLine" id="cb1120-19" data-line-number="19">    <span class="dt">int</span> * y = bit_cast&lt;<span class="dt">int</span> *&gt;(start + <span class="dv">4</span>) ;</a>
<a class="sourceLine" id="cb1120-20" data-line-number="20">    <span class="co">// オフセット8</span></a>
<a class="sourceLine" id="cb1120-21" data-line-number="21">    <span class="dt">int</span> * z = bit_cast&lt;<span class="dt">int</span> *&gt;(start + <span class="dv">8</span>) ;</a>
<a class="sourceLine" id="cb1120-22" data-line-number="22"></a>
<a class="sourceLine" id="cb1120-23" data-line-number="23">    <span class="bu">std::</span>cout &lt;&lt; *x &lt;&lt; *y &lt;&lt; *z ;</a>
<a class="sourceLine" id="cb1120-24" data-line-number="24">}</a></code></pre></div>
<p>筆者の環境では以下のように出力される</p>
<pre><code>123456789</code></pre>
<p>このプログラムの実行結果は環境によって変わる。読者の使っている環境でデータメンバーへのポインターが筆者の環境と同じように実装されているとは限らない。</p>
<h1 id="イテレーター詳細">イテレーター詳細</h1>
<h2 id="イテレーターとポインターの関係">イテレーターとポインターの関係</h2>
<p>arrayのイテレーターの実装を振り返ろう。前回実装したイテレーターは、リファレンスとインデックスを使うものだった。</p>
<div class="sourceCode" id="cb1122"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1122-1" data-line-number="1"><span class="kw">template</span> &lt; Array &gt;</a>
<a class="sourceLine" id="cb1122-2" data-line-number="2"><span class="kw">struct</span> array_iterator</a>
<a class="sourceLine" id="cb1122-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb1122-4" data-line-number="4">    <span class="kw">using</span> reference = <span class="kw">typename</span> Array::reference ;</a>
<a class="sourceLine" id="cb1122-5" data-line-number="5"></a>
<a class="sourceLine" id="cb1122-6" data-line-number="6">    Array &amp; a ;</a>
<a class="sourceLine" id="cb1122-7" data-line-number="7">    <span class="bu">std::</span>size_t i ;</a>
<a class="sourceLine" id="cb1122-8" data-line-number="8"></a>
<a class="sourceLine" id="cb1122-9" data-line-number="9">    array_iterator( Array * a, <span class="bu">std::</span>size_t i )</a>
<a class="sourceLine" id="cb1122-10" data-line-number="10">        a(a), i(i) { }</a>
<a class="sourceLine" id="cb1122-11" data-line-number="11"></a>
<a class="sourceLine" id="cb1122-12" data-line-number="12">    reference <span class="kw">operator</span> *() <span class="at">const</span></a>
<a class="sourceLine" id="cb1122-13" data-line-number="13">    { <span class="cf">return</span> a[i] ; }</a>
<a class="sourceLine" id="cb1122-14" data-line-number="14"></a>
<a class="sourceLine" id="cb1122-15" data-line-number="15">    array_iterator &amp; <span class="kw">operator</span> ++()</a>
<a class="sourceLine" id="cb1122-16" data-line-number="16">    {</a>
<a class="sourceLine" id="cb1122-17" data-line-number="17">        ++i ;</a>
<a class="sourceLine" id="cb1122-18" data-line-number="18">        <span class="cf">return</span> *<span class="kw">this</span> ;</a>
<a class="sourceLine" id="cb1122-19" data-line-number="19">    }</a>
<a class="sourceLine" id="cb1122-20" data-line-number="20"></a>
<a class="sourceLine" id="cb1122-21" data-line-number="21">    reference <span class="kw">operator</span> [] ( <span class="bu">std::</span>size_t n )</a>
<a class="sourceLine" id="cb1122-22" data-line-number="22">    { <span class="cf">return</span> a[i + n] ; }</a>
<a class="sourceLine" id="cb1122-23" data-line-number="23">} ;</a></code></pre></div>
<p>このコードは単にポインターをクラスで実装しているだけではないだろうか。ならば、ポインターでイテレーターを実装することもできるのではないか。</p>
<div class="sourceCode" id="cb1123"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1123-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> Array &gt;</a>
<a class="sourceLine" id="cb1123-2" data-line-number="2"><span class="kw">struct</span> array_iterator</a>
<a class="sourceLine" id="cb1123-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb1123-4" data-line-number="4">    <span class="kw">using</span> pointer = <span class="kw">typename</span> Array::pointer ;</a>
<a class="sourceLine" id="cb1123-5" data-line-number="5">    <span class="kw">using</span> reference = <span class="kw">typename</span> Array::reference ;</a>
<a class="sourceLine" id="cb1123-6" data-line-number="6">    pointer p ;</a>
<a class="sourceLine" id="cb1123-7" data-line-number="7"></a>
<a class="sourceLine" id="cb1123-8" data-line-number="8">    array_iterator( pointer p )</a>
<a class="sourceLine" id="cb1123-9" data-line-number="9">        : p(p) { }</a>
<a class="sourceLine" id="cb1123-10" data-line-number="10"></a>
<a class="sourceLine" id="cb1123-11" data-line-number="11">    reference <span class="kw">operator</span> *()</a>
<a class="sourceLine" id="cb1123-12" data-line-number="12">    { <span class="cf">return</span> *p ; }</a>
<a class="sourceLine" id="cb1123-13" data-line-number="13"></a>
<a class="sourceLine" id="cb1123-14" data-line-number="14">    array_iterator &amp; <span class="kw">operator</span> ++()</a>
<a class="sourceLine" id="cb1123-15" data-line-number="15">    {</a>
<a class="sourceLine" id="cb1123-16" data-line-number="16">        ++p ;</a>
<a class="sourceLine" id="cb1123-17" data-line-number="17">        <span class="cf">return</span> *<span class="kw">this</span> ;</a>
<a class="sourceLine" id="cb1123-18" data-line-number="18">    }</a>
<a class="sourceLine" id="cb1123-19" data-line-number="19"></a>
<a class="sourceLine" id="cb1123-20" data-line-number="20">    reference <span class="kw">operator</span>[] ( <span class="bu">std::</span>size_t n )</a>
<a class="sourceLine" id="cb1123-21" data-line-number="21">    { <span class="cf">return</span> p[n] ; }</a>
<a class="sourceLine" id="cb1123-22" data-line-number="22">} ;</a></code></pre></div>
<p>このコードは本当にポインターをクラスで実装しているだけだ。ならばイテレータークラスの代わりにポインターでもいいのではないだろうか。</p>
<div class="sourceCode" id="cb1124"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1124-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> T, <span class="bu">std::</span>size_t N &gt;</a>
<a class="sourceLine" id="cb1124-2" data-line-number="2"><span class="kw">struct</span> array</a>
<a class="sourceLine" id="cb1124-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb1124-4" data-line-number="4"></a>
<a class="sourceLine" id="cb1124-5" data-line-number="5">    T storage[N] ;</a>
<a class="sourceLine" id="cb1124-6" data-line-number="6"></a>
<a class="sourceLine" id="cb1124-7" data-line-number="7">    <span class="co">// ポインター</span></a>
<a class="sourceLine" id="cb1124-8" data-line-number="8">    <span class="kw">using</span> iterator = T * ;</a>
<a class="sourceLine" id="cb1124-9" data-line-number="9"></a>
<a class="sourceLine" id="cb1124-10" data-line-number="10">    iterator begin()</a>
<a class="sourceLine" id="cb1124-11" data-line-number="11">    { <span class="cf">return</span> &amp;storage[<span class="dv">0</span>] ;  }</a>
<a class="sourceLine" id="cb1124-12" data-line-number="12"></a>
<a class="sourceLine" id="cb1124-13" data-line-number="13">    iterator end()</a>
<a class="sourceLine" id="cb1124-14" data-line-number="14">    { <span class="cf">return</span> begin() + N ; }</a>
<a class="sourceLine" id="cb1124-15" data-line-number="15">} ;</a></code></pre></div>
<p>これは動く。そして実際の<code>std::array</code>の実装もこうなっている。</p>
<p>実はイテレーターはポインターを参考にして作られた。インクリメントで次の要素を参照、<code>operator *</code>で参照先の要素にアクセスといった操作は、すべてポインターの操作をより抽象化したものだ。</p>
<p>ポインターの操作をすべてサポートしたイテレーターは、ランダムアクセスイテレーターと呼ばれる。</p>
<h2 id="イテレーターカテゴリー">イテレーターカテゴリー</h2>
<p>イテレーターにはサポートしている操作に応じて以下のような種類が存在する。</p>
<ul>
<li>入力イテレーター(Input Iterator)</li>
<li>出力イテレーター(Output Iterator)</li>
<li>前方イテレーター(Forward Iterator)</li>
<li>双方向イテレーター(Bidirectional Iterator)</li>
<li>ランダムアクセスイテレーター(Random Access Iterator)</li>
</ul>
<p>イテレーターの関係は以下のようになっている。</p>
<pre><code>TODO: 図示
ランダムアクセスイテレーター → 双方向イテレーター → 前方イテレーター → 入力イテレーター
                                                                     → 出力イテレーター</code></pre>
<p>矢印<code>A → B</code>はAがBであることを意味している。</p>
<p>ランダムアクセスイテレーターは双方向イテレーターのすべての操作をサポートする。故にランダムアクセスイテレーターは双方向イテレーターである。</p>
<p>同様に、双方向イテレーターは前方イテレーターである。前方イテレーターは入力イテレーター/出力イテレーターである。</p>
<p>AはBであることに加えて、追加の操作をサポートしている。</p>
<h3 id="ランダムアクセスイテレーター">ランダムアクセスイテレーター</h3>
<p>ランダムアクセスイテレーターは名前の通りランダムアクセスができる。イテレーターがn番目の要素を指すとき、n+m番目の要素を指すことができる。mは負数でもよい。</p>
<div class="sourceCode" id="cb1126"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1126-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> RandomAccessIterator &gt;</a>
<a class="sourceLine" id="cb1126-2" data-line-number="2"><span class="dt">void</span> f( RandomAccessIterator i, <span class="dt">int</span> n  )</a>
<a class="sourceLine" id="cb1126-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb1126-4" data-line-number="4">    i + n ;</a>
<a class="sourceLine" id="cb1126-5" data-line-number="5">    i - n ;</a>
<a class="sourceLine" id="cb1126-6" data-line-number="6">    n + i ; <span class="co">// i+nと同じ</span></a>
<a class="sourceLine" id="cb1126-7" data-line-number="7">    n - i ; <span class="co">// n-iと同じ</span></a>
<a class="sourceLine" id="cb1126-8" data-line-number="8"></a>
<a class="sourceLine" id="cb1126-9" data-line-number="9">    i + (-n) ; <span class="co">// i - nと同じ</span></a>
<a class="sourceLine" id="cb1126-10" data-line-number="10"></a>
<a class="sourceLine" id="cb1126-11" data-line-number="11">    <span class="co">// i = i + n ; と同じ</span></a>
<a class="sourceLine" id="cb1126-12" data-line-number="12">    i += n ;</a>
<a class="sourceLine" id="cb1126-13" data-line-number="13">    <span class="co">// i = i - n ; と同じ</span></a>
<a class="sourceLine" id="cb1126-14" data-line-number="14">    i -= n ;</a>
<a class="sourceLine" id="cb1126-15" data-line-number="15">}</a></code></pre></div>
<p>と書ける。nの型が符号付き整数型でよい。<code>i + (-5)</code>は<code>i-5</code>と同じ意味だ。</p>
<p>イテレーター間の距離を計算したいときはイテレーター同士を引き算する。</p>
<div class="sourceCode" id="cb1127"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1127-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> RandomAccessIterator &gt;</a>
<a class="sourceLine" id="cb1127-2" data-line-number="2"><span class="dt">void</span> f( RandomAccessIterator a, RandomAccessIterator b )</a>
<a class="sourceLine" id="cb1127-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb1127-4" data-line-number="4">    b - a ; <span class="co">// aからbまでの距離</span></a>
<a class="sourceLine" id="cb1127-5" data-line-number="5">    a - b ; <span class="co">// bからaまでの距離。</span></a>
<a class="sourceLine" id="cb1127-6" data-line-number="6">}</a></code></pre></div>
<p>イテレーター間の距離は負数にもなる。</p>
<div class="sourceCode" id="cb1128"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1128-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> RandomAccessIterator &gt;</a>
<a class="sourceLine" id="cb1128-2" data-line-number="2"><span class="dt">void</span> f( RandomAccessIterator a )</a>
<a class="sourceLine" id="cb1128-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb1128-4" data-line-number="4">    <span class="kw">auto</span> b = a ;</a>
<a class="sourceLine" id="cb1128-5" data-line-number="5">    <span class="co">// bはaより3進んでいる</span></a>
<a class="sourceLine" id="cb1128-6" data-line-number="6">    ++b ; ++b ; ++b ;</a>
<a class="sourceLine" id="cb1128-7" data-line-number="7">    b - a ; <span class="co">// 3</span></a>
<a class="sourceLine" id="cb1128-8" data-line-number="8">    a - b ; <span class="co">// -3</span></a>
<a class="sourceLine" id="cb1128-9" data-line-number="9">}</a></code></pre></div>
<p>イテレーターbはaより3進んでいるので、aからbまでの距離である<code>b - a</code>は3になる。ではbからaまでの距離である<code>a - b</code>はどうなるかというと、-3になる。bにとってaは3戻っているからだ。</p>
<p>イテレーターiのn個先の要素を参照したい場合は、</p>
<div class="sourceCode" id="cb1129"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1129-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> RandomAccessIterator &gt;</a>
<a class="sourceLine" id="cb1129-2" data-line-number="2"><span class="dt">void</span> f( RandomAccessIterator i, <span class="bu">std::</span>size_t n )</a>
<a class="sourceLine" id="cb1129-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb1129-4" data-line-number="4">    <span class="co">// *(i + n) ; と同じ</span></a>
<a class="sourceLine" id="cb1129-5" data-line-number="5">    i[n] ;</a>
<a class="sourceLine" id="cb1129-6" data-line-number="6">}</a></code></pre></div>
<p>と書ける。</p>
<p>ランダムアクセスイテレーターは大小比較ができる。</p>
<div class="sourceCode" id="cb1130"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1130-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> RandomAccessIterator &gt;</a>
<a class="sourceLine" id="cb1130-2" data-line-number="2"><span class="dt">void</span> f( RandomAccessIterator i, RandomAccessIterator j )</a>
<a class="sourceLine" id="cb1130-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb1130-4" data-line-number="4">    i   &lt;   j ;</a>
<a class="sourceLine" id="cb1130-5" data-line-number="5">    i   &gt;   j ;</a>
<a class="sourceLine" id="cb1130-6" data-line-number="6">    i   &lt;=  j ;</a>
<a class="sourceLine" id="cb1130-7" data-line-number="7">    i   &gt;=  j ;</a>
<a class="sourceLine" id="cb1130-8" data-line-number="8">}</a></code></pre></div>
<p>イテレーターの比較は、イテレーターが参照する要素の値の比較ではない。イテレーターが参照する要素の順番の比較だ。</p>
<p>n番目の要素を参照するイテレーターは、n+1番目の要素を参照するイテレーターより小さい。n-1番目を参照するイテレーターより大きい。</p>
<div class="sourceCode" id="cb1131"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1131-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> Iterator &gt;</a>
<a class="sourceLine" id="cb1131-2" data-line-number="2"><span class="dt">void</span> f( Iterator i )</a>
<a class="sourceLine" id="cb1131-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb1131-4" data-line-number="4">    <span class="co">// jはn+1番目を指す</span></a>
<a class="sourceLine" id="cb1131-5" data-line-number="5">    <span class="kw">auto</span> j = i + <span class="dv">1</span> ;</a>
<a class="sourceLine" id="cb1131-6" data-line-number="6"></a>
<a class="sourceLine" id="cb1131-7" data-line-number="7">    i &lt; j ; <span class="co">// true</span></a>
<a class="sourceLine" id="cb1131-8" data-line-number="8">    i &gt; j ; <span class="co">// false</span></a>
<a class="sourceLine" id="cb1131-9" data-line-number="9">}</a></code></pre></div>
<p>ここまでの操作はランダムアクセスイテレーターにしかできない。</p>
<p>双方向イテレーター以下のイテレーターができる比較は同値比較だけだ。</p>
<div class="sourceCode" id="cb1132"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1132-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> Iterator &gt;</a>
<a class="sourceLine" id="cb1132-2" data-line-number="2"><span class="dt">void</span> f( Iterator i, Iterator j )</a>
<a class="sourceLine" id="cb1132-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb1132-4" data-line-number="4">    i == j ;</a>
<a class="sourceLine" id="cb1132-5" data-line-number="5">    i != j ;</a>
<a class="sourceLine" id="cb1132-6" data-line-number="6">}</a></code></pre></div>
<p>イテレーターは同じn番目の要素を指しているときに等しいと比較される。</p>
<div class="sourceCode" id="cb1133"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1133-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> Iterator &gt;</a>
<a class="sourceLine" id="cb1133-2" data-line-number="2"><span class="dt">void</span> f( Iterator i )</a>
<a class="sourceLine" id="cb1133-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb1133-4" data-line-number="4">    <span class="kw">auto</span> j = i ;</a>
<a class="sourceLine" id="cb1133-5" data-line-number="5">    i == j ;    <span class="co">// true</span></a>
<a class="sourceLine" id="cb1133-6" data-line-number="6">    ++j ;</a>
<a class="sourceLine" id="cb1133-7" data-line-number="7">    i = j ;     <span class="co">// false</span></a>
<a class="sourceLine" id="cb1133-8" data-line-number="8">}</a></code></pre></div>
<h3 id="双方向イテレーター">双方向イテレーター</h3>
<p>双方向イテレーターは名前の通り双方向のイテレーターの移動ができる。双方向というのはイテレーターが参照しているn番目の要素のn-1番目の要素とn+1番目の要素だ。</p>
<div class="sourceCode" id="cb1134"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1134-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> BidirectionalIterator &gt;</a>
<a class="sourceLine" id="cb1134-2" data-line-number="2"><span class="dt">void</span> f( BidirectionalIterator i )</a>
<a class="sourceLine" id="cb1134-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb1134-4" data-line-number="4">    ++i ; <span class="co">// i+1</span></a>
<a class="sourceLine" id="cb1134-5" data-line-number="5">    --i ; <span class="co">// i-1</span></a>
<a class="sourceLine" id="cb1134-6" data-line-number="6"></a>
<a class="sourceLine" id="cb1134-7" data-line-number="7">    <span class="co">// r1, r2は変更する前のiの値</span></a>
<a class="sourceLine" id="cb1134-8" data-line-number="8">    <span class="kw">auto</span> r1 = i++ ;</a>
<a class="sourceLine" id="cb1134-9" data-line-number="9">    <span class="kw">auto</span> r2 = i-- ;</a>
<a class="sourceLine" id="cb1134-10" data-line-number="10">}</a></code></pre></div>
<p>と書ける。この操作は前方イテレーターにはできない。</p>
<p>1個づつ移動できるのであれば、イテレーターをn個進めることもできそうなものだ。実際、双方向イテレーターを以下のようにしてn個進めることができる。</p>
<div class="sourceCode" id="cb1135"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1135-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> BidirectionalIterator &gt;</a>
<a class="sourceLine" id="cb1135-2" data-line-number="2">BidirectionalIterator</a>
<a class="sourceLine" id="cb1135-3" data-line-number="3">nth_next( BidirectionalIterator iter, <span class="bu">std::</span>size_t n )</a>
<a class="sourceLine" id="cb1135-4" data-line-number="4">{</a>
<a class="sourceLine" id="cb1135-5" data-line-number="5">    <span class="cf">for</span> ( <span class="bu">std::</span>size_t i = <span class="dv">0</span> ; i != n ; ++i )</a>
<a class="sourceLine" id="cb1135-6" data-line-number="6">        ++iter ;</a>
<a class="sourceLine" id="cb1135-7" data-line-number="7">    <span class="cf">return</span> iter ;</a>
<a class="sourceLine" id="cb1135-8" data-line-number="8">}</a></code></pre></div>
<p>たしかにこれはできる。できるが、効率的ではない。双方向イテレーターが提供される場合というのは、ランダムアクセスが技術的に可能ではあるが非効率的な場合だ。具体的なデータ構造を出すと、例えばリンクリストがある。リンクリストに対するランダムアクセスは技術的に可能であるが非効率的だ。</p>
<h3 id="前方イテレーター">前方イテレーター</h3>
<p>前方イテレーターは前方にしか移動できない。イテレーターが0番目の要素を指しているならば1番目、1番目の要素を指しているならば2番目に移動できる。</p>
<div class="sourceCode" id="cb1136"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1136-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> ForwardIterator &gt;</a>
<a class="sourceLine" id="cb1136-2" data-line-number="2"><span class="dt">void</span> f( ForwardIterator i )</a>
<a class="sourceLine" id="cb1136-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb1136-4" data-line-number="4">    ++i ;</a>
<a class="sourceLine" id="cb1136-5" data-line-number="5">}</a></code></pre></div>
<p>前方イテレーターにはマルチパス保証がある。イテレーターの指す要素を動かす前のイテレーターの値を保持しておき、保持した値を動かしたとき、ふたつのイテレーターは同一になるという保証だ。</p>
<div class="sourceCode" id="cb1137"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1137-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> ForwardIterator &gt;</a>
<a class="sourceLine" id="cb1137-2" data-line-number="2"><span class="dt">void</span> f( ForwardIterator i )</a>
<a class="sourceLine" id="cb1137-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb1137-4" data-line-number="4">    <span class="co">// 動かす前の値を保持</span></a>
<a class="sourceLine" id="cb1137-5" data-line-number="5">    <span class="kw">auto</span> prev = i ;</a>
<a class="sourceLine" id="cb1137-6" data-line-number="6">    <span class="co">// 次の要素を指す</span></a>
<a class="sourceLine" id="cb1137-7" data-line-number="7">    ++i ;</a>
<a class="sourceLine" id="cb1137-8" data-line-number="8">    <span class="co">// 動かす前の値も次の要素を指すようにする</span></a>
<a class="sourceLine" id="cb1137-9" data-line-number="9">    ++prev ;</a>
<a class="sourceLine" id="cb1137-10" data-line-number="10"></a>
<a class="sourceLine" id="cb1137-11" data-line-number="11">    <span class="co">// true</span></a>
<a class="sourceLine" id="cb1137-12" data-line-number="12">    <span class="dt">bool</span> b = ( i == prev ) ;</a>
<a class="sourceLine" id="cb1137-13" data-line-number="13"></a>
<a class="sourceLine" id="cb1137-14" data-line-number="14">    <span class="co">// r1, r2は同じ要素を指す</span></a>
<a class="sourceLine" id="cb1137-15" data-line-number="15">    <span class="kw">auto</span> &amp; r1 = *i ;</a>
<a class="sourceLine" id="cb1137-16" data-line-number="16">    <span class="kw">auto</span> &amp; r2 = *prev ;</a>
<a class="sourceLine" id="cb1137-17" data-line-number="17">}</a></code></pre></div>
<p>入力イテレーター、出力イテレーターにはこの保証がない。</p>
<h3 id="入力イテレーター">入力イテレーター</h3>
<p>入力イテレーターはイテレーターの比較、イテレーターの参照、イテレーターのインクリメントができる。</p>
<div class="sourceCode" id="cb1138"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1138-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> InputIterator &gt;</a>
<a class="sourceLine" id="cb1138-2" data-line-number="2"><span class="dt">void</span> f( InputIterator i, InputIterator j )</a>
<a class="sourceLine" id="cb1138-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb1138-4" data-line-number="4">    <span class="co">// 比較</span></a>
<a class="sourceLine" id="cb1138-5" data-line-number="5">    <span class="dt">bool</span> b1 = (i == j) ;</a>
<a class="sourceLine" id="cb1138-6" data-line-number="6">    <span class="dt">bool</span> b2 = (i != j) ;</a>
<a class="sourceLine" id="cb1138-7" data-line-number="7"></a>
<a class="sourceLine" id="cb1138-8" data-line-number="8">    <span class="co">// 参照</span></a>
<a class="sourceLine" id="cb1138-9" data-line-number="9">    *i ;</a>
<a class="sourceLine" id="cb1138-10" data-line-number="10">    <span class="co">// (*i).m と同じ</span></a>
<a class="sourceLine" id="cb1138-11" data-line-number="11">    i-&gt;m ;</a>
<a class="sourceLine" id="cb1138-12" data-line-number="12"></a>
<a class="sourceLine" id="cb1138-13" data-line-number="13">    <span class="co">// インクリメント</span></a>
<a class="sourceLine" id="cb1138-14" data-line-number="14">    ++i ;</a>
<a class="sourceLine" id="cb1138-15" data-line-number="15">    i++ ;</a>
<a class="sourceLine" id="cb1138-16" data-line-number="16">}</a></code></pre></div>
<p>入力イテレーターの参照は、読み込みことしか保証されていない。</p>
<div class="sourceCode" id="cb1139"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1139-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> InputIterator &gt;</a>
<a class="sourceLine" id="cb1139-2" data-line-number="2"><span class="dt">void</span> f( InputIterator i )</a>
<a class="sourceLine" id="cb1139-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb1139-4" data-line-number="4">    <span class="co">// OK</span></a>
<a class="sourceLine" id="cb1139-5" data-line-number="5">    <span class="kw">auto</span> value = *i ;</a>
<a class="sourceLine" id="cb1139-6" data-line-number="6">    <span class="co">// エラー</span></a>
<a class="sourceLine" id="cb1139-7" data-line-number="7">    *i = value ;</a>
<a class="sourceLine" id="cb1139-8" data-line-number="8">}</a></code></pre></div>
<p>書き込みは出力イテレーターの仕事だ。</p>
<h3 id="出力イテレーター">出力イテレーター</h3>
<p>出力イテレーターはイテレーターのインクリメントと、イテレーターの参照への代入ができる。</p>
<div class="sourceCode" id="cb1140"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1140-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> OutputIterator &gt;</a>
<a class="sourceLine" id="cb1140-2" data-line-number="2"><span class="dt">void</span> f( OutputIterator i, <span class="kw">typename</span> OutputIterator::<span class="dt">value_type</span> v )</a>
<a class="sourceLine" id="cb1140-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb1140-4" data-line-number="4">    <span class="co">// 参照への代入</span></a>
<a class="sourceLine" id="cb1140-5" data-line-number="5">    *i = v ;</a>
<a class="sourceLine" id="cb1140-6" data-line-number="6"></a>
<a class="sourceLine" id="cb1140-7" data-line-number="7">    <span class="co">// インクリメント</span></a>
<a class="sourceLine" id="cb1140-8" data-line-number="8">    ++i ;</a>
<a class="sourceLine" id="cb1140-9" data-line-number="9">    i++ ;</a>
<a class="sourceLine" id="cb1140-10" data-line-number="10">}</a></code></pre></div>
<p>出力イテレーターを参照した結果は定められていない。<code>void</code>かもしれない。したがって出力イテレーターの値を読むのは意味がない。</p>
<div class="sourceCode" id="cb1141"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1141-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> OutputIterator &gt;</a>
<a class="sourceLine" id="cb1141-2" data-line-number="2"><span class="dt">void</span> f( OutputIterator i )</a>
<a class="sourceLine" id="cb1141-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb1141-4" data-line-number="4">    <span class="co">// 意味がない。</span></a>
<a class="sourceLine" id="cb1141-5" data-line-number="5">    <span class="kw">auto</span> value = *i ;</a>
<a class="sourceLine" id="cb1141-6" data-line-number="6">}</a></code></pre></div>
<h2 id="iterator_traits">iterator_traits</h2>
<p>イテレーターカテゴリーやイテレーターの参照する値を見分けるためのライブラリとして、<code>iterator_traits&lt;T&gt;</code>がある。これは以下のようになっている。</p>
<div class="sourceCode" id="cb1142"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1142-1" data-line-number="1"><span class="kw">namespace</span> std {</a>
<a class="sourceLine" id="cb1142-2" data-line-number="2"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;</a>
<a class="sourceLine" id="cb1142-3" data-line-number="3"><span class="kw">struct</span> iterator</a>
<a class="sourceLine" id="cb1142-4" data-line-number="4">{</a>
<a class="sourceLine" id="cb1142-5" data-line-number="5">    <span class="kw">using</span> <span class="dt">difference_type</span> = ... ;</a>
<a class="sourceLine" id="cb1142-6" data-line-number="6">    <span class="kw">using</span> <span class="dt">value_type</span> = ... ;</a>
<a class="sourceLine" id="cb1142-7" data-line-number="7">    <span class="kw">using</span> pointer = ... ;</a>
<a class="sourceLine" id="cb1142-8" data-line-number="8">    <span class="kw">using</span> reference = ... ;</a>
<a class="sourceLine" id="cb1142-9" data-line-number="9">    <span class="kw">using</span> iterator_category = ... ;</a>
<a class="sourceLine" id="cb1142-10" data-line-number="10"></a>
<a class="sourceLine" id="cb1142-11" data-line-number="11">} ;</a>
<a class="sourceLine" id="cb1142-12" data-line-number="12"></a>
<a class="sourceLine" id="cb1142-13" data-line-number="13">}</a></code></pre></div>
<p><code>difference_type</code>はイテレーター同士の距離を指す数値だ。</p>
<div class="sourceCode" id="cb1143"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1143-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> Iterator &gt;</a>
<a class="sourceLine" id="cb1143-2" data-line-number="2"><span class="dt">void</span> f( Iterator i, Iterator j )</a>
<a class="sourceLine" id="cb1143-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb1143-4" data-line-number="4">    <span class="co">// イテレーター同士の距離</span></a>
<a class="sourceLine" id="cb1143-5" data-line-number="5">    <span class="kw">typename</span> <span class="bu">std::</span>iterator_traits&lt;Iterator&gt;::<span class="dt">difference_type</span> diff = j - i ;</a>
<a class="sourceLine" id="cb1143-6" data-line-number="6">}</a></code></pre></div>
<p><code>value_type</code>はイテレーターの参照する値の型、<code>pointer</code>はそのポインター型、<code>reference</code>はそのリファレンス型だ。</p>
<div class="sourceCode" id="cb1144"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1144-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> Iterator &gt;</a>
<a class="sourceLine" id="cb1144-2" data-line-number="2"><span class="dt">void</span> f( Iterator i )</a>
<a class="sourceLine" id="cb1144-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb1144-4" data-line-number="4">    <span class="co">// 値型</span></a>
<a class="sourceLine" id="cb1144-5" data-line-number="5">    <span class="kw">typename</span> <span class="bu">std::</span>iterator_traits&lt;Iterator&gt;::<span class="dt">value_type</span> v = *i ;</a>
<a class="sourceLine" id="cb1144-6" data-line-number="6">    <span class="co">// ポインター型 </span></a>
<a class="sourceLine" id="cb1144-7" data-line-number="7">    <span class="kw">typename</span> <span class="bu">std::</span>iterator_traits&lt;Iterator&gt;::pointer p = &amp;v ;</a>
<a class="sourceLine" id="cb1144-8" data-line-number="8">    <span class="co">// リファレンス型</span></a>
<a class="sourceLine" id="cb1144-9" data-line-number="9">    <span class="kw">typename</span> <span class="bu">std::</span>iterator_traits&lt;Iterator&gt;::reference r = v ;</a>
<a class="sourceLine" id="cb1144-10" data-line-number="10">}</a></code></pre></div>
<p><code>iterator_category</code>はイテレーターカテゴリーを示す型で、以下のようになっている。</p>
<div class="sourceCode" id="cb1145"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1145-1" data-line-number="1"><span class="kw">namespace</span> std {</a>
<a class="sourceLine" id="cb1145-2" data-line-number="2"><span class="kw">struct</span> input_iterator_tag { };</a>
<a class="sourceLine" id="cb1145-3" data-line-number="3"><span class="kw">struct</span> output_iterator_tag { };</a>
<a class="sourceLine" id="cb1145-4" data-line-number="4"><span class="kw">struct</span> forward_iterator_tag: <span class="kw">public</span> input_iterator_tag { };</a>
<a class="sourceLine" id="cb1145-5" data-line-number="5"><span class="kw">struct</span> bidirectional_iterator_tag: <span class="kw">public</span> forward_iterator_tag { };</a>
<a class="sourceLine" id="cb1145-6" data-line-number="6"><span class="kw">struct</span> random_access_iterator_tag: <span class="kw">public</span> bidirectional_iterator_tag { };</a>
<a class="sourceLine" id="cb1145-7" data-line-number="7">}</a></code></pre></div>
<p><code>forward_iterator_tag</code>以降のコロン文字の後に続くコードについては、今は気にしなくてもよい。これは派生というまだ説明していないクラスの機能だ。</p>
<p>あるイテレーターがあるイテレーターカテゴリーを満たすかどうかを調べるには以下のようにする。</p>
<div class="sourceCode" id="cb1146"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1146-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> tag, <span class="kw">typename</span> Iterator &gt;</a>
<a class="sourceLine" id="cb1146-2" data-line-number="2"><span class="kw">constexpr</span> <span class="dt">bool</span> is_category_of( )</a>
<a class="sourceLine" id="cb1146-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb1146-4" data-line-number="4">    <span class="kw">using</span> iter_tag = <span class="kw">typename</span> <span class="bu">std::</span>iterator_traits&lt;Iterator&gt;::iterator_category ;</a>
<a class="sourceLine" id="cb1146-5" data-line-number="5">    <span class="cf">return</span> <span class="bu">std::</span>is_base_of_v&lt; tag, iter_tag&gt; ;</a>
<a class="sourceLine" id="cb1146-6" data-line-number="6">}</a>
<a class="sourceLine" id="cb1146-7" data-line-number="7"></a>
<a class="sourceLine" id="cb1146-8" data-line-number="8"></a>
<a class="sourceLine" id="cb1146-9" data-line-number="9"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1146-10" data-line-number="10">{</a>
<a class="sourceLine" id="cb1146-11" data-line-number="11">    <span class="kw">using</span> iterator = <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt;::iterator ;</a>
<a class="sourceLine" id="cb1146-12" data-line-number="12">    <span class="dt">bool</span> b = is_category_of&lt; <span class="bu">std::</span>forward_iterator_tag, iterator &gt;() ;</a>
<a class="sourceLine" id="cb1146-13" data-line-number="13">    <span class="co">// vecotrのイテレーターはランダムアクセスイテレーターなので前方イテレーターでもある</span></a>
<a class="sourceLine" id="cb1146-14" data-line-number="14">    <span class="bu">std::</span>cout &lt;&lt; b ;</a>
<a class="sourceLine" id="cb1146-15" data-line-number="15">}</a></code></pre></div>
<p>このコードはまだ学んでいないC++の機能をふんだんに使っているので、現時点で理解するのは難しい。</p>
<h2 id="イテレーターカテゴリーの実例">イテレーターカテゴリーの実例</h2>
<p>イテレーターカテゴリーについて学んだので、イテレーターカテゴリーの実例について見ていこう。</p>
<h3 id="出力イテレーター-1">出力イテレーター</h3>
<p>前方イテレーター以上のイテレーターカテゴリーを満たすイテレーターはすべて、出力イテレーターとして使える。例えばstd::arrayの内容をstd::vectorにコピーしたければ以下のように書ける。</p>
<div class="sourceCode" id="cb1147"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1147-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1147-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1147-3" data-line-number="3">    <span class="bu">std::</span>array&lt;<span class="dt">int</span>, <span class="dv">5</span>&gt; a = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</a>
<a class="sourceLine" id="cb1147-4" data-line-number="4">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v(<span class="dv">5</span>) ;</a>
<a class="sourceLine" id="cb1147-5" data-line-number="5"></a>
<a class="sourceLine" id="cb1147-6" data-line-number="6">    <span class="bu">std::</span>copy( <span class="bu">std::</span>begin(a), <span class="bu">std::</span>end(a), <span class="bu">std::</span>begin(v) ) ;</a>
<a class="sourceLine" id="cb1147-7" data-line-number="7">}</a></code></pre></div>
<p>std::vectorのイテレーターは出力イテレーターとして振る舞う。</p>
<p>出力イテレーターの要件しか満たさないイテレーターは、例えば以下のようなものだ。</p>
<div class="sourceCode" id="cb1148"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1148-1" data-line-number="1"><span class="kw">struct</span> cout_iterator</a>
<a class="sourceLine" id="cb1148-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1148-3" data-line-number="3"><span class="co">// --- ボイラープレートコード</span></a>
<a class="sourceLine" id="cb1148-4" data-line-number="4">    <span class="co">// 出力イテレーターでは使わないのでvoidでいい</span></a>
<a class="sourceLine" id="cb1148-5" data-line-number="5">    <span class="kw">using</span> <span class="dt">difference_type</span> = <span class="dt">void</span> ;</a>
<a class="sourceLine" id="cb1148-6" data-line-number="6">    <span class="kw">using</span> <span class="dt">value_type</span> = <span class="dt">void</span> ;</a>
<a class="sourceLine" id="cb1148-7" data-line-number="7">    <span class="kw">using</span> reference = <span class="dt">void</span> ;</a>
<a class="sourceLine" id="cb1148-8" data-line-number="8">    <span class="kw">using</span> pointer = <span class="dt">void</span> ;</a>
<a class="sourceLine" id="cb1148-9" data-line-number="9">    <span class="co">// イテレーターカテゴリーは出力イテレーター</span></a>
<a class="sourceLine" id="cb1148-10" data-line-number="10">    <span class="kw">using</span> iterator_category = <span class="bu">std::</span>output_iterator_tag ;</a>
<a class="sourceLine" id="cb1148-11" data-line-number="11">    <span class="co">// 何もしない</span></a>
<a class="sourceLine" id="cb1148-12" data-line-number="12">    <span class="co">// 自分自身を返すだけ</span></a>
<a class="sourceLine" id="cb1148-13" data-line-number="13">    cout_iterator &amp; <span class="kw">operator</span> *() { <span class="cf">return</span> *<span class="kw">this</span> ; }</a>
<a class="sourceLine" id="cb1148-14" data-line-number="14">    cout_iterator &amp; <span class="kw">operator</span> ++() { <span class="cf">return</span> *<span class="kw">this</span> ; }</a>
<a class="sourceLine" id="cb1148-15" data-line-number="15">    cout_iterator &amp; <span class="kw">operator</span> ++(<span class="dt">int</span>) { <span class="cf">return</span> *<span class="kw">this</span> ; }</a>
<a class="sourceLine" id="cb1148-16" data-line-number="16"><span class="co">// --- ボイラープレートコード</span></a>
<a class="sourceLine" id="cb1148-17" data-line-number="17"></a>
<a class="sourceLine" id="cb1148-18" data-line-number="18">    <span class="co">// ここが肝心</span></a>
<a class="sourceLine" id="cb1148-19" data-line-number="19">    <span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;</a>
<a class="sourceLine" id="cb1148-20" data-line-number="20">    cout_iterator &amp; <span class="kw">operator</span> =( T <span class="at">const</span> &amp; x )</a>
<a class="sourceLine" id="cb1148-21" data-line-number="21">    {</a>
<a class="sourceLine" id="cb1148-22" data-line-number="22">        <span class="bu">std::</span>cout &lt;&lt; x ;</a>
<a class="sourceLine" id="cb1148-23" data-line-number="23">        <span class="cf">return</span> *<span class="kw">this</span> ;</a>
<a class="sourceLine" id="cb1148-24" data-line-number="24">    }</a>
<a class="sourceLine" id="cb1148-25" data-line-number="25">} ;</a>
<a class="sourceLine" id="cb1148-26" data-line-number="26"></a>
<a class="sourceLine" id="cb1148-27" data-line-number="27"></a>
<a class="sourceLine" id="cb1148-28" data-line-number="28"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1148-29" data-line-number="29">{</a>
<a class="sourceLine" id="cb1148-30" data-line-number="30">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</a>
<a class="sourceLine" id="cb1148-31" data-line-number="31">    cout_iterator out ;</a>
<a class="sourceLine" id="cb1148-32" data-line-number="32"></a>
<a class="sourceLine" id="cb1148-33" data-line-number="33">    <span class="bu">std::</span>copy( <span class="bu">std::</span>begin(v), <span class="bu">std::</span>end(v), out ) ;</a>
<a class="sourceLine" id="cb1148-34" data-line-number="34">}</a></code></pre></div>
<p><code>cout_iterator</code>は<code>*i = x;</code>と書いたときに、値xを<code>std::cout</code>で出力する。</p>
<p>cout_iteratorは出力イテレーターの要件を満たすので<code>std::copy</code>に渡せる。<code>std::copy</code>はイテレーターを順番に<code>*out = *i ;</code>のように実行するので、結果として値が全て<code>std::cout</code>で出力される。</p>
<p><code>cout_iterator</code>はとても便利なので、標準ライブラリには<code>std::ostream_iterator&lt;T&gt;</code>がある。</p>
<div class="sourceCode" id="cb1149"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1149-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1149-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1149-3" data-line-number="3">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</a>
<a class="sourceLine" id="cb1149-4" data-line-number="4">    <span class="bu">std::</span>ostream_iterator&lt;<span class="dt">int</span>&gt; out(<span class="bu">std::</span>cout) ;</a>
<a class="sourceLine" id="cb1149-5" data-line-number="5">    <span class="bu">std::</span>copy( <span class="bu">std::</span>begin(v), <span class="bu">std::</span>end(v), out ) ;</a>
<a class="sourceLine" id="cb1149-6" data-line-number="6">}</a></code></pre></div>
<p><code>ostream_iterator</code>は出力ストリーム(ostream)に対するイテレーターだ。コンストラクターに出力先の出力ストリームを渡すことで値を出力先に出力してくれる。今回は<code>std::cout</code>だ。</p>
<p>上のような出力イテレーターが<code>operator =</code>で以下のようなことをしていたらどうだろう。</p>
<div class="sourceCode" id="cb1150"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1150-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> Container &gt;</a>
<a class="sourceLine" id="cb1150-2" data-line-number="2"><span class="kw">struct</span> back_inserter ;</a>
<a class="sourceLine" id="cb1150-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb1150-4" data-line-number="4">    back_inserter( Container &amp; c )</a>
<a class="sourceLine" id="cb1150-5" data-line-number="5">        : c(c) { }</a>
<a class="sourceLine" id="cb1150-6" data-line-number="6"></a>
<a class="sourceLine" id="cb1150-7" data-line-number="7">    <span class="co">// その他のボイラープレートコード</span></a>
<a class="sourceLine" id="cb1150-8" data-line-number="8"></a>
<a class="sourceLine" id="cb1150-9" data-line-number="9">    </a>
<a class="sourceLine" id="cb1150-10" data-line-number="10">    back_inserter &amp; <span class="kw">operator</span> =( <span class="at">const</span> <span class="kw">typename</span> Container::<span class="dt">value_type</span> &amp; value )</a>
<a class="sourceLine" id="cb1150-11" data-line-number="11">    {</a>
<a class="sourceLine" id="cb1150-12" data-line-number="12">        c.push_back(value) ;</a>
<a class="sourceLine" id="cb1150-13" data-line-number="13">    }</a>
<a class="sourceLine" id="cb1150-14" data-line-number="14"></a>
<a class="sourceLine" id="cb1150-15" data-line-number="15">    Container &amp; c ;</a>
<a class="sourceLine" id="cb1150-16" data-line-number="16">} ;</a>
<a class="sourceLine" id="cb1150-17" data-line-number="17"></a>
<a class="sourceLine" id="cb1150-18" data-line-number="18"><span class="kw">template</span> &lt; <span class="kw">typename</span> Container &gt;</a>
<a class="sourceLine" id="cb1150-19" data-line-number="19"><span class="dt">void</span> f( Container <span class="at">const</span> &amp; c )</a>
<a class="sourceLine" id="cb1150-20" data-line-number="20">{</a>
<a class="sourceLine" id="cb1150-21" data-line-number="21">    <span class="co">// cの全要素をコピーしたい</span></a>
<a class="sourceLine" id="cb1150-22" data-line-number="22">    std:vector&lt; <span class="kw">typename</span> Container::<span class="dt">value_type</span> &gt; temp ;</a>
<a class="sourceLine" id="cb1150-23" data-line-number="23">    <span class="kw">auto</span> out = back_inserter(temp) ;</a>
<a class="sourceLine" id="cb1150-24" data-line-number="24">    <span class="bu">std::</span>copy( <span class="bu">std::</span>begin(c), <span class="bu">std::</span>end(c), out ) ;</a>
<a class="sourceLine" id="cb1150-25" data-line-number="25">}</a></code></pre></div>
<p>このコードが何をするかわかるだろうか。コンテナー<code>c</code>の全要素を出力イテレーターで出力する。出力イテレーターは渡された値valueを<code>temp.push_back(value) ;</code>する。その結果、<code>temp</code>は<code>c</code>のすべての要素を保持していることになる。</p>
<p>C++の標準ライブラリには<code>std::back_inserter</code>がある。</p>
<div class="sourceCode" id="cb1151"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1151-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1151-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1151-3" data-line-number="3">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</a>
<a class="sourceLine" id="cb1151-4" data-line-number="4">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; temp ;</a>
<a class="sourceLine" id="cb1151-5" data-line-number="5">    <span class="kw">auto</span> out = <span class="bu">std::</span>back_inserter(temp) ;</a>
<a class="sourceLine" id="cb1151-6" data-line-number="6"></a>
<a class="sourceLine" id="cb1151-7" data-line-number="7">    <span class="bu">std::</span>copy( <span class="bu">std::</span>begin(v), <span class="bu">std::</span>end(v), out ) ;</a>
<a class="sourceLine" id="cb1151-8" data-line-number="8">}</a></code></pre></div>
<p><code>std::back_inserter(c)</code>はコンテナー<code>c</code>に出力イテレーターとして渡された値を<code>puch_back</code>する。</p>
<p>ただし、<code>std::back_inserter</code>は古いライブラリなので、ここで示した方法とは少し違う実装がされている。</p>
<div class="sourceCode" id="cb1152"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1152-1" data-line-number="1"><span class="co">// 出力イテレーター</span></a>
<a class="sourceLine" id="cb1152-2" data-line-number="2"><span class="kw">template</span> &lt; <span class="kw">typename</span> Container &gt;</a>
<a class="sourceLine" id="cb1152-3" data-line-number="3"><span class="kw">struct</span> back_insert_iterator</a>
<a class="sourceLine" id="cb1152-4" data-line-number="4">{</a>
<a class="sourceLine" id="cb1152-5" data-line-number="5">    back_insert_iterator( Container &amp; c )</a>
<a class="sourceLine" id="cb1152-6" data-line-number="6">        : c(&amp;c) { }</a>
<a class="sourceLine" id="cb1152-7" data-line-number="7">    Container * c ;</a>
<a class="sourceLine" id="cb1152-8" data-line-number="8"></a>
<a class="sourceLine" id="cb1152-9" data-line-number="9">    <span class="co">// その他のコード</span></a>
<a class="sourceLine" id="cb1152-10" data-line-number="10">} ;</a>
<a class="sourceLine" id="cb1152-11" data-line-number="11"></a>
<a class="sourceLine" id="cb1152-12" data-line-number="12"><span class="co">// 出力イテレーターを返す関数</span></a>
<a class="sourceLine" id="cb1152-13" data-line-number="13"><span class="kw">template</span> &lt; <span class="kw">typename</span> Container &gt;</a>
<a class="sourceLine" id="cb1152-14" data-line-number="14">back_insert_iterator&lt;Container&gt; back_inserter( Container &amp; c )</a>
<a class="sourceLine" id="cb1152-15" data-line-number="15">{</a>
<a class="sourceLine" id="cb1152-16" data-line-number="16">    <span class="cf">return</span> back_insert_iterator&lt;Container&gt;(c) ;</a>
<a class="sourceLine" id="cb1152-17" data-line-number="17">}</a></code></pre></div>
<p>この理由は、C++17以前のC++ではクラスのコンストラクターからテンプレート実引数の推定ができなかったためだ。</p>
<div class="sourceCode" id="cb1153"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1153-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;</a>
<a class="sourceLine" id="cb1153-2" data-line-number="2"><span class="dt">void</span> f( T ) { }</a>
<a class="sourceLine" id="cb1153-3" data-line-number="3"></a>
<a class="sourceLine" id="cb1153-4" data-line-number="4"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;</a>
<a class="sourceLine" id="cb1153-5" data-line-number="5"><span class="kw">struct</span> S</a>
<a class="sourceLine" id="cb1153-6" data-line-number="6">{</a>
<a class="sourceLine" id="cb1153-7" data-line-number="7">    S( T ) { }</a>
<a class="sourceLine" id="cb1153-8" data-line-number="8">} ;</a>
<a class="sourceLine" id="cb1153-9" data-line-number="9"></a>
<a class="sourceLine" id="cb1153-10" data-line-number="10"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1153-11" data-line-number="11">{</a>
<a class="sourceLine" id="cb1153-12" data-line-number="12">    <span class="co">// f&lt;int&gt;と推定</span></a>
<a class="sourceLine" id="cb1153-13" data-line-number="13">    f(<span class="dv">0</span>) ;</a>
<a class="sourceLine" id="cb1153-14" data-line-number="14"></a>
<a class="sourceLine" id="cb1153-15" data-line-number="15">    <span class="co">// S&lt;int&gt;と推定</span></a>
<a class="sourceLine" id="cb1153-16" data-line-number="16">    S s(<span class="dv">0</span>) ;</a>
<a class="sourceLine" id="cb1153-17" data-line-number="17">}</a></code></pre></div>
<p>C++17以前のC++では関数の実引数からテンプレート仮引数<code>T</code>の型を推定することはできたが、クラスのコンストラクターから推定することはできなかった。C++17以降は可能だ。</p>
<p><code>std::cout</code>に出力したり、コンテナーに<code>push_back</code>する実装のイテレーターは、マルチパス保証を満たさない。実装を見ればわかるように、イテレーターをコピーして別々にインクリメントした結果のイテレーターのオブジェクトに対する操作は同一ではないからだ。</p>
<h3 id="入力イテレーター-1">入力イテレーター</h3>
<p>入力イテレーターの実例はどうか。</p>
<p><code>std::cin</code>からT型を読み込む入力イテレーターの実装は以下のようになる。</p>
<div class="sourceCode" id="cb1154"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1154-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;</a>
<a class="sourceLine" id="cb1154-2" data-line-number="2"><span class="kw">struct</span> cin_iterator</a>
<a class="sourceLine" id="cb1154-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb1154-4" data-line-number="4"><span class="co">// --- ボイラープレートコード</span></a>
<a class="sourceLine" id="cb1154-5" data-line-number="5">    <span class="kw">using</span> <span class="dt">difference_type</span> = <span class="bu">std::</span>ptrdiff_t ;</a>
<a class="sourceLine" id="cb1154-6" data-line-number="6">    <span class="kw">using</span> <span class="dt">value_type</span> = T ;</a>
<a class="sourceLine" id="cb1154-7" data-line-number="7">    <span class="kw">using</span> reference = T &amp; ;</a>
<a class="sourceLine" id="cb1154-8" data-line-number="8">    <span class="kw">using</span> pointer = T * ;</a>
<a class="sourceLine" id="cb1154-9" data-line-number="9">    <span class="co">// イテレーターカテゴリーは入力イテレーター</span></a>
<a class="sourceLine" id="cb1154-10" data-line-number="10">    <span class="kw">using</span> iterator_category = <span class="bu">std::</span>input_iterator_tag ;</a>
<a class="sourceLine" id="cb1154-11" data-line-number="11"><span class="co">// --- ボイラープレートコード</span></a>
<a class="sourceLine" id="cb1154-12" data-line-number="12"></a>
<a class="sourceLine" id="cb1154-13" data-line-number="13">    <span class="co">// コンストラクター</span></a>
<a class="sourceLine" id="cb1154-14" data-line-number="14">    cin_iterator( <span class="dt">bool</span> fail = <span class="kw">false</span> )</a>
<a class="sourceLine" id="cb1154-15" data-line-number="15">        : fail(fail)</a>
<a class="sourceLine" id="cb1154-16" data-line-number="16">    { ++*<span class="kw">this</span> ; }    </a>
<a class="sourceLine" id="cb1154-17" data-line-number="17"></a>
<a class="sourceLine" id="cb1154-18" data-line-number="18">    <span class="co">// キャッシュした値を返す</span></a>
<a class="sourceLine" id="cb1154-19" data-line-number="19">    <span class="at">const</span> reference <span class="kw">operator</span> *() <span class="at">const</span></a>
<a class="sourceLine" id="cb1154-20" data-line-number="20">    { <span class="cf">return</span> value ; }</a>
<a class="sourceLine" id="cb1154-21" data-line-number="21"></a>
<a class="sourceLine" id="cb1154-22" data-line-number="22">    <span class="co">// 新しい値をキャッシュする</span></a>
<a class="sourceLine" id="cb1154-23" data-line-number="23">    cin_iterator &amp; <span class="kw">operator</span> ++()</a>
<a class="sourceLine" id="cb1154-24" data-line-number="24">    {</a>
<a class="sourceLine" id="cb1154-25" data-line-number="25">        <span class="cf">if</span> ( !fail )</a>
<a class="sourceLine" id="cb1154-26" data-line-number="26">        {</a>
<a class="sourceLine" id="cb1154-27" data-line-number="27">            <span class="bu">std::</span>cin &gt;&gt; value ;</a>
<a class="sourceLine" id="cb1154-28" data-line-number="28">            fail = <span class="bu">std::</span>cin.fail() ;</a>
<a class="sourceLine" id="cb1154-29" data-line-number="29">        }</a>
<a class="sourceLine" id="cb1154-30" data-line-number="30">        <span class="cf">return</span> *<span class="kw">this</span> ;</a>
<a class="sourceLine" id="cb1154-31" data-line-number="31">    }</a>
<a class="sourceLine" id="cb1154-32" data-line-number="32"></a>
<a class="sourceLine" id="cb1154-33" data-line-number="33">    <span class="co">// 後置インクリメント</span></a>
<a class="sourceLine" id="cb1154-34" data-line-number="34">    cin_iterator <span class="kw">operator</span> ++(<span class="dt">int</span>)</a>
<a class="sourceLine" id="cb1154-35" data-line-number="35">    {</a>
<a class="sourceLine" id="cb1154-36" data-line-number="36">        <span class="kw">auto</span> old = *<span class="kw">this</span> ;</a>
<a class="sourceLine" id="cb1154-37" data-line-number="37">        ++*<span class="kw">this</span> ;</a>
<a class="sourceLine" id="cb1154-38" data-line-number="38">        <span class="cf">return</span> old ;</a>
<a class="sourceLine" id="cb1154-39" data-line-number="39">    }</a>
<a class="sourceLine" id="cb1154-40" data-line-number="40"></a>
<a class="sourceLine" id="cb1154-41" data-line-number="41">    <span class="co">// イテレーターの等価比較の状態</span></a>
<a class="sourceLine" id="cb1154-42" data-line-number="42">    <span class="dt">bool</span> fail ;</a>
<a class="sourceLine" id="cb1154-43" data-line-number="43">    <span class="co">// 値のキャッシュ</span></a>
<a class="sourceLine" id="cb1154-44" data-line-number="44">    <span class="dt">value_type</span> value ;</a>
<a class="sourceLine" id="cb1154-45" data-line-number="45">} ;</a>
<a class="sourceLine" id="cb1154-46" data-line-number="46"></a>
<a class="sourceLine" id="cb1154-47" data-line-number="47"><span class="co">// 比較演算子</span></a>
<a class="sourceLine" id="cb1154-48" data-line-number="48"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;</a>
<a class="sourceLine" id="cb1154-49" data-line-number="49"><span class="dt">bool</span> <span class="kw">operator</span> ==( cin_iterator&lt;T&gt; <span class="at">const</span> &amp; l, cin_iterator&lt;T&gt; <span class="at">const</span> &amp; r )</a>
<a class="sourceLine" id="cb1154-50" data-line-number="50">{ <span class="cf">return</span> l.fail == r.fail ; }</a>
<a class="sourceLine" id="cb1154-51" data-line-number="51"></a>
<a class="sourceLine" id="cb1154-52" data-line-number="52"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;</a>
<a class="sourceLine" id="cb1154-53" data-line-number="53"><span class="dt">bool</span> <span class="kw">operator</span> !=( cin_iterator&lt;T&gt; <span class="at">const</span> &amp; l, cin_iterator&lt;T&gt; <span class="at">const</span> &amp; r )</a>
<a class="sourceLine" id="cb1154-54" data-line-number="54">{ <span class="cf">return</span> !(l == r) ; }</a></code></pre></div>
<p>以下のように使える。</p>
<div class="sourceCode" id="cb1155"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1155-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1155-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1155-3" data-line-number="3">    cin_iterator&lt;<span class="dt">int</span>&gt; input, fail(<span class="kw">true</span>) ;</a>
<a class="sourceLine" id="cb1155-4" data-line-number="4">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; buffer ;</a>
<a class="sourceLine" id="cb1155-5" data-line-number="5"></a>
<a class="sourceLine" id="cb1155-6" data-line-number="6">    <span class="bu">std::</span>copy( input, fail, <span class="bu">std::</span>back_inserter(buffer) ) ;</a>
<a class="sourceLine" id="cb1155-7" data-line-number="7">}</a></code></pre></div>
<p>実装としては、まずボイラープレートコード</p>
<div class="sourceCode" id="cb1156"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1156-1" data-line-number="1"><span class="kw">using</span> <span class="dt">difference_type</span> = <span class="bu">std::</span>ptrdiff_t ;</a>
<a class="sourceLine" id="cb1156-2" data-line-number="2"><span class="kw">using</span> <span class="dt">value_type</span> = T ;</a>
<a class="sourceLine" id="cb1156-3" data-line-number="3"><span class="kw">using</span> reference = T &amp; ;</a>
<a class="sourceLine" id="cb1156-4" data-line-number="4"><span class="kw">using</span> pointer = T * ;</a>
<a class="sourceLine" id="cb1156-5" data-line-number="5"><span class="co">// イテレーターカテゴリーは入力イテレーター</span></a>
<a class="sourceLine" id="cb1156-6" data-line-number="6"><span class="kw">using</span> iterator_category = <span class="bu">std::</span>input_iterator_tag ;</a></code></pre></div>
<p><code>difference_type</code>はイテレーターの距離を表現する型で、通常は<code>std::ptrdiff_t</code>という型が使われる。これはポインターの距離を表現する型だ。</p>
<p><code>value_type</code>は参照している要素の型、<code>reference</code>と<code>pointer</code>は要素に対するリファレンスとポインターだ。</p>
<p><code>iterator_category</code>は今回は入力イテレーターなので<code>std::input_iterator_tag</code>になる。</p>
<p>データメンバーが2つ。</p>
<div class="sourceCode" id="cb1157"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1157-1" data-line-number="1"><span class="dt">bool</span> fail ;</a>
<a class="sourceLine" id="cb1157-2" data-line-number="2"><span class="dt">value_type</span> value ;</a></code></pre></div>
<p><code>fail</code>は<code>std::cin</code>が失敗状態のときに<code>true</code>になる。通常は<code>false</code>だ。<code>std::cin</code>が失敗状態かどうかは、メンバー関数<code>fail</code>で確かめることができる。</p>
<div class="sourceCode" id="cb1158"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1158-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1158-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1158-3" data-line-number="3">    <span class="dt">bool</span> b = <span class="bu">std::</span>cin.fail() ;</a>
<a class="sourceLine" id="cb1158-4" data-line-number="4">}</a></code></pre></div>
<p><code>std:cin</code>が失敗状態になる理由はいくつかあるが、EOFが入力された場合や、指定した型の値を読み込めなかった場合、例えばint型を読み込むのに入力が“abcd”のような文字列だった場合に<code>true</code>になる。</p>
<p><code>value</code>は<code>std::cin</code>から読み込んだ値だ。</p>
<p>イテレーターから値を読み込むのは<code>operator *</code>の仕事だ。これは単にvalueを返す。</p>
<div class="sourceCode" id="cb1159"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1159-1" data-line-number="1"><span class="at">const</span> reference <span class="kw">operator</span> *() <span class="at">const</span></a>
<a class="sourceLine" id="cb1159-2" data-line-number="2">{ <span class="cf">return</span> value ; }</a></code></pre></div>
<p>入力イテレーターでは値の読み込みのみをサポートしている。書き込みはサポートしない。イテレーターiに対して<code>*i</code>は書けるが、<code>*i = x</code>とは書けない。</p>
<p>実際に<code>std::cin</code>から値を読み込むのは<code>operator ++</code>で行われる。</p>
<div class="sourceCode" id="cb1160"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1160-1" data-line-number="1">cin_iterator &amp; <span class="kw">operator</span> ++()</a>
<a class="sourceLine" id="cb1160-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1160-3" data-line-number="3">    <span class="co">// 失敗状態でなければ</span></a>
<a class="sourceLine" id="cb1160-4" data-line-number="4">    <span class="cf">if</span> ( !fail )</a>
<a class="sourceLine" id="cb1160-5" data-line-number="5">    {</a>
<a class="sourceLine" id="cb1160-6" data-line-number="6">        <span class="co">// 値を読み込む</span></a>
<a class="sourceLine" id="cb1160-7" data-line-number="7">        <span class="bu">std::</span>cin &gt;&gt; value ;</a>
<a class="sourceLine" id="cb1160-8" data-line-number="8">        <span class="co">// 失敗状態かどうかも調べる</span></a>
<a class="sourceLine" id="cb1160-9" data-line-number="9">        fail = <span class="bu">std::</span>cin.fail() ;</a>
<a class="sourceLine" id="cb1160-10" data-line-number="10">    }</a>
<a class="sourceLine" id="cb1160-11" data-line-number="11">    <span class="cf">return</span> *<span class="kw">this</span> ;</a>
<a class="sourceLine" id="cb1160-12" data-line-number="12">}</a></code></pre></div>
<p>まず<code>std::cin</code>が失敗状態でないかどうかを確認する。失敗状態となった<code>std::cin</code>からは読み込めないからだ。失敗状態でなければ値を読み込み、失敗状態かどうかを確認する。結果の値は<code>value</code>に、失敗状態かどうかは<code>fail</code>に保持される。</p>
<p>後置インクリメントは前置インクリメントを呼び出すだけの汎用的な実装だ。</p>
<div class="sourceCode" id="cb1161"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1161-1" data-line-number="1">cin_iterator <span class="kw">operator</span> ++(<span class="dt">int</span>)</a>
<a class="sourceLine" id="cb1161-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1161-3" data-line-number="3">    <span class="co">// 元の値をコピーし</span></a>
<a class="sourceLine" id="cb1161-4" data-line-number="4">    <span class="kw">auto</span> old = *<span class="kw">this</span> ;</a>
<a class="sourceLine" id="cb1161-5" data-line-number="5">    <span class="co">// 次の値を読み込み</span></a>
<a class="sourceLine" id="cb1161-6" data-line-number="6">    ++*<span class="kw">this</span> ;</a>
<a class="sourceLine" id="cb1161-7" data-line-number="7">    <span class="co">// 元の値を返す</span></a>
<a class="sourceLine" id="cb1161-8" data-line-number="8">    <span class="cf">return</span> old ;</a>
<a class="sourceLine" id="cb1161-9" data-line-number="9">}</a></code></pre></div>
<p>コンストラクターにtrueを渡すと、イテレーターを最初から失敗状態にしておく</p>
<div class="sourceCode" id="cb1162"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1162-1" data-line-number="1">cin_iterator( <span class="dt">bool</span> fail = <span class="kw">false</span> )</a>
<a class="sourceLine" id="cb1162-2" data-line-number="2">    : fail(fail)</a>
<a class="sourceLine" id="cb1162-3" data-line-number="3">{ ++*<span class="kw">this</span> ; }    </a></code></pre></div>
<p>コンストラクターは最初の値を読み込むために自分自身にインクリメントを呼び出す。</p>
<p>入力イテレーターは同値比較ができる。</p>
<div class="sourceCode" id="cb1163"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1163-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;</a>
<a class="sourceLine" id="cb1163-2" data-line-number="2"><span class="dt">bool</span> <span class="kw">operator</span> ==( cin_iterator&lt;T&gt; <span class="at">const</span> &amp; l, cin_iterator&lt;T&gt; <span class="at">const</span> &amp; r )</a>
<a class="sourceLine" id="cb1163-3" data-line-number="3">{ <span class="cf">return</span> l.fail == r.fail ; }</a>
<a class="sourceLine" id="cb1163-4" data-line-number="4"></a>
<a class="sourceLine" id="cb1163-5" data-line-number="5"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;</a>
<a class="sourceLine" id="cb1163-6" data-line-number="6"><span class="dt">bool</span> <span class="kw">operator</span> !=( cin_iterator&lt;T&gt; <span class="at">const</span> &amp; l, cin_iterator&lt;T&gt; <span class="at">const</span> &amp; r )</a>
<a class="sourceLine" id="cb1163-7" data-line-number="7">{ <span class="cf">return</span> !(l == r) ; }</a></code></pre></div>
<p>イテレーターが同値比較できると、イテレーターが終了条件に達したかどうかの判定ができる。</p>
<div class="sourceCode" id="cb1164"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1164-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> InputIterator &gt;</a>
<a class="sourceLine" id="cb1164-2" data-line-number="2"><span class="dt">void</span> print( InputIterator iter, InputIterator end_iter )</a>
<a class="sourceLine" id="cb1164-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb1164-4" data-line-number="4">    <span class="co">// 終了条件に達するまで</span></a>
<a class="sourceLine" id="cb1164-5" data-line-number="5">    <span class="cf">while</span> ( iter != end_iter )</a>
<a class="sourceLine" id="cb1164-6" data-line-number="6">    {   <span class="co">// 値を標準出力する</span></a>
<a class="sourceLine" id="cb1164-7" data-line-number="7">        <span class="bu">std::</span>cout &lt;&lt; *iter ;</a>
<a class="sourceLine" id="cb1164-8" data-line-number="8">        ++iter ;</a>
<a class="sourceLine" id="cb1164-9" data-line-number="9">    }</a>
<a class="sourceLine" id="cb1164-10" data-line-number="10">}</a></code></pre></div>
<p>このような関数printに、vectorのbegin/endを渡すと、vectorの要素をすべて標準出力する。</p>
<div class="sourceCode" id="cb1165"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1165-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1165-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1165-3" data-line-number="3">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</a>
<a class="sourceLine" id="cb1165-4" data-line-number="4">    print( <span class="bu">std::</span>begin(v), <span class="bu">std::</span>end(v) ) ;</a>
<a class="sourceLine" id="cb1165-5" data-line-number="5">}</a></code></pre></div>
<p><code>cin_iterator</code>を渡した場合、失敗状態になるまで標準出力する。</p>
<div class="sourceCode" id="cb1166"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1166-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1166-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1166-3" data-line-number="3">    cin_iterator iter, fail(<span class="kw">true</span>) ;</a>
<a class="sourceLine" id="cb1166-4" data-line-number="4">    print( iter, fail )</a>
<a class="sourceLine" id="cb1166-5" data-line-number="5">}</a></code></pre></div>
<p><code>cin_iterator</code>が比較するのは<code>std::cin</code>の失敗状態の有無だ。この比較によって、cin_iteratorで標準入力から失敗するまで値を読み込み続けることができる。</p>
<p>このようなイテレーターは標準に<code>std::istream_iterator&lt;T&gt;</code>として存在する。</p>
<div class="sourceCode" id="cb1167"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1167-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1167-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1167-3" data-line-number="3">    <span class="bu">std::</span>istream_iterator&lt;<span class="dt">int</span>&gt; iter( <span class="bu">std::</span>cin ), end_iter ;</a>
<a class="sourceLine" id="cb1167-4" data-line-number="4">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v ;</a>
<a class="sourceLine" id="cb1167-5" data-line-number="5"></a>
<a class="sourceLine" id="cb1167-6" data-line-number="6">    <span class="bu">std::</span>copy( iter, end_iter, <span class="bu">std::</span>back_inserter(v) ) ;</a>
<a class="sourceLine" id="cb1167-7" data-line-number="7">}</a></code></pre></div>
<p>標準ライブラリは読み込むストリームをコンストラクターで取る。何も指定しない場合は失敗状態になる。</p>
<h3 id="前方イテレーター-1">前方イテレーター</h3>
<p>前方イテレーター以上のイテレーターの例として、<code>iota_iterator&lt;T&gt;</code>を実装してみよう。</p>
<p>このイテレーターはT型の整数を保持し、<code>operator *</code>でリファレンスを返し、<code>operator ++</code>でインクリメントする。</p>
<p>以下のように使える。</p>
<div class="sourceCode" id="cb1168"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1168-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1168-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1168-3" data-line-number="3">    iota_iterator iter(<span class="dv">0</span>) ;</a>
<a class="sourceLine" id="cb1168-4" data-line-number="4">    *iter ; <span class="co">// 0</span></a>
<a class="sourceLine" id="cb1168-5" data-line-number="5">    *++iter ; <span class="co">// 1</span></a>
<a class="sourceLine" id="cb1168-6" data-line-number="6">    *++iter ; <span class="co">// 2</span></a>
<a class="sourceLine" id="cb1168-7" data-line-number="7"></a>
<a class="sourceLine" id="cb1168-8" data-line-number="8">    iota_iterator first(<span class="dv">0</span>), last(<span class="dv">10</span>) ;</a>
<a class="sourceLine" id="cb1168-9" data-line-number="9"></a>
<a class="sourceLine" id="cb1168-10" data-line-number="10">    <span class="co">// 0123456789と出力される</span></a>
<a class="sourceLine" id="cb1168-11" data-line-number="11">    <span class="bu">std::</span>for_each( first, last,</a>
<a class="sourceLine" id="cb1168-12" data-line-number="12">        [](<span class="kw">auto</span> i){ <span class="bu">std::</span>cout &lt;&lt; i ;}</a>
<a class="sourceLine" id="cb1168-13" data-line-number="13">    ) ;</a>
<a class="sourceLine" id="cb1168-14" data-line-number="14"></a>
<a class="sourceLine" id="cb1168-15" data-line-number="15">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v ;</a>
<a class="sourceLine" id="cb1168-16" data-line-number="16">    <span class="bu">std::</span>copy( first, last, <span class="bu">std::</span>back_inserter(v) ) ;</a>
<a class="sourceLine" id="cb1168-17" data-line-number="17">    <span class="co">// vは{0,1,2,3,4,5,6,7,8,9}</span></a>
<a class="sourceLine" id="cb1168-18" data-line-number="18">}</a></code></pre></div>
<p>早速実装してみよう。まずはネストされた型名と初期化から。</p>
<div class="sourceCode" id="cb1169"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1169-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;</a>
<a class="sourceLine" id="cb1169-2" data-line-number="2"><span class="kw">struct</span> iota_iterator</a>
<a class="sourceLine" id="cb1169-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb1169-4" data-line-number="4">    <span class="co">// イテレーター同士の距離を表現する型</span></a>
<a class="sourceLine" id="cb1169-5" data-line-number="5">    <span class="kw">using</span> <span class="dt">difference_type</span> = <span class="bu">std::</span>ptrdiff_t ;</a>
<a class="sourceLine" id="cb1169-6" data-line-number="6">    <span class="co">// 要素の型</span></a>
<a class="sourceLine" id="cb1169-7" data-line-number="7">    <span class="kw">using</span> <span class="dt">value_type</span> = T ;</a>
<a class="sourceLine" id="cb1169-8" data-line-number="8">    <span class="kw">using</span> reference = T &amp; ;</a>
<a class="sourceLine" id="cb1169-9" data-line-number="9">    <span class="kw">using</span> pointer = T * ;</a>
<a class="sourceLine" id="cb1169-10" data-line-number="10">    <span class="co">// イテレーターカテゴリーは前方イテレーター</span></a>
<a class="sourceLine" id="cb1169-11" data-line-number="11">    <span class="kw">using</span> iterator_category = <span class="bu">std::</span>forward_iterator_tag ;</a>
<a class="sourceLine" id="cb1169-12" data-line-number="12"></a>
<a class="sourceLine" id="cb1169-13" data-line-number="13">    <span class="co">// 値を保持する</span></a>
<a class="sourceLine" id="cb1169-14" data-line-number="14">    T value ;</a>
<a class="sourceLine" id="cb1169-15" data-line-number="15"></a>
<a class="sourceLine" id="cb1169-16" data-line-number="16">    <span class="co">// コンストラクター</span></a>
<a class="sourceLine" id="cb1169-17" data-line-number="17">    iota_iterator( T value = <span class="dv">0</span> )</a>
<a class="sourceLine" id="cb1169-18" data-line-number="18">        : value(value)</a>
<a class="sourceLine" id="cb1169-19" data-line-number="19">    { }</a>
<a class="sourceLine" id="cb1169-20" data-line-number="20"></a>
<a class="sourceLine" id="cb1169-21" data-line-number="21">    <span class="co">// 残りのコード</span></a>
<a class="sourceLine" id="cb1169-22" data-line-number="22">} ;</a></code></pre></div>
<p>これでイテレーターとしてオブジェクトを作ることができるようになる。コピーは自動的に生成されるので書く必要はない。</p>
<div class="sourceCode" id="cb1170"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1170-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1170-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1170-3" data-line-number="3">    <span class="co">// i(0)</span></a>
<a class="sourceLine" id="cb1170-4" data-line-number="4">    iota_iterator&lt;<span class="dt">int</span>&gt; i ;</a>
<a class="sourceLine" id="cb1170-5" data-line-number="5">    <span class="co">// iota_iterator&lt;int&gt;</span></a>
<a class="sourceLine" id="cb1170-6" data-line-number="6">    iota_iterator first(<span class="dv">0</span>), last(<span class="dv">10</span>)</a>
<a class="sourceLine" id="cb1170-7" data-line-number="7"></a>
<a class="sourceLine" id="cb1170-8" data-line-number="8">    <span class="co">// lastをiにコピー</span></a>
<a class="sourceLine" id="cb1170-9" data-line-number="9">    i = last ;</a>
<a class="sourceLine" id="cb1170-10" data-line-number="10">}</a></code></pre></div>
<p>残りのコードも書いていこう。<code>operator *</code>は単にvalueを返すだけだ。</p>
<div class="sourceCode" id="cb1171"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1171-1" data-line-number="1"><span class="co">// 非const版</span></a>
<a class="sourceLine" id="cb1171-2" data-line-number="2">reference       <span class="kw">operator</span> *() <span class="kw">noexcept</span></a>
<a class="sourceLine" id="cb1171-3" data-line-number="3">{ <span class="cf">return</span> value ; }</a>
<a class="sourceLine" id="cb1171-4" data-line-number="4"><span class="co">// const版</span></a>
<a class="sourceLine" id="cb1171-5" data-line-number="5"><span class="at">const</span> reference <span class="kw">operator</span> *() <span class="at">const</span> <span class="kw">noexcept</span></a>
<a class="sourceLine" id="cb1171-6" data-line-number="6">{ <span class="cf">return</span> value ; }</a></code></pre></div>
<p>非const版とconst版があるのは、constなiota_iteratorのオブジェクトからも使えるようにするためだ。</p>
<div class="sourceCode" id="cb1172"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1172-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1172-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1172-3" data-line-number="3">    <span class="co">// 非constなオブジェクト</span></a>
<a class="sourceLine" id="cb1172-4" data-line-number="4">    iota_iterator non_const(<span class="dv">0</span>) ;</a>
<a class="sourceLine" id="cb1172-5" data-line-number="5">    <span class="co">// 非const版のoperator *を呼び出す</span></a>
<a class="sourceLine" id="cb1172-6" data-line-number="6">    <span class="dt">int</span> value = *non_const ;</a>
<a class="sourceLine" id="cb1172-7" data-line-number="7">    <span class="co">// 変更できる</span></a>
<a class="sourceLine" id="cb1172-8" data-line-number="8">    *non_const = <span class="dv">1</span> ;</a>
<a class="sourceLine" id="cb1172-9" data-line-number="9"></a>
<a class="sourceLine" id="cb1172-10" data-line-number="10">    <span class="co">// constなオブジェクト</span></a>
<a class="sourceLine" id="cb1172-11" data-line-number="11">    iota_iterator immutable(<span class="dv">0</span>) ;</a>
<a class="sourceLine" id="cb1172-12" data-line-number="12">    <span class="co">// const版のoperator *を呼び出す</span></a>
<a class="sourceLine" id="cb1172-13" data-line-number="13">    <span class="dt">int</span> const_value = *immutable ;</a>
<a class="sourceLine" id="cb1172-14" data-line-number="14">    <span class="co">// 変更はできない</span></a>
<a class="sourceLine" id="cb1172-15" data-line-number="15">}</a></code></pre></div>
<p><code>noexcept</code>はこの関数は例外を外に投げないという宣言だ。今回、例外を投げる処理は使わないので、noexceptを指定できる。</p>
<p><code>operator ++</code>を実装しよう。</p>
<div class="sourceCode" id="cb1173"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1173-1" data-line-number="1"><span class="co">// 前置</span></a>
<a class="sourceLine" id="cb1173-2" data-line-number="2">iota_iterator &amp; <span class="kw">operator</span> ++() <span class="kw">noexcept</span></a>
<a class="sourceLine" id="cb1173-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb1173-4" data-line-number="4">    ++value ;</a>
<a class="sourceLine" id="cb1173-5" data-line-number="5">    <span class="cf">return</span> *<span class="kw">this</span> ;</a>
<a class="sourceLine" id="cb1173-6" data-line-number="6">!}</a>
<a class="sourceLine" id="cb1173-7" data-line-number="7"><span class="co">// 後置</span></a>
<a class="sourceLine" id="cb1173-8" data-line-number="8">iota_iterator   <span class="kw">operator</span> ++(<span class="dt">int</span>) <span class="kw">noexcept</span></a>
<a class="sourceLine" id="cb1173-9" data-line-number="9">{</a>
<a class="sourceLine" id="cb1173-10" data-line-number="10">    <span class="kw">auto</span> temp = *<span class="kw">this</span> ;</a>
<a class="sourceLine" id="cb1173-11" data-line-number="11">    ++*<span class="kw">this</span> ;</a>
<a class="sourceLine" id="cb1173-12" data-line-number="12">    <span class="cf">return</span> temp ;</a>
<a class="sourceLine" id="cb1173-13" data-line-number="13">}</a></code></pre></div>
<p>すでに説明したようにインクリメント演算子には前置後置の2種類が存在する。</p>
<div class="sourceCode" id="cb1174"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1174-1" data-line-number="1">++i ; <span class="co">// 前置</span></a>
<a class="sourceLine" id="cb1174-2" data-line-number="2">i++ ; <span class="co">// 後置</span></a></code></pre></div>
<p>前置インクリメント演算子は引数を取らず、後置インクリメント演算子は区別のためだけに特に意味のないint型の引数を取る。</p>
<p>インクリメント演算子も例外を投げないのでnoexceptを指定する。</p>
<p>インクリメント演算子はデータメンバーを変更するのでconstは指定しない。</p>
<p>最後は比較演算子だ。</p>
<div class="sourceCode" id="cb1175"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1175-1" data-line-number="1"><span class="dt">bool</span> <span class="kw">operator</span> == ( iota_iterator <span class="at">const</span> &amp; i ) <span class="at">const</span> <span class="kw">noexcept</span></a>
<a class="sourceLine" id="cb1175-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1175-3" data-line-number="3">    <span class="cf">return</span> value == i.value ;</a>
<a class="sourceLine" id="cb1175-4" data-line-number="4">}</a>
<a class="sourceLine" id="cb1175-5" data-line-number="5"><span class="dt">bool</span> <span class="kw">operator</span> != ( iota_iterator <span class="at">const</span> &amp; i ) <span class="at">const</span> <span class="kw">noexcept</span></a>
<a class="sourceLine" id="cb1175-6" data-line-number="6">{</a>
<a class="sourceLine" id="cb1175-7" data-line-number="7">    <span class="cf">return</span> !(*<span class="kw">this</span> == i) ;</a>
<a class="sourceLine" id="cb1175-8" data-line-number="8">}</a></code></pre></div>
<p>前方イテレーターがサポートする比較演算子は2つ、<code>operator ==</code>と<code>operator !=</code>だ。<code>!=</code>は<code>==</code>で実装してしまうとして、==は単にvalueを比較する。通常、イテレーターの比較は要素の値の比較ではなく、同じ要素を参照するイテレーターかどうかの比較になるが、iota_iteratorの場合、<code>vector</code>や<code>array</code>のようなメモリ上に構築された要素は存在しないので、valueの比較でよい。</p>
<p>前方イテレーターが提供される実例としては、前方リンクリストがある。</p>
<div class="sourceCode" id="cb1176"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1176-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;</a>
<a class="sourceLine" id="cb1176-2" data-line-number="2"><span class="kw">struct</span> forward_link_list</a>
<a class="sourceLine" id="cb1176-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb1176-4" data-line-number="4">    T value ;</a>
<a class="sourceLine" id="cb1176-5" data-line-number="5">    forward_link_list * next ;</a>
<a class="sourceLine" id="cb1176-6" data-line-number="6">} ;</a>
<a class="sourceLine" id="cb1176-7" data-line-number="7"></a>
<a class="sourceLine" id="cb1176-8" data-line-number="8"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1176-9" data-line-number="9">{</a>
<a class="sourceLine" id="cb1176-10" data-line-number="10">    forward_link_list&lt;<span class="dt">int</span>&gt; list3{ <span class="dv">3</span>, <span class="kw">nullptr</span> } ;</a>
<a class="sourceLine" id="cb1176-11" data-line-number="11">    forward_link_list&lt;<span class="dt">int</span>&gt; list2{ <span class="dv">2</span>, &amp;list3 } ;</a>
<a class="sourceLine" id="cb1176-12" data-line-number="12">    forward_link_list&lt;<span class="dt">int</span>&gt; list1{ <span class="dv">1</span>, &amp;list2 } ;</a>
<a class="sourceLine" id="cb1176-13" data-line-number="13">    forward_link_list&lt;<span class="dt">int</span>&gt; list0{ <span class="dv">0</span>, &amp;list1 } ;</a>
<a class="sourceLine" id="cb1176-14" data-line-number="14">}</a></code></pre></div>
<p>この<code>forward_link_list&lt;T&gt;</code>というクラスはT型の値を保持するvalueと、次のクラスのオブジェクトを参照するポインターnextを持っている。このクラスlistの次の要素は<code>*(list.next)</code>で、listの2つ次の要素は<code>*(*list.next).next)</code>だ。</p>
<p>このようなforward_link_list<T>へのイテレーターの骨子は以下のように書ける。</p>
<div class="sourceCode" id="cb1177"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1177-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;</a>
<a class="sourceLine" id="cb1177-2" data-line-number="2"><span class="kw">struct</span> iterator </a>
<a class="sourceLine" id="cb1177-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb1177-4" data-line-number="4">    forward_link_list&lt;T&gt; * ptr ;</a>
<a class="sourceLine" id="cb1177-5" data-line-number="5"></a>
<a class="sourceLine" id="cb1177-6" data-line-number="6">    T &amp; <span class="kw">operator</span> *() <span class="kw">noexcept</span></a>
<a class="sourceLine" id="cb1177-7" data-line-number="7">    {</a>
<a class="sourceLine" id="cb1177-8" data-line-number="8">        <span class="cf">return</span> ptr-&gt;value ;</a>
<a class="sourceLine" id="cb1177-9" data-line-number="9">    }</a>
<a class="sourceLine" id="cb1177-10" data-line-number="10"></a>
<a class="sourceLine" id="cb1177-11" data-line-number="11">    iterator &amp; <span class="kw">operator</span> ++() <span class="kw">noexcept</span></a>
<a class="sourceLine" id="cb1177-12" data-line-number="12">    {</a>
<a class="sourceLine" id="cb1177-13" data-line-number="13">        ptr = ptr-&gt;next ;</a>
<a class="sourceLine" id="cb1177-14" data-line-number="14">        <span class="cf">return</span> *<span class="kw">this</span> ;</a>
<a class="sourceLine" id="cb1177-15" data-line-number="15">    }</a>
<a class="sourceLine" id="cb1177-16" data-line-number="16"><span class="co">// 省略</span></a>
<a class="sourceLine" id="cb1177-17" data-line-number="17">} ;</a></code></pre></div>
<p>前方リンクリストはvectorやarrayのように要素の線形の集合を表現できる。n番目の要素からn+1番目の要素を返すことはできる。</p>
<div class="sourceCode" id="cb1178"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1178-1" data-line-number="1"><span class="co">// n+1番目の要素を返す関数</span></a>
<a class="sourceLine" id="cb1178-2" data-line-number="2"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;</a>
<a class="sourceLine" id="cb1178-3" data-line-number="3">forward_link_list&lt;T&gt; &amp; next( forward_link_list&lt;T&gt; &amp; list ) <span class="kw">noexcept</span></a>
<a class="sourceLine" id="cb1178-4" data-line-number="4">{</a>
<a class="sourceLine" id="cb1178-5" data-line-number="5">    <span class="co">// 次の要素</span></a>
<a class="sourceLine" id="cb1178-6" data-line-number="6">    <span class="cf">return</span> *list.next ;</a>
<a class="sourceLine" id="cb1178-7" data-line-number="7">}</a></code></pre></div>
<p>ただしn-1番目の要素を返すことはできない。その方法がないからだ。</p>
<p>前方イテレーターが入力/出力イテレーターと違う点は、マルチパス保証があることだ。イテレーターのコピーを使いまわして複数回同じ要素をたどることができる。</p>
<div class="sourceCode" id="cb1179"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1179-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> ForwardIterator &gt;</a>
<a class="sourceLine" id="cb1179-2" data-line-number="2"><span class="dt">void</span> f( ForwardIterator first, ForwardIterator last )</a>
<a class="sourceLine" id="cb1179-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb1179-4" data-line-number="4">    <span class="kw">using</span> <span class="dt">vector_type</span> = <span class="bu">std::</span>vector&lt; <span class="kw">typename</span> ForwardIterator::<span class="dt">value_type</span> &gt; ;</a>
<a class="sourceLine" id="cb1179-5" data-line-number="5"></a>
<a class="sourceLine" id="cb1179-6" data-line-number="6">    <span class="co">// 全要素の値をv1にコピー</span></a>
<a class="sourceLine" id="cb1179-7" data-line-number="7">    <span class="dt">vector_type</span> v1 ;</a>
<a class="sourceLine" id="cb1179-8" data-line-number="8">    <span class="cf">for</span> ( <span class="kw">auto</span> iter = first ; iter != last ; ++iter )</a>
<a class="sourceLine" id="cb1179-9" data-line-number="9">        v1.push_back( *iter ) ;</a>
<a class="sourceLine" id="cb1179-10" data-line-number="10"></a>
<a class="sourceLine" id="cb1179-11" data-line-number="11">    <span class="co">// 全要素の値をv2にコピー</span></a>
<a class="sourceLine" id="cb1179-12" data-line-number="12">    <span class="co">// イテレーターがもう一度使われる</span></a>
<a class="sourceLine" id="cb1179-13" data-line-number="13">    <span class="dt">vector_type</span> v2 ;</a>
<a class="sourceLine" id="cb1179-14" data-line-number="14">    <span class="cf">for</span> ( <span class="kw">auto</span> iter = first ; iter != last ; ++iter )</a>
<a class="sourceLine" id="cb1179-15" data-line-number="15">        v2.push_back( *iter ) ;</a>
<a class="sourceLine" id="cb1179-16" data-line-number="16"></a>
<a class="sourceLine" id="cb1179-17" data-line-number="17">    <span class="co">// マルチパス保証があれば常にtrue</span></a>
<a class="sourceLine" id="cb1179-18" data-line-number="18">    <span class="dt">bool</span> b = v1 == v2 ;</a>
<a class="sourceLine" id="cb1179-19" data-line-number="19">}</a></code></pre></div>
<p>前方イテレーター以上のイテレーターにはこのマルチパス保証がある。</p>
<h3 id="双方向イテレーター-1">双方向イテレーター</h3>
<p>双方向イテレーターはn番目の要素を指すイテレーターからn-1番目を指すイテレーターを得られるイテレーターだ。n-1番目を指すには<code>operator --</code>を使う。</p>
<div class="sourceCode" id="cb1180"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1180-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> Iterator &gt;</a>
<a class="sourceLine" id="cb1180-2" data-line-number="2"><span class="dt">void</span> f( Iterator i )</a>
<a class="sourceLine" id="cb1180-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb1180-4" data-line-number="4">    ++i ; <span class="co">// n+1番目</span></a>
<a class="sourceLine" id="cb1180-5" data-line-number="5">    --i ; <span class="co">// n-1番目</span></a>
<a class="sourceLine" id="cb1180-6" data-line-number="6">}</a></code></pre></div>
<p>iota_iteratorを双方向イテレーターにするのは簡単だ。</p>
<div class="sourceCode" id="cb1181"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1181-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;</a>
<a class="sourceLine" id="cb1181-2" data-line-number="2"><span class="kw">struct</span> iota_iterator</a>
<a class="sourceLine" id="cb1181-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb1181-4" data-line-number="4">    <span class="co">// イテレーターカテゴリー</span></a>
<a class="sourceLine" id="cb1181-5" data-line-number="5">    <span class="kw">using</span> iterator_category = <span class="bu">std::</span>bidirectional_iterator_tag ;</a>
<a class="sourceLine" id="cb1181-6" data-line-number="6"></a>
<a class="sourceLine" id="cb1181-7" data-line-number="7">    iota_iterator &amp; <span class="kw">operator</span> --() <span class="kw">noexcept</span></a>
<a class="sourceLine" id="cb1181-8" data-line-number="8">    {</a>
<a class="sourceLine" id="cb1181-9" data-line-number="9">        --value ;</a>
<a class="sourceLine" id="cb1181-10" data-line-number="10">        <span class="cf">return</span> *<span class="kw">this</span> ;</a>
<a class="sourceLine" id="cb1181-11" data-line-number="11">    }</a>
<a class="sourceLine" id="cb1181-12" data-line-number="12">    iota_iterator   <span class="kw">operator</span> --(<span class="dt">int</span>) <span class="kw">noexcept</span></a>
<a class="sourceLine" id="cb1181-13" data-line-number="13">    {</a>
<a class="sourceLine" id="cb1181-14" data-line-number="14">        <span class="kw">auto</span> temp = *<span class="kw">this</span> ;</a>
<a class="sourceLine" id="cb1181-15" data-line-number="15">        --*<span class="kw">this</span> ;</a>
<a class="sourceLine" id="cb1181-16" data-line-number="16">        <span class="cf">return</span> temp ;</a>
<a class="sourceLine" id="cb1181-17" data-line-number="17">    }</a>
<a class="sourceLine" id="cb1181-18" data-line-number="18"></a>
<a class="sourceLine" id="cb1181-19" data-line-number="19">    <span class="co">// 省略</span></a>
<a class="sourceLine" id="cb1181-20" data-line-number="20">} ;</a></code></pre></div>
<p>イテレーターカテゴリーは双方向イテレーターを表現する<code>std::bidirectional_iterator_tag</code>を指定する。</p>
<p><code>operator --</code>の実装は<code>operator ++</code>の実装と要領は同じだ。</p>
<p>これでiota_iteratorが双方向イテレーターになった。</p>
<p>双方向イテレーターが提供される実例としては、双方向リンクリストがある。前方リンクリストが前方の要素への参照を持つのに対し、双方向リンクリストは後方の要素への参照も持つ。</p>
<div class="sourceCode" id="cb1182"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1182-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;</a>
<a class="sourceLine" id="cb1182-2" data-line-number="2"><span class="kw">struct</span> bidirectional_link_list</a>
<a class="sourceLine" id="cb1182-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb1182-4" data-line-number="4">    T value ;</a>
<a class="sourceLine" id="cb1182-5" data-line-number="5"></a>
<a class="sourceLine" id="cb1182-6" data-line-number="6">    bidirectional_link_list * next ;</a>
<a class="sourceLine" id="cb1182-7" data-line-number="7">    bidirectional_link_list * prev ;</a>
<a class="sourceLine" id="cb1182-8" data-line-number="8">} ;</a></code></pre></div>
<p>双方向リンクリストに対するイテレーター操作の骨子は以下のようになる。</p>
<div class="sourceCode" id="cb1183"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1183-1" data-line-number="1"></a>
<a class="sourceLine" id="cb1183-2" data-line-number="2"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;</a>
<a class="sourceLine" id="cb1183-3" data-line-number="3"><span class="kw">struct</span> iterator </a>
<a class="sourceLine" id="cb1183-4" data-line-number="4">{</a>
<a class="sourceLine" id="cb1183-5" data-line-number="5">    <span class="co">// 前方 n+1</span></a>
<a class="sourceLine" id="cb1183-6" data-line-number="6">    iterator &amp; <span class="kw">operator</span> ++() <span class="kw">noexcept</span></a>
<a class="sourceLine" id="cb1183-7" data-line-number="7">    {</a>
<a class="sourceLine" id="cb1183-8" data-line-number="8">        ptr = ptr-&gt;next ;</a>
<a class="sourceLine" id="cb1183-9" data-line-number="9">        <span class="cf">return</span> *<span class="kw">this</span> ;</a>
<a class="sourceLine" id="cb1183-10" data-line-number="10">    }</a>
<a class="sourceLine" id="cb1183-11" data-line-number="11">    <span class="co">// 後方 n-1</span></a>
<a class="sourceLine" id="cb1183-12" data-line-number="12">    iterator &amp; <span class="kw">operator</span> --() <span class="kw">noexcept</span></a>
<a class="sourceLine" id="cb1183-13" data-line-number="13">    {</a>
<a class="sourceLine" id="cb1183-14" data-line-number="14">        ptr = ptr-&gt;prev ;</a>
<a class="sourceLine" id="cb1183-15" data-line-number="15">        <span class="cf">return</span> *<span class="kw">this</span> ;</a>
<a class="sourceLine" id="cb1183-16" data-line-number="16">    }</a>
<a class="sourceLine" id="cb1183-17" data-line-number="17">} ;</a></code></pre></div>
<h3 id="ランダムアクセスイテレーター-1">ランダムアクセスイテレーター</h3>
<p>ランダムアクセスイテレーターにできることは多い。すでにランダムアクセスイテレーターでできることは解説したので、iota_iteratorを対応させていこう。</p>
<p>イテレーターの参照する要素の移動の部分。</p>
<div class="sourceCode" id="cb1184"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1184-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;</a>
<a class="sourceLine" id="cb1184-2" data-line-number="2"><span class="kw">struct</span> iota_iterator</a>
<a class="sourceLine" id="cb1184-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb1184-4" data-line-number="4">    iota_iterator &amp; <span class="kw">operator</span> += ( <span class="dt">difference_type</span> n )</a>
<a class="sourceLine" id="cb1184-5" data-line-number="5">    {</a>
<a class="sourceLine" id="cb1184-6" data-line-number="6">        value += n ;</a>
<a class="sourceLine" id="cb1184-7" data-line-number="7">        <span class="cf">return</span> *<span class="kw">this</span> ;</a>
<a class="sourceLine" id="cb1184-8" data-line-number="8">    }</a>
<a class="sourceLine" id="cb1184-9" data-line-number="9">    iota_iterator <span class="kw">operator</span> + ( <span class="dt">difference_type</span> n ) <span class="at">const</span></a>
<a class="sourceLine" id="cb1184-10" data-line-number="10">    {</a>
<a class="sourceLine" id="cb1184-11" data-line-number="11">        <span class="kw">auto</span> temp = *<span class="kw">this</span> ;</a>
<a class="sourceLine" id="cb1184-12" data-line-number="12">        temp += n ;</a>
<a class="sourceLine" id="cb1184-13" data-line-number="13">        <span class="cf">return</span> *<span class="kw">this</span> ;</a>
<a class="sourceLine" id="cb1184-14" data-line-number="14">    }</a>
<a class="sourceLine" id="cb1184-15" data-line-number="15">    iota_iterator &amp; <span class="kw">operator</span> -= ( <span class="dt">difference_type</span> n )</a>
<a class="sourceLine" id="cb1184-16" data-line-number="16">    {</a>
<a class="sourceLine" id="cb1184-17" data-line-number="17">        value -= n ;</a>
<a class="sourceLine" id="cb1184-18" data-line-number="18">        <span class="cf">return</span> *<span class="kw">this</span> ;</a>
<a class="sourceLine" id="cb1184-19" data-line-number="19">    }</a>
<a class="sourceLine" id="cb1184-20" data-line-number="20">    iota_iterator <span class="kw">operator</span> - ( <span class="dt">difference_type</span> n ) <span class="at">const</span></a>
<a class="sourceLine" id="cb1184-21" data-line-number="21">    {</a>
<a class="sourceLine" id="cb1184-22" data-line-number="22">        <span class="kw">auto</span> temp = *<span class="kw">this</span> ;</a>
<a class="sourceLine" id="cb1184-23" data-line-number="23">        temp -= n ;</a>
<a class="sourceLine" id="cb1184-24" data-line-number="24">        <span class="cf">return</span> *<span class="kw">this</span> ;</a>
<a class="sourceLine" id="cb1184-25" data-line-number="25">    }</a>
<a class="sourceLine" id="cb1184-26" data-line-number="26">    <span class="co">// 省略</span></a>
<a class="sourceLine" id="cb1184-27" data-line-number="27">} ;</a>
<a class="sourceLine" id="cb1184-28" data-line-number="28"></a>
<a class="sourceLine" id="cb1184-29" data-line-number="29"><span class="co">// difference_type + iota_iteratorの場合</span></a>
<a class="sourceLine" id="cb1184-30" data-line-number="30"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;</a>
<a class="sourceLine" id="cb1184-31" data-line-number="31">iota_iterator&lt;T&gt; <span class="kw">operator</span> +</a>
<a class="sourceLine" id="cb1184-32" data-line-number="32">(</a>
<a class="sourceLine" id="cb1184-33" data-line-number="33">    <span class="kw">typename</span> iota_iterator&lt;T&gt;::<span class="dt">difference_type</span> n,</a>
<a class="sourceLine" id="cb1184-34" data-line-number="34">    iota_iterator&lt;T&gt; <span class="at">const</span> &amp; i</a>
<a class="sourceLine" id="cb1184-35" data-line-number="35">)</a>
<a class="sourceLine" id="cb1184-36" data-line-number="36">{ <span class="cf">return</span> i + n ; }</a>
<a class="sourceLine" id="cb1184-37" data-line-number="37"></a>
<a class="sourceLine" id="cb1184-38" data-line-number="38"></a>
<a class="sourceLine" id="cb1184-39" data-line-number="39"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;</a>
<a class="sourceLine" id="cb1184-40" data-line-number="40">iota_iterator&lt;T&gt; <span class="kw">operator</span> - </a>
<a class="sourceLine" id="cb1184-41" data-line-number="41">(</a>
<a class="sourceLine" id="cb1184-42" data-line-number="42">    <span class="kw">typename</span> iota_iterator&lt;T&gt;::<span class="dt">difference_type</span> n,</a>
<a class="sourceLine" id="cb1184-43" data-line-number="43">    iota_iterator&lt;T&gt; <span class="at">const</span> &amp; i</a>
<a class="sourceLine" id="cb1184-44" data-line-number="44">)</a>
<a class="sourceLine" id="cb1184-45" data-line-number="45">{ <span class="cf">return</span> i - n ; }</a></code></pre></div>
<p>ランダムアクセスイテレーター iとdifference_type nがあるとき、<code>i + n</code>と<code>n + i</code>は同じ意味だ。<code>i + n</code>はイテレーターのメンバー関数としても、クラス外のフリー関数としても実装できる。どちらでも好きな方法で実装してよい。</p>
<p>参考に、クラス外のフリー関数として実装する場合は以下のようになる。</p>
<div class="sourceCode" id="cb1185"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1185-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;</a>
<a class="sourceLine" id="cb1185-2" data-line-number="2">iota_iterator&lt;T&gt; <span class="kw">operator</span> +</a>
<a class="sourceLine" id="cb1185-3" data-line-number="3">(</a>
<a class="sourceLine" id="cb1185-4" data-line-number="4">    iota_iterator&lt;T&gt; i,</a>
<a class="sourceLine" id="cb1185-5" data-line-number="5">    <span class="kw">typename</span> iota_iterator&lt;T&gt;::<span class="dt">difference_type</span> n</a>
<a class="sourceLine" id="cb1185-6" data-line-number="6">)</a>
<a class="sourceLine" id="cb1185-7" data-line-number="7">{ <span class="cf">return</span> i + n ; }</a>
<a class="sourceLine" id="cb1185-8" data-line-number="8"></a>
<a class="sourceLine" id="cb1185-9" data-line-number="9"></a>
<a class="sourceLine" id="cb1185-10" data-line-number="10"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;</a>
<a class="sourceLine" id="cb1185-11" data-line-number="11">iota_iterator&lt;T&gt; <span class="kw">operator</span> - </a>
<a class="sourceLine" id="cb1185-12" data-line-number="12">(</a>
<a class="sourceLine" id="cb1185-13" data-line-number="13">    iota_iterator&lt;T&gt; i,</a>
<a class="sourceLine" id="cb1185-14" data-line-number="14">    <span class="kw">typename</span> iota_iterator&lt;T&gt;::<span class="dt">difference_type</span> n</a>
<a class="sourceLine" id="cb1185-15" data-line-number="15">)</a>
<a class="sourceLine" id="cb1185-16" data-line-number="16">{ <span class="cf">return</span> i - n ; }</a></code></pre></div>
<p><code>n + i</code>は必ずクラス外のフリー関数として実装しなければならない。クラスのメンバー関数として演算子のオーバーロードをする場合はオペランドがthisになるからだ。</p>
<p>イテレーターの距離の実装はiota_iteratorの場合、単にvalueの差だ。</p>
<p>メンバー関数として実装する場合は以下の通り。</p>
<div class="sourceCode" id="cb1186"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1186-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;</a>
<a class="sourceLine" id="cb1186-2" data-line-number="2"><span class="kw">struct</span> iota_iterator</a>
<a class="sourceLine" id="cb1186-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb1186-4" data-line-number="4">    <span class="dt">difference_type</span> <span class="kw">operator</span> - ( iota_iterator <span class="at">const</span> &amp; i )</a>
<a class="sourceLine" id="cb1186-5" data-line-number="5">    {</a>
<a class="sourceLine" id="cb1186-6" data-line-number="6">        <span class="cf">return</span> value - i.value ;</a>
<a class="sourceLine" id="cb1186-7" data-line-number="7">    }</a>
<a class="sourceLine" id="cb1186-8" data-line-number="8">} ;</a></code></pre></div>
<p>クラス外のフリー関数として実装する場合は以下の通り。</p>
<div class="sourceCode" id="cb1187"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1187-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;</a>
<a class="sourceLine" id="cb1187-2" data-line-number="2"><span class="kw">typename</span> iota_iterator&lt;T&gt;::<span class="dt">difference_type</span></a>
<a class="sourceLine" id="cb1187-3" data-line-number="3">( iota_iterator&lt;T&gt; <span class="at">const</span> &amp; a, iota_iterator&lt;T&gt; <span class="at">const</span> &amp; b )</a>
<a class="sourceLine" id="cb1187-4" data-line-number="4">{</a>
<a class="sourceLine" id="cb1187-5" data-line-number="5">    <span class="cf">return</span> a.value - b.value ;</a>
<a class="sourceLine" id="cb1187-6" data-line-number="6">}</a></code></pre></div>
<p>大小比較の実装もvalueを比較するだけだ。</p>
<div class="sourceCode" id="cb1188"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1188-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;</a>
<a class="sourceLine" id="cb1188-2" data-line-number="2"><span class="kw">struct</span> iota_iterator </a>
<a class="sourceLine" id="cb1188-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb1188-4" data-line-number="4">    <span class="dt">bool</span> <span class="kw">operator</span> &lt; ( iota_iterator <span class="at">const</span> &amp; i ) <span class="at">const</span> <span class="kw">noexcept</span> </a>
<a class="sourceLine" id="cb1188-5" data-line-number="5">    { <span class="cf">return</span> value &lt; i.value ; }</a>
<a class="sourceLine" id="cb1188-6" data-line-number="6">    <span class="dt">bool</span> <span class="kw">operator</span> &lt;= ( iota_iterator <span class="at">const</span> &amp; i ) <span class="at">const</span> <span class="kw">noexcept</span> </a>
<a class="sourceLine" id="cb1188-7" data-line-number="7">    { <span class="cf">return</span> value &lt;= i.value ; }</a>
<a class="sourceLine" id="cb1188-8" data-line-number="8">    <span class="dt">bool</span> <span class="kw">operator</span> &gt; ( iota_iterator <span class="at">const</span> &amp; i ) <span class="at">const</span> <span class="kw">noexcept</span> </a>
<a class="sourceLine" id="cb1188-9" data-line-number="9">    { <span class="cf">return</span> value &gt; i.value ; }</a>
<a class="sourceLine" id="cb1188-10" data-line-number="10">    <span class="dt">bool</span> <span class="kw">operator</span> &gt;= ( iota_iterator <span class="at">const</span> &amp; i ) <span class="at">const</span> <span class="kw">noexcept</span> </a>
<a class="sourceLine" id="cb1188-11" data-line-number="11">    { <span class="cf">return</span> value &gt;= i.value ; }</a>
<a class="sourceLine" id="cb1188-12" data-line-number="12">    <span class="co">// 省略</span></a>
<a class="sourceLine" id="cb1188-13" data-line-number="13">} ;</a></code></pre></div>
<p>ランダムアクセスイテレーターの実例としては、連続したメモリ上に構築された要素の集合に対するイテレーターがある。標準ライブラリでは、vectorやarrayが該当する。</p>
<p>vectorやarrayの中身は連続したメモリ上に確保された要素で、要素の参照にはポインターか、ポインターとインデックスが用いられる。</p>
<div class="sourceCode" id="cb1189"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1189-1" data-line-number="1"><span class="co">// arrayやvectorのイテレーター</span></a>
<a class="sourceLine" id="cb1189-2" data-line-number="2"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;</a>
<a class="sourceLine" id="cb1189-3" data-line-number="3"><span class="kw">struct</span> iterator</a>
<a class="sourceLine" id="cb1189-4" data-line-number="4">{</a>
<a class="sourceLine" id="cb1189-5" data-line-number="5">    T * ptr ;</a>
<a class="sourceLine" id="cb1189-6" data-line-number="6"></a>
<a class="sourceLine" id="cb1189-7" data-line-number="7">    T &amp; <span class="kw">operator</span> * () { <span class="cf">return</span> *ptr ; }</a>
<a class="sourceLine" id="cb1189-8" data-line-number="8">    iterator &amp; <span class="kw">operator</span> ++ () <span class="kw">noexcept</span></a>
<a class="sourceLine" id="cb1189-9" data-line-number="9">    { ++ptr ; <span class="cf">return</span> *<span class="kw">this</span> ; }</a>
<a class="sourceLine" id="cb1189-10" data-line-number="10">    <span class="co">// その他のメンバー</span></a>
<a class="sourceLine" id="cb1189-11" data-line-number="11">} ;</a></code></pre></div>
<p>vectorやarrayのイテレーターの実装は、ポインターとほぼ同じ処理をしている。その実装は上にあるように、単にポインターに処理をデリゲートするだけだ。</p>
<p>そこで、C++標準ライブラリの実装によっては、vectorやarrayの実装は単に生のポインターを返す。</p>
<div class="sourceCode" id="cb1190"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1190-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> T, <span class="bu">std::</span>size_t N &gt;</a>
<a class="sourceLine" id="cb1190-2" data-line-number="2"><span class="kw">struct</span> array</a>
<a class="sourceLine" id="cb1190-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb1190-4" data-line-number="4">    T storage[N] ;</a>
<a class="sourceLine" id="cb1190-5" data-line-number="5"></a>
<a class="sourceLine" id="cb1190-6" data-line-number="6">    T * begin() <span class="kw">noexcept</span></a>
<a class="sourceLine" id="cb1190-7" data-line-number="7">    { <span class="cf">return</span> storage ; }</a>
<a class="sourceLine" id="cb1190-8" data-line-number="8">    T * end() <span class="kw">noexcept</span></a>
<a class="sourceLine" id="cb1190-9" data-line-number="9">    { <span class="cf">return</span> storage + N ; }</a>
<a class="sourceLine" id="cb1190-10" data-line-number="10">} ;</a></code></pre></div>
<p>イテレーターはクラスであり、そのネストされた型名にvalue_typeやdifference_typeやiterator_categoryなどの型がある。</p>
<div class="sourceCode" id="cb1191"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1191-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> Iterator &gt;</a>
<a class="sourceLine" id="cb1191-2" data-line-number="2"><span class="co">// ネストされた型名を使う</span></a>
<a class="sourceLine" id="cb1191-3" data-line-number="3"><span class="kw">typename</span> Iterator::<span class="dt">reference_type</span></a>
<a class="sourceLine" id="cb1191-4" data-line-number="4">get_value( Iterator i )</a>
<a class="sourceLine" id="cb1191-5" data-line-number="5">{</a>
<a class="sourceLine" id="cb1191-6" data-line-number="6">    <span class="cf">return</span> *i ;</a>
<a class="sourceLine" id="cb1191-7" data-line-number="7">}</a></code></pre></div>
<p>vectorやarrayのイテレーターが単に生のポインターを返す実装の場合、上のコードは動かない。</p>
<p>こういうときのために、<code>iterator_traits&lt;T&gt;</code>がある。もしTがポインターの場合は、ネストされた型名を都合のいいように宣言してくれる。</p>
<div class="sourceCode" id="cb1192"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1192-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> Iterator &gt;</a>
<a class="sourceLine" id="cb1192-2" data-line-number="2"><span class="co">// ポインターにも対応</span></a>
<a class="sourceLine" id="cb1192-3" data-line-number="3"><span class="kw">typename</span> <span class="bu">std::</span>iterator_traits&lt;Iterator&gt;::<span class="dt">reference_type</span></a>
<a class="sourceLine" id="cb1192-4" data-line-number="4">get_value( Iterator i )</a>
<a class="sourceLine" id="cb1192-5" data-line-number="5">{</a>
<a class="sourceLine" id="cb1192-6" data-line-number="6">    <span class="cf">return</span> *i ;</a>
<a class="sourceLine" id="cb1192-7" data-line-number="7">}</a></code></pre></div>
<p>そのため、イテレーターのネストされた型名を使うときには、直接使うのではなく、一度<code>iterator_traits</code>を経由してつかうとよい。</p>
<h2 id="イテレーター操作">イテレーター操作</h2>
<p>イテレーターはそのまま使うこともできるが、一部の操作を簡単に行うための標準ライブラリがある。</p>
<h3 id="advance-i-n-n移動する"><code>advance( i, n )</code>: n移動する</h3>
<p>イテレーター iをn回移動したいとする。ランダムアクセスイテレーターならば以下のようにする。</p>
<div class="sourceCode" id="cb1193"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1193-1" data-line-number="1">i += n ;</a></code></pre></div>
<p>しかし前方イテレーターの場合、<code>operator +=</code>は使えない。n回<code>operator ++</code>を呼び出す必要がある。</p>
<div class="sourceCode" id="cb1194"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1194-1" data-line-number="1"><span class="cf">for</span> ( <span class="kw">auto</span> count = <span class="dv">0</span> ; count != n ; ++count )</a>
<a class="sourceLine" id="cb1194-2" data-line-number="2">    ++i ;</a></code></pre></div>
<p>双方向イテレーターの場合、nは負数の場合がある。nが負数の場合、n回<code>operator --</code>を呼び出すことになる。</p>
<div class="sourceCode" id="cb1195"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1195-1" data-line-number="1"><span class="cf">if</span> ( n &gt; <span class="dv">0</span> )</a>
<a class="sourceLine" id="cb1195-2" data-line-number="2">    <span class="cf">for</span> ( <span class="kw">auto</span> count = <span class="dv">0</span> ; count != n ; ++count )</a>
<a class="sourceLine" id="cb1195-3" data-line-number="3">        ++i ;</a>
<a class="sourceLine" id="cb1195-4" data-line-number="4"><span class="cf">else</span></a>
<a class="sourceLine" id="cb1195-5" data-line-number="5">    <span class="cf">for</span> ( <span class="kw">auto</span> count = <span class="dv">0</span> count != n ; --count )</a>
<a class="sourceLine" id="cb1195-6" data-line-number="6">        --i ;</a></code></pre></div>
<p>双方向イテレーター用のコードはランダムアクセスイテレーターでも動くが非効率的だ。</p>
<p>今使っているイテレーターの種類を把握して適切な方法を選ぶコードを書くのは面倒だ。そこで標準ライブラリには、イテレーター iをn回移動してくれる<code>advance(i, n)</code>がある。</p>
<div class="sourceCode" id="cb1196"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1196-1" data-line-number="1"><span class="co">// iを1前方に移動</span></a>
<a class="sourceLine" id="cb1196-2" data-line-number="2"><span class="bu">std::</span>advance(i, <span class="dv">1</span>) ;</a>
<a class="sourceLine" id="cb1196-3" data-line-number="3"><span class="co">// iを5前方に移動</span></a>
<a class="sourceLine" id="cb1196-4" data-line-number="4"><span class="bu">std::</span>advance(i, <span class="dv">5</span>) ;</a>
<a class="sourceLine" id="cb1196-5" data-line-number="5"><span class="co">// iを5後方に移動</span></a>
<a class="sourceLine" id="cb1196-6" data-line-number="6"><span class="bu">std::</span>advance(i, <span class="dv">-5</span>) ;</a>
<a class="sourceLine" id="cb1196-7" data-line-number="7"><span class="co">// iは移動しない</span></a>
<a class="sourceLine" id="cb1196-8" data-line-number="8"><span class="bu">std::</span>advance(i, <span class="dv">0</span>) ;</a></code></pre></div>
<p>nが正数の場合は前方(i+1の方向)に、nが負数の場合は後方(i-1の方向)に、それぞれn回移動させる。</p>
<p><code>advance(i,n)</code>はi自体が書き換わる。</p>
<div class="sourceCode" id="cb1197"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1197-1" data-line-number="1">i ; <span class="co">// n番目を指す</span></a>
<a class="sourceLine" id="cb1197-2" data-line-number="2"><span class="bu">std::</span>advance( i, <span class="dv">1</span> ) ;</a>
<a class="sourceLine" id="cb1197-3" data-line-number="3">i ; <span class="co">// n+1番目を指す</span></a></code></pre></div>
<h3 id="distance-first-last-firstからlastまでの距離"><code>distance( first, last )</code>: firstからlastまでの距離</h3>
<p>イテレーター firstからlastまでの距離を求めたいとする。</p>
<p>ランダムアクセスイテレーターならば以下のようにする。</p>
<div class="sourceCode" id="cb1198"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1198-1" data-line-number="1"><span class="kw">auto</span> dist = last - first ;</a></code></pre></div>
<p>それ以外のイテレーターならば、firstがlastと等しくなるまで<code>operator ++</code>を呼び出す。</p>
<div class="sourceCode" id="cb1199"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1199-1" data-line-number="1"><span class="bu">std::</span>size_t dist = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb1199-2" data-line-number="2"><span class="cf">for</span> ( <span class="kw">auto</span> iter = first ; iter != last ; ++iter )</a>
<a class="sourceLine" id="cb1199-3" data-line-number="3">    ++dist ;</a></code></pre></div>
<p>これをやるのも面倒なので標準ライブラリがある。</p>
<p><code>distance( first, last )</code>はfirstからlastまでの距離を返す。</p>
<div class="sourceCode" id="cb1200"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1200-1" data-line-number="1"><span class="co">// iからjまでの距離を返す</span></a>
<a class="sourceLine" id="cb1200-2" data-line-number="2"><span class="kw">auto</span> dist = <span class="bu">std::</span>distance( i, j ) ;</a></code></pre></div>
<p>ランダムアクセスイテレーターならば<code>j - i</code>と同じで、そうでなければiがjと等しくなるまで<code>operator ++</code>を呼び出す。</p>
<p><code>distance</code>に渡したイテレーターは変更されない。</p>
<h3 id="nextprev-移動したイテレーターを返す">next/prev : 移動したイテレーターを返す</h3>
<p><code>advance(i, n)</code>はイテレーターiを変更してしまう。イテレーターを変更させずに移動後のイテレーターも欲しい場合、以下のように書かなければならない。</p>
<div class="sourceCode" id="cb1201"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1201-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> Iterator &gt;</a>
<a class="sourceLine" id="cb1201-2" data-line-number="2"><span class="dt">void</span> f( Iterator i )</a>
<a class="sourceLine" id="cb1201-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb1201-4" data-line-number="4">    <span class="kw">auto</span> j = i ;</a>
<a class="sourceLine" id="cb1201-5" data-line-number="5">    <span class="bu">std::</span>advance( j, <span class="dv">3</span> ) ;</a>
<a class="sourceLine" id="cb1201-6" data-line-number="6">    <span class="co">// jはiより3前方に移動している</span></a>
<a class="sourceLine" id="cb1201-7" data-line-number="7">}</a></code></pre></div>
<p>標準ライブラリのnext/prevは、引数に渡したイテレーターを変更せず、移動後のイテレーターを返してくれる。</p>
<div class="sourceCode" id="cb1202"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1202-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> Iterator &gt;</a>
<a class="sourceLine" id="cb1202-2" data-line-number="2"><span class="dt">void</span> f( Iterator i )</a>
<a class="sourceLine" id="cb1202-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb1202-4" data-line-number="4">    <span class="kw">auto</span> j = <span class="bu">std::</span>next( i, <span class="dv">3</span> ) ;</a>
<a class="sourceLine" id="cb1202-5" data-line-number="5">    <span class="co">// jはiより3前方に移動している</span></a>
<a class="sourceLine" id="cb1202-6" data-line-number="6">}</a></code></pre></div>
<p>prevはその逆だ。</p>
<div class="sourceCode" id="cb1203"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1203-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> Iterator &gt;</a>
<a class="sourceLine" id="cb1203-2" data-line-number="2"><span class="dt">void</span> f( Iterator i )</a>
<a class="sourceLine" id="cb1203-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb1203-4" data-line-number="4">    <span class="kw">auto</span> j = <span class="bu">std::</span>prev( i, <span class="dv">3</span> ) ;</a>
<a class="sourceLine" id="cb1203-5" data-line-number="5">    <span class="co">// jはiより3後方に移動している</span></a>
<a class="sourceLine" id="cb1203-6" data-line-number="6">    <span class="co">// jはstd::advance(i, 3)した後のiと同じ値</span></a>
<a class="sourceLine" id="cb1203-7" data-line-number="7">}</a></code></pre></div>
<p>next/prevに第二引数を渡さない場合、前後に1だけ移動する。</p>
<div class="sourceCode" id="cb1204"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1204-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> Iterator &gt;</a>
<a class="sourceLine" id="cb1204-2" data-line-number="2"><span class="dt">void</span> f( Iterator i )</a>
<a class="sourceLine" id="cb1204-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb1204-4" data-line-number="4">    <span class="kw">auto</span> j = <span class="bu">std::</span>next(i) ;</a>
<a class="sourceLine" id="cb1204-5" data-line-number="5">    <span class="co">// jは++iしたのと同じ値</span></a>
<a class="sourceLine" id="cb1204-6" data-line-number="6">    <span class="kw">auto</span> k = <span class="bu">std::</span>prev(i) ;</a>
<a class="sourceLine" id="cb1204-7" data-line-number="7">    <span class="co">// kは--iしたのと同じ値</span></a>
<a class="sourceLine" id="cb1204-8" data-line-number="8">}</a></code></pre></div>
<h2 id="リバースイテレーター">リバースイテレーター</h2>
<p>イテレーターは要素を順番通りにたどる。例えば以下は要素を順番に出力する関数テンプレート<code>print</code>だ。</p>
<div class="sourceCode" id="cb1205"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1205-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> Iterator &gt;</a>
<a class="sourceLine" id="cb1205-2" data-line-number="2"><span class="dt">void</span> print( Iterator first, Iterator last )</a>
<a class="sourceLine" id="cb1205-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb1205-4" data-line-number="4">    <span class="cf">for</span> ( <span class="kw">auto</span> iter = first ; iter != last ; ++iter )</a>
<a class="sourceLine" id="cb1205-5" data-line-number="5">        <span class="bu">std::</span>cout &lt;&lt; *iter ;</a>
<a class="sourceLine" id="cb1205-6" data-line-number="6">}</a></code></pre></div>
<p>逆順に出力するにはどうすればいいのだろうか。</p>
<p>双方向イテレーター以上ならば逆順にたどることはできる。すると逆順に出力する関数テンプレート<code>reverse_print</code>は以下のように書ける。</p>
<div class="sourceCode" id="cb1206"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1206-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;</a>
<a class="sourceLine" id="cb1206-2" data-line-number="2"><span class="dt">void</span> reverse_print( Iterator first, Iterator last )</a>
<a class="sourceLine" id="cb1206-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb1206-4" data-line-number="4">    <span class="cf">for</span> ( <span class="kw">auto</span> iter = <span class="bu">std::</span>prev(last) ; iter != first ; --iter )</a>
<a class="sourceLine" id="cb1206-5" data-line-number="5">    {</a>
<a class="sourceLine" id="cb1206-6" data-line-number="6">        <span class="bu">std::</span>cout &lt;&lt; *iter ;</a>
<a class="sourceLine" id="cb1206-7" data-line-number="7">    }</a>
<a class="sourceLine" id="cb1206-8" data-line-number="8">    <span class="co">// 最初の要素の出力</span></a>
<a class="sourceLine" id="cb1206-9" data-line-number="9">    <span class="bu">std::</span>cout &lt;&lt; *iter ;</a>
<a class="sourceLine" id="cb1206-10" data-line-number="10">}</a></code></pre></div>
<p>しかしイテレーターを正順にたどるか逆順にたどるかという違いだけで、本質的に同じアルゴリズム、同じコードを二度も書きたくはない。そういうときに役立つのがリバースイテレーターだ。</p>
<p><code>std::reverse_iterator&lt;Iterator&gt;</code>はイテレーター<code>Iterator</code>に対するリバースイテレーターを提供する。リバースイテレーターはイテレーターのペア <code>[first,last)</code>を受け取り、lastの1つ前の要素が先頭でfirstの要素が末尾になるような順番のイテレーターにしてくれる。</p>
<div class="sourceCode" id="cb1207"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1207-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1207-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1207-3" data-line-number="3">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</a>
<a class="sourceLine" id="cb1207-4" data-line-number="4"></a>
<a class="sourceLine" id="cb1207-5" data-line-number="5">    <span class="co">// std::reverse_iterator&lt; std::vector&lt;int&gt;::iterator &gt;</span></a>
<a class="sourceLine" id="cb1207-6" data-line-number="6">    <span class="bu">std::</span>reverse_iterator first{ <span class="bu">std::</span>end(v) } ;</a>
<a class="sourceLine" id="cb1207-7" data-line-number="7">    <span class="bu">std::</span>reverse_iterator last{ <span class="bu">std::</span>begin(v) } ;</a>
<a class="sourceLine" id="cb1207-8" data-line-number="8"></a>
<a class="sourceLine" id="cb1207-9" data-line-number="9">    <span class="co">// 54321</span></a>
<a class="sourceLine" id="cb1207-10" data-line-number="10">    <span class="bu">std::</span>for_each( first, last,</a>
<a class="sourceLine" id="cb1207-11" data-line-number="11">        [](<span class="kw">auto</span> x ){ <span class="bu">std::</span>cout &lt;&lt; x ; } ) ;</a>
<a class="sourceLine" id="cb1207-12" data-line-number="12">}</a></code></pre></div>
<p>これで、<code>print</code>と<code>reverse_print</code>のような本質的に同じコードを重複して書かずに済む。</p>
<p>リバースイテレーターはとても便利なので、<code>std::vector</code>のような標準ライブラリのコンテナーには最初からネストされた型名としてリバースイテレーター<code>::reverse_iterator</code>がある。リバースイテレーターを返す<code>rbegin/rend</code>もある。</p>
<div class="sourceCode" id="cb1208"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1208-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1208-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1208-3" data-line-number="3">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</a>
<a class="sourceLine" id="cb1208-4" data-line-number="4"></a>
<a class="sourceLine" id="cb1208-5" data-line-number="5">    <span class="co">// std::vector&lt;int&gt;::reverse_iterator</span></a>
<a class="sourceLine" id="cb1208-6" data-line-number="6">    <span class="kw">auto</span> first = <span class="bu">std::</span>rbegin(v) ;</a>
<a class="sourceLine" id="cb1208-7" data-line-number="7">    <span class="kw">auto</span> last = <span class="bu">std::</span>rend(v) ;</a>
<a class="sourceLine" id="cb1208-8" data-line-number="8"></a>
<a class="sourceLine" id="cb1208-9" data-line-number="9">    <span class="bu">std::</span>for_each( first, last,</a>
<a class="sourceLine" id="cb1208-10" data-line-number="10">        [](<span class="kw">auto</span> x ){ <span class="bu">std::</span>cout &lt;&lt; x ; } ) ;</a>
<a class="sourceLine" id="cb1208-11" data-line-number="11">}</a></code></pre></div>
<h1 id="動的メモリ確保">動的メモリ確保</h1>
<h2 id="概要">概要</h2>
<p>動的メモリ確保は任意のサイズのメモリを確保できる機能だ。</p>
<p>例えば<code>std::vector</code>は任意個の要素を保持できる。</p>
<div class="sourceCode" id="cb1209"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1209-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1209-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1209-3" data-line-number="3">    <span class="dt">int</span> input { } ;</a>
<a class="sourceLine" id="cb1209-4" data-line-number="4">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v ;</a>
<a class="sourceLine" id="cb1209-5" data-line-number="5">    <span class="cf">while</span> ( <span class="bu">std::</span>cin &gt;&gt; input )</a>
<a class="sourceLine" id="cb1209-6" data-line-number="6">    {</a>
<a class="sourceLine" id="cb1209-7" data-line-number="7">        v.push_back( input ) ;</a>
<a class="sourceLine" id="cb1209-8" data-line-number="8">    }</a>
<a class="sourceLine" id="cb1209-9" data-line-number="9">}</a></code></pre></div>
<p>このプログラムは任意個のint型の値を保持する。いくつ保持するかはコンパイル時にはわからないし、実行途中にもわからない。プログラムが終了するまで、実際にいくつ値を保持したのかはわからない。</p>
<p>このような事前にいくつの値を保持するかわからない状況では、動的メモリ確保を使う。</p>
<h2 id="mallocfree">malloc/free</h2>
<p><code>malloc/free</code>はC言語から受け継いだ素朴な動的メモリ確保のライブラリだ。</p>
<div class="sourceCode" id="cb1210"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1210-1" data-line-number="1"><span class="kw">namespace</span> std {</a>
<a class="sourceLine" id="cb1210-2" data-line-number="2">    <span class="dt">void</span> *  malloc  ( <span class="bu">std::</span>size_t size ) ;</a>
<a class="sourceLine" id="cb1210-3" data-line-number="3">    <span class="dt">void</span>    free    ( <span class="dt">void</span> * ptr ) ;</a>
<a class="sourceLine" id="cb1210-4" data-line-number="4">}</a></code></pre></div>
<p><code>malloc(n)</code>はnバイトの生のメモリを確保して、その先頭バイトへのポインターを返す。</p>
<div class="sourceCode" id="cb1211"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1211-1" data-line-number="1"><span class="co">// 5バイトのメモリを確保</span></a>
<a class="sourceLine" id="cb1211-2" data-line-number="2"><span class="dt">void</span> * ptr = <span class="bu">std::</span>malloc( <span class="dv">5</span> ) ;</a></code></pre></div>
<p>これによって確保されるメモリは、1バイトごとのメモリが配列のように連続したメモリだ。型で書くと、<code>std::byte [5]</code>のようなものだ。</p>
<p>確保したメモリは<code>free</code>で解放するまで有効だ。<code>free(ptr)</code>は<code>malloc</code>が返したポインター<code>ptr</code>を解放する。その結果、メモリはまた再びmallocによって再利用できるようになる。</p>
<div class="sourceCode" id="cb1212"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1212-1" data-line-number="1"><span class="co">// 5バイトの生のメモリを確保</span></a>
<a class="sourceLine" id="cb1212-2" data-line-number="2"><span class="dt">void</span> * ptr = <span class="bu">std::</span>malloc( <span class="dv">5</span> ) ;</a>
<a class="sourceLine" id="cb1212-3" data-line-number="3"><span class="co">// 解放</span></a>
<a class="sourceLine" id="cb1212-4" data-line-number="4"><span class="bu">std::</span>free( ptr ) ;</a>
<a class="sourceLine" id="cb1212-5" data-line-number="5"><span class="co">// これ以降、ptrの値は無効</span></a></code></pre></div>
<h2 id="operator-newoperator-delete">operator new/operator delete</h2>
<p>C++の追加した生のメモリを確保する方法が、<code>operator new</code>と<code>operator delete</code>だ。</p>
<div class="sourceCode" id="cb1213"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1213-1" data-line-number="1"><span class="co">// グローバル名前空間</span></a>
<a class="sourceLine" id="cb1213-2" data-line-number="2"><span class="dt">void</span> *  <span class="kw">operator</span> <span class="kw">new</span>    ( <span class="bu">std::</span>size_t size );</a>
<a class="sourceLine" id="cb1213-3" data-line-number="3"><span class="dt">void</span>    <span class="kw">operator</span> <span class="kw">delete</span> ( <span class="dt">void</span> * ptr ) ;</a></code></pre></div>
<p>使い方はmallocとほぼ同じだ。“operator new”までが名前なので少し混乱するが、通常の関数呼び出しと同じだ。</p>
<div class="sourceCode" id="cb1214"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1214-1" data-line-number="1"><span class="dt">void</span> * ptr = ::<span class="kw">operator</span> <span class="kw">new</span>( <span class="dv">5</span> ) ;</a></code></pre></div>
<p>グローバル名前空間であることを明示するために<code>::</code>を使っている。</p>
<p><code>operator new</code>で確保したメモリは、<code>operator delete</code>で解放するまで有効だ。</p>
<div class="sourceCode" id="cb1215"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1215-1" data-line-number="1"><span class="dt">void</span> * ptr = ::<span class="kw">operator</span> <span class="kw">new</span>( <span class="dv">5</span> ) ;</a>
<a class="sourceLine" id="cb1215-2" data-line-number="2">::<span class="kw">operator</span> <span class="kw">delete</span> ( ptr ) ;</a></code></pre></div>
<h2 id="生のバイト列を基本的な型の値として使う方法">生のバイト列を基本的な型の値として使う方法。</h2>
<p><code>int</code>や<code>double</code>のような基本的な型は、生のバイト列のポインターを型変換するだけで使える。</p>
<ol type="1">
<li>生のメモリを確保</li>
<li>ポインターを型変換</li>
<li>値を代入</li>
</ol>
<div class="sourceCode" id="cb1216"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1216-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1216-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1216-3" data-line-number="3">    <span class="co">// 確保</span></a>
<a class="sourceLine" id="cb1216-4" data-line-number="4">    <span class="dt">void</span> * void_ptr = ::<span class="kw">operator</span> <span class="kw">new</span>( <span class="kw">sizeof</span>(<span class="dt">int</span>) ) ;</a>
<a class="sourceLine" id="cb1216-5" data-line-number="5">    <span class="co">// 型変換</span></a>
<a class="sourceLine" id="cb1216-6" data-line-number="6">    <span class="dt">int</span> * int_ptr = <span class="kw">static_cast</span>&lt;<span class="dt">int</span> *&gt;( void_ptr ) ;</a>
<a class="sourceLine" id="cb1216-7" data-line-number="7">    <span class="co">// 代入</span></a>
<a class="sourceLine" id="cb1216-8" data-line-number="8">    *int_ptr = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb1216-9" data-line-number="9">    <span class="co">// 解放</span></a>
<a class="sourceLine" id="cb1216-10" data-line-number="10">    ::<span class="kw">operator</span> <span class="kw">delete</span> ( void_ptr ) ;</a>
<a class="sourceLine" id="cb1216-11" data-line-number="11">}</a></code></pre></div>
<p><code>int</code>型のサイズは<code>sizeof(int)</code>バイトなので、<code>sizeof(int)</code>バイトのメモリを確保する。<code>void *</code>型から<code>int *</code>型に型変換する。あとはポインターを経由して使うだけだ。</p>
<p>ポインターの文法がわかりにくい場合、リファレンスを使うこともできる。</p>
<div class="sourceCode" id="cb1217"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1217-1" data-line-number="1"><span class="dt">int</span> &amp; int_ref = *int_ptr ;</a></code></pre></div>
<p><code>malloc</code>や<code>operator new</code>が返すメモリの値は不定だ。なので、確保した生のメモリーへのポインターを、実際に使う型のポインターに型変換して、その値を参照しようとすると、結果は未定義だ。</p>
<div class="sourceCode" id="cb1218"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1218-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1218-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1218-3" data-line-number="3">    <span class="co">// ここまでは定義された挙動</span></a>
<a class="sourceLine" id="cb1218-4" data-line-number="4">    <span class="dt">int</span> * ptr = <span class="kw">static_cast</span>&lt;<span class="dt">int</span> *&gt;( ::<span class="kw">operator</span> <span class="kw">new</span>(<span class="kw">sizeof</span>(<span class="dt">int</span>)) ) ;</a>
<a class="sourceLine" id="cb1218-5" data-line-number="5">    <span class="co">// 未定義の挙動</span></a>
<a class="sourceLine" id="cb1218-6" data-line-number="6">    <span class="bu">std::</span>cout &lt;&lt; *ptr ;</a>
<a class="sourceLine" id="cb1218-7" data-line-number="7">}</a></code></pre></div>
<p>このプログラムを実行した結果、何が起こるかはわからない。</p>
<h2 id="メモリ確保の失敗">メモリ確保の失敗</h2>
<p>メモリ確保は失敗する可能性がある。現実のコンピューターは有限のリソースしか持たないために、メモリも当然有限のリソースだ。</p>
<p><code>malloc</code>が失敗すると、<code>nullptr</code>が返される。<code>malloc</code>が失敗したかどうかを調べるには、戻り値を<code>nullptr</code>と比較すればよい。</p>
<div class="sourceCode" id="cb1219"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1219-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1219-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1219-3" data-line-number="3">    <span class="dt">void</span> * ptr = <span class="bu">std::</span>malloc( <span class="dv">1</span> ) ;</a>
<a class="sourceLine" id="cb1219-4" data-line-number="4"></a>
<a class="sourceLine" id="cb1219-5" data-line-number="5">    <span class="cf">if</span> ( ptr == <span class="kw">nullptr</span> ) {</a>
<a class="sourceLine" id="cb1219-6" data-line-number="6">        <span class="co">// メモリ確保失敗</span></a>
<a class="sourceLine" id="cb1219-7" data-line-number="7">    } <span class="cf">else</span> {</a>
<a class="sourceLine" id="cb1219-8" data-line-number="8">        <span class="co">// メモリ確保成功</span></a>
<a class="sourceLine" id="cb1219-9" data-line-number="9">    }</a>
<a class="sourceLine" id="cb1219-10" data-line-number="10">}</a></code></pre></div>
<p><code>operator new</code>が失敗すると、<code>std::bad_alloc</code>が投げられる。</p>
<div class="sourceCode" id="cb1220"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1220-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1220-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1220-3" data-line-number="3">    <span class="cf">try</span> {</a>
<a class="sourceLine" id="cb1220-4" data-line-number="4">        <span class="dt">void</span> * ptr = ::<span class="kw">operator</span> <span class="kw">new</span>( <span class="dv">1</span> ) ;</a>
<a class="sourceLine" id="cb1220-5" data-line-number="5">        <span class="co">// メモリ確保成功</span></a>
<a class="sourceLine" id="cb1220-6" data-line-number="6">    } <span class="cf">catch</span> ( <span class="bu">std::</span>bad_alloc e )</a>
<a class="sourceLine" id="cb1220-7" data-line-number="7">    {</a>
<a class="sourceLine" id="cb1220-8" data-line-number="8">        <span class="co">// メモリ確保失敗</span></a>
<a class="sourceLine" id="cb1220-9" data-line-number="9">    }</a>
<a class="sourceLine" id="cb1220-10" data-line-number="10">}</a></code></pre></div>
<p>大抵の環境ではメモリ確保が失敗したときにできることは少ない。そのままプログラムを終了するのが最も適切な処理だ。というのも、ほとんどの処理にはメモリ確保が必要だからだ。</p>
<p>例外の場合、catchしなければプログラムは終了する。<code>malloc</code>の場合、自分でメモリ確保が失敗したかどうかを調べてプログラムを終了しなければならない。プログラムを途中で強制的に終了するには、<code>std::abort</code>が使える。</p>
<div class="sourceCode" id="cb1221"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1221-1" data-line-number="1"><span class="dt">void</span> f()</a>
<a class="sourceLine" id="cb1221-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1221-3" data-line-number="3">    <span class="dt">void</span> * ptr = malloc(<span class="dv">1</span>) ;</a>
<a class="sourceLine" id="cb1221-4" data-line-number="4"></a>
<a class="sourceLine" id="cb1221-5" data-line-number="5">    <span class="co">// 失敗判定</span></a>
<a class="sourceLine" id="cb1221-6" data-line-number="6">    <span class="cf">if</span> ( ptr == <span class="kw">nullptr</span> )</a>
<a class="sourceLine" id="cb1221-7" data-line-number="7">        <span class="bu">std::</span>abort() ;</a>
<a class="sourceLine" id="cb1221-8" data-line-number="8"></a>
<a class="sourceLine" id="cb1221-9" data-line-number="9">    <span class="co">// 成功</span></a>
<a class="sourceLine" id="cb1221-10" data-line-number="10">}</a></code></pre></div>
<h2 id="クラス型の値の構築">クラス型の値の構築</h2>
<p>動的に確保したメモリを<code>int</code>や<code>double</code>のような基本的な型の値として使うには以下のように書けばよいことはすでに学んだ。</p>
<ol type="1">
<li>その型のサイズ分のメモリを確保</li>
<li>ポインターを型変換</li>
<li>適切な値を代入</li>
</ol>
<p>より汎用的にテンプレートを使って書くと以下のようになる。</p>
<div class="sourceCode" id="cb1222"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1222-1" data-line-number="1"><span class="co">// 動的確保したメモリをT型の値として使う</span></a>
<a class="sourceLine" id="cb1222-2" data-line-number="2"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;</a>
<a class="sourceLine" id="cb1222-3" data-line-number="3"><span class="dt">void</span> dynamic_allocate()</a>
<a class="sourceLine" id="cb1222-4" data-line-number="4">{</a>
<a class="sourceLine" id="cb1222-5" data-line-number="5">    <span class="co">// 1. その型のサイズ分のメモリを確保</span></a>
<a class="sourceLine" id="cb1222-6" data-line-number="6">    <span class="dt">void</span> * ptr = ::<span class="kw">operator</span> <span class="kw">new</span>( <span class="kw">sizeof</span>(T) ) ;</a>
<a class="sourceLine" id="cb1222-7" data-line-number="7">    <span class="co">// 2. ポインターを型変換</span></a>
<a class="sourceLine" id="cb1222-8" data-line-number="8">    T * T_ptr = <span class="kw">static_cast</span>&lt;T * &gt;( ptr ) ;</a>
<a class="sourceLine" id="cb1222-9" data-line-number="9">    <span class="co">// 3. 適切な値を代入</span></a>
<a class="sourceLine" id="cb1222-10" data-line-number="10">    *T_ptr = T{} ;</a>
<a class="sourceLine" id="cb1222-11" data-line-number="11">    ::<span class="kw">operator</span> <span class="kw">delete</span>( ptr ) ;</a>
<a class="sourceLine" id="cb1222-12" data-line-number="12">}</a>
<a class="sourceLine" id="cb1222-13" data-line-number="13"></a>
<a class="sourceLine" id="cb1222-14" data-line-number="14"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1222-15" data-line-number="15">{</a>
<a class="sourceLine" id="cb1222-16" data-line-number="16">    dynamic_allocate&lt;<span class="dt">int</span>&gt;() ;</a>
<a class="sourceLine" id="cb1222-17" data-line-number="17">    dynamic_allocate&lt;<span class="dt">double</span>&gt;() ;</a>
<a class="sourceLine" id="cb1222-18" data-line-number="18">}</a></code></pre></div>
<p>この方法は、ほとんどのクラスには使えない。例えば<code>std::vector&lt;T&gt;</code>には使えない。</p>
<div class="sourceCode" id="cb1223"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1223-1" data-line-number="1"><span class="co">// エラー</span></a>
<a class="sourceLine" id="cb1223-2" data-line-number="2">dynamic_allocate&lt; <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; &gt;() ;</a></code></pre></div>
<p>「ほとんどのクラス」と書いたからには、使えるクラスもあるということだ。例えば以下のようなクラスでは使える。</p>
<div class="sourceCode" id="cb1224"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1224-1" data-line-number="1"><span class="kw">struct</span> Simple</a>
<a class="sourceLine" id="cb1224-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1224-3" data-line-number="3">    <span class="dt">int</span> i ;</a>
<a class="sourceLine" id="cb1224-4" data-line-number="4">    <span class="dt">double</span> d ;</a>
<a class="sourceLine" id="cb1224-5" data-line-number="5">} ;</a>
<a class="sourceLine" id="cb1224-6" data-line-number="6"></a>
<a class="sourceLine" id="cb1224-7" data-line-number="7"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1224-8" data-line-number="8">{</a>
<a class="sourceLine" id="cb1224-9" data-line-number="9">    <span class="co">// 使える</span></a>
<a class="sourceLine" id="cb1224-10" data-line-number="10">    dynamic_allocate&lt;Simple&gt;() ;</a>
<a class="sourceLine" id="cb1224-11" data-line-number="11">}</a></code></pre></div>
<p>なぜ<code>Simple</code>のようなクラスでは使えるのだろうか。<code>std::vector&lt;T&gt;</code>とはどう違うのか。この違いを厳密に解説するためには、とても長くて厳密なC++の標準規格の理解が必要だ。とても難しいため、本書では解説しない。</p>
<p>クラスの値を使うためには、メモリ上にクラスのオブジェクトを構築する必要がある。クラスの構築にはコンストラクター呼び出し以外にも、そのメモリをクラスのオブジェクトとして使うのに必要な何らかの初期化が含まれる。</p>
<div class="sourceCode" id="cb1225"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1225-1" data-line-number="1"><span class="co">// sizeof(std::vector&lt;int&gt;)バイトのメモリを確保し</span></a>
<a class="sourceLine" id="cb1225-2" data-line-number="2"><span class="co">// そのメモリ上にクラスのオブジェクトを構築</span></a>
<a class="sourceLine" id="cb1225-3" data-line-number="3"><span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v ;</a></code></pre></div>
<p>生のメモリ上にクラスのような複雑な型を構築するには、<code>newプレイスメント</code>を使う。</p>
<div class="sourceCode" id="cb1226"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1226-1" data-line-number="1"><span class="kw">new</span> ( 生のポインター ) 型 new初期化子</a></code></pre></div>
<p><code>new初期化子</code>というのは<code>()</code>か<code>{}</code>で囲んだコンストラクターへの引数だ。引数がない場合は省略もできる。</p>
<p>例えば<code>std::vector&lt;int&gt;</code>型を構築するには以下のようにする。</p>
<div class="sourceCode" id="cb1227"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1227-1" data-line-number="1"><span class="co">// 生のメモリを動的確保</span></a>
<a class="sourceLine" id="cb1227-2" data-line-number="2"><span class="dt">void</span> * ptr = ::<span class="kw">operator</span> <span class="kw">new</span> ( <span class="kw">sizeof</span>( <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; ) ) ;</a>
<a class="sourceLine" id="cb1227-3" data-line-number="3"><span class="co">// 生のメモリ上に型を構築</span></a>
<a class="sourceLine" id="cb1227-4" data-line-number="4"><span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; * vector_ptr = <span class="kw">new</span> (ptr) <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt;{} ;</a></code></pre></div>
<p>こうすればクラスが適切にメモリ上に構築され、コンストラクターも呼ばれる。コンストラクターが呼ばれることを確かめてみよう。</p>
<div class="sourceCode" id="cb1228"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1228-1" data-line-number="1"><span class="kw">struct</span> Logger</a>
<a class="sourceLine" id="cb1228-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1228-3" data-line-number="3">    <span class="bu">std::</span>string name ;</a>
<a class="sourceLine" id="cb1228-4" data-line-number="4">    Logger( <span class="bu">std::</span>string name )</a>
<a class="sourceLine" id="cb1228-5" data-line-number="5">        : name( name )</a>
<a class="sourceLine" id="cb1228-6" data-line-number="6">    { <span class="bu">std::</span>cout &lt;&lt; name &lt;&lt; <span class="st">&quot; is constructed.</span><span class="sc">\n</span><span class="st">&quot;</span>s ; }</a>
<a class="sourceLine" id="cb1228-7" data-line-number="7">    ~Logger()</a>
<a class="sourceLine" id="cb1228-8" data-line-number="8">    { <span class="bu">std::</span>cout &lt;&lt; name &lt;&lt; <span class="st">&quot; is destructed.</span><span class="sc">\n</span><span class="st">&quot;</span>s ; }</a>
<a class="sourceLine" id="cb1228-9" data-line-number="9">} ;</a>
<a class="sourceLine" id="cb1228-10" data-line-number="10"></a>
<a class="sourceLine" id="cb1228-11" data-line-number="11"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1228-12" data-line-number="12">{</a>
<a class="sourceLine" id="cb1228-13" data-line-number="13">    <span class="dt">void</span> * ptr = ::<span class="kw">operator</span> <span class="kw">new</span> ( <span class="kw">sizeof</span>( Logger ) ) ;</a>
<a class="sourceLine" id="cb1228-14" data-line-number="14">    Logger * logger_ptr = <span class="kw">new</span> (ptr) Logger{<span class="st">&quot;Alice&quot;</span>s} ;</a>
<a class="sourceLine" id="cb1228-15" data-line-number="15">}</a></code></pre></div>
<p>このプログラムを実行すると、“Alice is constructed.”と出力される。</p>
<p>クラスのオブジェクトを適切に破棄するためには、デストラクターを呼ばなければならない。通常の変数ならば、変数が寿命を迎えたときに自動的にデストラクターが呼ばれてくれる。</p>
<div class="sourceCode" id="cb1229"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1229-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1229-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1229-3" data-line-number="3">    Logger Alice(<span class="st">&quot;Alice&quot;</span>s) ;</a>
<a class="sourceLine" id="cb1229-4" data-line-number="4">    {</a>
<a class="sourceLine" id="cb1229-5" data-line-number="5">        Logger Bob(<span class="st">&quot;Bob&quot;</span>s) ;</a>
<a class="sourceLine" id="cb1229-6" data-line-number="6">        <span class="co">// Bobの寿命はここまで</span></a>
<a class="sourceLine" id="cb1229-7" data-line-number="7">    }</a>
<a class="sourceLine" id="cb1229-8" data-line-number="8">    <span class="co">// Aliceの寿命はここまで</span></a>
<a class="sourceLine" id="cb1229-9" data-line-number="9">}</a></code></pre></div>
<p>このプログラムを実行すると、以下のように出力される。</p>
<pre><code>Alice is constructed.
Bob is constructed.
Bob is destructed.
Alice is destructed.</code></pre>
<p>動的に確保されるメモリ上に構築されたオブジェクトは自動的に破棄されてくれない。クラスのオブジェクトの場合デストラクターを呼び出さなければならないが、動的メモリ確保したメモリ上に構築したクラスのオブジェクトの場合は、明示的に呼び出さなければならない。</p>
<div class="sourceCode" id="cb1231"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1231-1" data-line-number="1"><span class="co">// 動的メモリ確保</span></a>
<a class="sourceLine" id="cb1231-2" data-line-number="2"><span class="dt">void</span> * raw_ptr = ::<span class="kw">operator</span> <span class="kw">new</span>( <span class="kw">sizeof</span>(Logger) ) ;</a>
<a class="sourceLine" id="cb1231-3" data-line-number="3"><span class="co">// 構築</span></a>
<a class="sourceLine" id="cb1231-4" data-line-number="4">Logger * logger_ptr = <span class="kw">new</span>(raw_ptr) Logger{ <span class="st">&quot;Alice&quot;</span>s } ;</a>
<a class="sourceLine" id="cb1231-5" data-line-number="5"><span class="co">// デストラクター呼び出し</span></a>
<a class="sourceLine" id="cb1231-6" data-line-number="6">logger_ptr-&gt;~Logger() ;</a>
<a class="sourceLine" id="cb1231-7" data-line-number="7"><span class="co">// 破棄</span></a>
<a class="sourceLine" id="cb1231-8" data-line-number="8">::<span class="kw">operator</span> <span class="kw">delete</span>( raw_ptr ) ;</a></code></pre></div>
<p>このようにすれば、コンストラクター、デストラクターが適切に呼ばれる。また確保したメモリも解放される。</p>
<h2 id="newdelete">new/delete</h2>
<p>クラスのオブジェクトを動的確保するのに、生の文字列の確保/解放と、クラスのオブジェクトの構築/破棄をすべて自前で行うのは面倒だ。幸い、確保と構築、破棄と解放を同時にやってくれる機能がある。<code>new式</code>と<code>delete式</code>だ。</p>
<pre><code>new 型 new初期化子
delete ポインター</code></pre>
<p><code>new式</code>は生のメモリを確保し、型のオブジェクトを構築し、型へのポインターを返す。</p>
<div class="sourceCode" id="cb1233"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1233-1" data-line-number="1"><span class="dt">int</span> * int_ptr = <span class="kw">new</span> <span class="dt">int</span>{<span class="dv">123</span>} ;</a>
<a class="sourceLine" id="cb1233-2" data-line-number="2"><span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; * vector_ptr = <span class="kw">new</span> <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt;{} ;</a></code></pre></div>
<p><code>delete式</code>は<code>new式</code>で返されたポインターの指し示すオブジェクトを破棄し、生のメモリを解放する。</p>
<div class="sourceCode" id="cb1234"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1234-1" data-line-number="1"><span class="kw">delete</span> int_ptr ;</a>
<a class="sourceLine" id="cb1234-2" data-line-number="2"><span class="kw">delete</span> vector_ptr ;</a></code></pre></div>
<p><code>new式</code>がメモリの確保に失敗すると、<code>std::bad_alloc</code>例外を投げる。</p>
<div class="sourceCode" id="cb1235"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1235-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1235-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1235-3" data-line-number="3">    <span class="cf">try</span> {</a>
<a class="sourceLine" id="cb1235-4" data-line-number="4">        <span class="kw">new</span> <span class="dt">int</span>{<span class="dv">0</span>} ;</a>
<a class="sourceLine" id="cb1235-5" data-line-number="5">        <span class="co">// 確保成功</span></a>
<a class="sourceLine" id="cb1235-6" data-line-number="6">    } <span class="cf">catch</span>( <span class="bu">std::</span>bad_alloc e )</a>
<a class="sourceLine" id="cb1235-7" data-line-number="7">    {</a>
<a class="sourceLine" id="cb1235-8" data-line-number="8">        <span class="co">// 確保失敗</span></a>
<a class="sourceLine" id="cb1235-9" data-line-number="9">    }</a>
<a class="sourceLine" id="cb1235-10" data-line-number="10">}</a></code></pre></div>
<h2 id="配列版newdelete">配列版new/delete</h2>
<p><code>new式</code>は配列型を動的確保することもできる。</p>
<div class="sourceCode" id="cb1236"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1236-1" data-line-number="1"><span class="dt">int</span> * int_array_ptr =  <span class="kw">new</span> <span class="dt">int</span>[<span class="dv">5</span>]{<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</a></code></pre></div>
<p>配列型を<code>new式</code>で動的確保した場合、<code>delete式</code>は通常の<code>delete</code>ではなく、<code>delete[]</code>を使わなければならない。</p>
<div class="sourceCode" id="cb1237"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1237-1" data-line-number="1"><span class="kw">delete</span> [] int_array_ptr ;</a></code></pre></div>
<h2 id="スマートポインター">スマートポインター</h2>
<p>クラスのオブジェクトの動的確保は、解放を明示的にしなければならないので間違いをしやすい。この問題はクラスを使って解決できる。</p>
<p>クラスのコンストラクターで動的確保し、デストラクターで解放すればよいのだ。</p>
<div class="sourceCode" id="cb1238"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1238-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;</a>
<a class="sourceLine" id="cb1238-2" data-line-number="2"><span class="kw">struct</span> smart_ptr</a>
<a class="sourceLine" id="cb1238-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb1238-4" data-line-number="4">    T * ptr ;</a>
<a class="sourceLine" id="cb1238-5" data-line-number="5">    <span class="co">// コンストラクターで構築</span></a>
<a class="sourceLine" id="cb1238-6" data-line-number="6">    smart_ptr()</a>
<a class="sourceLine" id="cb1238-7" data-line-number="7">        : ptr( <span class="kw">new</span> T{} )</a>
<a class="sourceLine" id="cb1238-8" data-line-number="8">    { }</a>
<a class="sourceLine" id="cb1238-9" data-line-number="9">    <span class="co">// デストラクターで破棄</span></a>
<a class="sourceLine" id="cb1238-10" data-line-number="10">    ~smart_ptr()</a>
<a class="sourceLine" id="cb1238-11" data-line-number="11">    { <span class="kw">delete</span> ptr ; }</a>
<a class="sourceLine" id="cb1238-12" data-line-number="12"></a>
<a class="sourceLine" id="cb1238-13" data-line-number="13">    T &amp; <span class="kw">operator</span> *() <span class="at">const</span> <span class="kw">noexcept</span></a>
<a class="sourceLine" id="cb1238-14" data-line-number="14">    { <span class="cf">return</span> *ptr ; }</a>
<a class="sourceLine" id="cb1238-15" data-line-number="15">} ;</a>
<a class="sourceLine" id="cb1238-16" data-line-number="16"></a>
<a class="sourceLine" id="cb1238-17" data-line-number="17"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1238-18" data-line-number="18">{</a>
<a class="sourceLine" id="cb1238-19" data-line-number="19">    smart_ptr&lt;<span class="dt">int</span>&gt; ptr ;</a>
<a class="sourceLine" id="cb1238-20" data-line-number="20">    *ptr = <span class="dv">123</span> ;</a>
<a class="sourceLine" id="cb1238-21" data-line-number="21">    <span class="co">// 自動的に破棄される</span></a>
<a class="sourceLine" id="cb1238-22" data-line-number="22">}</a></code></pre></div>
<p>このクラスは様々な点で実用的ではない。例えばこのクラスはコピーできてしまう。</p>
<div class="sourceCode" id="cb1239"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1239-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1239-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1239-3" data-line-number="3">    smart_ptr&lt;<span class="dt">int</span>&gt; p1 ;</a>
<a class="sourceLine" id="cb1239-4" data-line-number="4">    <span class="co">// コピーされる</span></a>
<a class="sourceLine" id="cb1239-5" data-line-number="5">    <span class="kw">auto</span> p2 = p1 ;</a>
<a class="sourceLine" id="cb1239-6" data-line-number="6">    <span class="co">// p2の寿命</span></a>
<a class="sourceLine" id="cb1239-7" data-line-number="7">    <span class="co">// エラー、p1の寿命</span></a>
<a class="sourceLine" id="cb1239-8" data-line-number="8">}</a></code></pre></div>
<p>このコードの何がまずいかというと、<code>smart_ptr::ptr</code>がコピーされてしまうということだ。<code>p2</code>が破棄されると、<code>delete ptr</code>が実行される。その後に<code>p1</code>が破棄されるのだが、もう一度<code>delete ptr</code>が実行されてしまうのだ。一度<code>delete</code>を呼び出したポインターはもう無効になっているので、それ以上<code>delete</code>を呼び出すことはできない。よってエラーになる。</p>
<p>この問題を解決するには、まだ学んでいないC++の機能がたくさん必要になる。この問題は必要な機能をすべて学び終えた後の章で、もう一度挑戦することにしよう。</p>
<h1 id="vectorの実装-基礎">vectorの実装 : 基礎</h1>
<p>クラス、ポインター、メモリ確保を学んだので、とうとうコンテナーの中でも一番有名な<code>std::vector</code>を実装する用意ができた。しかしその前に、アロケーターについて学ぶ必要がある。</p>
<p><code>std::vector</code>は<code>std::vector&lt;T&gt;</code>のように要素の型Tを指定して使うので、以下のようになっていると思う読者もいるだろう。</p>
<div class="sourceCode" id="cb1240"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1240-1" data-line-number="1"><span class="kw">namespace</span> std {</a>
<a class="sourceLine" id="cb1240-2" data-line-number="2">    <span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;</a>
<a class="sourceLine" id="cb1240-3" data-line-number="3">    <span class="kw">struct</span> vector ;</a>
<a class="sourceLine" id="cb1240-4" data-line-number="4">}</a></code></pre></div>
<p>実際には以下のようになっている。</p>
<div class="sourceCode" id="cb1241"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1241-1" data-line-number="1"><span class="kw">namespace</span> std {</a>
<a class="sourceLine" id="cb1241-2" data-line-number="2">    <span class="kw">template</span> &lt; <span class="kw">typename</span> T, <span class="kw">typename</span> allocator = allocator&lt;T&gt; &gt;</a>
<a class="sourceLine" id="cb1241-3" data-line-number="3">    <span class="kw">struct</span> vector ;</a>
<a class="sourceLine" id="cb1241-4" data-line-number="4">}</a></code></pre></div>
<p><code>std::allocator&lt;T&gt;</code>というのは標準ライブラリのアロケーターだ。アロケーターは生のメモリの確保と解放をするライブラリだ。デフォルトで<code>std::allocator&lt;T&gt;</code>が渡されるので、普段ユーザーはアロケーターを意識することはない。</p>
<p><code>std::vector</code>は<code>malloc</code>や<code>operator new</code>を直接使わずアロケーターを使ってメモリ確保を行う。</p>
<p>アロケーターはテンプレートパラメーターで指定できる。何らかの理由で独自のメモリ確保を行いたい場合、独自のアロケーターを実装してコンテナーに渡すことができる。</p>
<div class="sourceCode" id="cb1242"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1242-1" data-line-number="1"><span class="co">// 独自のアロケーター</span></a>
<a class="sourceLine" id="cb1242-2" data-line-number="2"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;</a>
<a class="sourceLine" id="cb1242-3" data-line-number="3"><span class="kw">struct</span> custo<span class="va">m_allocator</span></a>
<a class="sourceLine" id="cb1242-4" data-line-number="4">{</a>
<a class="sourceLine" id="cb1242-5" data-line-number="5">    <span class="co">// ...</span></a>
<a class="sourceLine" id="cb1242-6" data-line-number="6">} ;</a>
<a class="sourceLine" id="cb1242-7" data-line-number="7"></a>
<a class="sourceLine" id="cb1242-8" data-line-number="8"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;</a>
<a class="sourceLine" id="cb1242-9" data-line-number="9"><span class="kw">using</span> custom_vector = <span class="bu">std::</span>vector&lt; T, custom_allocator&lt;T&gt; &gt; ;</a>
<a class="sourceLine" id="cb1242-10" data-line-number="10"></a>
<a class="sourceLine" id="cb1242-11" data-line-number="11"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1242-12" data-line-number="12">{</a>
<a class="sourceLine" id="cb1242-13" data-line-number="13">    custom_vector&lt;<span class="dt">int</span>&gt; v ;</a>
<a class="sourceLine" id="cb1242-14" data-line-number="14">    <span class="co">// 独自のアロケーターを使ったメモリ確保</span></a>
<a class="sourceLine" id="cb1242-15" data-line-number="15">    v.push_back(<span class="dv">0</span>) ;</a>
<a class="sourceLine" id="cb1242-16" data-line-number="16">}</a></code></pre></div>
<h2 id="stdallocatortの概要"><code>std::allocator&lt;T&gt;</code>の概要</h2>
<p><code>std::allocator&lt;T&gt;</code>は<code>T</code>型を構築できる生のメモリを確保するための以下のようになっている。</p>
<div class="sourceCode" id="cb1243"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1243-1" data-line-number="1"><span class="kw">namespace</span> std {</a>
<a class="sourceLine" id="cb1243-2" data-line-number="2"><span class="kw">template</span>&lt;<span class="kw">class</span> T&gt; <span class="kw">class</span> allocator {</a>
<a class="sourceLine" id="cb1243-3" data-line-number="3">    <span class="co">// ネストされた型名の宣言</span></a>
<a class="sourceLine" id="cb1243-4" data-line-number="4">    <span class="kw">using</span> <span class="dt">value_type</span> = T;</a>
<a class="sourceLine" id="cb1243-5" data-line-number="5">    <span class="kw">using</span> <span class="dt">size_type</span> = <span class="dt">size_t</span>;</a>
<a class="sourceLine" id="cb1243-6" data-line-number="6">    <span class="kw">using</span> <span class="dt">difference_type</span> = <span class="dt">ptrdiff_t</span>;</a>
<a class="sourceLine" id="cb1243-7" data-line-number="7">    <span class="kw">using</span> propagate_on_container_move_assignment = <span class="dt">true_type</span>;</a>
<a class="sourceLine" id="cb1243-8" data-line-number="8">    <span class="kw">using</span> is_always_equal = <span class="dt">true_type</span>;</a>
<a class="sourceLine" id="cb1243-9" data-line-number="9"></a>
<a class="sourceLine" id="cb1243-10" data-line-number="10">    <span class="co">// コンストラクター</span></a>
<a class="sourceLine" id="cb1243-11" data-line-number="11">    <span class="co">// constexprはまだ学んでいない</span></a>
<a class="sourceLine" id="cb1243-12" data-line-number="12">    <span class="kw">constexpr</span> allocator() <span class="kw">noexcept</span>;</a>
<a class="sourceLine" id="cb1243-13" data-line-number="13">    <span class="kw">constexpr</span> allocator(<span class="at">const</span> allocator&amp;) <span class="kw">noexcept</span>;</a>
<a class="sourceLine" id="cb1243-14" data-line-number="14">    <span class="kw">template</span>&lt;<span class="kw">class</span> U&gt; <span class="kw">constexpr</span> allocator(<span class="at">const</span> allocator&lt;U&gt;&amp;) <span class="kw">noexcept</span>;</a>
<a class="sourceLine" id="cb1243-15" data-line-number="15">    ~ allocator();</a>
<a class="sourceLine" id="cb1243-16" data-line-number="16">    <span class="co">// コピー代入演算子</span></a>
<a class="sourceLine" id="cb1243-17" data-line-number="17">    allocator&amp; <span class="kw">operator</span>=(<span class="at">const</span> allocator&amp;) = <span class="cf">default</span>;</a>
<a class="sourceLine" id="cb1243-18" data-line-number="18"></a>
<a class="sourceLine" id="cb1243-19" data-line-number="19">    <span class="co">// ここが重要</span></a>
<a class="sourceLine" id="cb1243-20" data-line-number="20">    [[<span class="at">nodiscard</span>]] T* allocate(<span class="dt">size_t</span> n);</a>
<a class="sourceLine" id="cb1243-21" data-line-number="21">    <span class="dt">void</span> deallocate(T* p, <span class="dt">size_t</span> n);</a>
<a class="sourceLine" id="cb1243-22" data-line-number="22">};</a>
<a class="sourceLine" id="cb1243-23" data-line-number="23">}</a></code></pre></div>
<p><code>constexpr</code>というキーワードがあるが、ここでは気にする必要はない。あとで学ぶ。</p>
<p>重要なのはメモリ確保をする<code>allocate</code>と、メモリ解放をする<code>deallocate</code>だ。</p>
<h2 id="stdallocatortの使い方"><code>std::allocator&lt;T&gt;</code>の使い方</h2>
<p>標準ライブラリのアロケーター、<code>std::allocator&lt;T&gt;</code>は、T型を構築できる生のメモリの確保と解放をするライブラリだ。重要なメンバーは以下の通り。</p>
<div class="sourceCode" id="cb1244"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1244-1" data-line-number="1"><span class="co">// メモリ確保</span></a>
<a class="sourceLine" id="cb1244-2" data-line-number="2">[[<span class="at">nodiscard</span>]] T* allocate(<span class="dt">size_t</span> n);</a>
<a class="sourceLine" id="cb1244-3" data-line-number="3"><span class="co">// メモリ解放</span></a>
<a class="sourceLine" id="cb1244-4" data-line-number="4"><span class="dt">void</span> deallocate(T* p, <span class="dt">size_t</span> n);</a></code></pre></div>
<p><code>allocate(n)</code>はT型のn個の配列を構築できるだけの生のメモリを確保してその先頭へのポインターを返す。</p>
<p><code>deallocate(p, n)</code>は<code>allocate(n)</code>で確保されたメモリを解放する。</p>
<div class="sourceCode" id="cb1245"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1245-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1245-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1245-3" data-line-number="3">    <span class="bu">std::</span>allocator&lt;<span class="bu">std::</span>string&gt; a ;</a>
<a class="sourceLine" id="cb1245-4" data-line-number="4">    <span class="co">// 生のメモリ確保</span></a>
<a class="sourceLine" id="cb1245-5" data-line-number="5">    <span class="co">// std::string [1]分のメモリサイズ</span></a>
<a class="sourceLine" id="cb1245-6" data-line-number="6">    <span class="bu">std::</span>string * p = a.allocate(<span class="dv">1</span>) ;</a>
<a class="sourceLine" id="cb1245-7" data-line-number="7">    <span class="co">// メモリ解放</span></a>
<a class="sourceLine" id="cb1245-8" data-line-number="8">    a.deallocate( p, <span class="dv">1</span> ) ;</a>
<a class="sourceLine" id="cb1245-9" data-line-number="9">}</a></code></pre></div>
<p><code>allocate</code>には<code>[[nodiscard]]</code>という属性がついている。これにより戻り値を無視すると警告が出る。</p>
<div class="sourceCode" id="cb1246"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1246-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1246-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1246-3" data-line-number="3">    <span class="bu">std::</span>allocator&lt;<span class="dt">int</span>&gt; a ;</a>
<a class="sourceLine" id="cb1246-4" data-line-number="4">    <span class="co">// 警告、戻り値が無視されている</span></a>
<a class="sourceLine" id="cb1246-5" data-line-number="5">    a.allocate(<span class="dv">1</span>) ;</a>
<a class="sourceLine" id="cb1246-6" data-line-number="6"></a>
<a class="sourceLine" id="cb1246-7" data-line-number="7">    <span class="co">// OK</span></a>
<a class="sourceLine" id="cb1246-8" data-line-number="8">    <span class="dt">int</span> * p = a.allocate(<span class="dv">1</span>) ;</a>
<a class="sourceLine" id="cb1246-9" data-line-number="9">}</a></code></pre></div>
<p>確保されるのが生のメモリだということに注意したい。実際にT型の値として使うには、newによる構築が必要だ。</p>
<div class="sourceCode" id="cb1247"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1247-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1247-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1247-3" data-line-number="3">    <span class="bu">std::</span>allocator&lt;<span class="bu">std::</span>string&gt; a ;</a>
<a class="sourceLine" id="cb1247-4" data-line-number="4">    <span class="co">// 生のメモリ確保</span></a>
<a class="sourceLine" id="cb1247-5" data-line-number="5">    <span class="co">// std::string [1]分のメモリサイズ</span></a>
<a class="sourceLine" id="cb1247-6" data-line-number="6">    <span class="bu">std::</span>string * p = a.allocate(<span class="dv">1</span>) ;</a>
<a class="sourceLine" id="cb1247-7" data-line-number="7">    <span class="co">// 構築</span></a>
<a class="sourceLine" id="cb1247-8" data-line-number="8">    <span class="bu">std::</span>string * s = <span class="kw">new</span>(p) <span class="bu">std::</span>string(<span class="st">&quot;hello&quot;</span>) ;</a>
<a class="sourceLine" id="cb1247-9" data-line-number="9">    <span class="co">// 明示的なデストラクター呼び出し</span></a>
<a class="sourceLine" id="cb1247-10" data-line-number="10">    s-&gt;basic_string() ;</a>
<a class="sourceLine" id="cb1247-11" data-line-number="11">    <span class="co">// メモリ解放</span></a>
<a class="sourceLine" id="cb1247-12" data-line-number="12">    a.deallocate( p, <span class="dv">1</span> ) ;</a>
<a class="sourceLine" id="cb1247-13" data-line-number="13">}</a></code></pre></div>
<p>このように書くのはとても面倒だ。特に<code>std::string</code>の明示的なデストラクター呼び出し<code>s-&gt;basic_string</code>が面倒だ。なぜ<code>s-&gt;string</code>ではだめなのか。</p>
<p>実は<code>std::string</code>は以下のようなクラステンプレートになっている。</p>
<div class="sourceCode" id="cb1248"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1248-1" data-line-number="1"><span class="kw">namespace</span> std {</a>
<a class="sourceLine" id="cb1248-2" data-line-number="2"><span class="kw">template</span> &lt;</a>
<a class="sourceLine" id="cb1248-3" data-line-number="3">    <span class="kw">typename</span> charT,</a>
<a class="sourceLine" id="cb1248-4" data-line-number="4">    <span class="kw">typename</span> traits     = char_traits&lt;charT&gt;,</a>
<a class="sourceLine" id="cb1248-5" data-line-number="5">    <span class="kw">typename</span> Allocator  = allocator&lt;charT&gt;&gt;</a>
<a class="sourceLine" id="cb1248-6" data-line-number="6"><span class="kw">class</span> basic_string</a>
<a class="sourceLine" id="cb1248-7" data-line-number="7">{</a>
<a class="sourceLine" id="cb1248-8" data-line-number="8">    <span class="co">// デストラクター</span></a>
<a class="sourceLine" id="cb1248-9" data-line-number="9">    ~basic_string() ;</a>
<a class="sourceLine" id="cb1248-10" data-line-number="10">} ;</a>
<a class="sourceLine" id="cb1248-11" data-line-number="11"></a>
<a class="sourceLine" id="cb1248-12" data-line-number="12">}</a></code></pre></div>
<p>本当のクラス名は<code>basic_string</code>なのだ。</p>
<p>普段は使っている<code>std::string</code>というのは、以下のようなエイリアスだ。</p>
<div class="sourceCode" id="cb1249"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1249-1" data-line-number="1"><span class="kw">namespace</span> std {</a>
<a class="sourceLine" id="cb1249-2" data-line-number="2"><span class="kw">using</span> string = basic_string&lt;<span class="dt">char</span>&gt; ;</a>
<a class="sourceLine" id="cb1249-3" data-line-number="3">}</a></code></pre></div>
<p>明示的なデストラクター呼び出しにエイリアスは使えないので、本当のクラス名である<code>basic_string</code>を直接指定しなければならない。</p>
<p>この問題はテンプレートで解決できる。</p>
<div class="sourceCode" id="cb1250"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1250-1" data-line-number="1"><span class="co">// 明示的なデストラクター呼び出しをする関数テンプレート</span></a>
<a class="sourceLine" id="cb1250-2" data-line-number="2"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;</a>
<a class="sourceLine" id="cb1250-3" data-line-number="3"><span class="dt">void</span> destroy_at( T * location )</a>
<a class="sourceLine" id="cb1250-4" data-line-number="4">{</a>
<a class="sourceLine" id="cb1250-5" data-line-number="5">    location-&gt;~T() ;</a>
<a class="sourceLine" id="cb1250-6" data-line-number="6">}</a></code></pre></div>
<p>このようにテンプレートで書くことによって、クラス名を意識せずに破棄ができる。</p>
<div class="sourceCode" id="cb1251"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1251-1" data-line-number="1"><span class="co">// 破棄</span></a>
<a class="sourceLine" id="cb1251-2" data-line-number="2">destroy_at( s ) ;</a></code></pre></div>
<p>このようなコードを書くのは面倒なので、標準ライブラリには<code>std::destory_at</code>がある。また、これらをひっくるめたあロケーターを使うためのライブラリである<code>allocator_traits</code>がある。</p>
<h2 id="stdallocator_traitsalloc"><code>std::allocator_traits&lt;Alloc&gt;</code></h2>
<p><code>std::allocator_traits&lt;Alloc&gt;</code>はアロケーター<code>Alloc</code>を簡単に使うためのライブラリだ。</p>
<p><code>allocator_traits&lt;Alloc&gt;</code>はアロケーターの型<code>Alloc</code>を指定して使う。</p>
<div class="sourceCode" id="cb1252"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1252-1" data-line-number="1"><span class="bu">std::</span>allocator&lt;<span class="dt">int</span>&gt; a ;</a>
<a class="sourceLine" id="cb1252-2" data-line-number="2"><span class="dt">int</span> * p = a.allocate(<span class="dv">1</span>) ;</a></code></pre></div>
<p>と書くかわりに、</p>
<div class="sourceCode" id="cb1253"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1253-1" data-line-number="1"><span class="bu">std::</span>allocator&lt;<span class="dt">int</span>&gt; a ;</a>
<a class="sourceLine" id="cb1253-2" data-line-number="2"><span class="dt">int</span> * p = <span class="bu">std::</span>allocator_traits&lt; <span class="bu">std::</span>allocator&lt;<span class="dt">int</span>&gt; &gt;::allocate( a, <span class="dv">1</span> ) ;</a></code></pre></div>
<p>と書く。</p>
<p>これはとても使いづらいので、<code>allocator_traits</code>のエイリアスを書くとよい。</p>
<div class="sourceCode" id="cb1254"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1254-1" data-line-number="1"><span class="bu">std::</span>allocator&lt;<span class="dt">int</span>&gt; a ;</a>
<a class="sourceLine" id="cb1254-2" data-line-number="2"><span class="co">// エイリアス</span></a>
<a class="sourceLine" id="cb1254-3" data-line-number="3"><span class="kw">using</span> traits = <span class="bu">std::</span>allocator_traits&lt; <span class="bu">std::</span>allocator&lt;<span class="dt">int</span>&gt; &gt; ;</a>
<a class="sourceLine" id="cb1254-4" data-line-number="4"><span class="dt">int</span> * p = traits::allocate( a, <span class="dv">1</span> ) ;</a></code></pre></div>
<p>これもまだ書きにくいので、<code>decltype</code>を使う。<code>decltype(expr)</code>は式<code>expr</code>の型として使える機能だ。</p>
<div class="sourceCode" id="cb1255"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1255-1" data-line-number="1"><span class="co">// int型</span></a>
<a class="sourceLine" id="cb1255-2" data-line-number="2"><span class="kw">decltype</span>(<span class="dv">0</span>) a ;</a>
<a class="sourceLine" id="cb1255-3" data-line-number="3"><span class="co">// double型</span></a>
<a class="sourceLine" id="cb1255-4" data-line-number="4"><span class="kw">decltype</span>(<span class="fl">0.0</span>) b ;</a>
<a class="sourceLine" id="cb1255-5" data-line-number="5"><span class="co">// int型</span></a>
<a class="sourceLine" id="cb1255-6" data-line-number="6"><span class="kw">decltype</span>( <span class="dv">1</span> + <span class="dv">1</span> ) c ;</a>
<a class="sourceLine" id="cb1255-7" data-line-number="7"><span class="co">// std::string型</span></a>
<a class="sourceLine" id="cb1255-8" data-line-number="8"><span class="kw">decltype</span>( <span class="st">&quot;hello&quot;</span>s ) c ;</a></code></pre></div>
<p><code>decltype</code>を使うと以下のように書ける。</p>
<div class="sourceCode" id="cb1256"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1256-1" data-line-number="1"><span class="bu">std::</span>allocator&lt;<span class="dt">int</span>&gt; a ;</a>
<a class="sourceLine" id="cb1256-2" data-line-number="2"><span class="co">// エイリアス</span></a>
<a class="sourceLine" id="cb1256-3" data-line-number="3"><span class="kw">using</span> traits = <span class="bu">std::</span>allocator_traits&lt; <span class="kw">decltype</span>(a) &gt; ;</a>
<a class="sourceLine" id="cb1256-4" data-line-number="4"><span class="dt">int</span> * p = traits::allocate( a, <span class="dv">1</span> ) ;</a></code></pre></div>
<p><code>allocator_traits</code>はアロケーターを使った生のメモリの確保、解放と、そのメモリ上にオブジェクトを構築、破棄する機能を提供している。</p>
<div class="sourceCode" id="cb1257"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1257-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1257-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1257-3" data-line-number="3">    <span class="bu">std::</span>allocator&lt;<span class="bu">std::</span>string&gt; a ;</a>
<a class="sourceLine" id="cb1257-4" data-line-number="4">    <span class="co">// allocator_traits型</span></a>
<a class="sourceLine" id="cb1257-5" data-line-number="5">    <span class="kw">using</span> traits = <span class="bu">std::</span>allocator_traits&lt;<span class="kw">decltype</span>(a)&gt; ;</a>
<a class="sourceLine" id="cb1257-6" data-line-number="6"></a>
<a class="sourceLine" id="cb1257-7" data-line-number="7">    <span class="co">// 生のメモリ確保</span></a>
<a class="sourceLine" id="cb1257-8" data-line-number="8">    <span class="bu">std::</span>string * p = traits::allocate( a, <span class="dv">1</span> ) ;</a>
<a class="sourceLine" id="cb1257-9" data-line-number="9">    <span class="co">// 構築</span></a>
<a class="sourceLine" id="cb1257-10" data-line-number="10">    <span class="bu">std::</span>string * s = traits::construct( a, p, <span class="st">&quot;hello&quot;</span>) ;</a>
<a class="sourceLine" id="cb1257-11" data-line-number="11">    <span class="co">// 破棄</span></a>
<a class="sourceLine" id="cb1257-12" data-line-number="12">    traits::destory( a, s ) ;</a>
<a class="sourceLine" id="cb1257-13" data-line-number="13">    <span class="co">// メモリ解放</span></a>
<a class="sourceLine" id="cb1257-14" data-line-number="14">    traits::deallocate( a, p, <span class="dv">1</span> ) ;</a>
<a class="sourceLine" id="cb1257-15" data-line-number="15">}</a></code></pre></div>
<p>T型のN個の配列を構築するには、まずN個の生のメモリを確保し、</p>
<div class="sourceCode" id="cb1258"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1258-1" data-line-number="1"><span class="bu">std::</span>allocator&lt;<span class="bu">std::</span>string&gt; a ;</a>
<a class="sourceLine" id="cb1258-2" data-line-number="2"><span class="kw">using</span> traits = <span class="bu">std::</span>allocator_traits&lt;<span class="kw">decltype</span>(a)&gt; ;</a>
<a class="sourceLine" id="cb1258-3" data-line-number="3"><span class="bu">std::</span>string * p = traits::allocate( a, N ) ;</a></code></pre></div>
<p>N回の構築を行う。</p>
<div class="sourceCode" id="cb1259"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1259-1" data-line-number="1"><span class="cf">for</span> ( <span class="kw">auto</span> i = p, last = p + N ; i != last ; ++i )</a>
<a class="sourceLine" id="cb1259-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1259-3" data-line-number="3">    traits::construct( a, i, <span class="st">&quot;hello&quot;</span> ) ;</a>
<a class="sourceLine" id="cb1259-4" data-line-number="4">}</a></code></pre></div>
<p>破棄もN回行う。</p>
<div class="sourceCode" id="cb1260"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1260-1" data-line-number="1"><span class="cf">for</span> ( <span class="kw">auto</span> i = p + N, first = p ; i != first ; --i )</a>
<a class="sourceLine" id="cb1260-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1260-3" data-line-number="3">    traits::destroy( a, i ) ;</a>
<a class="sourceLine" id="cb1260-4" data-line-number="4">}</a></code></pre></div>
<p>生のメモリを破棄する。</p>
<div class="sourceCode" id="cb1261"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1261-1" data-line-number="1">traits::deallocate( a, p, N ) ;</a></code></pre></div>
<h2 id="簡易vectorの概要">簡易vectorの概要</h2>
<p>準備はできた。簡易的なvectorを実装していこう。以下が本書で実装する簡易vectorだ。</p>
<div class="sourceCode" id="cb1262"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1262-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> T, <span class="kw">typename</span> Allocator = <span class="bu">std::</span>allocator&lt;T&gt; &gt;</a>
<a class="sourceLine" id="cb1262-2" data-line-number="2"><span class="kw">class</span> vector</a>
<a class="sourceLine" id="cb1262-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb1262-4" data-line-number="4"><span class="kw">private</span> :</a>
<a class="sourceLine" id="cb1262-5" data-line-number="5">    <span class="co">// データメンバー</span></a>
<a class="sourceLine" id="cb1262-6" data-line-number="6"><span class="kw">public</span> :</a>
<a class="sourceLine" id="cb1262-7" data-line-number="7">    <span class="co">// value_typeなどネストされた型名</span></a>
<a class="sourceLine" id="cb1262-8" data-line-number="8">    <span class="kw">using</span> <span class="dt">value_type</span> = T ;</a>
<a class="sourceLine" id="cb1262-9" data-line-number="9">    <span class="co">// コンストラクター</span></a>
<a class="sourceLine" id="cb1262-10" data-line-number="10">    vector( <span class="bu">std::</span>size_t n = <span class="dv">0</span>, Allocator a = Allocator() ) ;</a>
<a class="sourceLine" id="cb1262-11" data-line-number="11">    <span class="co">// デストラクター</span></a>
<a class="sourceLine" id="cb1262-12" data-line-number="12">    ~vector() ;</a>
<a class="sourceLine" id="cb1262-13" data-line-number="13">    <span class="co">// コピー</span></a>
<a class="sourceLine" id="cb1262-14" data-line-number="14">    vector( <span class="at">const</span> vector &amp; x ) ;</a>
<a class="sourceLine" id="cb1262-15" data-line-number="15">    vector &amp; <span class="kw">operator</span> =( <span class="at">const</span> vector &amp; x ) ;</a>
<a class="sourceLine" id="cb1262-16" data-line-number="16"></a>
<a class="sourceLine" id="cb1262-17" data-line-number="17">    <span class="co">// 要素アクセス</span></a>
<a class="sourceLine" id="cb1262-18" data-line-number="18">    <span class="dt">void</span> push_back( <span class="at">const</span> T &amp; x ) ;</a>
<a class="sourceLine" id="cb1262-19" data-line-number="19">    T &amp; <span class="kw">operator</span> []( <span class="bu">std::</span>size_t i ) <span class="kw">noexcept</span> ;</a>
<a class="sourceLine" id="cb1262-20" data-line-number="20"></a>
<a class="sourceLine" id="cb1262-21" data-line-number="21">    <span class="co">// イテレーターアクセス</span></a>
<a class="sourceLine" id="cb1262-22" data-line-number="22">    iterator begin() <span class="kw">noexcept</span> ;</a>
<a class="sourceLine" id="cb1262-23" data-line-number="23">    iterator end() <span class="kw">noexcept</span> ;</a>
<a class="sourceLine" id="cb1262-24" data-line-number="24">} ;</a></code></pre></div>
<p>これだけの簡易vectorでもかなり便利に使える。</p>
<p>例えば要素数を定めて配列のようにアクセスできる。</p>
<div class="sourceCode" id="cb1263"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1263-1" data-line-number="1">vector v(<span class="dv">100</span>) ;</a>
<a class="sourceLine" id="cb1263-2" data-line-number="2"><span class="cf">for</span> ( <span class="kw">auto</span> i = <span class="dv">0</span> ; i != <span class="dv">100</span> ; ++i )</a>
<a class="sourceLine" id="cb1263-3" data-line-number="3">    v[i] = i ; </a></code></pre></div>
<p>イテレーターも使える。</p>
<div class="sourceCode" id="cb1264"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1264-1" data-line-number="1"><span class="bu">std::</span>for_each( <span class="bu">std::</span>begin(v), <span class="bu">std::</span>end(v),</a>
<a class="sourceLine" id="cb1264-2" data-line-number="2">    []( <span class="kw">auto</span> x ) { <span class="bu">std::</span>cout &lt;&lt; x ; } ) ;</a></code></pre></div>
<p>要素を際限なく追加できる。</p>
<div class="sourceCode" id="cb1265"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1265-1" data-line-number="1"><span class="bu">std::</span>copy(</a>
<a class="sourceLine" id="cb1265-2" data-line-number="2">    <span class="bu">std::</span>istream_iterator&lt;<span class="dt">int</span>&gt;(<span class="bu">std::</span>cin), <span class="bu">std::</span>istream_iterator&lt;<span class="dt">int</span>&gt;(), </a>
<a class="sourceLine" id="cb1265-3" data-line-number="3">    <span class="bu">std::</span>back_inserter(v) ) ;</a></code></pre></div>
<h2 id="classとアクセス指定">classとアクセス指定</h2>
<p>簡易vectorの概要では、まだ学んでいない機能が使われていた。<code>class</code>と<code>public</code>と<code>private</code>だ。</p>
<p>C++のクラスにはアクセス指定がある。<code>public:</code>と<code>private:</code>だ。アクセス指定が書かれた後、別のアクセス指定が現れるまでの間のメンバーは、アクセス指定の影響を受ける。</p>
<div class="sourceCode" id="cb1266"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1266-1" data-line-number="1"><span class="kw">struct</span> C</a>
<a class="sourceLine" id="cb1266-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1266-3" data-line-number="3"><span class="kw">public</span> :</a>
<a class="sourceLine" id="cb1266-4" data-line-number="4">    <span class="co">// publicなメンバー</span></a>
<a class="sourceLine" id="cb1266-5" data-line-number="5">    <span class="dt">int</span> public_member1 ;</a>
<a class="sourceLine" id="cb1266-6" data-line-number="6">    <span class="dt">int</span> public_member2 ;</a>
<a class="sourceLine" id="cb1266-7" data-line-number="7"><span class="kw">private</span> :</a>
<a class="sourceLine" id="cb1266-8" data-line-number="8">    <span class="co">// privateなメンバー</span></a>
<a class="sourceLine" id="cb1266-9" data-line-number="9">    <span class="dt">int</span> private_member1 ;</a>
<a class="sourceLine" id="cb1266-10" data-line-number="10">    <span class="dt">int</span> private_member2 ;</a>
<a class="sourceLine" id="cb1266-11" data-line-number="11"><span class="kw">public</span> :</a>
<a class="sourceLine" id="cb1266-12" data-line-number="12">    <span class="co">// 再びpublicなメンバー</span></a>
<a class="sourceLine" id="cb1266-13" data-line-number="13">    <span class="dt">int</span> public_member3 ;    </a>
<a class="sourceLine" id="cb1266-14" data-line-number="14">} ;</a></code></pre></div>
<p>publicメンバーはクラスの外から使うことができる。</p>
<div class="sourceCode" id="cb1267"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1267-1" data-line-number="1"><span class="kw">struct</span> C</a>
<a class="sourceLine" id="cb1267-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1267-3" data-line-number="3">pubilc :</a>
<a class="sourceLine" id="cb1267-4" data-line-number="4">    <span class="dt">int</span> data_member ;</a>
<a class="sourceLine" id="cb1267-5" data-line-number="5">    <span class="dt">void</span> member_function() { }</a>
<a class="sourceLine" id="cb1267-6" data-line-number="6">} ;</a>
<a class="sourceLine" id="cb1267-7" data-line-number="7"></a>
<a class="sourceLine" id="cb1267-8" data-line-number="8"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1267-9" data-line-number="9">{</a>
<a class="sourceLine" id="cb1267-10" data-line-number="10">    C c;</a>
<a class="sourceLine" id="cb1267-11" data-line-number="11">    <span class="co">// クラスの外から使う</span></a>
<a class="sourceLine" id="cb1267-12" data-line-number="12">    c.data_member = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb1267-13" data-line-number="13">    c.member_function() ;</a>
<a class="sourceLine" id="cb1267-14" data-line-number="14">}</a></code></pre></div>
<p>privateメンバーはクラスの外から使うことができない。</p>
<div class="sourceCode" id="cb1268"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1268-1" data-line-number="1"><span class="kw">struct</span> C</a>
<a class="sourceLine" id="cb1268-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1268-3" data-line-number="3"><span class="kw">private</span> :</a>
<a class="sourceLine" id="cb1268-4" data-line-number="4">    <span class="dt">int</span> data_member ;</a>
<a class="sourceLine" id="cb1268-5" data-line-number="5">    <span class="dt">void</span> member_function() ;</a>
<a class="sourceLine" id="cb1268-6" data-line-number="6">} ;</a>
<a class="sourceLine" id="cb1268-7" data-line-number="7"></a>
<a class="sourceLine" id="cb1268-8" data-line-number="8"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1268-9" data-line-number="9">{</a>
<a class="sourceLine" id="cb1268-10" data-line-number="10">    C c ;</a>
<a class="sourceLine" id="cb1268-11" data-line-number="11">    <span class="co">// エラー</span></a>
<a class="sourceLine" id="cb1268-12" data-line-number="12">    v.data_member = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb1268-13" data-line-number="13">    <span class="co">// エラー</span></a>
<a class="sourceLine" id="cb1268-14" data-line-number="14">    c.member_function() ;</a>
<a class="sourceLine" id="cb1268-15" data-line-number="15">}</a></code></pre></div>
<p>コンストラクターもアクセス指定の対象になる。</p>
<div class="sourceCode" id="cb1269"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1269-1" data-line-number="1"><span class="kw">struct</span> C</a>
<a class="sourceLine" id="cb1269-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1269-3" data-line-number="3"><span class="kw">public</span> :</a>
<a class="sourceLine" id="cb1269-4" data-line-number="4">    C(<span class="dt">int</span>) { }</a>
<a class="sourceLine" id="cb1269-5" data-line-number="5"><span class="kw">private</span> :</a>
<a class="sourceLine" id="cb1269-6" data-line-number="6">    C(<span class="dt">double</span>) { }</a>
<a class="sourceLine" id="cb1269-7" data-line-number="7">} ;</a>
<a class="sourceLine" id="cb1269-8" data-line-number="8"></a>
<a class="sourceLine" id="cb1269-9" data-line-number="9"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1269-10" data-line-number="10">{</a>
<a class="sourceLine" id="cb1269-11" data-line-number="11">    <span class="co">// OK</span></a>
<a class="sourceLine" id="cb1269-12" data-line-number="12">    C pub(<span class="dv">0</span>) ;</a>
<a class="sourceLine" id="cb1269-13" data-line-number="13">    <span class="co">// エラー</span></a>
<a class="sourceLine" id="cb1269-14" data-line-number="14">    C pri(<span class="fl">0.0</span>) ;</a>
<a class="sourceLine" id="cb1269-15" data-line-number="15">}</a></code></pre></div>
<p>この例では、<code>C::C(int)</code>はpublicメンバーなのでクラスの外から使えるが、<code>C::C(double)</code>はprivateメンバーなのでクラスの外からは使えない。</p>
<p>privateメンバーはクラスの中から使うことができる。クラスの中であればどのアクセス指定のメンバーからでも使える。</p>
<div class="sourceCode" id="cb1270"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1270-1" data-line-number="1"><span class="kw">struct</span> C</a>
<a class="sourceLine" id="cb1270-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1270-3" data-line-number="3"><span class="kw">public</span> :</a>
<a class="sourceLine" id="cb1270-4" data-line-number="4">    <span class="dt">void</span> f()</a>
<a class="sourceLine" id="cb1270-5" data-line-number="5">    {</a>
<a class="sourceLine" id="cb1270-6" data-line-number="6">        <span class="co">// ここはクラスの中</span></a>
<a class="sourceLine" id="cb1270-7" data-line-number="7">        data_member = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb1270-8" data-line-number="8">        member_function() ;</a>
<a class="sourceLine" id="cb1270-9" data-line-number="9">    }</a>
<a class="sourceLine" id="cb1270-10" data-line-number="10"></a>
<a class="sourceLine" id="cb1270-11" data-line-number="11"><span class="kw">private</span> :</a>
<a class="sourceLine" id="cb1270-12" data-line-number="12">    <span class="dt">int</span> data_member ;</a>
<a class="sourceLine" id="cb1270-13" data-line-number="13">    <span class="dt">void</span> member_function() { }</a>
<a class="sourceLine" id="cb1270-14" data-line-number="14">} ;</a></code></pre></div>
<p>privateメンバーの目的はクラスの外から使ってほしくないメンバーを守ることだ。例えば以下のようにコンストラクターでnewしてデストラクターでdeleteするようなクラスがあるとする。</p>
<div class="sourceCode" id="cb1271"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1271-1" data-line-number="1"><span class="kw">class</span> dynamic_int</a>
<a class="sourceLine" id="cb1271-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1271-3" data-line-number="3"><span class="kw">private</span> :</a>
<a class="sourceLine" id="cb1271-4" data-line-number="4">    <span class="dt">int</span> * ptr ;</a>
<a class="sourceLine" id="cb1271-5" data-line-number="5"><span class="kw">public</span> :</a>
<a class="sourceLine" id="cb1271-6" data-line-number="6">    dynamic_int( <span class="dt">int</span> value = <span class="dv">0</span>  )</a>
<a class="sourceLine" id="cb1271-7" data-line-number="7">        : ptr( <span class="kw">new</span> <span class="dt">int</span>(value) )</a>
<a class="sourceLine" id="cb1271-8" data-line-number="8">    { }</a>
<a class="sourceLine" id="cb1271-9" data-line-number="9">    ~dyamic_int()</a>
<a class="sourceLine" id="cb1271-10" data-line-number="10">    {</a>
<a class="sourceLine" id="cb1271-11" data-line-number="11">        <span class="kw">delete</span> ptr ;</a>
<a class="sourceLine" id="cb1271-12" data-line-number="12">    }</a>
<a class="sourceLine" id="cb1271-13" data-line-number="13">} ;</a></code></pre></div>
<p>もし<code>dynamic_int::ptr</code>がpublicメンバーだった場合、以下のようなコードのコンパイルが通ってしまう。</p>
<div class="sourceCode" id="cb1272"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1272-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1272-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1272-3" data-line-number="3">    dynamic_int i ;</a>
<a class="sourceLine" id="cb1272-4" data-line-number="4">    <span class="kw">delete</span> i.ptr ;</a>
<a class="sourceLine" id="cb1272-5" data-line-number="5">    <span class="dt">int</span> obj{} ;</a>
<a class="sourceLine" id="cb1272-6" data-line-number="6">    i.ptr = &amp;obj ;</a>
<a class="sourceLine" id="cb1272-7" data-line-number="7">}</a></code></pre></div>
<p>このプログラムが<code>dynamic_int</code>のデストラクターを呼ぶと、main関数のローカル変数のポインターに対して<code>delete</code>を呼び出してしまう。これは未定義の挙動となる。</p>
<p>外部から使われては困るメンバーをprivateメンバーにすることでこの問題はコンパイル時にエラーにでき、未然に回避できる。</p>
<p>クラスを定義するにはキーワードとして<code>struct</code>もしくは<code>class</code>を使う。</p>
<div class="sourceCode" id="cb1273"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1273-1" data-line-number="1"><span class="kw">struct</span>  foo { } ;</a>
<a class="sourceLine" id="cb1273-2" data-line-number="2"><span class="kw">class</span>   bar { } ;</a></code></pre></div>
<p>違いはデフォルトのアクセス指定だ。</p>
<p>structはデフォルトでpublicとなる。</p>
<div class="sourceCode" id="cb1274"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1274-1" data-line-number="1"><span class="kw">struct</span> foo</a>
<a class="sourceLine" id="cb1274-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1274-3" data-line-number="3">    <span class="co">// publicメンバー</span></a>
<a class="sourceLine" id="cb1274-4" data-line-number="4">    <span class="dt">int</span> member ;</a>
<a class="sourceLine" id="cb1274-5" data-line-number="5">} ;</a></code></pre></div>
<p>classはデフォルトでprivateとなる。</p>
<div class="sourceCode" id="cb1275"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1275-1" data-line-number="1"><span class="kw">class</span> bar</a>
<a class="sourceLine" id="cb1275-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1275-3" data-line-number="3">    <span class="co">// privateメンバー</span></a>
<a class="sourceLine" id="cb1275-4" data-line-number="4">    <span class="dt">int</span> member ;</a>
<a class="sourceLine" id="cb1275-5" data-line-number="5">} ;</a></code></pre></div>
<p><code>struct</code>と<code>class</code>の違いはデフォルトのアクセス指定だけだ。アクセス指定を明示的に書く場合、違いはなくなる。</p>
<h2 id="ネストされた型名-1">ネストされた型名</h2>
<p><code>std::vector</code>には様々なネストされた型名がある。</p>
<div class="sourceCode" id="cb1276"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1276-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1276-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1276-3" data-line-number="3">    <span class="kw">using</span> vec = <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; ;</a>
<a class="sourceLine" id="cb1276-4" data-line-number="4">    vec v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>} ;</a>
<a class="sourceLine" id="cb1276-5" data-line-number="5"></a>
<a class="sourceLine" id="cb1276-6" data-line-number="6">    vec::<span class="dt">value_type</span> val = v[<span class="dv">0</span>] ;</a>
<a class="sourceLine" id="cb1276-7" data-line-number="7">    vec::iterator i = v.begin() ;</a>
<a class="sourceLine" id="cb1276-8" data-line-number="8">}</a></code></pre></div>
<p>自作の簡易vectorで<code>std::vector</code>と同じようにネストされた型名を書いていこう。</p>
<p>要素型に関係するネストされた型名</p>
<div class="sourceCode" id="cb1277"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1277-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> T, <span class="kw">typename</span> Allocator = <span class="bu">std::</span>allocator&lt;T&gt; &gt;</a>
<a class="sourceLine" id="cb1277-2" data-line-number="2"><span class="kw">class</span> vector</a>
<a class="sourceLine" id="cb1277-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb1277-4" data-line-number="4"><span class="kw">public</span> :</a>
<a class="sourceLine" id="cb1277-5" data-line-number="5">    <span class="kw">using</span> <span class="dt">value_type</span>                = T ;</a>
<a class="sourceLine" id="cb1277-6" data-line-number="6">    <span class="kw">using</span> pointer                   = T *;</a>
<a class="sourceLine" id="cb1277-7" data-line-number="7">    <span class="kw">using</span> const_pointer             = <span class="at">const</span> pointer;</a>
<a class="sourceLine" id="cb1277-8" data-line-number="8">    <span class="kw">using</span> reference                 = <span class="dt">value_type</span> &amp; ;</a>
<a class="sourceLine" id="cb1277-9" data-line-number="9">    <span class="kw">using</span> const_reference           = <span class="at">const</span> <span class="dt">value_type</span> &amp; ;</a>
<a class="sourceLine" id="cb1277-10" data-line-number="10">} ;</a></code></pre></div>
<p>本物の<code>std::vector</code>とは少し異なるが、ほぼ同じだ。要素型が<code>value_type</code>で、あとは要素型のポインター、constポインター、リファレンス、constリファレンスがそれぞれエイリアス宣言される。</p>
<p>アロケーター型も<code>allocator_type</code>としてエイリアス宣言される。</p>
<div class="sourceCode" id="cb1278"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1278-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> T, <span class="kw">typename</span> Allocator = <span class="bu">std::</span>allocator&lt;T&gt; &gt;</a>
<a class="sourceLine" id="cb1278-2" data-line-number="2"><span class="kw">class</span> vector</a>
<a class="sourceLine" id="cb1278-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb1278-4" data-line-number="4"><span class="kw">public</span> :</a>
<a class="sourceLine" id="cb1278-5" data-line-number="5">    <span class="kw">using</span> <span class="dt">allocator_type</span> = Allocator ;</a>
<a class="sourceLine" id="cb1278-6" data-line-number="6">}</a></code></pre></div>
<p><code>size_type</code>は要素数を表現する型だ。</p>
<div class="sourceCode" id="cb1279"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1279-1" data-line-number="1"><span class="dt">void</span> f( <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; &amp; v )</a>
<a class="sourceLine" id="cb1279-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1279-3" data-line-number="3">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt;::<span class="dt">size_type</span> s = v.size() ;</a>
<a class="sourceLine" id="cb1279-4" data-line-number="4">}</a></code></pre></div>
<p>通常<code>std::size_t</code>が使われる。</p>
<div class="sourceCode" id="cb1280"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1280-1" data-line-number="1"><span class="dt">size_type</span> = <span class="bu">std::</span>size_t ;</a></code></pre></div>
<p><code>difference_type</code>はイテレーターの<code>difference_type</code>と同じだ。これはイテレーター間の距離を表現する型だ。</p>
<div class="sourceCode" id="cb1281"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1281-1" data-line-number="1"><span class="dt">void</span> f( <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; &amp; v )</a>
<a class="sourceLine" id="cb1281-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1281-3" data-line-number="3">    <span class="kw">auto</span> i = v.begin() ;</a>
<a class="sourceLine" id="cb1281-4" data-line-number="4">    <span class="kw">auto</span> j = i + <span class="dv">3</span> ;</a>
<a class="sourceLine" id="cb1281-5" data-line-number="5"></a>
<a class="sourceLine" id="cb1281-6" data-line-number="6">    <span class="co">// iとjの距離</span></a>
<a class="sourceLine" id="cb1281-7" data-line-number="7">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt;::<span class="dt">difference_type</span> d = j - i ;</a>
<a class="sourceLine" id="cb1281-8" data-line-number="8">}</a></code></pre></div>
<p>通常<code>std::ptrdiff_t</code>が使われる。</p>
<div class="sourceCode" id="cb1282"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1282-1" data-line-number="1"><span class="dt">difference_type</span> = <span class="bu">std::</span>ptrdiff_t ;</a></code></pre></div>
<p>イテレーターのエイリアス。</p>
<div class="sourceCode" id="cb1283"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1283-1" data-line-number="1"><span class="kw">using</span> iterator                  = pointer ;</a>
<a class="sourceLine" id="cb1283-2" data-line-number="2"><span class="kw">using</span> const_iterator            = const_pointer ;</a>
<a class="sourceLine" id="cb1283-3" data-line-number="3"><span class="kw">using</span> reverse_iterator          = <span class="bu">std::</span>reverse_iterator&lt;iterator&gt; ;</a>
<a class="sourceLine" id="cb1283-4" data-line-number="4"><span class="kw">using</span> const_reverse_iterator    = <span class="bu">std::</span>reverse_iterator&lt;const_iterator&gt; ;</a></code></pre></div>
<p>今回実装する簡易vectorでは、ポインター型をイテレーター型として使う。<code>std::vector</code>の実装がこのようになっている保証はない。</p>
<p><code>reverse_iterator</code>と<code>const_reverse_iterator</code>はリバースイテレーターだ。</p>
<h2 id="簡易vectorのデータメンバー">簡易vectorのデータメンバー</h2>
<p>簡易vectorにはどのようなデータメンバーがあればいいのだろうか。以下の4つの情報を保持する必要がある。</p>
<ol type="1">
<li>動的確保したストレージへのポインター</li>
<li>現在有効な要素数</li>
<li>動的確保したストレージのサイズ</li>
<li>アロケーター</li>
</ol>
<p>これを素直に考えると、ポインター1つ、整数2つ、アロケーター1つの4つのデータメンバーになる。</p>
<div class="sourceCode" id="cb1284"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1284-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> T, <span class="kw">typename</span> Allocator = <span class="bu">std::</span>allocator&lt;T&gt; &gt;</a>
<a class="sourceLine" id="cb1284-2" data-line-number="2"><span class="kw">class</span> vector</a>
<a class="sourceLine" id="cb1284-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb1284-4" data-line-number="4"><span class="kw">private</span> :</a>
<a class="sourceLine" id="cb1284-5" data-line-number="5">    <span class="co">// 動的確保したストレージへのポインター</span></a>
<a class="sourceLine" id="cb1284-6" data-line-number="6">    pointer first = <span class="kw">nullptr</span> ;</a>
<a class="sourceLine" id="cb1284-7" data-line-number="7">    <span class="co">// 現在有効な要素数</span></a>
<a class="sourceLine" id="cb1284-8" data-line-number="8">    <span class="dt">size_type</span> valid_size = <span class="kw">nullptr</span> ;</a>
<a class="sourceLine" id="cb1284-9" data-line-number="9">    <span class="co">// 動的確保したストレージのサイズ</span></a>
<a class="sourceLine" id="cb1284-10" data-line-number="10">    <span class="dt">size_type</span> allocated_size = <span class="kw">nullptr</span> ;</a>
<a class="sourceLine" id="cb1284-11" data-line-number="11">    <span class="co">// アロケーターの値</span></a>
<a class="sourceLine" id="cb1284-12" data-line-number="12">    <span class="dt">allocator_type</span> alloc ;</a>
<a class="sourceLine" id="cb1284-13" data-line-number="13">} ;</a></code></pre></div>
<p>確かに<code>std::vector</code>はこのようなデータメンバーでも実装できる。しかし多くの実装では以下のようなポインター3つとアロケーター1つになっている。</p>
<div class="sourceCode" id="cb1285"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1285-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> T, <span class="kw">typename</span> Allocator = <span class="bu">std::</span>allocator&lt;T&gt; &gt;</a>
<a class="sourceLine" id="cb1285-2" data-line-number="2"><span class="kw">class</span> vector</a>
<a class="sourceLine" id="cb1285-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb1285-4" data-line-number="4"><span class="kw">private</span> :</a>
<a class="sourceLine" id="cb1285-5" data-line-number="5">    <span class="co">// 先頭の要素へのポインター</span></a>
<a class="sourceLine" id="cb1285-6" data-line-number="6">    pointer first ;</a>
<a class="sourceLine" id="cb1285-7" data-line-number="7">    <span class="co">// 最後の要素のひとつ前方のポインター</span></a>
<a class="sourceLine" id="cb1285-8" data-line-number="8">    pointer last ;</a>
<a class="sourceLine" id="cb1285-9" data-line-number="9">    <span class="co">// 確保したストレージの終端</span></a>
<a class="sourceLine" id="cb1285-10" data-line-number="10">    pointer reserved_last ;</a>
<a class="sourceLine" id="cb1285-11" data-line-number="11">    <span class="co">// アロケーターの値</span></a>
<a class="sourceLine" id="cb1285-12" data-line-number="12">    <span class="dt">allocator_type</span> alloc ;</a>
<a class="sourceLine" id="cb1285-13" data-line-number="13">} ;</a></code></pre></div>
<p>このように実装すると、現在有効な要素数は<code>last - first</code>で得られる。確保したストレージのサイズは<code>reserved_last - first</code>だ。ポインターで持つことによってポインターが必要な場面でポインターと整数の演算を必要としない。</p>
<p>効率的な実装はC++が実行される環境によっても異なるので、すべての環境に最適な実装はない。</p>
<h2 id="簡単なメンバー関数の実装">簡単なメンバー関数の実装</h2>
<p>簡易vectorの簡単なメンバー関数を実装していく。ここでのサンプルコードはすべて簡易vectorのクラス定義の中に書いたかのように扱う。例えば</p>
<div class="sourceCode" id="cb1286"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1286-1" data-line-number="1"><span class="dt">void</span> f() { }</a></code></pre></div>
<p>とある場合、これは、</p>
<div class="sourceCode" id="cb1287"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1287-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> T, <span class="kw">typename</span> Allocator = <span class="bu">std::</span>allocator&lt;T&gt; &gt;</a>
<a class="sourceLine" id="cb1287-2" data-line-number="2"><span class="kw">class</span> vector</a>
<a class="sourceLine" id="cb1287-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb1287-4" data-line-number="4">    <span class="co">// その他のメンバーすべて</span></a>
<a class="sourceLine" id="cb1287-5" data-line-number="5"><span class="kw">public</span> :</a>
<a class="sourceLine" id="cb1287-6" data-line-number="6">    <span class="dt">void</span> f() {}</a>
<a class="sourceLine" id="cb1287-7" data-line-number="7">} ;</a></code></pre></div>
<p>のように書いたものとして考えよう。</p>
<h3 id="イテレーター">イテレーター</h3>
<p>簡易vectorは要素の集合を配列のように連続したストレージ上に構築された要素として保持する。したがってイテレーターは単にポインターを返すだけでよい。</p>
<p>まず通常のイテレーター</p>
<div class="sourceCode" id="cb1288"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1288-1" data-line-number="1">iterator begin() <span class="kw">noexcept</span></a>
<a class="sourceLine" id="cb1288-2" data-line-number="2">{ <span class="cf">return</span> first ; }</a>
<a class="sourceLine" id="cb1288-3" data-line-number="3">iterator end() <span class="kw">noexcept</span></a>
<a class="sourceLine" id="cb1288-4" data-line-number="4">{ <span class="cf">return</span> last ; }</a></code></pre></div>
<p>これは簡単だ。<code>iterator</code>型は実際には<code>T *</code>型へのエイリアスだ。このメンバー関数は例外を投げないので<code>noexcept</code>を指定する。</p>
<p><code>vector</code>のオブジェクトがconstの場合、<code>begin/end</code>は<code>const_iterator</code>が返る。</p>
<div class="sourceCode" id="cb1289"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1289-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1289-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1289-3" data-line-number="3">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v(<span class="dv">1</span>) ;</a>
<a class="sourceLine" id="cb1289-4" data-line-number="4">    <span class="co">// std::vector&lt;int&gt;::iterator</span></a>
<a class="sourceLine" id="cb1289-5" data-line-number="5">    <span class="kw">auto</span> i = v.begin() ;</a>
<a class="sourceLine" id="cb1289-6" data-line-number="6">    <span class="co">// OK、代入可能</span></a>
<a class="sourceLine" id="cb1289-7" data-line-number="7">    *i = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb1289-8" data-line-number="8">    <span class="co">// constなvectorへのリファレンス</span></a>
<a class="sourceLine" id="cb1289-9" data-line-number="9">    <span class="kw">auto</span> <span class="at">const</span> &amp; cv = v ;</a>
<a class="sourceLine" id="cb1289-10" data-line-number="10">    <span class="co">// std::vector&lt;int&gt;::const_iterator</span></a>
<a class="sourceLine" id="cb1289-11" data-line-number="11">    <span class="kw">auto</span> ci = cv.begin() ;</a>
<a class="sourceLine" id="cb1289-12" data-line-number="12">    <span class="co">// エラー</span></a>
<a class="sourceLine" id="cb1289-13" data-line-number="13">    <span class="co">// const_iteratorを参照した先には代入できない</span></a>
<a class="sourceLine" id="cb1289-14" data-line-number="14">    *ci = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb1289-15" data-line-number="15">}</a></code></pre></div>
<p>これを実現するには、メンバー関数をconst修飾する。</p>
<div class="sourceCode" id="cb1290"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1290-1" data-line-number="1"><span class="kw">struct</span> Foo</a>
<a class="sourceLine" id="cb1290-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1290-3" data-line-number="3">    <span class="co">// 非const版</span></a>
<a class="sourceLine" id="cb1290-4" data-line-number="4">    <span class="dt">void</span> f() {}</a>
<a class="sourceLine" id="cb1290-5" data-line-number="5">    <span class="co">// const版</span></a>
<a class="sourceLine" id="cb1290-6" data-line-number="6">    <span class="dt">void</span> f() <span class="at">const</span> { }</a>
<a class="sourceLine" id="cb1290-7" data-line-number="7">} ;</a>
<a class="sourceLine" id="cb1290-8" data-line-number="8"></a>
<a class="sourceLine" id="cb1290-9" data-line-number="9"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1290-10" data-line-number="10">{</a>
<a class="sourceLine" id="cb1290-11" data-line-number="11">    <span class="co">// aは非constなオブジェクト</span></a>
<a class="sourceLine" id="cb1290-12" data-line-number="12">    Foo a ;</a>
<a class="sourceLine" id="cb1290-13" data-line-number="13">    <span class="co">// 非const版が呼ばれる</span></a>
<a class="sourceLine" id="cb1290-14" data-line-number="14">    a.f() ;</a>
<a class="sourceLine" id="cb1290-15" data-line-number="15">    <span class="co">// constなリファレンス</span></a>
<a class="sourceLine" id="cb1290-16" data-line-number="16">    <span class="at">const</span> Foo &amp; cref = a ;</a>
<a class="sourceLine" id="cb1290-17" data-line-number="17">    <span class="co">// const版が呼ばれる</span></a>
<a class="sourceLine" id="cb1290-18" data-line-number="18">    cref.f() ;</a>
<a class="sourceLine" id="cb1290-19" data-line-number="19">}</a></code></pre></div>
<p>すでに学んだようにconst修飾はthisポインターを修飾する。オブジェクトのconst性によって、適切な方のメンバー関数が呼ばれてくれる。</p>
<p>簡易vectorでの実装は単にconst修飾するだけだ。</p>
<div class="sourceCode" id="cb1291"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1291-1" data-line-number="1">iterator begin() <span class="at">const</span> <span class="kw">noexcept</span></a>
<a class="sourceLine" id="cb1291-2" data-line-number="2">{ <span class="cf">return</span> first ; }</a>
<a class="sourceLine" id="cb1291-3" data-line-number="3">iterator end() <span class="at">const</span> <span class="kw">noexcept</span></a>
<a class="sourceLine" id="cb1291-4" data-line-number="4">{ <span class="cf">return</span> last ; }</a></code></pre></div>
<p>constではないvectorのオブジェクトから<code>const_iterator</code>がほしいときに、わざわざconstなリファレンスに変換するのは面倒なので、<code>const_reference</code>を返す<code>cbegin/cend</code>もある。</p>
<div class="sourceCode" id="cb1292"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1292-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1292-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1292-3" data-line-number="3">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v(<span class="dv">1</span>) ;</a>
<a class="sourceLine" id="cb1292-4" data-line-number="4">    <span class="co">// std::vector&lt;int&gt;::const_iterator</span></a>
<a class="sourceLine" id="cb1292-5" data-line-number="5">    <span class="kw">auto</span> i = v.cbegin() ;</a>
<a class="sourceLine" id="cb1292-6" data-line-number="6">}</a></code></pre></div>
<p>この実装はメンバー関数名以外同じだ。</p>
<div class="sourceCode" id="cb1293"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1293-1" data-line-number="1">const_iterator cbegin() <span class="at">const</span> <span class="kw">noexcept</span></a>
<a class="sourceLine" id="cb1293-2" data-line-number="2">{ <span class="cf">return</span> first ; }</a>
<a class="sourceLine" id="cb1293-3" data-line-number="3">const_iterator cend() <span class="at">const</span> <span class="kw">noexcept</span></a>
<a class="sourceLine" id="cb1293-4" data-line-number="4">{ <span class="cf">return</span> last ; }</a></code></pre></div>
<p><code>std::vector</code>にはリバースイテレーターを返すメンバー関数<code>rbegin/rend</code>と<code>crbegin/crend</code>がある。</p>
<div class="sourceCode" id="cb1294"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1294-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1294-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1294-3" data-line-number="3">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</a>
<a class="sourceLine" id="cb1294-4" data-line-number="4"></a>
<a class="sourceLine" id="cb1294-5" data-line-number="5">    <span class="co">// イテレーター</span></a>
<a class="sourceLine" id="cb1294-6" data-line-number="6">    <span class="kw">auto</span> i = v.begin() ;</a>
<a class="sourceLine" id="cb1294-7" data-line-number="7">    *i ; <span class="co">// 1</span></a>
<a class="sourceLine" id="cb1294-8" data-line-number="8"></a>
<a class="sourceLine" id="cb1294-9" data-line-number="9">    <span class="co">// リバースイテレーター</span></a>
<a class="sourceLine" id="cb1294-10" data-line-number="10">    <span class="kw">auto</span> r = v.rbegin() ;</a>
<a class="sourceLine" id="cb1294-11" data-line-number="11">    *r ; <span class="co">// 5</span></a>
<a class="sourceLine" id="cb1294-12" data-line-number="12">}</a></code></pre></div>
<p><code>begin</code>に対する<code>rbegin/rend</code>の実装は以下のようになる。<code>crbegin/crend</code>は自分で実装してみよう。</p>
<div class="sourceCode" id="cb1295"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1295-1" data-line-number="1">reverse_iterator rbegin() <span class="kw">noexcept</span></a>
<a class="sourceLine" id="cb1295-2" data-line-number="2">{ <span class="cf">return</span> reverse_iterator{ last } ; }</a>
<a class="sourceLine" id="cb1295-3" data-line-number="3">reverse_iterator rend() <span class="kw">noexcept</span></a>
<a class="sourceLine" id="cb1295-4" data-line-number="4">{ <span class="cf">return</span> reverse_iterator{ first } ; }</a></code></pre></div>
<p>return文で<code>T{e}</code>という形の明示的な型変換を使っている。これには理由がある。</p>
<p>C++では引数が1つしかないコンストラクターを<code>変換コンストラクター</code>として特別に扱う。</p>
<p>例えば以下は数値のように振る舞う<code>Number</code>クラスの例だ。</p>
<div class="sourceCode" id="cb1296"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1296-1" data-line-number="1"><span class="kw">class</span> Number</a>
<a class="sourceLine" id="cb1296-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1296-3" data-line-number="3">    Number( <span class="dt">int</span> i ) ;</a>
<a class="sourceLine" id="cb1296-4" data-line-number="4">    Number( <span class="dt">double</span> d ) ;</a>
<a class="sourceLine" id="cb1296-5" data-line-number="5">    Number( <span class="bu">std::</span>string s ) ;</a>
<a class="sourceLine" id="cb1296-6" data-line-number="6">} ;</a></code></pre></div>
<p>この<code>Number</code>は初期値をコンストラクターで取る。そのとき、int型、double型、はては文字列で数値を表現したstd::string型まで取る。この3つのコンストラクターは引数が1つしかないため変換コンストラクターだ。</p>
<p>クラスは変換コンストラクターの引数の型から暗黙に型変換できる。</p>
<p>例えば<code>Number</code>クラスを引数に取る関数があると、</p>
<div class="sourceCode" id="cb1297"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1297-1" data-line-number="1"><span class="dt">void</span> print_number( Number n ) ;</a></code></pre></div>
<p>変換コンストラクターの型の値を渡せる。</p>
<div class="sourceCode" id="cb1298"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1298-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1298-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1298-3" data-line-number="3">    <span class="co">// int型から変換</span></a>
<a class="sourceLine" id="cb1298-4" data-line-number="4">    print_number( <span class="dv">123</span> ) ;</a>
<a class="sourceLine" id="cb1298-5" data-line-number="5">    <span class="co">// double型から変換</span></a>
<a class="sourceLine" id="cb1298-6" data-line-number="6">    print_number( <span class="fl">3.14</span> ) ;</a>
<a class="sourceLine" id="cb1298-7" data-line-number="7">    <span class="co">// std::string型から変換</span></a>
<a class="sourceLine" id="cb1298-8" data-line-number="8">    print_number( <span class="st">&quot;3.14&quot;</span>s ) ;</a>
<a class="sourceLine" id="cb1298-9" data-line-number="9">}</a></code></pre></div>
<p>intやdoubleやstd::stringはNumberではないが、変換コンストラクターによって暗黙に型変換される。</p>
<p>戻り値として返すときにも変換できる。</p>
<div class="sourceCode" id="cb1299"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1299-1" data-line-number="1"><span class="co">// Number型のゼロを返す</span></a>
<a class="sourceLine" id="cb1299-2" data-line-number="2">Number zero()</a>
<a class="sourceLine" id="cb1299-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb1299-4" data-line-number="4">    <span class="co">// int型から変換</span></a>
<a class="sourceLine" id="cb1299-5" data-line-number="5">    <span class="cf">return</span> <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb1299-6" data-line-number="6">}</a></code></pre></div>
<p>しかし、場合によってはこのような暗黙の型変換を行いたくないこともある。そういう場合、コンストラクターに<code>explicit</code>キーワードをつけると、暗黙の型変換を禁止させることができる。</p>
<div class="sourceCode" id="cb1300"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1300-1" data-line-number="1"></a>
<a class="sourceLine" id="cb1300-2" data-line-number="2"><span class="kw">class</span> Number</a>
<a class="sourceLine" id="cb1300-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb1300-4" data-line-number="4">    <span class="kw">explicit</span> Number( <span class="dt">int</span> i ) ;</a>
<a class="sourceLine" id="cb1300-5" data-line-number="5">    <span class="kw">explicit</span> Number( <span class="dt">double</span> d ) ;</a>
<a class="sourceLine" id="cb1300-6" data-line-number="6">    <span class="kw">explicit</span> Number( <span class="bu">std::</span>string s ) ;</a>
<a class="sourceLine" id="cb1300-7" data-line-number="7">} ;</a></code></pre></div>
<p>実は<code>std::reverse_iterator&lt;Iterator&gt;</code>のコンストラクターにも<code>explicit</code>キーワードがついている。</p>
<div class="sourceCode" id="cb1301"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1301-1" data-line-number="1"><span class="kw">namespace</span> std {</a>
<a class="sourceLine" id="cb1301-2" data-line-number="2"><span class="kw">template</span>&lt; <span class="kw">typename</span>  Iterator &gt;</a>
<a class="sourceLine" id="cb1301-3" data-line-number="3"><span class="kw">class</span> reverse_iterator</a>
<a class="sourceLine" id="cb1301-4" data-line-number="4">{</a>
<a class="sourceLine" id="cb1301-5" data-line-number="5">    <span class="kw">constexpr</span> <span class="kw">explicit</span> reverse_iterator(Iterator x);</a>
<a class="sourceLine" id="cb1301-6" data-line-number="6">    <span class="co">// ...</span></a>
<a class="sourceLine" id="cb1301-7" data-line-number="7">} ;</a>
<a class="sourceLine" id="cb1301-8" data-line-number="8">}</a></code></pre></div>
<p><code>explicit</code>キーワード付きの変換コンストラクターを持つクラスは、暗黙の型変換ができないので、明示的に型変換しなければならない。</p>
<h3 id="容量確認">容量確認</h3>
<p><code>std::vector</code>には容量を確認するメンバー関数がある。</p>
<div class="sourceCode" id="cb1302"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1302-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1302-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1302-3" data-line-number="3">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v ;</a>
<a class="sourceLine" id="cb1302-4" data-line-number="4">    <span class="co">// true、要素数0</span></a>
<a class="sourceLine" id="cb1302-5" data-line-number="5">    <span class="dt">bool</span> a = v.empty() ;</a>
<a class="sourceLine" id="cb1302-6" data-line-number="6">    v.push_back(<span class="dv">0</span>) ;</a>
<a class="sourceLine" id="cb1302-7" data-line-number="7">    <span class="co">// false、要素数非ゼロ</span></a>
<a class="sourceLine" id="cb1302-8" data-line-number="8">    <span class="dt">bool</span> b = v.empty() ;</a>
<a class="sourceLine" id="cb1302-9" data-line-number="9">    <span class="co">// 1、現在の要素数</span></a>
<a class="sourceLine" id="cb1302-10" data-line-number="10">    <span class="kw">auto</span> s = v.size() ;</a>
<a class="sourceLine" id="cb1302-11" data-line-number="11">    <span class="co">// 実装依存、追加の動的メモリ確保をせずに格納できる要素の最大数</span></a>
<a class="sourceLine" id="cb1302-12" data-line-number="12">    <span class="kw">auto</span> c = v.capacity() ;</a>
<a class="sourceLine" id="cb1302-13" data-line-number="13">}</a></code></pre></div>
<p>早速実装していこう。</p>
<p><code>size</code>は要素数を返す。イテレーターの距離を求めればよい。</p>
<div class="sourceCode" id="cb1303"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1303-1" data-line-number="1"><span class="dt">size_type</span> size() <span class="at">const</span> <span class="kw">noexcept</span></a>
<a class="sourceLine" id="cb1303-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1303-3" data-line-number="3">    <span class="cf">return</span> end() - begin() ;</a>
<a class="sourceLine" id="cb1303-4" data-line-number="4">} ;</a></code></pre></div>
<p>イテレーターライブラリを使ってもよい。本物の<code>std::vector</code>では以下のように実装されている。</p>
<div class="sourceCode" id="cb1304"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1304-1" data-line-number="1"><span class="dt">size_type</span> size() <span class="at">const</span> <span class="kw">noexcept</span></a>
<a class="sourceLine" id="cb1304-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1304-3" data-line-number="3">    <span class="cf">return</span> <span class="bu">std::</span>distance( begin(), end() ) ;</a>
<a class="sourceLine" id="cb1304-4" data-line-number="4">} ;</a></code></pre></div>
<p><code>empty</code>は空であればtrue、そうでなければfalseを返す。「空」というのは要素数がゼロという意味だ。</p>
<div class="sourceCode" id="cb1305"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1305-1" data-line-number="1"><span class="dt">bool</span> empty() <span class="at">const</span> <span class="kw">noexcept</span></a>
<a class="sourceLine" id="cb1305-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1305-3" data-line-number="3">    <span class="cf">return</span> size() == <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb1305-4" data-line-number="4">}</a></code></pre></div>
<p>しかし<code>size() == 0</code>というのは、<code>begin() == end()</code>ということだ。なぜならば要素数が0であれば、イテレーターのペアはどちらも終端のイテレーターを差しているからだ。本物の<code>std::vector</code>では以下のように実装されている。</p>
<div class="sourceCode" id="cb1306"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1306-1" data-line-number="1"><span class="dt">bool</span> empty() <span class="at">const</span> <span class="kw">noexcept</span></a>
<a class="sourceLine" id="cb1306-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1306-3" data-line-number="3">    <span class="cf">return</span> begin() == end() ;</a>
<a class="sourceLine" id="cb1306-4" data-line-number="4">}</a></code></pre></div>
<p><code>capacity</code>は、追加の動的メモリ確保をせずに追加できる要素の最大数を返す。これを計算するには、動的確保したストレージの末尾の1つ次のポインターであるデータメンバーである<code>reserved_last</code>を使う。最初の要素へのポインターである<code>first</code>から<code>reserved_last</code>までの距離が答えだ。ポインターの距離はイテレーターと同じく引き算する。</p>
<div class="sourceCode" id="cb1307"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1307-1" data-line-number="1"><span class="dt">size_type</span> capacity() <span class="at">const</span> <span class="kw">noexcept</span></a>
<a class="sourceLine" id="cb1307-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1307-3" data-line-number="3">    <span class="cf">return</span> reserved_last - first ;</a>
<a class="sourceLine" id="cb1307-4" data-line-number="4">}</a></code></pre></div>
<h3 id="要素アクセス">要素アクセス</h3>
<h4 id="operator">operator []</h4>
<p><code>std::vector</code>の<code>operator []</code>相当のものを簡易vectorにも実装しよう。</p>
<div class="sourceCode" id="cb1308"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1308-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1308-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1308-3" data-line-number="3">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</a>
<a class="sourceLine" id="cb1308-4" data-line-number="4">    v[<span class="dv">1</span>] ; <span class="co">// 2</span></a>
<a class="sourceLine" id="cb1308-5" data-line-number="5">    v[<span class="dv">3</span>] ; <span class="co">// 4</span></a>
<a class="sourceLine" id="cb1308-6" data-line-number="6">}</a></code></pre></div>
<p><code>operator []</code>は非const版とconst版の2種類がある。</p>
<div class="sourceCode" id="cb1309"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1309-1" data-line-number="1">reference <span class="kw">operator</span> []( <span class="dt">size_type</span> i )</a>
<a class="sourceLine" id="cb1309-2" data-line-number="2">{ <span class="cf">return</span> first[i] ; }</a>
<a class="sourceLine" id="cb1309-3" data-line-number="3">const_reference <span class="kw">operator</span> []( <span class="dt">size_type</span> i ) <span class="at">const</span></a>
<a class="sourceLine" id="cb1309-4" data-line-number="4">{ <span class="cf">return</span> first[i] ; }</a></code></pre></div>
<h4 id="at">at</h4>
<p>メンバー関数<code>at(i)</code>は<code>operator [](i)</code>と同じだが、範囲外のインデックスを指定した場合、<code>std::out_of_range</code>が例外として投げられる。</p>
<div class="sourceCode" id="cb1310"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1310-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1310-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1310-3" data-line-number="3">    <span class="cf">try</span> {</a>
<a class="sourceLine" id="cb1310-4" data-line-number="4">        <span class="co">// 有効なインデックスはv[0]からv[4]まで</span></a>
<a class="sourceLine" id="cb1310-5" data-line-number="5">        <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</a>
<a class="sourceLine" id="cb1310-6" data-line-number="6">        v[<span class="dv">0</span>] = <span class="dv">0</span> ; <span class="co">// OK</span></a>
<a class="sourceLine" id="cb1310-7" data-line-number="7">        v[<span class="dv">3</span>] = <span class="dv">0</span> ; <span class="co">// OK</span></a>
<a class="sourceLine" id="cb1310-8" data-line-number="8">        v[<span class="dv">5</span>] = <span class="dv">0</span> ; <span class="co">// エラー</span></a>
<a class="sourceLine" id="cb1310-9" data-line-number="9">    } <span class="cf">catch</span>( <span class="bu">std::</span>out_of_range e )</a>
<a class="sourceLine" id="cb1310-10" data-line-number="10">    {</a>
<a class="sourceLine" id="cb1310-11" data-line-number="11">        <span class="bu">std::</span>cout &lt;&lt; e.what() ;</a>
<a class="sourceLine" id="cb1310-12" data-line-number="12">    }</a>
<a class="sourceLine" id="cb1310-13" data-line-number="13">}</a></code></pre></div>
<p>実装はインデックスを<code>size()</code>と比較して、範囲外であれば<code>std::out_of_range</code>をthrowする。<code>operator []</code>と同じく、非const版とconst版がある。</p>
<div class="sourceCode" id="cb1311"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1311-1" data-line-number="1">reference at( <span class="dt">size_type</span> i )</a>
<a class="sourceLine" id="cb1311-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1311-3" data-line-number="3">    <span class="cf">if</span> ( i &gt;= size() )</a>
<a class="sourceLine" id="cb1311-4" data-line-number="4">        <span class="cf">throw</span> <span class="bu">std::</span>out_of_range( <span class="st">&quot;index is out of range.&quot;</span> ) ;</a>
<a class="sourceLine" id="cb1311-5" data-line-number="5"></a>
<a class="sourceLine" id="cb1311-6" data-line-number="6">    <span class="cf">return</span> first[i] ;</a>
<a class="sourceLine" id="cb1311-7" data-line-number="7">}</a>
<a class="sourceLine" id="cb1311-8" data-line-number="8">const_reference at( <span class="dt">size_type</span> i ) <span class="at">const</span></a>
<a class="sourceLine" id="cb1311-9" data-line-number="9">{</a>
<a class="sourceLine" id="cb1311-10" data-line-number="10">    <span class="cf">if</span> ( i &gt;= size() )</a>
<a class="sourceLine" id="cb1311-11" data-line-number="11">        <span class="cf">throw</span> <span class="bu">std::</span>out_of_range( <span class="st">&quot;index is out of range.&quot;</span> ) ;</a>
<a class="sourceLine" id="cb1311-12" data-line-number="12"></a>
<a class="sourceLine" id="cb1311-13" data-line-number="13">    <span class="cf">return</span> first[i] ;</a>
<a class="sourceLine" id="cb1311-14" data-line-number="14">}</a></code></pre></div>
<h4 id="frontback">front/back</h4>
<p><code>front()</code>は先頭要素へのリファレンスを返す。</p>
<p><code>back()</code>は末尾の要素へのリファレンスを返す</p>
<div class="sourceCode" id="cb1312"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1312-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1312-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1312-3" data-line-number="3">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</a>
<a class="sourceLine" id="cb1312-4" data-line-number="4">    v.front() ; <span class="co">// 1</span></a>
<a class="sourceLine" id="cb1312-5" data-line-number="5">    v.back() ; <span class="co">// 5</span></a>
<a class="sourceLine" id="cb1312-6" data-line-number="6">}</a></code></pre></div>
<p>これにもconst版と非const版がある。<code>vector</code>の<code>last</code>が最後の要素の次のポインターを指していることに注意。</p>
<div class="sourceCode" id="cb1313"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1313-1" data-line-number="1">reference front()</a>
<a class="sourceLine" id="cb1313-2" data-line-number="2">{ <span class="cf">return</span> first ; }</a>
<a class="sourceLine" id="cb1313-3" data-line-number="3">const_reference front() <span class="at">const</span></a>
<a class="sourceLine" id="cb1313-4" data-line-number="4">{ <span class="cf">return</span> first ; }</a>
<a class="sourceLine" id="cb1313-5" data-line-number="5">reference back()</a>
<a class="sourceLine" id="cb1313-6" data-line-number="6">{ <span class="cf">return</span> last - <span class="dv">1</span> ; }</a>
<a class="sourceLine" id="cb1313-7" data-line-number="7">const_reference back() <span class="at">const</span></a>
<a class="sourceLine" id="cb1313-8" data-line-number="8">{ <span class="cf">return</span> last - <span class="dv">1</span> ; }</a></code></pre></div>
<h4 id="data">data</h4>
<p><code>data()</code>は先頭の要素へのポインターを返す。</p>
<div class="sourceCode" id="cb1314"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1314-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1314-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1314-3" data-line-number="3">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>} ;</a>
<a class="sourceLine" id="cb1314-4" data-line-number="4">    <span class="dt">int</span> * ptr = v.data() ;</a>
<a class="sourceLine" id="cb1314-5" data-line-number="5">    *ptr ; <span class="co">// 1</span></a>
<a class="sourceLine" id="cb1314-6" data-line-number="6">}</a></code></pre></div>
<p>実装は<code>first</code>を返すだけだ。</p>
<div class="sourceCode" id="cb1315"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1315-1" data-line-number="1">pointer data() <span class="kw">noexcept</span></a>
<a class="sourceLine" id="cb1315-2" data-line-number="2">{ <span class="cf">return</span> first ; }</a>
<a class="sourceLine" id="cb1315-3" data-line-number="3">const_pointer data() <span class="at">const</span> <span class="kw">noexcept</span></a>
<a class="sourceLine" id="cb1315-4" data-line-number="4">{ <span class="cf">return</span> first ; }</a></code></pre></div>
<h1 id="vectorの実装-メモリ確保">vectorの実装 : メモリ確保</h1>
<h2 id="メモリ確保の起こるタイミング">メモリ確保の起こるタイミング</h2>
<p><code>std::vector</code>はどこでメモリを確保しているのだろうか。</p>
<p>デフォルト構築すると空になる。</p>
<div class="sourceCode" id="cb1316"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1316-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1316-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1316-3" data-line-number="3">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v ;</a>
<a class="sourceLine" id="cb1316-4" data-line-number="4">    v.empty() ; <span class="co">// bool</span></a>
<a class="sourceLine" id="cb1316-5" data-line-number="5">}</a></code></pre></div>
<p>コンストラクターに要素数を渡すことができる。</p>
<div class="sourceCode" id="cb1317"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1317-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1317-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1317-3" data-line-number="3">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v(<span class="dv">100</span>) ;</a>
<a class="sourceLine" id="cb1317-4" data-line-number="4">    v.size() ; <span class="co">// 100</span></a>
<a class="sourceLine" id="cb1317-5" data-line-number="5">}</a></code></pre></div>
<p>すると<code>std::vector</code>は指定した要素数の有効な要素をもつ。</p>
<p>コンストラクターに要素数と初期値を渡すことができる。</p>
<div class="sourceCode" id="cb1318"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1318-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1318-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1318-3" data-line-number="3">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v(<span class="dv">100</span>, <span class="dv">123</span>) ;</a>
<a class="sourceLine" id="cb1318-4" data-line-number="4">    v[<span class="dv">0</span>] ; <span class="co">// 123</span></a>
<a class="sourceLine" id="cb1318-5" data-line-number="5">    v[<span class="dv">12</span>] ; <span class="co">// 123</span></a>
<a class="sourceLine" id="cb1318-6" data-line-number="6">    v[<span class="dv">68</span>] ; <span class="co">// 123</span></a>
<a class="sourceLine" id="cb1318-7" data-line-number="7">}</a></code></pre></div>
<p>すると、指定した要素数で、要素の値はすべて初期値になる。</p>
<p>vectorのオブジェクトを構築した後でも、メンバー関数<code>resize(size)</code>で要素数を<code>size</code>個にできる。</p>
<div class="sourceCode" id="cb1319"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1319-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1319-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1319-3" data-line-number="3">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v ;</a>
<a class="sourceLine" id="cb1319-4" data-line-number="4">    v.resize(<span class="dv">10</span>) ;</a>
<a class="sourceLine" id="cb1319-5" data-line-number="5">    v.size() ; <span class="co">// 10</span></a>
<a class="sourceLine" id="cb1319-6" data-line-number="6">    <span class="co">// 減らす</span></a>
<a class="sourceLine" id="cb1319-7" data-line-number="7">    v.resize(<span class="dv">5</span>) ;</a>
<a class="sourceLine" id="cb1319-8" data-line-number="8">    v.size(<span class="dv">5</span>) ;</a>
<a class="sourceLine" id="cb1319-9" data-line-number="9">}</a></code></pre></div>
<p><code>resize</code>で要素数が増える場合、増えた要素の初期値も指定できる。</p>
<div class="sourceCode" id="cb1320"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1320-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1320-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1320-3" data-line-number="3">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v ;</a>
<a class="sourceLine" id="cb1320-4" data-line-number="4">    v.resize(<span class="dv">3</span>, <span class="dv">123</span>) ;</a>
<a class="sourceLine" id="cb1320-5" data-line-number="5">    <span class="co">// vは{123,123,123}</span></a>
<a class="sourceLine" id="cb1320-6" data-line-number="6">}</a></code></pre></div>
<p><code>resize</code>で要素数が減る場合、末尾が削られる。</p>
<div class="sourceCode" id="cb1321"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1321-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1321-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1321-3" data-line-number="3">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</a>
<a class="sourceLine" id="cb1321-4" data-line-number="4">    v.resize(<span class="dv">3</span>) ;</a>
<a class="sourceLine" id="cb1321-5" data-line-number="5">    <span class="co">// vは{1,2,3}</span></a>
<a class="sourceLine" id="cb1321-6" data-line-number="6">}</a></code></pre></div>
<p>メンバー関数<code>push_back(value)</code>を呼び出すと要素数が1増え、要素の末尾の要素が値<code>value</code>になる。</p>
<div class="sourceCode" id="cb1322"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1322-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1322-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1322-3" data-line-number="3">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v ;</a>
<a class="sourceLine" id="cb1322-4" data-line-number="4">    <span class="co">// vは{}</span></a>
<a class="sourceLine" id="cb1322-5" data-line-number="5">    v.push_back(<span class="dv">1</span>) ;</a>
<a class="sourceLine" id="cb1322-6" data-line-number="6">    <span class="co">// vは{1}</span></a>
<a class="sourceLine" id="cb1322-7" data-line-number="7">    v.push_back(<span class="dv">2</span>) ;</a>
<a class="sourceLine" id="cb1322-8" data-line-number="8">    <span class="co">// vは[1,2}</span></a>
<a class="sourceLine" id="cb1322-9" data-line-number="9">    v.push_back(<span class="dv">3</span>) ;</a>
<a class="sourceLine" id="cb1322-10" data-line-number="10">    <span class="co">// vは{1,2,3}</span></a>
<a class="sourceLine" id="cb1322-11" data-line-number="11">}</a></code></pre></div>
<p><code>reserve(size)</code>は少なくとも<code>size</code>個の要素が追加の動的メモリ確保なしで追加できるようにメモリを予約する。</p>
<div class="sourceCode" id="cb1323"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1323-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1323-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1323-3" data-line-number="3">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v ;</a>
<a class="sourceLine" id="cb1323-4" data-line-number="4">    <span class="co">// 少なくとも3個の要素を追加できるように動的メモリ確保</span></a>
<a class="sourceLine" id="cb1323-5" data-line-number="5">    v.reserve(<span class="dv">3</span>) ;</a>
<a class="sourceLine" id="cb1323-6" data-line-number="6">    v.size() ; <span class="co">// 0</span></a>
<a class="sourceLine" id="cb1323-7" data-line-number="7">    v.capacity() ; <span class="co">// 3以上</span></a>
<a class="sourceLine" id="cb1323-8" data-line-number="8"></a>
<a class="sourceLine" id="cb1323-9" data-line-number="9">    <span class="co">// 動的メモリ確保は発生しない</span></a>
<a class="sourceLine" id="cb1323-10" data-line-number="10">    v.push_back(<span class="dv">1</span>) ;</a>
<a class="sourceLine" id="cb1323-11" data-line-number="11">    v.push_back(<span class="dv">2</span>) ;</a>
<a class="sourceLine" id="cb1323-12" data-line-number="12">    v.push_back(<span class="dv">3</span>) ;</a>
<a class="sourceLine" id="cb1323-13" data-line-number="13">    <span class="co">// 動的メモリ確保が発生する可能性がある。</span></a>
<a class="sourceLine" id="cb1323-14" data-line-number="14">    v.push_back(<span class="dv">3</span>) ;</a>
<a class="sourceLine" id="cb1323-15" data-line-number="15">}</a></code></pre></div>
<p>この章ではここまでの実装をする。</p>
<h2 id="デフォルトコンストラクター">デフォルトコンストラクター</h2>
<p>簡易vectorのデフォルトコンストラクターは何もしない。</p>
<div class="sourceCode" id="cb1324"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1324-1" data-line-number="1">vector( ) { }</a></code></pre></div>
<p>何もしなくてもポインターはすべてnullptrで初期化され、アロケーターもデフォルト構築されるからだ。</p>
<p>これで簡易vectorの変数を作れるようになった。ただしまだ何もできない。</p>
<div class="sourceCode" id="cb1325"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1325-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1325-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1325-3" data-line-number="3">    vector&lt;<span class="dt">int</span>&gt; v ;</a>
<a class="sourceLine" id="cb1325-4" data-line-number="4">    <span class="co">// まだ何もできない。</span></a>
<a class="sourceLine" id="cb1325-5" data-line-number="5">}</a></code></pre></div>
<h2 id="アロケーターを取るコンストラクター">アロケーターを取るコンストラクター</h2>
<p><code>std::vector</code>のコンストラクターは最後の引数にアロケーターを取れる。</p>
<div class="sourceCode" id="cb1326"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1326-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1326-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1326-3" data-line-number="3">    <span class="bu">std::</span>allocator&lt;<span class="dt">int</span>&gt; alloc ;</a>
<a class="sourceLine" id="cb1326-4" data-line-number="4">    <span class="co">// 空</span></a>
<a class="sourceLine" id="cb1326-5" data-line-number="5">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v1(alloc) ;</a>
<a class="sourceLine" id="cb1326-6" data-line-number="6">    <span class="co">// 要素数5</span></a>
<a class="sourceLine" id="cb1326-7" data-line-number="7">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v2(<span class="dv">5</span>, alloc) ;</a>
<a class="sourceLine" id="cb1326-8" data-line-number="8">    <span class="co">// 要素数5で初期値123</span></a>
<a class="sourceLine" id="cb1326-9" data-line-number="9">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v3(<span class="dv">5</span>, <span class="dv">123</span>, alloc) ;</a>
<a class="sourceLine" id="cb1326-10" data-line-number="10">}</a></code></pre></div>
<p>これを実装するには、アロケーターを取ってデータメンバーにコピーするコンストラクターを書く。</p>
<div class="sourceCode" id="cb1327"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1327-1" data-line-number="1">vector( <span class="at">const</span> <span class="dt">allocator_type</span> &amp; alloc ) <span class="kw">noexcept</span></a>
<a class="sourceLine" id="cb1327-2" data-line-number="2">    alloc( alloc )</a>
<a class="sourceLine" id="cb1327-3" data-line-number="3">{ }</a></code></pre></div>
<p>他のコンストラクターはこのコンストラクターにまずデリゲートすればよい。</p>
<div class="sourceCode" id="cb1328"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1328-1" data-line-number="1">vector()</a>
<a class="sourceLine" id="cb1328-2" data-line-number="2">    : vector( <span class="dt">allocator_type</span>() )</a>
<a class="sourceLine" id="cb1328-3" data-line-number="3">{ }</a>
<a class="sourceLine" id="cb1328-4" data-line-number="4"></a>
<a class="sourceLine" id="cb1328-5" data-line-number="5">vector( <span class="dt">size_type</span> size, <span class="at">const</span> <span class="dt">allocator_type</span> &amp; alloc = <span class="dt">allocator_type</span>() )</a>
<a class="sourceLine" id="cb1328-6" data-line-number="6">    : vector( alloc )</a>
<a class="sourceLine" id="cb1328-7" data-line-number="7">{ <span class="co">/*実装*/</span> }</a>
<a class="sourceLine" id="cb1328-8" data-line-number="8">vector( <span class="dt">size_type</span> size, const_reference value, <span class="at">const</span> <span class="dt">allocator_type</span> &amp; alloc = <span class="dt">allocator_type</span>() )</a>
<a class="sourceLine" id="cb1328-9" data-line-number="9">    : vector( alloc )</a>
<a class="sourceLine" id="cb1328-10" data-line-number="10">{ <span class="co">/*実装*/</span> }</a></code></pre></div>
<h2 id="要素数と初期値を取るコンストラクターの実装">要素数と初期値を取るコンストラクターの実装</h2>
<p>要素数と初期値を取るコンストラクターは<code>resize</code>を使えば簡単に実装できる。</p>
<div class="sourceCode" id="cb1329"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1329-1" data-line-number="1">vector( <span class="dt">size_type</span> size, <span class="at">const</span> <span class="dt">allocator_type</span> &amp; alloc )</a>
<a class="sourceLine" id="cb1329-2" data-line-number="2">    : vector( alloc )</a>
<a class="sourceLine" id="cb1329-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb1329-4" data-line-number="4">    resize( size ) ;</a>
<a class="sourceLine" id="cb1329-5" data-line-number="5">}</a>
<a class="sourceLine" id="cb1329-6" data-line-number="6">vector( <span class="dt">size_type</span> size, const_reference value, <span class="at">const</span> <span class="dt">allocator_type</span> &amp; alloc )</a>
<a class="sourceLine" id="cb1329-7" data-line-number="7">    : vector( alloc )</a>
<a class="sourceLine" id="cb1329-8" data-line-number="8">{</a>
<a class="sourceLine" id="cb1329-9" data-line-number="9">    resize( size, value ) ;</a>
<a class="sourceLine" id="cb1329-10" data-line-number="10">}</a></code></pre></div>
<p>しかしこれは実装を<code>resize</code>に丸投げしただけだ。<code>resize</code>の実装をする前に、実装を楽にするヘルパー関数を実装する。</p>
<h2 id="ヘルパー関数">ヘルパー関数</h2>
<p>ここではvectorの実装を楽にするためのヘルパー関数をいくつか実装する。このヘルパー関数はユーザーから使うことは想定しないので、privateメンバーにする。</p>
<div class="sourceCode" id="cb1330"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1330-1" data-line-number="1"><span class="co">// 例</span></a>
<a class="sourceLine" id="cb1330-2" data-line-number="2"><span class="kw">struct</span> vector</a>
<a class="sourceLine" id="cb1330-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb1330-4" data-line-number="4"><span class="kw">private</span> :</a>
<a class="sourceLine" id="cb1330-5" data-line-number="5">    <span class="co">// ユーザーからは使えないヘルパー関数</span></a>
<a class="sourceLine" id="cb1330-6" data-line-number="6">    <span class="dt">void</span> helper_function() ;</a>
<a class="sourceLine" id="cb1330-7" data-line-number="7"><span class="kw">public</span> :</a>
<a class="sourceLine" id="cb1330-8" data-line-number="8">    <span class="co">// ユーザーが使える関数</span></a>
<a class="sourceLine" id="cb1330-9" data-line-number="9">    <span class="dt">void</span> func()</a>
<a class="sourceLine" id="cb1330-10" data-line-number="10">    {</a>
<a class="sourceLine" id="cb1330-11" data-line-number="11">        <span class="co">// ヘルパー関数を使って実装</span></a>
<a class="sourceLine" id="cb1330-12" data-line-number="12">        helper_function() ;</a>
<a class="sourceLine" id="cb1330-13" data-line-number="13">    }</a>
<a class="sourceLine" id="cb1330-14" data-line-number="14">} ;</a></code></pre></div>
<h3 id="ネストされた型名traits">ネストされた型名traits</h3>
<p>アロケーターは<code>allocator_traits</code>を経由して使う。実際のコードはとても冗長になる。</p>
<div class="sourceCode" id="cb1331"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1331-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> Allocator &gt;</a>
<a class="sourceLine" id="cb1331-2" data-line-number="2"><span class="dt">void</span> f( Allocator &amp; alloc )</a>
<a class="sourceLine" id="cb1331-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb1331-4" data-line-number="4">    <span class="bu">std::</span>allocator_traits&lt;Allocator&gt;::allocate( alloc, <span class="dv">1</span> ) ;</a>
<a class="sourceLine" id="cb1331-5" data-line-number="5">}</a></code></pre></div>
<p>この問題はエイリアス名を使えば解決できる。</p>
<div class="sourceCode" id="cb1332"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1332-1" data-line-number="1"><span class="kw">private</span> :</a>
<a class="sourceLine" id="cb1332-2" data-line-number="2">    <span class="kw">using</span> traits = <span class="bu">std::</span>allocator_traits&lt;<span class="dt">allocator_type</span>&gt; ;</a>
<a class="sourceLine" id="cb1332-3" data-line-number="3"></a>
<a class="sourceLine" id="cb1332-4" data-line-number="4">    <span class="kw">template</span> &lt; <span class="kw">typename</span> Allocator &gt;</a>
<a class="sourceLine" id="cb1332-5" data-line-number="5">    <span class="dt">void</span> f( Allocator &amp; alloc )</a>
<a class="sourceLine" id="cb1332-6" data-line-number="6">    {</a>
<a class="sourceLine" id="cb1332-7" data-line-number="7">        traits::allocate( alloc, <span class="dv">1</span> ) ;</a>
<a class="sourceLine" id="cb1332-8" data-line-number="8">    }</a></code></pre></div>
<h3 id="allocatedeallocate">allocate/deallocate</h3>
<p><code>allocate(n)</code>はアロケーターから<code>n</code>個の要素を格納できる生のメモリの動的確保をして先頭要素へのポインターを返す。</p>
<p><code>deallocate(ptr)</code>はポインター<code>ptr</code>を解放する。</p>
<div class="sourceCode" id="cb1333"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1333-1" data-line-number="1"><span class="kw">private</span>: </a>
<a class="sourceLine" id="cb1333-2" data-line-number="2">    pointer allocate( <span class="dt">size_type</span> n )</a>
<a class="sourceLine" id="cb1333-3" data-line-number="3">    { <span class="cf">return</span> traits::allocate( alloc, n ) ; }</a>
<a class="sourceLine" id="cb1333-4" data-line-number="4">    <span class="dt">void</span> deallocate( )</a>
<a class="sourceLine" id="cb1333-5" data-line-number="5">    { traits::deallocate( alloc, first, capacity() ) ; }</a></code></pre></div>
<h3 id="constructdestroy">construct/destroy</h3>
<p><code>construct(ptr)</code>は生のメモリへのポインター<code>ptr</code>に<code>vector</code>の<code>value_type</code>型の値をデフォルト構築する。</p>
<p><code>construct(ptr, value)</code>は生のメモリへのポインター<code>ptr</code>に値<code>value</code>のオブジェクトを構築する。</p>
<div class="sourceCode" id="cb1334"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1334-1" data-line-number="1"></a>
<a class="sourceLine" id="cb1334-2" data-line-number="2">    <span class="dt">void</span> construct( pointer ptr )</a>
<a class="sourceLine" id="cb1334-3" data-line-number="3">    { traits::construct( alloc, ptr ) ; }</a>
<a class="sourceLine" id="cb1334-4" data-line-number="4">    <span class="dt">void</span> construct( pointer ptr, const_reference value )</a>
<a class="sourceLine" id="cb1334-5" data-line-number="5">    { traits::construct( alloc, ptr, value ) ; }</a></code></pre></div>
<p><code>destroy(ptr)</code>は<code>ptr</code>の指すオブジェクトを破棄する。</p>
<div class="sourceCode" id="cb1335"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1335-1" data-line-number="1"><span class="kw">private</span> :</a>
<a class="sourceLine" id="cb1335-2" data-line-number="2">    <span class="dt">void</span> destroy( pointer ptr )</a>
<a class="sourceLine" id="cb1335-3" data-line-number="3">    { traits::destroy( alloc, ptr ) ; }</a></code></pre></div>
<h3 id="destroy_alldestroy_until"><code>destroy_all/destroy_until</code></h3>
<p><code>destroy_all()</code>は<code>vector</code>の要素を末尾から先頭に向けて順番に破棄する。</p>
<p><code>std::vector</code>の初期化では、要素は先頭から末尾に向けて順番に構築される。C++では破棄は構築の逆順に行われるので、<code>std::vector</code>の破棄にあたっては、要素は末尾から先頭に向けて順番に破棄される。</p>
<div class="sourceCode" id="cb1336"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1336-1" data-line-number="1"><span class="kw">struct</span> X</a>
<a class="sourceLine" id="cb1336-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1336-3" data-line-number="3">    X() { }</a>
<a class="sourceLine" id="cb1336-4" data-line-number="4">    ~X)() { }</a>
<a class="sourceLine" id="cb1336-5" data-line-number="5">} ;</a>
<a class="sourceLine" id="cb1336-6" data-line-number="6"></a>
<a class="sourceLine" id="cb1336-7" data-line-number="7"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1336-8" data-line-number="8">{</a>
<a class="sourceLine" id="cb1336-9" data-line-number="9">    <span class="bu">std::</span>vector&lt;X&gt; v(<span class="dv">3</span>) ;</a>
<a class="sourceLine" id="cb1336-10" data-line-number="10">}</a></code></pre></div>
<p>このコードでは、<code>v[0], v[1], v[2]</code>の順番に要素が構築され、<code>v[2], v[1], v[0]</code>の順番で破棄される。</p>
<p><code>destroy_all</code>の実装は、この次に説明する<code>destroy_until</code>を使う。</p>
<div class="sourceCode" id="cb1337"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1337-1" data-line-number="1"><span class="kw">private</span> :</a>
<a class="sourceLine" id="cb1337-2" data-line-number="2">    <span class="dt">void</span> destroy_all()</a>
<a class="sourceLine" id="cb1337-3" data-line-number="3">    {</a>
<a class="sourceLine" id="cb1337-4" data-line-number="4">        destroy_until( rend() ) ;</a>
<a class="sourceLine" id="cb1337-5" data-line-number="5">    }</a></code></pre></div>
<p><code>destroy_until(rend)</code>は、<code>vector</code>が保持する<code>rbegin()</code>からリバースイテレーター<code>rend</code>までの要素を破棄する。リーバスイテレーターを使うので、要素の末尾から先頭に向けて順番に破棄される。</p>
<div class="sourceCode" id="cb1338"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1338-1" data-line-number="1"><span class="kw">private</span> :</a>
<a class="sourceLine" id="cb1338-2" data-line-number="2">    <span class="dt">void</span> destroy_until( reverse_iterator rend )</a>
<a class="sourceLine" id="cb1338-3" data-line-number="3">    {</a>
<a class="sourceLine" id="cb1338-4" data-line-number="4">        <span class="cf">for</span> ( <span class="kw">auto</span> riter = rbegin() ; riter != rend ; ++riter )</a>
<a class="sourceLine" id="cb1338-5" data-line-number="5">        {</a>
<a class="sourceLine" id="cb1338-6" data-line-number="6">            destroy( &amp;*riter ) ;</a>
<a class="sourceLine" id="cb1338-7" data-line-number="7">        }</a>
<a class="sourceLine" id="cb1338-8" data-line-number="8">    }</a></code></pre></div>
<p><code>&amp;*riter</code>はやや泥臭い方法だ。簡易<code>vector&lt;T&gt;</code>の<code>iterator</code>は単なる<code>T *</code>だが、<code>riter</code>はリバースイテレーターなのでポインターではない。ポインターを取るために<code>*riter</code>でまず<code>T &amp;</code>を得て、そこに<code>&amp;</code>を適用することで<code>T *</code>を得ている。</p>
<h2 id="デストラクター">デストラクター</h2>
<p>ヘルパー関数を組み合わせることでデストラクターが実装できるようになった。</p>
<p><code>std::vector</code>のデストラクターは、</p>
<ol type="1">
<li>要素を末尾から先頭に向かう順番で破棄</li>
<li>生のメモリを解放する</li>
</ol>
<p>この2つの処理はすでに実装した。デストラクターの実装は単にヘルパー関数を並べて呼び出すだけでよい。</p>
<div class="sourceCode" id="cb1339"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1339-1" data-line-number="1">~vector()</a>
<a class="sourceLine" id="cb1339-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1339-3" data-line-number="3">    <span class="co">// 1. 要素を末尾から先頭に向かう順番で破棄</span></a>
<a class="sourceLine" id="cb1339-4" data-line-number="4">    destroy_all( ) ;</a>
<a class="sourceLine" id="cb1339-5" data-line-number="5">    <span class="co">// 2. 生のメモリを解放する</span></a>
<a class="sourceLine" id="cb1339-6" data-line-number="6">    deallocate() ;    </a>
<a class="sourceLine" id="cb1339-7" data-line-number="7">}         </a></code></pre></div>
<h2 id="reserveの実装">reserveの実装</h2>
<p>reserveの実装は生の動的メモリを確保してデータメンバーを適切に設定する。</p>
<p>ただし、いろいろと考慮すべきことが多い。</p>
<p>現在の<code>capacity</code>より小さい要素数が<code>reserve</code>された場合、無視してよい。</p>
<div class="sourceCode" id="cb1340"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1340-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1340-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1340-3" data-line-number="3">    <span class="co">// 要素数5</span></a>
<a class="sourceLine" id="cb1340-4" data-line-number="4">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</a>
<a class="sourceLine" id="cb1340-5" data-line-number="5">    <span class="co">// 3個の要素を保持できるよう予約</span></a>
<a class="sourceLine" id="cb1340-6" data-line-number="6">    v.reserve( <span class="dv">3</span> ) ;</a>
<a class="sourceLine" id="cb1340-7" data-line-number="7">    <span class="co">// 無視する</span></a>
<a class="sourceLine" id="cb1340-8" data-line-number="8">}</a></code></pre></div>
<p>すでに指定された要素数以上に予約されているからだ。</p>
<p>動的メモリ確保が行われていない場合、単に動的メモリ確保をすればよい。</p>
<div class="sourceCode" id="cb1341"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1341-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1341-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1341-3" data-line-number="3">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v ;</a>
<a class="sourceLine" id="cb1341-4" data-line-number="4">    <span class="co">// おそらく動的メモリ確保</span></a>
<a class="sourceLine" id="cb1341-5" data-line-number="5">    v.reserve( <span class="dv">10000</span> ) ;</a>
<a class="sourceLine" id="cb1341-6" data-line-number="6">}</a></code></pre></div>
<p>「おそらく」というのは、C++の規格はvectorのデフォルトコンストラクターが予約するストレージについて何も言及していないからだ。すでに要素数10000を超えるストレージが予約されている実装も規格準拠だ。本書で実装している<code>vector</code>は、デフォルトコンストラクターでは動的メモリ確保をしない実装になっている。</p>
<p>有効な要素が存在する場合、その要素の値は引き継がなければならない。</p>
<div class="sourceCode" id="cb1342"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1342-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1342-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1342-3" data-line-number="3">    <span class="co">// 要素数3</span></a>
<a class="sourceLine" id="cb1342-4" data-line-number="4">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>} ;</a>
<a class="sourceLine" id="cb1342-5" data-line-number="5">    <span class="co">// 1万個の要素を保持できるだけのメモリを予約</span></a>
<a class="sourceLine" id="cb1342-6" data-line-number="6">    v.reserve( <span class="dv">10000</span> ) ;</a>
<a class="sourceLine" id="cb1342-7" data-line-number="7">    <span class="co">// vは{1,2,3}</span></a>
<a class="sourceLine" id="cb1342-8" data-line-number="8">}</a></code></pre></div>
<p>つまり動的メモリ確保をした後に、既存の要素を新しいストレージにコピーしなければならないということだ。</p>
<p>まとめよう。</p>
<ol type="1">
<li>すでに指定された要素数以上に予約されているなら何もしない</li>
<li>まだ動的メモリ確保が行われていなければ動的メモリ確保をする</li>
<li>有効な要素がある場合は新しいストレージにコピーする。</li>
</ol>
<div class="sourceCode" id="cb1343"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1343-1" data-line-number="1"><span class="dt">void</span> reserve( <span class="dt">size_type</span> sz )</a>
<a class="sourceLine" id="cb1343-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1343-3" data-line-number="3">    <span class="co">// すでに指定された要素数以上に予約されているなら何もしない</span></a>
<a class="sourceLine" id="cb1343-4" data-line-number="4">    <span class="cf">if</span> ( sz &lt;= capacity() )</a>
<a class="sourceLine" id="cb1343-5" data-line-number="5">        <span class="cf">return</span> ;</a>
<a class="sourceLine" id="cb1343-6" data-line-number="6"></a>
<a class="sourceLine" id="cb1343-7" data-line-number="7">    <span class="co">// 動的メモリ確保をする</span></a>
<a class="sourceLine" id="cb1343-8" data-line-number="8">    <span class="kw">auto</span> ptr = allocate( sz ) ;</a>
<a class="sourceLine" id="cb1343-9" data-line-number="9">    <span class="co">// 現在の要素数を保存しておく。</span></a>
<a class="sourceLine" id="cb1343-10" data-line-number="10">    <span class="kw">auto</span> current_size = size() ;</a>
<a class="sourceLine" id="cb1343-11" data-line-number="11">    <span class="co">// 有効な要素があれば</span></a>
<a class="sourceLine" id="cb1343-12" data-line-number="12">    <span class="cf">if</span> ( begin() != end() )</a>
<a class="sourceLine" id="cb1343-13" data-line-number="13">    {</a>
<a class="sourceLine" id="cb1343-14" data-line-number="14">        <span class="co">// 新しいストレージにコピーする</span></a>
<a class="sourceLine" id="cb1343-15" data-line-number="15">        <span class="bu">std::</span>copy( begin(), end(), ptr ) ;</a>
<a class="sourceLine" id="cb1343-16" data-line-number="16">        <span class="co">// 古いストレージ上の要素を破棄する</span></a>
<a class="sourceLine" id="cb1343-17" data-line-number="17">        destroy_all() ;</a>
<a class="sourceLine" id="cb1343-18" data-line-number="18">        <span class="co">// 古いストレージを解放する</span></a>
<a class="sourceLine" id="cb1343-19" data-line-number="19">        deallocate() ;</a>
<a class="sourceLine" id="cb1343-20" data-line-number="20">    }</a>
<a class="sourceLine" id="cb1343-21" data-line-number="21">    <span class="co">// 新しいストレージを使う</span></a>
<a class="sourceLine" id="cb1343-22" data-line-number="22">    first = ptr ;</a>
<a class="sourceLine" id="cb1343-23" data-line-number="23">    <span class="co">// 有効な要素の次のポインター</span></a>
<a class="sourceLine" id="cb1343-24" data-line-number="24">    last = ptr + current_size ;</a>
<a class="sourceLine" id="cb1343-25" data-line-number="25">    <span class="co">// 予約したストレージの末尾の次のポインター</span></a>
<a class="sourceLine" id="cb1343-26" data-line-number="26">    reserved_last = ptr + sz ;</a>
<a class="sourceLine" id="cb1343-27" data-line-number="27">}</a></code></pre></div>
<h2 id="resize">resize</h2>
<p><code>resize(sz)</code>は要素数を<code>sz</code>個にする。</p>
<div class="sourceCode" id="cb1344"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1344-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1344-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1344-3" data-line-number="3">    <span class="co">// 要素数0</span></a>
<a class="sourceLine" id="cb1344-4" data-line-number="4">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v ;</a>
<a class="sourceLine" id="cb1344-5" data-line-number="5">    <span class="co">// 要素数10</span></a>
<a class="sourceLine" id="cb1344-6" data-line-number="6">    v.resize(<span class="dv">10</span>) ;</a>
<a class="sourceLine" id="cb1344-7" data-line-number="7">    <span class="co">// 要素数5</span></a>
<a class="sourceLine" id="cb1344-8" data-line-number="8">    v.resize(<span class="dv">5</span>)</a>
<a class="sourceLine" id="cb1344-9" data-line-number="9">    <span class="co">// 要素数変わらず</span></a>
<a class="sourceLine" id="cb1344-10" data-line-number="10">    v.resize(<span class="dv">5</span>)</a>
<a class="sourceLine" id="cb1344-11" data-line-number="11">}</a></code></pre></div>
<p><code>resize</code>は呼び出し前より要素数を増やすことも減らすこともある。また変わらないこともある。</p>
<p>要素数が増える場合、増えた要素数の値はデフォルト構築された値になる。</p>
<div class="sourceCode" id="cb1345"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1345-1" data-line-number="1"><span class="kw">struct</span> X</a>
<a class="sourceLine" id="cb1345-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1345-3" data-line-number="3">    X() { <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;default constructed.</span><span class="sc">\n</span><span class="st">&quot;</span> ; }</a>
<a class="sourceLine" id="cb1345-4" data-line-number="4">} ;</a>
<a class="sourceLine" id="cb1345-5" data-line-number="5"></a>
<a class="sourceLine" id="cb1345-6" data-line-number="6"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1345-7" data-line-number="7">{</a>
<a class="sourceLine" id="cb1345-8" data-line-number="8">    <span class="bu">std::</span>vector&lt;X&gt; v ;</a>
<a class="sourceLine" id="cb1345-9" data-line-number="9">    v.resize(<span class="dv">5</span>) ;</a>
<a class="sourceLine" id="cb1345-10" data-line-number="10">}</a></code></pre></div>
<p>このプログラムを実行すると、“default constructed.”は5回標準出力される。</p>
<p><code>resize(sz, value)</code>は<code>resize</code>を呼び出した結果要素が増える場合、その要素を<code>value</code>で初期化する。</p>
<div class="sourceCode" id="cb1346"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1346-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1346-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1346-3" data-line-number="3">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>} ;</a>
<a class="sourceLine" id="cb1346-4" data-line-number="4">    v.resize(<span class="dv">5</span>, <span class="dv">4</span>) ;</a>
<a class="sourceLine" id="cb1346-5" data-line-number="5">    <span class="co">// vは{1,2,3,4,4} </span></a>
<a class="sourceLine" id="cb1346-6" data-line-number="6">}</a></code></pre></div>
<p>要素数が減る場合、要素は末尾から順番に破棄されていく。</p>
<div class="sourceCode" id="cb1347"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1347-1" data-line-number="1"><span class="kw">struct</span> X</a>
<a class="sourceLine" id="cb1347-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1347-3" data-line-number="3">    ~X()</a>
<a class="sourceLine" id="cb1347-4" data-line-number="4">    { <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;destructed.</span><span class="sc">\n</span><span class="st">&quot;</span>s ; }</a>
<a class="sourceLine" id="cb1347-5" data-line-number="5">} ;</a>
<a class="sourceLine" id="cb1347-6" data-line-number="6"></a>
<a class="sourceLine" id="cb1347-7" data-line-number="7"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1347-8" data-line-number="8">{</a>
<a class="sourceLine" id="cb1347-9" data-line-number="9">    <span class="bu">std::</span>vector&lt;X&gt; v(<span class="dv">5</span>) ;</a>
<a class="sourceLine" id="cb1347-10" data-line-number="10">    v.resize(<span class="dv">2</span>) ;</a>
<a class="sourceLine" id="cb1347-11" data-line-number="11">    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;resized.</span><span class="sc">\n</span><span class="st">&quot;</span>s ;</a>
<a class="sourceLine" id="cb1347-12" data-line-number="12">}</a></code></pre></div>
<p>このプログラムを実行すると、以下のように出力される。</p>
<div class="sourceCode" id="cb1348"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1348-1" data-line-number="1">destructed.</a>
<a class="sourceLine" id="cb1348-2" data-line-number="2">destructed.</a>
<a class="sourceLine" id="cb1348-3" data-line-number="3">destructed.</a>
<a class="sourceLine" id="cb1348-4" data-line-number="4">resized.</a>
<a class="sourceLine" id="cb1348-5" data-line-number="5">destructed.</a>
<a class="sourceLine" id="cb1348-6" data-line-number="6">destructed.</a></code></pre></div>
<p>最初の<code>v.resize(2)</code>で、<code>v[4], v[3], v[2]</code>が書いた順番で破棄されていく。<code>main</code>関数を抜けるときに残りの<code>v[1], v[0]</code>が破棄される。</p>
<p><code>resize(sz)</code>を呼び出したときに<code>sz</code>が現在の要素数と等しい場合は何もしない。</p>
<div class="sourceCode" id="cb1349"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1349-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1349-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1349-3" data-line-number="3">    <span class="co">// 要素数5</span></a>
<a class="sourceLine" id="cb1349-4" data-line-number="4">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v(<span class="dv">5</span>) ;</a>
<a class="sourceLine" id="cb1349-5" data-line-number="5">    v.resize(<span class="dv">5</span>) ; <span class="co">// 何もしない   </span></a>
<a class="sourceLine" id="cb1349-6" data-line-number="6">}</a></code></pre></div>
<p>まとめると<code>resize</code>は以下のように動作する。</p>
<ol type="1">
<li>現在の要素数より少なくリサイズする場合、末尾から要素を破棄する</li>
<li>現在の要素数より大きくリサイズする場合、末尾に要素を追加する</li>
<li>現在の要素数と等しくリサイズする場合、何もしない。</li>
</ol>
<p>実装しよう。</p>
<div class="sourceCode" id="cb1350"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1350-1" data-line-number="1"><span class="dt">void</span> resize( <span class="dt">size_type</span> sz )</a>
<a class="sourceLine" id="cb1350-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1350-3" data-line-number="3">    <span class="co">// 現在の要素数より少ない</span></a>
<a class="sourceLine" id="cb1350-4" data-line-number="4">    <span class="cf">if</span> ( sz &lt; size() )</a>
<a class="sourceLine" id="cb1350-5" data-line-number="5">    {</a>
<a class="sourceLine" id="cb1350-6" data-line-number="6">        <span class="co">// 破棄する要素数を求める</span></a>
<a class="sourceLine" id="cb1350-7" data-line-number="7">        <span class="kw">auto</span> diff = size() - sz ;</a>
<a class="sourceLine" id="cb1350-8" data-line-number="8">        <span class="co">// 末尾から順番に破棄する</span></a>
<a class="sourceLine" id="cb1350-9" data-line-number="9">        destroy_until( rbegin() + diff ) ;</a>
<a class="sourceLine" id="cb1350-10" data-line-number="10">        <span class="co">// 新しいサイズを設定</span></a>
<a class="sourceLine" id="cb1350-11" data-line-number="11">        last = first + sz ;</a>
<a class="sourceLine" id="cb1350-12" data-line-number="12">    }</a>
<a class="sourceLine" id="cb1350-13" data-line-number="13">    <span class="co">// 現在の要素数より大きい</span></a>
<a class="sourceLine" id="cb1350-14" data-line-number="14">    <span class="cf">else</span> <span class="cf">if</span> ( sz &gt; size() )</a>
<a class="sourceLine" id="cb1350-15" data-line-number="15">    {</a>
<a class="sourceLine" id="cb1350-16" data-line-number="16">        <span class="co">// 少なくとも指定された要素数を保持できるだけのメモリを予約する </span></a>
<a class="sourceLine" id="cb1350-17" data-line-number="17">        reserve( sz ) ;</a>
<a class="sourceLine" id="cb1350-18" data-line-number="18">        <span class="co">// 追加の要素を構築する。</span></a>
<a class="sourceLine" id="cb1350-19" data-line-number="19">        <span class="cf">for</span> ( <span class="kw">auto</span> iter = last ; iter != reserved_last ; ++iter )</a>
<a class="sourceLine" id="cb1350-20" data-line-number="20">        {</a>
<a class="sourceLine" id="cb1350-21" data-line-number="21">            construct( iter ) ;</a>
<a class="sourceLine" id="cb1350-22" data-line-number="22">        }</a>
<a class="sourceLine" id="cb1350-23" data-line-number="23">        <span class="co">// 新しいサイズを設定</span></a>
<a class="sourceLine" id="cb1350-24" data-line-number="24">        last = first + sz ;</a>
<a class="sourceLine" id="cb1350-25" data-line-number="25">    }</a>
<a class="sourceLine" id="cb1350-26" data-line-number="26">}</a></code></pre></div>
<p>要素を破棄する場合、破棄する要素数だけ末尾から順番に破棄する。</p>
<p>要素を増やす場合、<code>reserve</code>を呼び出してメモリを予約してから、追加の要素を構築する。</p>
<p><code>sz == size()</code>の場合は、どちらのif文の条件にも引っかからないので、何もしない。</p>
<p><code>size(sz, value)</code>は、追加の引数を取るほか、<code>construct( iter )</code>の部分が<code>constrcut( iter, value )</code>に変わるだけだ。</p>
<div class="sourceCode" id="cb1351"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1351-1" data-line-number="1"><span class="dt">void</span> resize( <span class="dt">size_type</span> sz, const_reference value )</a>
<a class="sourceLine" id="cb1351-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1351-3" data-line-number="3">    <span class="co">// ...</span></a>
<a class="sourceLine" id="cb1351-4" data-line-number="4">            construct( iter, value ) ;</a>
<a class="sourceLine" id="cb1351-5" data-line-number="5">    <span class="co">// ...</span></a>
<a class="sourceLine" id="cb1351-6" data-line-number="6">}</a></code></pre></div>
<p>これで自作のvectorはある程度使えるようになった。コンストラクターで要素数を指定できるし、リサイズもできる。</p>
<div class="sourceCode" id="cb1352"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1352-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1352-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1352-3" data-line-number="3">    vector&lt;<span class="dt">int</span>&gt; v(<span class="dv">10</span>, <span class="dv">1</span>) ;</a>
<a class="sourceLine" id="cb1352-4" data-line-number="4">    v[<span class="dv">2</span>] = <span class="dv">99</span> ;</a>
<a class="sourceLine" id="cb1352-5" data-line-number="5">    v.resize(<span class="dv">5</span>) ;</a>
<a class="sourceLine" id="cb1352-6" data-line-number="6">    <span class="co">// vは{1,1,99,1,1}</span></a>
<a class="sourceLine" id="cb1352-7" data-line-number="7">}</a></code></pre></div>
<h2 id="push_back">push_back</h2>
<p><code>push_back</code>は<code>vector</code>の末尾に要素を追加する。</p>
<div class="sourceCode" id="cb1353"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1353-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1353-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1353-3" data-line-number="3">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v ;</a>
<a class="sourceLine" id="cb1353-4" data-line-number="4">    <span class="co">// vは{}</span></a>
<a class="sourceLine" id="cb1353-5" data-line-number="5">    v.push_back(<span class="dv">1</span>) ;</a>
<a class="sourceLine" id="cb1353-6" data-line-number="6">    <span class="co">// vは{1}</span></a>
<a class="sourceLine" id="cb1353-7" data-line-number="7">    v.push_back(<span class="dv">2</span>) ;</a>
<a class="sourceLine" id="cb1353-8" data-line-number="8">    <span class="co">// vは{1,2}</span></a>
<a class="sourceLine" id="cb1353-9" data-line-number="9">}</a></code></pre></div>
<p>push_backの実装は、末尾の予約された未使用のストレージに値を構築する。もし予約された未使用のストレージがない場合は、新しく動的メモリ確保する。</p>
<p>追加の動的メモリ確保なしで保持できる要素の個数はすでに実装した<code>capacity()</code>で取得できる。<code>push_back</code>は要素をひとつ追加するので、<code>size() + 1 &lt;= capacity()</code>ならば追加の動的メモリ確保はいらない。逆に、<code>size() + 1 &gt; capacity()</code>ならば追加の動的メモリ確保をしなければならない。追加の動的メモリ確保はすでに実装した<code>reserve</code>を使えばよい。</p>
<div class="sourceCode" id="cb1354"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1354-1" data-line-number="1"><span class="dt">void</span> push_back( const_reference value ) </a>
<a class="sourceLine" id="cb1354-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1354-3" data-line-number="3">    <span class="co">// 予約メモリが足りなければ拡張</span></a>
<a class="sourceLine" id="cb1354-4" data-line-number="4">    <span class="cf">if</span> ( size() + <span class="dv">1</span> &gt; capacity() )</a>
<a class="sourceLine" id="cb1354-5" data-line-number="5">    {</a>
<a class="sourceLine" id="cb1354-6" data-line-number="6">        <span class="co">// ひとつだけ増やす</span></a>
<a class="sourceLine" id="cb1354-7" data-line-number="7">        reserve( size() + <span class="dv">1</span> ) ;</a>
<a class="sourceLine" id="cb1354-8" data-line-number="8">    }</a>
<a class="sourceLine" id="cb1354-9" data-line-number="9"></a>
<a class="sourceLine" id="cb1354-10" data-line-number="10">    <span class="co">// 要素を末尾に追加</span></a>
<a class="sourceLine" id="cb1354-11" data-line-number="11">    construct( last, value ) ;</a>
<a class="sourceLine" id="cb1354-12" data-line-number="12">    <span class="co">// 有効な要素数を更新</span></a>
<a class="sourceLine" id="cb1354-13" data-line-number="13">    ++last ;</a>
<a class="sourceLine" id="cb1354-14" data-line-number="14">}</a></code></pre></div>
<p>これは動く。ただし、効率的ではない。自作のvectorを使った以下のような例を見てみよう。</p>
<div class="sourceCode" id="cb1355"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1355-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1355-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1355-3" data-line-number="3">    <span class="co">// 要素数10000</span></a>
<a class="sourceLine" id="cb1355-4" data-line-number="4">    vector&lt;<span class="dt">int</span>&gt; v(<span class="dv">1000</span>) ;</a>
<a class="sourceLine" id="cb1355-5" data-line-number="5">    <span class="co">// 10001個分のメモリを確保する</span></a>
<a class="sourceLine" id="cb1355-6" data-line-number="6">    <span class="co">// 10000個の既存の要素をコピーする</span></a>
<a class="sourceLine" id="cb1355-7" data-line-number="7">    v.push_back(<span class="dv">0</span>) ;</a>
<a class="sourceLine" id="cb1355-8" data-line-number="8">    <span class="co">// 10002個分のメモリを確保する</span></a>
<a class="sourceLine" id="cb1355-9" data-line-number="9">    <span class="co">// 10001個の既存の要素をコピーする</span></a>
<a class="sourceLine" id="cb1355-10" data-line-number="10">    v.push_back(<span class="dv">0</span>) ;</a>
<a class="sourceLine" id="cb1355-11" data-line-number="11">}</a></code></pre></div>
<p>たった1つの要素を追加するのに、毎回動的メモリ確保と既存の全要素のコピーをしている。これは無駄だ。</p>
<p><code>std::vector</code>は<code>push_back</code>で動的メモリ確保が必要な場合、<code>size()+1</code>よりも多くメモリを確保する。こうすると、<code>push_back</code>を呼び出すたびに毎回動的メモリ確保と全要素のコピーを行う必要がなくなるので、効率的になる。</p>
<p>ではどのくらい増やせばいいのか。10個づつ増やす戦略は以下のようになる。</p>
<div class="sourceCode" id="cb1356"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1356-1" data-line-number="1"><span class="dt">void</span> push_back( const_reference value ) </a>
<a class="sourceLine" id="cb1356-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1356-3" data-line-number="3">    <span class="co">// 予約メモリが足りなければ拡張</span></a>
<a class="sourceLine" id="cb1356-4" data-line-number="4">    <span class="cf">if</span> ( size() + <span class="dv">1</span> &gt; capacity() )</a>
<a class="sourceLine" id="cb1356-5" data-line-number="5">    {</a>
<a class="sourceLine" id="cb1356-6" data-line-number="6">        <span class="co">// 10個増やす</span></a>
<a class="sourceLine" id="cb1356-7" data-line-number="7">        reserve( capacity() + <span class="dv">10</span> ) ;</a>
<a class="sourceLine" id="cb1356-8" data-line-number="8">    }</a>
<a class="sourceLine" id="cb1356-9" data-line-number="9">    construct( last, value ) ;</a>
<a class="sourceLine" id="cb1356-10" data-line-number="10">    ++last ;</a>
<a class="sourceLine" id="cb1356-11" data-line-number="11">}</a></code></pre></div>
<p>しかしこの場合、以下のようなコードで効率が悪い。</p>
<div class="sourceCode" id="cb1357"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1357-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1357-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1357-3" data-line-number="3">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v ;</a>
<a class="sourceLine" id="cb1357-4" data-line-number="4">    <span class="cf">for</span> ( <span class="kw">auto</span> i = <span class="dv">0</span> ; i != <span class="dv">10000</span> ; ++i )</a>
<a class="sourceLine" id="cb1357-5" data-line-number="5">    {</a>
<a class="sourceLine" id="cb1357-6" data-line-number="6">        v.push_back(i) ;</a>
<a class="sourceLine" id="cb1357-7" data-line-number="7">    }</a>
<a class="sourceLine" id="cb1357-8" data-line-number="8">}</a></code></pre></div>
<p>10個づつ増やす戦略では、この場合に1000回の動的メモリ確保と全要素のコピーが発生する。</p>
<p>上のような場合、<code>vector</code>の利用者が事前に<code>v.reserve(10000)</code>とすれば効率的になる。しかし、コンパイル時に要素数がわからない場合、その手も使えない。</p>
<div class="sourceCode" id="cb1358"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1358-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1358-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1358-3" data-line-number="3">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; inputs ;</a>
<a class="sourceLine" id="cb1358-4" data-line-number="4">    <span class="co">// 要素数は実行時にしかわからない</span></a>
<a class="sourceLine" id="cb1358-5" data-line-number="5">    <span class="co">// 10万個の入力が行われるかも知れない</span></a>
<a class="sourceLine" id="cb1358-6" data-line-number="6">    <span class="bu">std::</span>copy(</a>
<a class="sourceLine" id="cb1358-7" data-line-number="7">        <span class="bu">std::</span>ostream_iterator&lt;<span class="dt">int</span>&gt;(<span class="bu">std::</span>cin&gt;),</a>
<a class="sourceLine" id="cb1358-8" data-line-number="8">        <span class="bu">std::</span>ostream_iterator&lt;<span class="dt">int</span>&gt;(),</a>
<a class="sourceLine" id="cb1358-9" data-line-number="9">        <span class="bu">std::</span>back_inserter(inputs) ) ;</a>
<a class="sourceLine" id="cb1358-10" data-line-number="10">}</a></code></pre></div>
<p>よくある実装は、現在のストレージサイズの2倍のストレージを確保する戦略だ。</p>
<div class="sourceCode" id="cb1359"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1359-1" data-line-number="1"><span class="dt">void</span> push_back( const_reference value ) </a>
<a class="sourceLine" id="cb1359-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1359-3" data-line-number="3">    <span class="co">// 予約メモリが足りなければ拡張</span></a>
<a class="sourceLine" id="cb1359-4" data-line-number="4">    <span class="cf">if</span> ( size() + <span class="dv">1</span> &gt; capacity() )</a>
<a class="sourceLine" id="cb1359-5" data-line-number="5">    {</a>
<a class="sourceLine" id="cb1359-6" data-line-number="6">        <span class="co">// 現在のストレージサイズ</span></a>
<a class="sourceLine" id="cb1359-7" data-line-number="7">        <span class="kw">auto</span> c = size() ;</a>
<a class="sourceLine" id="cb1359-8" data-line-number="8">        <span class="co">// 0の場合は1に</span></a>
<a class="sourceLine" id="cb1359-9" data-line-number="9">        <span class="cf">if</span> ( c == <span class="dv">0</span> )</a>
<a class="sourceLine" id="cb1359-10" data-line-number="10">            c = <span class="dv">1</span> ;</a>
<a class="sourceLine" id="cb1359-11" data-line-number="11">        <span class="cf">else</span></a>
<a class="sourceLine" id="cb1359-12" data-line-number="12">            <span class="co">// それ以外の場合は2倍する</span></a>
<a class="sourceLine" id="cb1359-13" data-line-number="13">            c *= <span class="dv">2</span> ;</a>
<a class="sourceLine" id="cb1359-14" data-line-number="14"></a>
<a class="sourceLine" id="cb1359-15" data-line-number="15">        reserve( c ) ;</a>
<a class="sourceLine" id="cb1359-16" data-line-number="16">    }</a>
<a class="sourceLine" id="cb1359-17" data-line-number="17">    construct( last, value ) ;</a>
<a class="sourceLine" id="cb1359-18" data-line-number="18">    ++last ;</a>
<a class="sourceLine" id="cb1359-19" data-line-number="19">}</a></code></pre></div>
<p><code>size()</code>は<code>0</code>を返す場合もあるということに注意。単に<code>reserve(size()*2)</code>としたのでは<code>size() == 0</code>のときに動かない。</p>
<h3 id="shrink_to_fit"><code>shrink_to_fit</code></h3>
<p><code>shrink_to_fit()</code>は<code>vector</code>が予約しているメモリのサイズを実サイズに近づけるメンバー関数だ。</p>
<p>本書で実装してきた自作の<code>vector</code>は、<code>push_back</code>時に予約しているメモリがなければ、現在の要素数の2倍のメモリを予約する実装だった。すると以下のようなコードで、</p>
<div class="sourceCode" id="cb1360"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1360-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1360-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1360-3" data-line-number="3">    vector&lt;<span class="dt">int</span>&gt; v ;</a>
<a class="sourceLine" id="cb1360-4" data-line-number="4">    <span class="bu">std::</span>copy( <span class="bu">std::</span>istream_iterator&lt;<span class="dt">int</span>&gt;(<span class="bu">std::</span>cin). <span class="bu">std::</span>istream_iterator&lt;<span class="dt">int</span>&gt;(),</a>
<a class="sourceLine" id="cb1360-5" data-line-number="5">        <span class="bu">std::</span>back_inserter(v) ) ;</a>
<a class="sourceLine" id="cb1360-6" data-line-number="6">}</a></code></pre></div>
<p>ユーザーが4万個のint型の値を入力した場合、65536個のint型の値を保持できるだけのメモリが確保されてしまい、差し引き<code>sizeof(int) * 25536</code>バイトのメモリが未使用のまま確保され続けてしまう。</p>
<p>メモリ要件の厳しい環境ではこのようなメモリの浪費を避けたい。しかし、実行時にユーザーから任意の個数の入力を受けるプログラムを書く場合には、<code>push_back</code>を使いたい。</p>
<p>こういうとき、<code>shrink_to_fit</code>はvectorが予約するメモリを切り詰めて実サイズに近くする、かもしれない。「かもしれない」というのは、C++の標準規格は<code>shrink_to_fit</code>が必ずメモリの予約サイズを切り詰めるよう規定してはいないからだ。</p>
<p>自作の<code>vector</code>では必ず切り詰める実装にしてみよう。</p>
<p>まず予約するメモリを切り詰めるとはどういうことか。現在予約しているメモリで保持できる最大の要素数は<code>capacity()</code>で得られる。実際に保持している要素数を返すのは<code>size()</code>だ。すると<code>size() == capacity()</code>になるようにすればいい。</p>
<div class="sourceCode" id="cb1361"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1361-1" data-line-number="1">vector&lt;<span class="dt">int</span>&gt; v ;</a>
<a class="sourceLine" id="cb1361-2" data-line-number="2"><span class="co">// ...</span></a>
<a class="sourceLine" id="cb1361-3" data-line-number="3">v.shrink_to_fit() ;</a>
<a class="sourceLine" id="cb1361-4" data-line-number="4">v.size() == v.capacity() ; <span class="co">// trueにする</span></a></code></pre></div>
<p><code>shrink_to_fit()</code>を呼んだとき、すでに<code>size() == capacity()</code>が<code>true</code>である場合は、何もしなくてもよい。</p>
<p>それ以外の場合は、現在の有効な要素数文の新しいストレージを確保し、現在の値を新しいストレージにコピーし、古いメモリは破棄する。</p>
<div class="sourceCode" id="cb1362"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1362-1" data-line-number="1"><span class="dt">void</span> shrink_to_fit()</a>
<a class="sourceLine" id="cb1362-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1362-3" data-line-number="3">    <span class="co">// 何もする必要がない</span></a>
<a class="sourceLine" id="cb1362-4" data-line-number="4">    <span class="cf">if</span> ( size() == capacity() )</a>
<a class="sourceLine" id="cb1362-5" data-line-number="5">        <span class="cf">return</span> ;</a>
<a class="sourceLine" id="cb1362-6" data-line-number="6"></a>
<a class="sourceLine" id="cb1362-7" data-line-number="7">    <span class="co">// 新しいストレージを確保</span></a>
<a class="sourceLine" id="cb1362-8" data-line-number="8">    <span class="kw">auto</span> ptr = allocate( size() ) ;</a>
<a class="sourceLine" id="cb1362-9" data-line-number="9">    <span class="co">// コピー</span></a>
<a class="sourceLine" id="cb1362-10" data-line-number="10">    <span class="kw">auto</span> current_size = size() ;</a>
<a class="sourceLine" id="cb1362-11" data-line-number="11">    <span class="cf">for</span> (   <span class="kw">auto</span> raw_ptr = ptr, iter = begin(), iter_end = end() ;</a>
<a class="sourceLine" id="cb1362-12" data-line-number="12">            iter != iter_end ; ++iter, ++raw_ptr )</a>
<a class="sourceLine" id="cb1362-13" data-line-number="13">    {</a>
<a class="sourceLine" id="cb1362-14" data-line-number="14">        construct( raw_ptr, *iter ) ;</a>
<a class="sourceLine" id="cb1362-15" data-line-number="15">    }</a>
<a class="sourceLine" id="cb1362-16" data-line-number="16">    <span class="co">// 破棄</span></a>
<a class="sourceLine" id="cb1362-17" data-line-number="17">    destroy_all() ;</a>
<a class="sourceLine" id="cb1362-18" data-line-number="18">    deallocate() ;</a>
<a class="sourceLine" id="cb1362-19" data-line-number="19">    <span class="co">// 新しいストレージを使う</span></a>
<a class="sourceLine" id="cb1362-20" data-line-number="20">    first = ptr ;</a>
<a class="sourceLine" id="cb1362-21" data-line-number="21">    last = ptr + current_size ;</a>
<a class="sourceLine" id="cb1362-22" data-line-number="22">    reserved_last = last ;</a>
<a class="sourceLine" id="cb1362-23" data-line-number="23">}</a></code></pre></div>
<p>この実装は<code>reserve</code>と似ている。</p>
<h1 id="cプリプロセッサー">Cプリプロセッサー</h1>
<p>CプリプロセッサーはC++がC言語から受け継いだ機能だ。CプリプロセッサーはソースコードをC++としてパースする前に、テキストをトークン単位で変形する処理のことだ。この処理はソースファイルをC++としてパースする前処理として行われる。CプリプロセッサーはC++ではなく別言語として認識すべきで、そもそもプログラミング言語ではなくマクロ言語だ。</p>
<p>C++ではCプリプロセッサーが広く使われており、今後もしばらくは使われるだろう。読者がC++で書かれた既存のコードを読む時、Cプリプロセッサーは避けて通れない。Cプリプロセッサーはいずれ廃止したい機能ではあるが、C++は未だに廃止できていない。</p>
<p>Cプリプロセッサーはプリプロセッシングディレクティブ(preprocessing directive)を認識し、トークン列を処理する。ディレクティブはソースファイルの文頭に文字<code>#</code>から始まり、改行文字で終わる。<code>#</code>とディレクティブの間に空白文字を入れてもよい。</p>
<div class="sourceCode" id="cb1363"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1363-1" data-line-number="1"><span class="pp">#define NOSPACE</span></a>
<a class="sourceLine" id="cb1363-2" data-line-number="2"><span class="pp">#    define SPACE</span></a></code></pre></div>
<h2 id="includeディレクティブ">#includeディレクティブ</h2>
<p><code>#include</code>は指定したファイルの内容をその場に挿入する。本質的にはコピペだ。C++では<code>#include</code>はライブラリを利用するのに使われる。</p>
<p><code>#include</code>は以下のいずれかの文法を持つ。</p>
<div class="sourceCode" id="cb1364"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1364-1" data-line-number="1"><span class="pp">#include </span><span class="im">&lt;ヘッダーファイルパス&gt;</span><span class="pp"> 改行文字</span></a>
<a class="sourceLine" id="cb1364-2" data-line-number="2"><span class="pp">#include </span><span class="im">&quot;ヘッダーファイルパス&quot;</span><span class="pp"> 改行文字</span></a></code></pre></div>
<p><code>#include</code>は指定したファイルパスのファイルの内容をその場所に挿入する。このファイルをヘッダーファイルという。<code>&lt;&gt;</code>によるファイルパスは、標準ライブラリやシステムのヘッダーファイルを格納したディレクトリーからヘッダーファイルを探す。<code>&quot;&quot;</code>によるファイルパスは、システム以外のディレクトリーからもヘッダーファイルを探す。例えばカレントディレクトリーなどだ。</p>
<p>例えば、以下のようなヘッダーファイル<code>foo.h</code>があり、</p>
<div class="sourceCode" id="cb1365"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1365-1" data-line-number="1"><span class="co">// foo.h</span></a>
<a class="sourceLine" id="cb1365-2" data-line-number="2">foo foo foo</a></code></pre></div>
<p>以下のようなソースファイル<code>bar.cpp</code>がある場合、</p>
<div class="sourceCode" id="cb1366"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1366-1" data-line-number="1"><span class="co">// bar.cpp</span></a>
<a class="sourceLine" id="cb1366-2" data-line-number="2"></a>
<a class="sourceLine" id="cb1366-3" data-line-number="3"><span class="pp">#include </span><span class="im">&quot;foo.h&quot;</span></a>
<a class="sourceLine" id="cb1366-4" data-line-number="4"></a>
<a class="sourceLine" id="cb1366-5" data-line-number="5"><span class="co">// end bar.cpp</span></a></code></pre></div>
<p><code>bar.cpp</code>をCプリプロセッサーにかけると、以下のようなソースファイルが出力される</p>
<div class="sourceCode" id="cb1367"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1367-1" data-line-number="1"><span class="co">// bar.cpp</span></a>
<a class="sourceLine" id="cb1367-2" data-line-number="2"></a>
<a class="sourceLine" id="cb1367-3" data-line-number="3"><span class="co">// foo.h</span></a>
<a class="sourceLine" id="cb1367-4" data-line-number="4">foo foo foo</a>
<a class="sourceLine" id="cb1367-5" data-line-number="5"></a>
<a class="sourceLine" id="cb1367-6" data-line-number="6"><span class="co">// end bar.h</span></a></code></pre></div>
<p>このソースファイルはC++のソースファイルとしてはエラーとなるが、Cプリプロセッサーは単純にトークン列で分割したテキストファイルとしてソースファイルを処理するため、Cプリプロセッサーとしてはエラーにはならない。</p>
<p>冒頭で述べたように、<code>#include</code>の本質はコンパイラーによるコピペである。あるテキストファイルの内容をその場に挿入するコピペ機能を提供する。</p>
<p><code>#include</code>は、他の言語でモジュール、importなどと呼ばれている機能を簡易的に提供する。C++の標準ライブラリを使うには、<code>&lt;iostream&gt;</code>や<code>&lt;string&gt;</code>や<code>&lt;vector&gt;</code>のようなヘッダーファイルを<code>#include</code>する必要がある。</p>
<div class="sourceCode" id="cb1368"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1368-1" data-line-number="1"><span class="co">// iostreamライブラリを使う</span></a>
<a class="sourceLine" id="cb1368-2" data-line-number="2"><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></a>
<a class="sourceLine" id="cb1368-3" data-line-number="3"><span class="co">// stringライブラリを使う</span></a>
<a class="sourceLine" id="cb1368-4" data-line-number="4"><span class="pp">#include </span><span class="im">&lt;string&gt;</span></a>
<a class="sourceLine" id="cb1368-5" data-line-number="5"></a>
<a class="sourceLine" id="cb1368-6" data-line-number="6"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1368-7" data-line-number="7">{</a>
<a class="sourceLine" id="cb1368-8" data-line-number="8">    <span class="co">// &lt;string&gt;のライブラリ</span></a>
<a class="sourceLine" id="cb1368-9" data-line-number="9">    <span class="bu">std::</span>string s(<span class="st">&quot;hello&quot;</span>) ;</a>
<a class="sourceLine" id="cb1368-10" data-line-number="10">    <span class="co">// iostreamのライブラリ</span></a>
<a class="sourceLine" id="cb1368-11" data-line-number="11">    <span class="bu">std::</span>cout &lt;&lt; s ;</a>
<a class="sourceLine" id="cb1368-12" data-line-number="12">}</a></code></pre></div>
<p>すでに述べたように<code>#include</code>はファイルの内容をその場に挿入するだけであり、他の言語にあるモジュールのための高級な機能ではない。本書を執筆時点で規格策定中のC++20では、より高級なモジュール機能を追加する予定がある。</p>
<p>同じヘッダーファイルを複数回<code>#include</code>すると、当然複数回挿入される。</p>
<p>以下のような<code>val.h</code>を、</p>
<div class="sourceCode" id="cb1369"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1369-1" data-line-number="1"><span class="co">// val.h</span></a>
<a class="sourceLine" id="cb1369-2" data-line-number="2"><span class="kw">inline</span> <span class="dt">int</span> val ;</a></code></pre></div>
<p>以下のように複数回<code>#include</code>すると、</p>
<div class="sourceCode" id="cb1370"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1370-1" data-line-number="1"><span class="pp">#include </span><span class="im">&quot;val.h&quot;</span></a>
<a class="sourceLine" id="cb1370-2" data-line-number="2"><span class="pp">#include </span><span class="im">&quot;val.h&quot;</span></a></code></pre></div>
<p>以下のように置換される。</p>
<div class="sourceCode" id="cb1371"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1371-1" data-line-number="1"><span class="co">// val.h</span></a>
<a class="sourceLine" id="cb1371-2" data-line-number="2"><span class="kw">inline</span> <span class="dt">int</span> val ;</a>
<a class="sourceLine" id="cb1371-3" data-line-number="3"><span class="co">// val.h</span></a>
<a class="sourceLine" id="cb1371-4" data-line-number="4"><span class="kw">inline</span> <span class="dt">int</span> val ;</a></code></pre></div>
<p>これはvalの定義が重複しているためエラーとなる。</p>
<p>しかし、ヘッダーファイルを一度しか<code>#include</code>しないようにするのは困難だ。なぜならば、ヘッダーファイルは他のヘッダーファイルから間接的に<code>#include</code>されることもあるからだ。</p>
<div class="sourceCode" id="cb1372"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1372-1" data-line-number="1"><span class="co">// lib_f.h</span></a>
<a class="sourceLine" id="cb1372-2" data-line-number="2"></a>
<a class="sourceLine" id="cb1372-3" data-line-number="3"><span class="pp">#include </span><span class="im">&quot;val.h&quot;</span></a>
<a class="sourceLine" id="cb1372-4" data-line-number="4"></a>
<a class="sourceLine" id="cb1372-5" data-line-number="5"><span class="dt">int</span> f() ;</a></code></pre></div>
<div class="sourceCode" id="cb1373"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1373-1" data-line-number="1"><span class="co">// lib_g.h</span></a>
<a class="sourceLine" id="cb1373-2" data-line-number="2"></a>
<a class="sourceLine" id="cb1373-3" data-line-number="3"><span class="pp">#include </span><span class="im">&quot;val.h&quot;</span></a>
<a class="sourceLine" id="cb1373-4" data-line-number="4"></a>
<a class="sourceLine" id="cb1373-5" data-line-number="5"><span class="dt">int</span> g() ;</a></code></pre></div>
<div class="sourceCode" id="cb1374"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1374-1" data-line-number="1"><span class="co">// main.cpp</span></a>
<a class="sourceLine" id="cb1374-2" data-line-number="2"></a>
<a class="sourceLine" id="cb1374-3" data-line-number="3"><span class="pp">#include </span><span class="im">&quot;lib_f.h&quot;</span></a>
<a class="sourceLine" id="cb1374-4" data-line-number="4"><span class="pp">#include </span><span class="im">&quot;lib_g.h&quot;</span></a>
<a class="sourceLine" id="cb1374-5" data-line-number="5"></a>
<a class="sourceLine" id="cb1374-6" data-line-number="6"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1374-7" data-line-number="7">{</a>
<a class="sourceLine" id="cb1374-8" data-line-number="8">    <span class="dt">int</span> result = f() + g() ;</a>
<a class="sourceLine" id="cb1374-9" data-line-number="9">}</a></code></pre></div>
<p>この<code>main.cpp</code>をCプリプロセッサーにかけると以下のように置換される。</p>
<div class="sourceCode" id="cb1375"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1375-1" data-line-number="1"><span class="co">// main.cpp</span></a>
<a class="sourceLine" id="cb1375-2" data-line-number="2"></a>
<a class="sourceLine" id="cb1375-3" data-line-number="3"><span class="co">// lib_f.h</span></a>
<a class="sourceLine" id="cb1375-4" data-line-number="4"></a>
<a class="sourceLine" id="cb1375-5" data-line-number="5"><span class="co">// val.h</span></a>
<a class="sourceLine" id="cb1375-6" data-line-number="6"><span class="kw">inline</span> <span class="dt">int</span> val ;</a>
<a class="sourceLine" id="cb1375-7" data-line-number="7"></a>
<a class="sourceLine" id="cb1375-8" data-line-number="8"><span class="dt">int</span> f() ;</a>
<a class="sourceLine" id="cb1375-9" data-line-number="9"></a>
<a class="sourceLine" id="cb1375-10" data-line-number="10"><span class="co">// lib_g.h</span></a>
<a class="sourceLine" id="cb1375-11" data-line-number="11"></a>
<a class="sourceLine" id="cb1375-12" data-line-number="12"><span class="co">// val.h</span></a>
<a class="sourceLine" id="cb1375-13" data-line-number="13"><span class="kw">inline</span> <span class="dt">int</span> val ;</a>
<a class="sourceLine" id="cb1375-14" data-line-number="14"></a>
<a class="sourceLine" id="cb1375-15" data-line-number="15"><span class="dt">int</span> g() ;</a>
<a class="sourceLine" id="cb1375-16" data-line-number="16"></a>
<a class="sourceLine" id="cb1375-17" data-line-number="17"></a>
<a class="sourceLine" id="cb1375-18" data-line-number="18"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1375-19" data-line-number="19">{</a>
<a class="sourceLine" id="cb1375-20" data-line-number="20">    <span class="dt">int</span> result = f() + g() ;</a>
<a class="sourceLine" id="cb1375-21" data-line-number="21">}</a></code></pre></div>
<p>これはvalの定義が重複しているためエラーとなる。</p>
<p>この問題に対処するためには、複数回<code>#include</code>されると困るヘッダーファイルでは、インクルードガード(include guard)と呼ばれている方法を使う。</p>
<div class="sourceCode" id="cb1376"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1376-1" data-line-number="1"><span class="co">// val.h</span></a>
<a class="sourceLine" id="cb1376-2" data-line-number="2"></a>
<a class="sourceLine" id="cb1376-3" data-line-number="3"><span class="pp">#ifndef INCLUDE_GUARD_HEADER_VAL_H</span></a>
<a class="sourceLine" id="cb1376-4" data-line-number="4"><span class="pp">#define INCLUDE_GUARD_HEADER_VAL_H</span></a>
<a class="sourceLine" id="cb1376-5" data-line-number="5"></a>
<a class="sourceLine" id="cb1376-6" data-line-number="6"><span class="kw">inline</span> <span class="dt">int</span> val ;</a>
<a class="sourceLine" id="cb1376-7" data-line-number="7"></a>
<a class="sourceLine" id="cb1376-8" data-line-number="8"><span class="pp">#endif</span></a></code></pre></div>
<p>このように記述した<code>val.h</code>を複数回<code>#include</code>しても、最初のifndefのみがコンパイル対象になるため、問題は起こらない。</p>
<p>インクルードガードは以下の様式を持つ。</p>
<div class="sourceCode" id="cb1377"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1377-1" data-line-number="1"><span class="pp">#ifndef 十分にユニークなマクロ名</span></a>
<a class="sourceLine" id="cb1377-2" data-line-number="2"><span class="pp">#define 十分にユニークなマクロ名 </span></a>
<a class="sourceLine" id="cb1377-3" data-line-number="3"></a>
<a class="sourceLine" id="cb1377-4" data-line-number="4"><span class="co">// 重複してコンパイルされたくないコードをここに書く</span></a>
<a class="sourceLine" id="cb1377-5" data-line-number="5"></a>
<a class="sourceLine" id="cb1377-6" data-line-number="6"><span class="pp">#endif</span></a></code></pre></div>
<p><code>十分にユニークなマクロ名</code>は全ソースファイル中で衝突しないそのヘッダーに固有のマクロ名を使う。慣習的に推奨される方法としてはすべて大文字を使い、十分に長いマクロ名にすることだ。</p>
<h2 id="define">#define</h2>
<p><code>#define</code>はマクロ置換を行う。マクロにはオブジェクト風マクロ(object-like macro)と関数風マクロ(function-like macro)がある。風というのは、マクロはオブジェクトでも関数でもないからだ。ただ、文法上オブジェクトや関数の似ているだけで、実態はトークン列の愚直な置換だ。</p>
<h3 id="オブジェクト風マクロ">オブジェクト風マクロ</h3>
<p>オブジェクト風マクロの文法は以下の通り</p>
<pre><code>#define マクロ名 置換リスト　改行文字</code></pre>
<p><code>#define</code>以降の行では、マクロ名が置換リストに置き換わる</p>
<div class="sourceCode" id="cb1379"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1379-1" data-line-number="1"><span class="pp">#define ONE             1</span></a>
<a class="sourceLine" id="cb1379-2" data-line-number="2"><span class="pp">#define ONE_PLUS_ONE    ONE + ONE</span></a>
<a class="sourceLine" id="cb1379-3" data-line-number="3"><span class="pp">#define GNU GNU&#39;s is NOT UNIX</span></a>
<a class="sourceLine" id="cb1379-4" data-line-number="4"></a>
<a class="sourceLine" id="cb1379-5" data-line-number="5">ONE</a>
<a class="sourceLine" id="cb1379-6" data-line-number="6">ONE_PLUS_ONE</a></code></pre></div>
<p>これをプリプロセスすると以下のソースコードになる。</p>
<div class="sourceCode" id="cb1380"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1380-1" data-line-number="1"><span class="dv">1</span></a>
<a class="sourceLine" id="cb1380-2" data-line-number="2"><span class="dv">1</span> + <span class="dv">1</span></a></code></pre></div>
<p>マクロ名<code>ONE</code>は<code>1</code>に置換される。</p>
<p>マクロ名<code>ONE_PLUS_ONE</code>は<code>ONE + ONE</code>に置換される。置換された結果に別のマクロ名があれば、そのマクロ名も置換される。</p>
<p>あるマクロ名を置換した結果、そのマクロ名が現れても再帰的に置換されることはない。</p>
<div class="sourceCode" id="cb1381"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1381-1" data-line-number="1"><span class="pp">#define GNU GNU&#39;s NOT UNIX!</span></a>
<a class="sourceLine" id="cb1381-2" data-line-number="2"></a>
<a class="sourceLine" id="cb1381-3" data-line-number="3">GNU</a></code></pre></div>
<p>これは以下のように置換される。</p>
<div class="sourceCode" id="cb1382"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1382-1" data-line-number="1">GNU<span class="ch">&#39;s NOT UNIX!</span></a></code></pre></div>
<p>マクロ名<code>GNU</code>を展開するとトークン`GNU’が現れるが、これは置換されたマクロ名と同じなので、再帰的に置換されることはない。</p>
<h3 id="関数風マクロ">関数風マクロ</h3>
<p>関数風マクロの文法は以下の通り。</p>
<pre><code>#define マクロ名( 識別子リスト ) 置換リスト 改行文字</code></pre>
<p>関数風マクロはあたかも関数のように記述できる。関数風マクロに実引数として渡したトークン列は、置換リスト内で仮引数としての識別子で参照できる。</p>
<div class="sourceCode" id="cb1384"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1384-1" data-line-number="1"><span class="pp">#define NO_ARGUMENT()           No argument</span></a>
<a class="sourceLine" id="cb1384-2" data-line-number="2"><span class="pp">#define ONE_ARGUMENT( ARG )     begin ARG end</span></a>
<a class="sourceLine" id="cb1384-3" data-line-number="3"><span class="pp">#define MAKE_IT_DOUBLE( ARG )   ONE_ARGUMENT( ARG ARG )</span></a>
<a class="sourceLine" id="cb1384-4" data-line-number="4"></a>
<a class="sourceLine" id="cb1384-5" data-line-number="5">NO_ARGUMENT()</a>
<a class="sourceLine" id="cb1384-6" data-line-number="6">ONE_ARGUMENT( foo bar )</a>
<a class="sourceLine" id="cb1384-7" data-line-number="7">MAKE_IT_DOUBLE( foo bar )</a></code></pre></div>
<p>これは以下のように置換される。</p>
<div class="sourceCode" id="cb1385"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1385-1" data-line-number="1">No argument</a>
<a class="sourceLine" id="cb1385-2" data-line-number="2">begin foo bar end</a>
<a class="sourceLine" id="cb1385-3" data-line-number="3">begin foo bar foo bar end</a></code></pre></div>
<p>複数の引数を取るマクロへの実引数は、カンマで区切られたトークン列を渡す。</p>
<div class="sourceCode" id="cb1386"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1386-1" data-line-number="1"><span class="pp">#define TWO( A, B ) A B</span></a>
<a class="sourceLine" id="cb1386-2" data-line-number="2"><span class="pp">#define THREE( A, B, C ) C B A</span></a>
<a class="sourceLine" id="cb1386-3" data-line-number="3"></a>
<a class="sourceLine" id="cb1386-4" data-line-number="4">TWO( <span class="dv">1</span> <span class="dv">2</span>, <span class="dv">3</span> <span class="dv">4</span> )</a>
<a class="sourceLine" id="cb1386-5" data-line-number="5">THREE( <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span> )</a></code></pre></div>
<p>これは以下のように置換される。</p>
<div class="sourceCode" id="cb1387"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1387-1" data-line-number="1"><span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span></a>
<a class="sourceLine" id="cb1387-2" data-line-number="2"><span class="dv">3</span> <span class="dv">2</span> <span class="dv">1</span></a></code></pre></div>
<p>ただし、括弧で囲まれたトークン列の中にあるカンマは、マクロの実引数の区切りとはみなされない。</p>
<div class="sourceCode" id="cb1388"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1388-1" data-line-number="1"><span class="pp">#define MACRO( A ) A</span></a>
<a class="sourceLine" id="cb1388-2" data-line-number="2"></a>
<a class="sourceLine" id="cb1388-3" data-line-number="3">MACRO( (a,b) )</a></code></pre></div>
<p>これは以下のように置換される。</p>
<pre><code>(a,b)</code></pre>
<h3 id="va_args__可変長引数マクロ"><code>__VA_ARGS__</code>(可変長引数マクロ)</h3>
<p><code>#define</code>の識別子リストを<code>...</code>だけにしたマクロは、可変長引数マクロになる。このときマクロの実引数のトークン列は、置換リストのなかで<code>__VA_ARGS__</code>として参照できる。</p>
<div class="sourceCode" id="cb1390"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1390-1" data-line-number="1"><span class="pp">#define MACRO(...) </span><span class="ot">__VA_ARGS__</span></a>
<a class="sourceLine" id="cb1390-2" data-line-number="2"></a>
<a class="sourceLine" id="cb1390-3" data-line-number="3">MACRO( You can write , <span class="kw">and</span> ,, <span class="kw">or</span> even ,,,, )</a></code></pre></div>
<p>これは以下のように置換される。</p>
<pre><code>You can write , and ,, or even ,,,,</code></pre>
<p>カンマも含めてすべてのトークン列がそのまま<code>__VA_ARGS__</code>で参照できる。</p>
<p>可変長引数マクロの識別子リストに仮引数と<code>...</code>を書いたマクロの置換リストでは、仮引数の数だけの実引数は仮引数で参照され、残りが<code>__VA_ARGS__</code>で参照される。</p>
<div class="sourceCode" id="cb1392"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1392-1" data-line-number="1"><span class="pp">#define MACRO( X, Y, Z, ... ) X Y Z and </span><span class="ot">__VA_ARGS__</span></a>
<a class="sourceLine" id="cb1392-2" data-line-number="2"></a>
<a class="sourceLine" id="cb1392-3" data-line-number="3">MACRO( <span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span> )</a></code></pre></div>
<p>これは以下のように置換される</p>
<pre><code>1 2 3 and 4,5,6</code></pre>
<p>X, Y, Zにそれぞれ1, 2, 3が入り、<code>__VA_ARGS__</code>には<code>4,5,6</code>が入る。</p>
<h3 id="va_opt__"><code>__VA_OPT__</code></h3>
<p><code>__VA_OPT__</code>は可変長引数マクロで<code>__VA_ARGS__</code>にトークン列が渡されたかどうかで置換結果を変えることができる。</p>
<p><code>__VA_OPT__</code>は可変引数マクロの置換リストでのみ使える。<code>__VA_OPT__(content)</code>は<code>__VA_ARGS__</code>にトークンがない場合はトークンなしに置換され、トークンがある場合はトークン列<code>content</code>に置換される。</p>
<div class="sourceCode" id="cb1394"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1394-1" data-line-number="1"><span class="pp">#define MACRO( X, ... ) f( X __VA_OPT__(,) </span><span class="ot">__VA_ARGS__</span><span class="pp"> )</span></a>
<a class="sourceLine" id="cb1394-2" data-line-number="2"></a>
<a class="sourceLine" id="cb1394-3" data-line-number="3">MACRO(<span class="dv">1</span>)</a>
<a class="sourceLine" id="cb1394-4" data-line-number="4">MACRO(<span class="dv">1</span>,<span class="dv">2</span>)</a></code></pre></div>
<p>これは以下のように置換される。</p>
<pre><code>f( 1 )
f( 1, 2 )</code></pre>
<p><code>MACRO(1)</code>は<code>X</code>が<code>1</code>になり、<code>__VA_ARGS__</code>にはトークンがないので、<code>__VA_OPT__(,)</code>は空に置換される。結果として<code>f(1)</code>となる。</p>
<p><code>MACRO(1,2)</code>は、Xが1になり、<code>__VA_ARGS__'にはトークン</code>2<code>が入るので、</code><strong>VA_OPT</strong>(,)<code>は</code>,<code>に置換される。結果として</code>f(1,2)`となる。</p>
<p><code>__VA_OPT__</code>は<code>__VA_ARGS__</code>に実引数となるトークン列がなければ空に置換されるので、このようにトークン列の有無によってカンマなどの文法上必須のトークン列の有無を切り替えたい場合に使うことができる。</p>
<h3 id="演算子">#演算子</h3>
<p><code>#</code>はマクロ実引数を文字列リテラルにする。</p>
<p><code>#</code>は関数風マクロの置換リストの中のみで使うことができる。<code>#</code>は関数風マクロの仮引数の識別子の直前に書くことができる。<code>#</code>が直前に書かれた識別子は、マクロ実引数のトークン列の文字列リテラルになる。</p>
<div class="sourceCode" id="cb1396"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1396-1" data-line-number="1"><span class="pp">#define STRING( X ) # X</span></a>
<a class="sourceLine" id="cb1396-2" data-line-number="2"></a>
<a class="sourceLine" id="cb1396-3" data-line-number="3">STRING( hello )</a>
<a class="sourceLine" id="cb1396-4" data-line-number="4">STRING( hello world )</a></code></pre></div>
<p>これは以下のように置換される。</p>
<pre><code>&quot;hello&quot;
&quot;hello world&quot;</code></pre>
<p>また、可変長マクロと組み合わせた場合、</p>
<div class="sourceCode" id="cb1398"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1398-1" data-line-number="1"><span class="pp">#define STRING( ... ) # </span><span class="ot">__VA_ARGS__</span></a>
<a class="sourceLine" id="cb1398-2" data-line-number="2"></a>
<a class="sourceLine" id="cb1398-3" data-line-number="3">STRING()</a>
<a class="sourceLine" id="cb1398-4" data-line-number="4">STRING( hello,world )</a></code></pre></div>
<p>以下のように置換される。</p>
<div class="sourceCode" id="cb1399"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1399-1" data-line-number="1"><span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="cb1399-2" data-line-number="2"><span class="st">&quot;hello,world&quot;</span></a></code></pre></div>
<h3 id="演算子-1">##演算子</h3>
<p><code>##</code>はマクロ実引数の結合を行う。</p>
<p><code>##</code>は関数風マクロの置換リストの中にしか書けない。<code>##</code>は両端にマクロの仮引数の識別子を書かなければならない。<code>##</code>は両端の識別子の参照するマクロ実引数のトークン列を結合した置換を行う。</p>
<div class="sourceCode" id="cb1400"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1400-1" data-line-number="1"><span class="pp">#define CONCAT( A, B ) A ## B</span></a>
<a class="sourceLine" id="cb1400-2" data-line-number="2"></a>
<a class="sourceLine" id="cb1400-3" data-line-number="3">CONCAT( foo, bar )</a>
<a class="sourceLine" id="cb1400-4" data-line-number="4">CONCAT( aaa bbb, ccc ddd)</a></code></pre></div>
<p>これは以下のように置換される。</p>
<pre><code>foobar
aaa bbbccc ddd</code></pre>
<p>結合した結果のトークンは更にマクロ置換の対象となる。</p>
<div class="sourceCode" id="cb1402"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1402-1" data-line-number="1"><span class="pp">#define CONCAT( A, B ) A ## B</span></a>
<a class="sourceLine" id="cb1402-2" data-line-number="2"><span class="pp">#define FOOBAR hello</span></a>
<a class="sourceLine" id="cb1402-3" data-line-number="3"></a>
<a class="sourceLine" id="cb1402-4" data-line-number="4">CONCAT( FOO, BAR )</a></code></pre></div>
<p>これは以下のように置換される。</p>
<pre><code>hello</code></pre>
<p><code>CONCAT(FOO,BAR)</code>は<code>FOOBAR</code>に置換され、FOOBARという名前のマクロ名があるためにさらに<code>hello</code>に置換される。</p>
<h3 id="複数行の置換リスト">複数行の置換リスト</h3>
<p><code>#define</code>ディレクティブの置換リストは複数行に渡って書くことができない。これは文法上の制約によるものだ。<code>#define</code>ディレクティブは改行文字で終端される。</p>
<p>しかし、関数やクラスを生成するような複雑なマクロは、複数行に分けて書きたい。</p>
<div class="sourceCode" id="cb1404"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1404-1" data-line-number="1"><span class="pp">#define LIST_NAME2( PREFIX, TYPE ) PREFIX ## TYPE</span></a>
<a class="sourceLine" id="cb1404-2" data-line-number="2"><span class="pp">#define LIST_NAME( TYPE ) LIST_NAME2( list_, TYPE )</span></a>
<a class="sourceLine" id="cb1404-3" data-line-number="3"></a>
<a class="sourceLine" id="cb1404-4" data-line-number="4"><span class="pp">#define DEFINE_LIST( TYPE ) struct LIST_NAME(TYPE){TYPE value ;LIST_NAME(TYPE) * prev ;LIST_NAME(TYPE) * next ;} ; </span></a>
<a class="sourceLine" id="cb1404-5" data-line-number="5"></a>
<a class="sourceLine" id="cb1404-6" data-line-number="6">DEFINE_LIST(<span class="dt">int</span>)</a>
<a class="sourceLine" id="cb1404-7" data-line-number="7">DEFINE_LIST(<span class="dt">double</span>)</a></code></pre></div>
<p>この場合、行末にバックスラッシュに続けて改行を書くと、バックスラッシュと改行がプリプロセッサーによって削除される。</p>
<p>上の例は以下のように、プリプロセッサーとしては比較的わかりやすく書くことができる。</p>
<div class="sourceCode" id="cb1405"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1405-1" data-line-number="1"><span class="pp">#define LIST_NAME2( PREFIX, TYPE ) PREFIX ## TYPE</span></a>
<a class="sourceLine" id="cb1405-2" data-line-number="2"><span class="pp">#define LIST_NAME( TYPE ) LIST_NAME2( list_, TYPE )</span></a>
<a class="sourceLine" id="cb1405-3" data-line-number="3"></a>
<a class="sourceLine" id="cb1405-4" data-line-number="4"><span class="pp">#define DEFINE_LIST( TYPE )</span>\</a>
<a class="sourceLine" id="cb1405-5" data-line-number="5"><span class="pp">struct LIST_NAME(TYPE)</span>\</a>
<a class="sourceLine" id="cb1405-6" data-line-number="6"><span class="pp">{</span>\</a>
<a class="sourceLine" id="cb1405-7" data-line-number="7"><span class="pp">    TYPE value ;</span>\</a>
<a class="sourceLine" id="cb1405-8" data-line-number="8"><span class="pp">    LIST_NAME(TYPE) * prev ;</span>\</a>
<a class="sourceLine" id="cb1405-9" data-line-number="9"><span class="pp">    LIST_NAME(TYPE) * next ;</span>\</a>
<a class="sourceLine" id="cb1405-10" data-line-number="10"><span class="pp">} ; </span></a>
<a class="sourceLine" id="cb1405-11" data-line-number="11"></a>
<a class="sourceLine" id="cb1405-12" data-line-number="12">DEFINE_LIST(<span class="dt">int</span>)</a>
<a class="sourceLine" id="cb1405-13" data-line-number="13">DEFINE_LIST(<span class="dt">double</span>)</a></code></pre></div>
<p>C++ではテンプレートがあるために、このようなマクロを書く必要はない。</p>
<h3 id="undefディレクティブ">#undefディレクティブ</h3>
<p><code>#undef</code>はそれ以前に定義されたマクロを削除する。</p>
<div class="sourceCode" id="cb1406"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1406-1" data-line-number="1"><span class="pp">#define FOO BAR</span></a>
<a class="sourceLine" id="cb1406-2" data-line-number="2">FOO</a>
<a class="sourceLine" id="cb1406-3" data-line-number="3"><span class="pp">#undef FOO</span></a>
<a class="sourceLine" id="cb1406-4" data-line-number="4">FOO</a></code></pre></div>
<p>これは以下のように置換される。</p>
<pre><code>BAR
FOO</code></pre>
<h2 id="条件付きソースファイル選択">条件付きソースファイル選択</h2>
<p><code>#if</code>, <code>#elif</code>, <code>#else</code>, <code>#endif</code>, <code>#ifdef</code>, <code>#ifndef</code>は条件付きのソースファイルの選択(conditional inclusion)を行う。これは条件付きコンパイルに近い機能を提供する。</p>
<h3 id="プリプロセッサーの定数式">プリプロセッサーの定数式</h3>
<p>プリプロセッサーで使える条件式は、C++の条件式とは比べてだいぶ制限がある。基本的には整数定数式で、<code>true</code>, <code>false</code>が使える他、<code>123</code>, <code>1+1</code>, <code>1 == 1</code>, <code>1 &lt; 1</code>のような式も使える。ただし、識別子はすべてマクロ名として置換できるものは置換され、置換できない識別子は、<code>true</code>, <code>false</code>以外はキーワードも含めてすべて0に置換される。</p>
<p>したがって、プリプロセッサーで以下のように書くと、</p>
<div class="sourceCode" id="cb1408"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1408-1" data-line-number="1"><span class="pp">#if UNDEFINED</span></a>
<a class="sourceLine" id="cb1408-2" data-line-number="2"><span class="pp">#endif</span></a></code></pre></div>
<p>以下のように書いたものと同じになる。</p>
<div class="sourceCode" id="cb1409"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1409-1" data-line-number="1"><span class="pp">#if 0</span></a>
<a class="sourceLine" id="cb1409-2" data-line-number="2"><span class="pp">#endif</span></a></code></pre></div>
<p>プリプロセッサーであるので、C++としてのconstexpr変数やconstexpr関数も使えない。</p>
<div class="sourceCode" id="cb1410"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1410-1" data-line-number="1"><span class="kw">constexpr</span> <span class="dt">int</span> x = <span class="dv">1</span> ;</a>
<a class="sourceLine" id="cb1410-2" data-line-number="2"></a>
<a class="sourceLine" id="cb1410-3" data-line-number="3"><span class="pp">#if x</span></a>
<a class="sourceLine" id="cb1410-4" data-line-number="4">hello</a>
<a class="sourceLine" id="cb1410-5" data-line-number="5"><span class="pp">#endif</span></a></code></pre></div>
<p>これは以下のように置換される。</p>
<pre><code>constexpr int x = 1 ;</code></pre>
<p>プリプロセッサーはC++の文法と意味を理解しない。単にトークン列として処理する。</p>
<p>以下の例はエラーになる。</p>
<div class="sourceCode" id="cb1412"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1412-1" data-line-number="1"><span class="kw">constexpr</span> <span class="dt">int</span> f() { <span class="cf">return</span> <span class="dv">1</span> ; }</a>
<a class="sourceLine" id="cb1412-2" data-line-number="2"></a>
<a class="sourceLine" id="cb1412-3" data-line-number="3"><span class="pp">#if f()</span></a>
<a class="sourceLine" id="cb1412-4" data-line-number="4"><span class="pp">#endif</span></a></code></pre></div>
<p>なぜならば、<code>0()</code>は整数定数式として合法なコードではないからだ。何度も言うように、プリプロセッサーはC++の文法と意味を理解しない。</p>
<p>プリプロセッサーの定数式では、特殊なマクロ風の式を使うことができる。<code>defined</code>と<code>__has_include</code>だ。</p>
<p><code>defined</code>は以下の文法を持つ</p>
<pre><code>defined 識別子
defined ( 識別子 )</code></pre>
<p><code>defined</code>は識別子がそれ以前の行で<code>#define</code>でマクロとして定義されていて<code>#undef</code>で取り消されていない場合<code>1</code>になり、それ以外の場合0になる。</p>
<div class="sourceCode" id="cb1414"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1414-1" data-line-number="1"><span class="co">// #if 0</span></a>
<a class="sourceLine" id="cb1414-2" data-line-number="2"><span class="pp">#if defined MACRO</span></a>
<a class="sourceLine" id="cb1414-3" data-line-number="3"><span class="pp">#endif</span></a>
<a class="sourceLine" id="cb1414-4" data-line-number="4"></a>
<a class="sourceLine" id="cb1414-5" data-line-number="5"><span class="pp">#define MACRO</span></a>
<a class="sourceLine" id="cb1414-6" data-line-number="6"></a>
<a class="sourceLine" id="cb1414-7" data-line-number="7"><span class="co">// #if 1</span></a>
<a class="sourceLine" id="cb1414-8" data-line-number="8"><span class="pp">#if defined MACRO</span></a>
<a class="sourceLine" id="cb1414-9" data-line-number="9"><span class="pp">#endif</span></a>
<a class="sourceLine" id="cb1414-10" data-line-number="10"></a>
<a class="sourceLine" id="cb1414-11" data-line-number="11"><span class="pp">#undef MACRO</span></a>
<a class="sourceLine" id="cb1414-12" data-line-number="12"></a>
<a class="sourceLine" id="cb1414-13" data-line-number="13"><span class="co">// #if 0</span></a>
<a class="sourceLine" id="cb1414-14" data-line-number="14"><span class="pp">#if defined MACRO</span></a>
<a class="sourceLine" id="cb1414-15" data-line-number="15"><span class="pp">#endif</span></a></code></pre></div>
<p><code>__has_include</code>は以下の文法を持つ。</p>
<div class="sourceCode" id="cb1415"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1415-1" data-line-number="1">__has_include ( &lt; ヘッダーファイル名 &gt; )</a>
<a class="sourceLine" id="cb1415-2" data-line-number="2">__has_include ( <span class="st">&quot; ヘッダーファイル名 &quot;</span> )</a>
<a class="sourceLine" id="cb1415-3" data-line-number="3">__has_include ( 文字列リテラル )</a>
<a class="sourceLine" id="cb1415-4" data-line-number="4">__has_include ( &lt; マクロ &gt; )</a></code></pre></div>
<p>1番目と2番目は、指定されたヘッダーファイル名がシステムに存在する場合<code>1</code>に、そうでない場合0になる。</p>
<div class="sourceCode" id="cb1416"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1416-1" data-line-number="1"><span class="co">// &lt;filesystem&gt;の存在を確認してから#includeする</span></a>
<a class="sourceLine" id="cb1416-2" data-line-number="2"><span class="pp">#if __has_include(&lt;filesystem&gt;)</span></a>
<a class="sourceLine" id="cb1416-3" data-line-number="3"><span class="pp">#   include </span><span class="im">&lt;filesystem&gt;</span></a>
<a class="sourceLine" id="cb1416-4" data-line-number="4"><span class="pp">#endif</span></a>
<a class="sourceLine" id="cb1416-5" data-line-number="5"></a>
<a class="sourceLine" id="cb1416-6" data-line-number="6"><span class="co">// &quot;mylibrary.h&quot;の存在を確認してから#includeする</span></a>
<a class="sourceLine" id="cb1416-7" data-line-number="7"><span class="pp">#if __has_include(&quot;mylibrary.h&quot;)</span></a>
<a class="sourceLine" id="cb1416-8" data-line-number="8"><span class="pp">#   include </span><span class="im">&quot;mylibrary.h&quot;</span></a>
<a class="sourceLine" id="cb1416-9" data-line-number="9"><span class="pp">#endif</span></a></code></pre></div>
<p>3番目と4番目は、1番目と2番目が適用できない場合に初めて考慮される。その場合、まず通常通りにプリプロセッサーのマクロ置換が行われる。</p>
<div class="sourceCode" id="cb1417"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1417-1" data-line-number="1"><span class="pp">#define STDIO &quot;stdio.h&quot;</span></a>
<a class="sourceLine" id="cb1417-2" data-line-number="2"></a>
<a class="sourceLine" id="cb1417-3" data-line-number="3"><span class="pp">#if __has_include( STDIO )</span></a>
<a class="sourceLine" id="cb1417-4" data-line-number="4"><span class="pp">#endif</span></a>
<a class="sourceLine" id="cb1417-5" data-line-number="5"></a>
<a class="sourceLine" id="cb1417-6" data-line-number="6"><span class="pp">#define STDLIB stdlib.h</span></a>
<a class="sourceLine" id="cb1417-7" data-line-number="7"></a>
<a class="sourceLine" id="cb1417-8" data-line-number="8"><span class="pp">#if __has_include( &lt;STDLIB&gt; )</span></a>
<a class="sourceLine" id="cb1417-9" data-line-number="9"><span class="pp">#endif</span></a></code></pre></div>
<h3 id="ifディレクティブ">#ifディレクティブ</h3>
<p><code>#if</code>ディレクティブは以下の文法を持つ。</p>
<pre><code>#if 定数式 改行文字

#endif</code></pre>
<p>もし定数式がゼロの場合、<code>#if</code>と<code>#endif</code>で囲まれたトークン列は処理されない。定数式が非ゼロの場合、処理される。</p>
<div class="sourceCode" id="cb1419"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1419-1" data-line-number="1"><span class="pp">#if 0</span></a>
<a class="sourceLine" id="cb1419-2" data-line-number="2"><span class="co">This line will be skipped.</span></a>
<a class="sourceLine" id="cb1419-3" data-line-number="3"><span class="pp">#endif</span></a>
<a class="sourceLine" id="cb1419-4" data-line-number="4"></a>
<a class="sourceLine" id="cb1419-5" data-line-number="5"><span class="pp">#if 1</span></a>
<a class="sourceLine" id="cb1419-6" data-line-number="6">This line will be processed.</a>
<a class="sourceLine" id="cb1419-7" data-line-number="7"><span class="pp">#endif</span></a></code></pre></div>
<p>これをプリプロセスすると以下のようになる。</p>
<div class="sourceCode" id="cb1420"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1420-1" data-line-number="1">This line will be processed.</a></code></pre></div>
<p><code>#if 0</code>は処理されないので、<code>#endif</code>までのトークン列は消える。</p>
<h3 id="elifディレクティブ">#elifディレクティブ</h3>
<p><code>#elif</code>ディレクティブは、C++でいう<code>else if</code>に相当する。</p>
<div class="sourceCode" id="cb1421"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1421-1" data-line-number="1"></a>
<a class="sourceLine" id="cb1421-2" data-line-number="2"><span class="pp">#elif 定数式 改行文字</span></a></code></pre></div>
<p><code>#elif</code>ディレクティブは<code>#if</code>ディレクティブと<code>#endif</code>ディレクティブの間に複数書くことができる。<code>#elif</code>のある<code>#if</code>が処理される場合、<code>#if</code>から<code>#elif</code>の間のトークン列が処理される、<code>#if</code>が処理されない場合、<code>#elif</code>が<code>#if</code>と同じように定数式を評価して処理されるかどうかが判断される。<code>#elif</code>が処理される場合、処理されるトークン列は次の<code>#elif</code>もしくは<code>#endif</code>までの間のトークン列になる。</p>
<p>以下の例は、すべてYESのトークンがある行のみ処理される。</p>
<div class="sourceCode" id="cb1422"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1422-1" data-line-number="1"><span class="pp">#if 1</span></a>
<a class="sourceLine" id="cb1422-2" data-line-number="2">YES</a>
<a class="sourceLine" id="cb1422-3" data-line-number="3"><span class="pp">#elif</span><span class="co"> 1</span></a>
<a class="sourceLine" id="cb1422-4" data-line-number="4"><span class="co">NO</span></a>
<a class="sourceLine" id="cb1422-5" data-line-number="5"><span class="pp">#endif</span></a>
<a class="sourceLine" id="cb1422-6" data-line-number="6"></a>
<a class="sourceLine" id="cb1422-7" data-line-number="7"><span class="pp">#if 0</span></a>
<a class="sourceLine" id="cb1422-8" data-line-number="8"><span class="co">NO</span></a>
<a class="sourceLine" id="cb1422-9" data-line-number="9"><span class="pp">#elif</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb1422-10" data-line-number="10">YES</a>
<a class="sourceLine" id="cb1422-11" data-line-number="11"><span class="pp">#endif</span></a>
<a class="sourceLine" id="cb1422-12" data-line-number="12"></a>
<a class="sourceLine" id="cb1422-13" data-line-number="13"><span class="pp">#if 0</span></a>
<a class="sourceLine" id="cb1422-14" data-line-number="14"><span class="co">NO</span></a>
<a class="sourceLine" id="cb1422-15" data-line-number="15"><span class="pp">#elif</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb1422-16" data-line-number="16">YES</a>
<a class="sourceLine" id="cb1422-17" data-line-number="17"><span class="pp">#elif 1</span></a>
<a class="sourceLine" id="cb1422-18" data-line-number="18">NO</a>
<a class="sourceLine" id="cb1422-19" data-line-number="19"><span class="pp">#endif</span></a>
<a class="sourceLine" id="cb1422-20" data-line-number="20"></a>
<a class="sourceLine" id="cb1422-21" data-line-number="21"><span class="pp">#if 0</span></a>
<a class="sourceLine" id="cb1422-22" data-line-number="22"><span class="co">NO</span></a>
<a class="sourceLine" id="cb1422-23" data-line-number="23"><span class="pp">#elif</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb1422-24" data-line-number="24">NO</a>
<a class="sourceLine" id="cb1422-25" data-line-number="25"><span class="pp">#elif 1</span></a>
<a class="sourceLine" id="cb1422-26" data-line-number="26">YES</a>
<a class="sourceLine" id="cb1422-27" data-line-number="27"><span class="pp">#endif</span></a></code></pre></div>
<p>プリプロセスした結果は以下の通り、</p>
<pre><code>YES
YES
YES
YES</code></pre>
<h3 id="elseディレクティブ">#elseディレクティブ</h3>
<p><code>#else</code>ディレクティブはC++でいう<code>else</code>に相当する。</p>
<p><code>#else</code>ディレクティブは<code>#if</code>ディレクティブと<code>#endif</code>ディレクティブの間に書くことができる。もし<code>#if</code>と<code>#elif</code>ディレクティブが処理されない場合で<code>#else</code>ディレクティブがある場合、<code>#else</code>から<code>#endif</code>までのトークン列が処理される。</p>
<p>以下の例は、YESのトークンがある行のみ処理される。</p>
<div class="sourceCode" id="cb1424"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1424-1" data-line-number="1"><span class="pp">#if 1</span></a>
<a class="sourceLine" id="cb1424-2" data-line-number="2">YES</a>
<a class="sourceLine" id="cb1424-3" data-line-number="3"><span class="pp">#else</span></a>
<a class="sourceLine" id="cb1424-4" data-line-number="4"><span class="co">NO</span></a>
<a class="sourceLine" id="cb1424-5" data-line-number="5"><span class="pp">#endif</span></a>
<a class="sourceLine" id="cb1424-6" data-line-number="6"></a>
<a class="sourceLine" id="cb1424-7" data-line-number="7"><span class="pp">#if 0</span></a>
<a class="sourceLine" id="cb1424-8" data-line-number="8"><span class="co">NO</span></a>
<a class="sourceLine" id="cb1424-9" data-line-number="9"><span class="pp">#else</span></a>
<a class="sourceLine" id="cb1424-10" data-line-number="10">YES</a>
<a class="sourceLine" id="cb1424-11" data-line-number="11"><span class="pp">#endif</span></a>
<a class="sourceLine" id="cb1424-12" data-line-number="12"></a>
<a class="sourceLine" id="cb1424-13" data-line-number="13"><span class="pp">#if 0</span></a>
<a class="sourceLine" id="cb1424-14" data-line-number="14"><span class="co">NO</span></a>
<a class="sourceLine" id="cb1424-15" data-line-number="15"><span class="pp">#elif</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb1424-16" data-line-number="16">YES</a>
<a class="sourceLine" id="cb1424-17" data-line-number="17"><span class="pp">#else</span></a>
<a class="sourceLine" id="cb1424-18" data-line-number="18">NO</a>
<a class="sourceLine" id="cb1424-19" data-line-number="19"><span class="pp">#endif</span></a></code></pre></div>
<h3 id="ifdef-ifndefディレクティブ">#ifdef, #ifndefディレクティブ</h3>
<pre><code>#ifdef 識別子
#ifndef 識別子</code></pre>
<p>は、それぞれ以下と同じ意味になる。</p>
<pre><code>#if defined 識別子
#if !defined 識別子</code></pre>
<p>例、</p>
<div class="sourceCode" id="cb1427"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1427-1" data-line-number="1"><span class="pp">#ifdef MACRO</span></a>
<a class="sourceLine" id="cb1427-2" data-line-number="2"><span class="pp">#endif</span></a>
<a class="sourceLine" id="cb1427-3" data-line-number="3"></a>
<a class="sourceLine" id="cb1427-4" data-line-number="4"><span class="co">// 上と同じ</span></a>
<a class="sourceLine" id="cb1427-5" data-line-number="5"><span class="pp">#if defined MACRO</span></a>
<a class="sourceLine" id="cb1427-6" data-line-number="6"><span class="pp">#endif</span></a>
<a class="sourceLine" id="cb1427-7" data-line-number="7"></a>
<a class="sourceLine" id="cb1427-8" data-line-number="8"></a>
<a class="sourceLine" id="cb1427-9" data-line-number="9"><span class="pp">#ifndef MACRO</span></a>
<a class="sourceLine" id="cb1427-10" data-line-number="10"><span class="pp">#endif</span></a>
<a class="sourceLine" id="cb1427-11" data-line-number="11"></a>
<a class="sourceLine" id="cb1427-12" data-line-number="12"><span class="co">// 上と同じ</span></a>
<a class="sourceLine" id="cb1427-13" data-line-number="13"><span class="pp">#if !defined MACRO</span></a>
<a class="sourceLine" id="cb1427-14" data-line-number="14"><span class="pp">#endif</span></a></code></pre></div>
<h2 id="lineディレクティブ">#lineディレクティブ</h2>
<p><code>#line</code>ディレクティブはディレクティブの次の行の行番号と、ソースファイル名を変更する。これは人間が使うのではなく、ツールによって生成されることを想定した機能だ。</p>
<p>以下の文法の<code>#line</code>ディレクティブは、<code>#line</code>ディレクティブの次の行の行番号をあたかも数値で指定した行番号であるかのように振る舞わせる。</p>
<pre><code>#line 数値 改行文字</code></pre>
<p>数値として0もしくは2147483647より大きい数を指定した場合の挙動は未定義となる。</p>
<p>以下の例はコンパイルエラーになるが、コンパイルエラーメッセージはあたかも102行目に問題があるかのように表示される。</p>
<div class="sourceCode" id="cb1429"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1429-1" data-line-number="1"><span class="co">// 1行目</span></a>
<a class="sourceLine" id="cb1429-2" data-line-number="2"><span class="co">// 2行目</span></a>
<a class="sourceLine" id="cb1429-3" data-line-number="3"><span class="pp">#line 100 </span><span class="co">// 3行目</span></a>
<a class="sourceLine" id="cb1429-4" data-line-number="4"><span class="co">// 100行目</span></a>
<a class="sourceLine" id="cb1429-5" data-line-number="5"><span class="co">// 101行目</span></a>
<a class="sourceLine" id="cb1429-6" data-line-number="6">ill-formed line <span class="co">// 102行目</span></a></code></pre></div>
<p>以下の例は999を出力するコードだ。</p>
<div class="sourceCode" id="cb1430"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1430-1" data-line-number="1"><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></a>
<a class="sourceLine" id="cb1430-2" data-line-number="2"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1430-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb1430-4" data-line-number="4"><span class="pp">#line 999</span></a>
<a class="sourceLine" id="cb1430-5" data-line-number="5">    <span class="bu">std::</span>cout &lt;&lt; <span class="ot">__LINE__</span> ;</a>
<a class="sourceLine" id="cb1430-6" data-line-number="6">}</a></code></pre></div>
<p>以下の文法の<code>#line</code>ディレクティブは、次の行の行番号を数値にした上で、ソースファイル名をソースファイル名にする。</p>
<pre class="v++"><code>#line 数値 &quot;ソースファイル名&quot; 改行文字</code></pre>
<p>例、</p>
<div class="sourceCode" id="cb1432"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1432-1" data-line-number="1"><span class="pp">#line 42 &quot;answer.cpp&quot;</span></a></code></pre></div>
<p>以下の文法の<code>#line</code>ディレクティブは、プリプロセッサートークン列をプリプロセスし、上の2つの文法のいずれかに合致させる。</p>
<div class="sourceCode" id="cb1433"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1433-1" data-line-number="1"><span class="pp">#line プリプロセッサートークン列 改行文字</span></a></code></pre></div>
<p>例、</p>
<div class="sourceCode" id="cb1434"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1434-1" data-line-number="1"><span class="pp">#define LINE_NUMBER 123</span></a>
<a class="sourceLine" id="cb1434-2" data-line-number="2"><span class="pp">#line LINE_NUMBER</span></a></code></pre></div>
<h2 id="errorディレクティブ">#errorディレクティブ</h2>
<p><code>#error</code>ディレクティブはコンパイルエラーを引き起こす。</p>
<pre><code>#error 改行文字
#error トークン列 改行文字</code></pre>
<p><code>#error</code>によるコンパイラーのエラーメッセージには<code>#error</code>のトークン列を含む。</p>
<p><code>#error</code>の利用例としては、<code>#if</code>と組み合わせるものがある。以下の例はCHAR_BITが8でなければコンパイルエラーになるソースファイルだ。</p>
<div class="sourceCode" id="cb1436"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1436-1" data-line-number="1"><span class="pp">#include </span><span class="im">&lt;climits&gt;</span></a>
<a class="sourceLine" id="cb1436-2" data-line-number="2"></a>
<a class="sourceLine" id="cb1436-3" data-line-number="3"><span class="pp">#if CHAR_BIT != 8</span></a>
<a class="sourceLine" id="cb1436-4" data-line-number="4"><span class="pp">#error CHAR_BIT != 8 implementation is not supported.</span></a>
<a class="sourceLine" id="cb1436-5" data-line-number="5"><span class="pp">#endif</span></a></code></pre></div>
<p><code>#if</code>が処理されなければ、その中にある<code>#error</code>も処理されないので、コンパイルエラーにはならない。</p>
<h2 id="pragma">#pragma</h2>
<p><code>#pragma</code>ディレクティブは実装依存の処理を行う。<code>#pragma</code>はコンパイラー独自の拡張機能を追加する文法として使われている。</p>
<p>文法は以下の通り。</p>
<pre><code>#pragma プリプロセッサートークン列 改行文字</code></pre>
<p>C++では属性が追加されたために、<code>#pragma</code>を使う必要はほとんどなくなっている。</p>
<h2 id="nullディレクティブ">Nullディレクティブ</h2>
<p><code>Null</code>ディレクティブとは何もしないプリプロセッサーディレクティブだ。</p>
<pre><code># 改行文字</code></pre>
<p>つまり、単に<code>#</code>とだけ書いた行はエラーにはならない。</p>
<h2 id="定義済みマクロ名">定義済みマクロ名</h2>
<p>いくつかのマクロ名がプリプロセッサーによって予め定義されている。</p>
<table>
<colgroup>
<col style="width: 42%" />
<col style="width: 17%" />
<col style="width: 40%" />
</colgroup>
<thead>
<tr class="header">
<th>マクロ名</th>
<th style="text-align: left;">値</th>
<th style="text-align: left;">意味</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>__cplusplus</td>
<td style="text-align: left;">201703L</td>
<td style="text-align: left;">C++17時点での値<br />
将来の規格で増やされる</td>
</tr>
<tr class="even">
<td>__DATE__</td>
<td style="text-align: left;">“Mmm dd yyyy”</td>
<td style="text-align: left;">ソースファイルがプリプロセスされた日付 Mmmは月、ddは日、yyyyは年<br />
月の文字列はasctimeが生成するものと同じ<br />
日が1桁の場合、ddの最初の文字は空白文字</td>
</tr>
<tr class="odd">
<td>__FILE__</td>
<td style="text-align: left;">文字列リテラル</td>
<td style="text-align: left;">ソースファイルの名前の文字列リテラル</td>
</tr>
<tr class="even">
<td>__LINE__</td>
<td style="text-align: left;">整数リテラル</td>
<td style="text-align: left;">ソースファイルの現在の行番号</td>
</tr>
<tr class="odd">
<td>__STDC_HOSTED__</td>
<td style="text-align: left;">整数リテラル</td>
<td style="text-align: left;">ホスト実装の場合1<br />
フリースタンディング実装の場合0</td>
</tr>
<tr class="even">
<td>__STDCPP_DEFAULT_NEW_ALIGNMENT__</td>
<td style="text-align: left;">整数リテラル</td>
<td style="text-align: left;">アライメント</td>
</tr>
</tbody>
</table>
<h1 id="分割コンパイル">分割コンパイル</h1>
<p>これまで、プログラムはひとつのソースファイルから作っていた。プログラムは複数のソースファイルから作ることもできる。ソースファイルを複数に分割することで、ソースファイルの管理がしやすくなったり、プログラムのビルド時間の短縮にもつながる。</p>
<h3 id="ソースファイルとコンパイル">ソースファイルとコンパイル</h3>
<p>ソースファイルを分割すると、C++の書き方にも注意が必要になる。だがその前に、複数のソースファイルをコンパイルしてひとつのプログラムにする方法を学ぶ。</p>
<h3 id="単一のソースファイルのコンパイル">単一のソースファイルのコンパイル</h3>
<p>C++のソースファイルをコンパイルして実行可能ファイルを作る方法を今一度おさらいをしよう。</p>
<p><code>source.cpp</code>という名前のソースファイルがあるとき、ここから<code>program</code>という名前の実行可能ファイルを作るには、</p>
<pre><code>$ g++ -o program source.file</code></pre>
<p>としていた。毎回このコマンドを入力するのは面倒なので、<code>Makefile</code>を以下のように書いていた。</p>
<pre><code>program: source.cpp
    g++ $&lt; -o $@</code></pre>
<h3 id="ヘッダーファイルはコピペ">ヘッダーファイルはコピペ</h3>
<p>すでに、ソースファイルの他にヘッダーファイルというファイルも使っている。ヘッダーファイルはソースファイルではない。コンパイル前にソースファイルにコピペされるだけのものだ。</p>
<p>例えば以下のような内容の<code>header.h</code>というヘッダーファイルがあるとして、</p>
<div class="sourceCode" id="cb1441"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1441-1" data-line-number="1"><span class="co">// header.h</span></a>
<a class="sourceLine" id="cb1441-2" data-line-number="2">++i ;</a></code></pre></div>
<p><code>source.cpp</code>が以下のようであるとき、</p>
<div class="sourceCode" id="cb1442"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1442-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1442-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1442-3" data-line-number="3">    <span class="dt">int</span> i = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb1442-4" data-line-number="4"><span class="pp">#include </span><span class="im">&quot;header.h&quot;</span></a>
<a class="sourceLine" id="cb1442-5" data-line-number="5"><span class="pp">#include </span><span class="im">&quot;header.h&quot;</span></a>
<a class="sourceLine" id="cb1442-6" data-line-number="6"><span class="pp">#include </span><span class="im">&quot;header.h&quot;</span></a>
<a class="sourceLine" id="cb1442-7" data-line-number="7">    <span class="dt">int</span> result = i ;</a>
<a class="sourceLine" id="cb1442-8" data-line-number="8">}</a></code></pre></div>
<p><code>source.cpp</code>をコンパイルすると、まずヘッダーファイルが以下のように展開される。</p>
<div class="sourceCode" id="cb1443"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1443-1" data-line-number="1"></a>
<a class="sourceLine" id="cb1443-2" data-line-number="2"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1443-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb1443-4" data-line-number="4">    <span class="dt">int</span> i = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb1443-5" data-line-number="5"><span class="co">// header.h</span></a>
<a class="sourceLine" id="cb1443-6" data-line-number="6">++i ;</a>
<a class="sourceLine" id="cb1443-7" data-line-number="7"><span class="co">// header.h</span></a>
<a class="sourceLine" id="cb1443-8" data-line-number="8">++i ;</a>
<a class="sourceLine" id="cb1443-9" data-line-number="9"><span class="co">// header.h</span></a>
<a class="sourceLine" id="cb1443-10" data-line-number="10">++i ;</a>
<a class="sourceLine" id="cb1443-11" data-line-number="11">    <span class="dt">int</span> result = i ;</a>
<a class="sourceLine" id="cb1443-12" data-line-number="12">}</a></code></pre></div>
<p>ヘッダーファイルとはこれだけのものだ。コンパイラーが<code>#include</code>された場所に、ヘッダーファイルの中身を愚直にコピペするだけだ。</p>
<h3 id="複数のソースファイルのコンパイル">複数のソースファイルのコンパイル</h3>
<p>2つのソースファイル、<code>foo.cpp</code>と<code>bar.cpp</code>からなるプログラムをコンパイルするには、</p>
<pre><code>$ g++ -o program foo.cpp bar.cpp</code></pre>
<p>とする。</p>
<h2 id="オブジェクトファイル">オブジェクトファイル</h2>
<p>単にソースファイルを分割したいだけならば、GCCに分割したソースファイルをすべて指定すればよい。しかしその場合、複数あるソースファイルのひとつだけを編集した場合でも、すべてのソースファイルをコンパイルしなければならない。</p>
<p>C++では伝統的に、ソースファイルを部分的にコンパイルしてオブジェクトファイルを生成し、オブジェクトファイルをリンクしてプログラムを生成する方法がある。</p>
<p>ソースファイルをオブジェクトファイルにコンパイルするのは<code>コンパイラー</code>、オブジェクトファイルをプログラムにリンクするのは<code>リンカー</code>の仕事だ。</p>
<pre><code>TODO: 図示
ソースファイル→(コンパイラー)→オブジェクトファイル→(リンカー)→プログラム</code></pre>
<p>GCCではC++コンパイラーの名前は<code>g++</code>で、リンカーの名前は<code>ld</code>だ。ただし、C++のオブジェクトファイルをリンクするのにリンカーを直接使うことはない。<code>g++</code>は<code>ld</code>を適切に呼び出してくれるからだ。</p>
<p>ソースファイル<code>source.cpp</code>をコンパイルしてオブジェクトファイルを生成するには、<code>-c</code>オプションを使う。</p>
<pre><code>$ g++ -c source.cpp</code></pre>
<p>生成されるオブジェクトファイルの名前はソースファイルの名前の拡張子を<code>.o</code>に置き換えたものになる。上のコマンドを実行した結果、オブジェクトファイル<code>source.o</code>が生成される。</p>
<p>生成したオブジェクトファイルは、<code>g++</code>の入力として使うことで、リンクしてプログラムにすることができる。<code>g++</code>は裏でリンカー<code>ld</code>を適切に呼び出してくれる。</p>
<pre><code>$ g++ -o program source.o</code></pre>
<p>オブジェクトファイル名を別の名前にしたい場合は、<code>-o object-file-name</code>オプションを使う。</p>
<pre><code>$ g++ -o object.o -c source.cpp</code></pre>
<p>複数のソースファイル、<code>foo.cpp</code>と<code>bar.cpp</code>からオブジェクトファイルを生成し、リンクして実行可能ファイル<code>program</code>を生成するには以下のようにする。</p>
<pre><code>$ ls
bar.cpp  foo.cpp
$ g++ -c foo.cpp
$ g++ -c bar.cpp
$ ls
bar.cpp  bar.o  foo.cpp  foo.o
$ g++ -o program foo.o bar.o
$ ls
bar.cpp  bar.o  foo.cpp  foo.o  program</code></pre>
<p>こうすることによって、ひとつのソースファイルを編集しただけで、すべてのソースファイルをコンパイルする必要がなくなる。</p>
<p>これをMakefileで書くには、出力するファイルと依存するファイルを考える。</p>
<ul>
<li><code>program</code>は<code>foo.o</code>と<code>bar.o</code>に依存する</li>
<li><code>foo.o</code>は<code>foo.cpp</code>に依存する</li>
<li><code>bar.o</code>は<code>bar.cpp</code>に依存する</li>
</ul>
<p>これを素直に書き出していけばよい。</p>
<pre><code># programはfoo.oとbar.oに依存する
program : foo.o bar.o
    g++ -o $@ $^
# foo.oはfoo.cppに依存する
foo.o : foo.cpp
    g++ -c $&lt;
# bar.oはbar.cppに依存する
bar.o : bar.cpp
    g++ -c $&lt;</code></pre>
<p><code>$^</code>はそのルールの依存するファイル名をすべて空白区切りで得る自動変数だ。この場合、<code>foo.o bar.o</code>に置換される。</p>
<h2 id="複数のソースファイルの書き方">複数のソースファイルの書き方</h2>
<p>C++のひとつのソースファイルは、1つの<code>翻訳単位</code>(translation unit)として扱われる。別の翻訳単位の定義を使うには、様々な制約がある。具体的な例で学ぼう。</p>
<h3 id="関数">関数</h3>
<p>以下のコードを見てみよう。</p>
<div class="sourceCode" id="cb1451"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1451-1" data-line-number="1"><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></a>
<a class="sourceLine" id="cb1451-2" data-line-number="2"></a>
<a class="sourceLine" id="cb1451-3" data-line-number="3"><span class="dt">void</span> print_int( <span class="dt">int</span> x )</a>
<a class="sourceLine" id="cb1451-4" data-line-number="4">{</a>
<a class="sourceLine" id="cb1451-5" data-line-number="5">    <span class="bu">std::</span>cout &lt;&lt; x ;    </a>
<a class="sourceLine" id="cb1451-6" data-line-number="6">}</a>
<a class="sourceLine" id="cb1451-7" data-line-number="7"></a>
<a class="sourceLine" id="cb1451-8" data-line-number="8"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1451-9" data-line-number="9">{</a>
<a class="sourceLine" id="cb1451-10" data-line-number="10">    print_int( <span class="dv">123</span> ) ;</a>
<a class="sourceLine" id="cb1451-11" data-line-number="11">}</a></code></pre></div>
<p>このコードには2つの定義がある。<code>print_int</code>と<code>main</code>だ。</p>
<p>関数<code>print_int</code>を別のソースファイルである<code>print_int.cpp</code>に分割してみよう。</p>
<div class="sourceCode" id="cb1452"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1452-1" data-line-number="1"><span class="co">// print_int.cpp</span></a>
<a class="sourceLine" id="cb1452-2" data-line-number="2"><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></a>
<a class="sourceLine" id="cb1452-3" data-line-number="3"></a>
<a class="sourceLine" id="cb1452-4" data-line-number="4"><span class="dt">void</span> print_int( <span class="dt">int</span> x )</a>
<a class="sourceLine" id="cb1452-5" data-line-number="5">{</a>
<a class="sourceLine" id="cb1452-6" data-line-number="6">    <span class="bu">std::</span>cout &lt;&lt; x ;    </a>
<a class="sourceLine" id="cb1452-7" data-line-number="7">}</a></code></pre></div>
<p>このコードは問題なくコンパイルできる。</p>
<pre><code>$ g++ -c print_int.cpp</code></pre>
<p>すると残りのソースファイルを<code>main.cpp</code>とすると以下のようになる。</p>
<div class="sourceCode" id="cb1454"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1454-1" data-line-number="1"><span class="co">// main.cpp</span></a>
<a class="sourceLine" id="cb1454-2" data-line-number="2"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1454-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb1454-4" data-line-number="4">    print_int( <span class="dv">123</span> ) ;</a>
<a class="sourceLine" id="cb1454-5" data-line-number="5">}</a></code></pre></div>
<p>このコードはコンパイルできない。なぜならば、C++では名前は使う前に宣言しなければならないからだ。</p>
<p>関数を宣言するには、関数の本体以外の部分を書き、セミコロンで終端する。</p>
<div class="sourceCode" id="cb1455"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1455-1" data-line-number="1"><span class="co">// main.cpp</span></a>
<a class="sourceLine" id="cb1455-2" data-line-number="2"><span class="dt">void</span> print_int( <span class="dt">int</span> ) ;</a>
<a class="sourceLine" id="cb1455-3" data-line-number="3"></a>
<a class="sourceLine" id="cb1455-4" data-line-number="4"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1455-5" data-line-number="5">{</a>
<a class="sourceLine" id="cb1455-6" data-line-number="6">    print_int( <span class="dv">123</span> ) ;</a>
<a class="sourceLine" id="cb1455-7" data-line-number="7">}</a></code></pre></div>
<p>これでコンパイル、リンクができるようになった。</p>
<pre><code>$ g++ -c main.cpp
$ g++ -o program main.o print_int.o</code></pre>
<p>このとき、<code>main.cpp</code>で関数<code>print_int</code>を定義することはできない。</p>
<div class="sourceCode" id="cb1457"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1457-1" data-line-number="1"><span class="co">// エラー、print_int.cppでも定義されている</span></a>
<a class="sourceLine" id="cb1457-2" data-line-number="2"><span class="dt">void</span> print_int( <span class="dt">int</span> ) { }</a>
<a class="sourceLine" id="cb1457-3" data-line-number="3"></a>
<a class="sourceLine" id="cb1457-4" data-line-number="4"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1457-5" data-line-number="5">{</a>
<a class="sourceLine" id="cb1457-6" data-line-number="6">    print_int( <span class="dv">123</span> ) ;</a>
<a class="sourceLine" id="cb1457-7" data-line-number="7">}</a></code></pre></div>
<p>C++では定義は全翻訳単位にひとつしか書くことができないルール、ODR(One Definition Rule、単一定義原則)があるからだ。</p>
<div class="sourceCode" id="cb1458"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1458-1" data-line-number="1"><span class="co">// 宣言</span></a>
<a class="sourceLine" id="cb1458-2" data-line-number="2"><span class="dt">void</span> f() ;</a>
<a class="sourceLine" id="cb1458-3" data-line-number="3"></a>
<a class="sourceLine" id="cb1458-4" data-line-number="4"><span class="co">// OK、再宣言</span></a>
<a class="sourceLine" id="cb1458-5" data-line-number="5"><span class="dt">void</span> f() ;</a>
<a class="sourceLine" id="cb1458-6" data-line-number="6"></a>
<a class="sourceLine" id="cb1458-7" data-line-number="7"><span class="co">// 定義</span></a>
<a class="sourceLine" id="cb1458-8" data-line-number="8"><span class="dt">void</span> f() { }</a>
<a class="sourceLine" id="cb1458-9" data-line-number="9"></a>
<a class="sourceLine" id="cb1458-10" data-line-number="10"><span class="co">// エラー、再定義</span></a>
<a class="sourceLine" id="cb1458-11" data-line-number="11"><span class="co">// ODR違反</span></a>
<a class="sourceLine" id="cb1458-12" data-line-number="12"><span class="dt">void</span> f() { }</a></code></pre></div>
<p>なぜODRがあるのか。なぜ定義はひとつしか書けないのか。理由は簡単だ。もし定義が複数書けるならば、異なる定義を書くことができてしまうからだ。</p>
<div class="sourceCode" id="cb1459"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1459-1" data-line-number="1"><span class="dt">bool</span> f() { <span class="cf">return</span> <span class="kw">true</span> ; }</a>
<a class="sourceLine" id="cb1459-2" data-line-number="2"><span class="dt">bool</span> f() { <span class="cf">return</span> <span class="kw">false</span> ; }</a></code></pre></div>
<p>もし定義を複数書くことができる場合、この関数<code>f</code>は<code>true</code>を返すべきだろうか。それとも<code>false</code>を返すべきだろうか。</p>
<p>この問題を防ぐために、C++にはODRがある。</p>
<p>複数のソースファイル、つまり複数の翻訳単位からなるプログラムの場合でもODRは適用される。定義はすべての翻訳単位内でひとつでなければならない。</p>
<p>引数リストが違う関数は別の関数で、別の定義になる。</p>
<div class="sourceCode" id="cb1460"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1460-1" data-line-number="1"><span class="co">// 定義</span></a>
<a class="sourceLine" id="cb1460-2" data-line-number="2"><span class="dt">void</span> f() { }</a>
<a class="sourceLine" id="cb1460-3" data-line-number="3"></a>
<a class="sourceLine" id="cb1460-4" data-line-number="4"><span class="co">// OK、別の定義</span></a>
<a class="sourceLine" id="cb1460-5" data-line-number="5"><span class="dt">void</span> f( <span class="dt">int</span> ) { }</a>
<a class="sourceLine" id="cb1460-6" data-line-number="6"></a>
<a class="sourceLine" id="cb1460-7" data-line-number="7"><span class="co">// OK、別の定義</span></a>
<a class="sourceLine" id="cb1460-8" data-line-number="8"><span class="dt">void</span> f( <span class="dt">double</span> ) { }</a></code></pre></div>
<p>名前は使う前に宣言が必要だが、肝心の定義は別のソースファイルに書いてある。宣言と定義を間違えてしまった場合はエラーになる。</p>
<div class="sourceCode" id="cb1461"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1461-1" data-line-number="1"><span class="co">// print_int.hpp</span></a>
<a class="sourceLine" id="cb1461-2" data-line-number="2"><span class="co">// 失敗状態を返す</span></a>
<a class="sourceLine" id="cb1461-3" data-line-number="3"><span class="dt">bool</span> print_int( <span class="dt">int</span> x )</a>
<a class="sourceLine" id="cb1461-4" data-line-number="4">{</a>
<a class="sourceLine" id="cb1461-5" data-line-number="5">    <span class="bu">std::</span>cout &lt;&lt; x ;</a>
<a class="sourceLine" id="cb1461-6" data-line-number="6">    <span class="cf">return</span> <span class="bu">std::</span>cout.fail() ;</a>
<a class="sourceLine" id="cb1461-7" data-line-number="7">}</a>
<a class="sourceLine" id="cb1461-8" data-line-number="8"></a>
<a class="sourceLine" id="cb1461-9" data-line-number="9"><span class="co">// main.cpp</span></a>
<a class="sourceLine" id="cb1461-10" data-line-number="10"><span class="dt">void</span> print_int( <span class="dt">int</span> ) ;</a>
<a class="sourceLine" id="cb1461-11" data-line-number="11"></a>
<a class="sourceLine" id="cb1461-12" data-line-number="12"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1461-13" data-line-number="13">{</a>
<a class="sourceLine" id="cb1461-14" data-line-number="14">    <span class="co">// エラー</span></a>
<a class="sourceLine" id="cb1461-15" data-line-number="15">    print_int( <span class="dv">123</span> ) ;</a>
<a class="sourceLine" id="cb1461-16" data-line-number="16">}</a></code></pre></div>
<p>このような間違いを防ぐためのお作法として、宣言はヘッダーファイルに書いて<code>#include</code>する。 ~~~c++ // print_int.h bool print_int( int x ) ;</p>
<p>// main.cpp #include “print_int.h”</p>
<p>int main() { // 間違えない bool result = print_int( 123 ) ; } ~~~</p>
<h3 id="変数-1">変数</h3>
<p>変数にも宣言と定義がある。通常、変数の宣言は定義を兼ねる。</p>
<div class="sourceCode" id="cb1462"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1462-1" data-line-number="1"><span class="co">// 宣言かつ定義</span></a>
<a class="sourceLine" id="cb1462-2" data-line-number="2"><span class="dt">int</span> variable ;</a></code></pre></div>
<p>そのため、別の翻訳単位の変数を使うために変数を書くと、定義が重複してしまい、ODR違反になる。</p>
<div class="sourceCode" id="cb1463"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1463-1" data-line-number="1"><span class="co">// global.cpp</span></a>
<a class="sourceLine" id="cb1463-2" data-line-number="2"><span class="dt">int</span> variable ;</a>
<a class="sourceLine" id="cb1463-3" data-line-number="3"></a>
<a class="sourceLine" id="cb1463-4" data-line-number="4"><span class="co">// main.cpp</span></a>
<a class="sourceLine" id="cb1463-5" data-line-number="5"><span class="co">// エラー、ODR違反</span></a>
<a class="sourceLine" id="cb1463-6" data-line-number="6"><span class="dt">int</span> variable ;</a>
<a class="sourceLine" id="cb1463-7" data-line-number="7"></a>
<a class="sourceLine" id="cb1463-8" data-line-number="8"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1463-9" data-line-number="9">{</a>
<a class="sourceLine" id="cb1463-10" data-line-number="10">    variable = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb1463-11" data-line-number="11">}</a></code></pre></div>
<p>変数を定義せずに宣言だけしたい場合は、<code>extern</code>キーワードを使う。</p>
<div class="sourceCode" id="cb1464"><pre class="sourceCode pp"><code class="sourceCode pascal"><a class="sourceLine" id="cb1464-1" data-line-number="1"><span class="co">// global.cpp</span></a>
<a class="sourceLine" id="cb1464-2" data-line-number="2">int variable ;</a>
<a class="sourceLine" id="cb1464-3" data-line-number="3"></a>
<a class="sourceLine" id="cb1464-4" data-line-number="4"><span class="co">// main.cpp</span></a>
<a class="sourceLine" id="cb1464-5" data-line-number="5"><span class="co">// OK</span></a>
<a class="sourceLine" id="cb1464-6" data-line-number="6"><span class="co">// 別の翻訳単位の定義を参照する</span></a>
<a class="sourceLine" id="cb1464-7" data-line-number="7">extern int variable ;</a>
<a class="sourceLine" id="cb1464-8" data-line-number="8"></a>
<a class="sourceLine" id="cb1464-9" data-line-number="9">int main()</a>
<a class="sourceLine" id="cb1464-10" data-line-number="10"><span class="co">{</span></a>
<a class="sourceLine" id="cb1464-11" data-line-number="11"><span class="co">    variable = 123 ;</span></a>
<a class="sourceLine" id="cb1464-12" data-line-number="12"><span class="co">}</span></a></code></pre></div>
<p><code>extern</code>キーワードを名前空間スコープで宣言された変数に使うと、定義せずに別の翻訳単位の定義を参照する意味になる。</p>
<p>変数の場合も、間違いを防ぐためにヘッダーファイルに書いて<code>#include</code>するとよい。</p>
<div class="sourceCode" id="cb1465"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1465-1" data-line-number="1"><span class="co">// global.h</span></a>
<a class="sourceLine" id="cb1465-2" data-line-number="2"><span class="at">extern</span> <span class="dt">int</span> variable ;</a>
<a class="sourceLine" id="cb1465-3" data-line-number="3"></a>
<a class="sourceLine" id="cb1465-4" data-line-number="4"><span class="co">// main.cpp</span></a>
<a class="sourceLine" id="cb1465-5" data-line-number="5"><span class="pp">#include </span><span class="im">&quot;global.h&quot;</span></a>
<a class="sourceLine" id="cb1465-6" data-line-number="6"></a>
<a class="sourceLine" id="cb1465-7" data-line-number="7"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1465-8" data-line-number="8">{</a>
<a class="sourceLine" id="cb1465-9" data-line-number="9">    variable = <span class="dv">123</span> ;</a>
<a class="sourceLine" id="cb1465-10" data-line-number="10">}</a></code></pre></div>
<h3 id="インライン関数インライン変数">インライン関数/インライン変数</h3>
<p>変数や関数の定義はODRにより重複できない。ということはヘッダーファイルに書いて複数の翻訳単位で<code>#include</code>できないということだ。</p>
<div class="sourceCode" id="cb1466"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1466-1" data-line-number="1"><span class="co">// library.h</span></a>
<a class="sourceLine" id="cb1466-2" data-line-number="2"><span class="bu">std::</span>string delimiter{<span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>} ;</a>
<a class="sourceLine" id="cb1466-3" data-line-number="3"></a>
<a class="sourceLine" id="cb1466-4" data-line-number="4"><span class="dt">void</span> print_int( <span class="dt">int</span> x )</a>
<a class="sourceLine" id="cb1466-5" data-line-number="5">{ <span class="bu">std::</span>cout &lt;&lt; x &lt;&lt; delimiter ; }</a>
<a class="sourceLine" id="cb1466-6" data-line-number="6"></a>
<a class="sourceLine" id="cb1466-7" data-line-number="7"><span class="co">// foo.cpp</span></a>
<a class="sourceLine" id="cb1466-8" data-line-number="8"><span class="co">// エラー、ODR違反</span></a>
<a class="sourceLine" id="cb1466-9" data-line-number="9"><span class="pp">#include </span><span class="im">&quot;library.h&quot;</span></a>
<a class="sourceLine" id="cb1466-10" data-line-number="10"></a>
<a class="sourceLine" id="cb1466-11" data-line-number="11"><span class="co">// bar.cpp</span></a>
<a class="sourceLine" id="cb1466-12" data-line-number="12"><span class="co">// エラー、ODR違反</span></a>
<a class="sourceLine" id="cb1466-13" data-line-number="13"><span class="pp">#include </span><span class="im">&quot;library.h&quot;</span></a></code></pre></div>
<p><code>library.h</code>には宣言だけを書いて、別途翻訳単位となるソースファイル、例えば<code>library.cpp</code>を用意しなければならない。</p>
<div class="sourceCode" id="cb1467"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1467-1" data-line-number="1"><span class="co">// library.h</span></a>
<a class="sourceLine" id="cb1467-2" data-line-number="2"><span class="dt">void</span> print_int( <span class="dt">int</span> x ) ;</a>
<a class="sourceLine" id="cb1467-3" data-line-number="3"></a>
<a class="sourceLine" id="cb1467-4" data-line-number="4"><span class="co">// library.cpp</span></a>
<a class="sourceLine" id="cb1467-5" data-line-number="5"><span class="bu">std::</span>string delimiter ;</a>
<a class="sourceLine" id="cb1467-6" data-line-number="6"></a>
<a class="sourceLine" id="cb1467-7" data-line-number="7"><span class="dt">void</span> print_int( <span class="dt">int</span> x )</a>
<a class="sourceLine" id="cb1467-8" data-line-number="8">{ <span class="bu">std::</span>cout &lt;&lt; x &lt;&lt; delimiter ; }</a></code></pre></div>
<p>小さなライブラリの場合、この制約は煩わしい。できればヘッダーファイルだけで済ませてしまいたい。このためにC++には特別なODRを例外的に回避する方法がある。</p>
<p>キーワード<code>inline</code>をつけて定義した関数と変数は、インライン関数、インライン変数となる。</p>
<div class="sourceCode" id="cb1468"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1468-1" data-line-number="1"><span class="co">// library.h</span></a>
<a class="sourceLine" id="cb1468-2" data-line-number="2"><span class="co">// インライン変数</span></a>
<a class="sourceLine" id="cb1468-3" data-line-number="3"><span class="kw">inline</span> <span class="bu">std::</span>string delimiter{<span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>} ;</a>
<a class="sourceLine" id="cb1468-4" data-line-number="4"><span class="co">// インライン関数</span></a>
<a class="sourceLine" id="cb1468-5" data-line-number="5"><span class="kw">inline</span> <span class="dt">void</span> print_int( <span class="dt">int</span> x )</a>
<a class="sourceLine" id="cb1468-6" data-line-number="6">{ <span class="bu">std::</span>cout &lt;&lt; x &lt;&lt; delimiter ; }</a></code></pre></div>
<p>インライン関数とインライン変数は、複数の翻訳単位で重複して定義できる。</p>
<div class="sourceCode" id="cb1469"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1469-1" data-line-number="1"><span class="co">// foo.cpp</span></a>
<a class="sourceLine" id="cb1469-2" data-line-number="2"><span class="pp">#include </span><span class="im">&quot;library.h&quot;</span></a>
<a class="sourceLine" id="cb1469-3" data-line-number="3"></a>
<a class="sourceLine" id="cb1469-4" data-line-number="4"><span class="co">// bar.cpp</span></a>
<a class="sourceLine" id="cb1469-5" data-line-number="5"><span class="pp">#include </span><span class="im">&quot;library.h&quot;</span></a></code></pre></div>
<p><code>inline</code>はODRを例外的に回避できるとは言え、強い制約がある。</p>
<ol type="1">
<li>異なる翻訳単位に限る</li>
</ol>
<p>同じ翻訳単位の中で重複することはできない。</p>
<div class="sourceCode" id="cb1470"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1470-1" data-line-number="1"><span class="co">// ひとつの翻訳単位</span></a>
<a class="sourceLine" id="cb1470-2" data-line-number="2"><span class="kw">inline</span> <span class="dt">int</span> variable ;</a>
<a class="sourceLine" id="cb1470-3" data-line-number="3"><span class="co">// エラー、再定義</span></a>
<a class="sourceLine" id="cb1470-4" data-line-number="4"><span class="kw">inline</span> <span class="dt">int</span> variable ;</a></code></pre></div>
<ol start="2" type="1">
<li>同じトークン列である</li>
</ol>
<p>インライン関数、インライン変数の定義のトークン列、つまりソースコードの文字列は完全に同じでなければならない。</p>
<p>たとえば以下はトークン列が違う。 ~<del>c++ inline int f( int x ) { return x ; } inline int f( int y ) { return y ; }</del>~</p>
<p>インライン関数と変数のトークン列を同じにするには、ヘッダーファイルに書いて<code>#include</code>で取り込むことを徹底する。</p>
<ol start="3" type="1">
<li>意味が同じである。</li>
</ol>
<p>同じトークン列でも意味が異なることがある。</p>
<div class="sourceCode" id="cb1471"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1471-1" data-line-number="1"><span class="co">// foo.cpp</span></a>
<a class="sourceLine" id="cb1471-2" data-line-number="2"><span class="dt">void</span> f( <span class="dt">int</span> ) {  }</a>
<a class="sourceLine" id="cb1471-3" data-line-number="3"><span class="kw">inline</span> <span class="dt">bool</span> g( )</a>
<a class="sourceLine" id="cb1471-4" data-line-number="4">{</a>
<a class="sourceLine" id="cb1471-5" data-line-number="5">    <span class="cf">return</span> f( <span class="dv">0</span> ) ;</a>
<a class="sourceLine" id="cb1471-6" data-line-number="6">}</a>
<a class="sourceLine" id="cb1471-7" data-line-number="7"></a>
<a class="sourceLine" id="cb1471-8" data-line-number="8"><span class="co">// bar.cpp</span></a>
<a class="sourceLine" id="cb1471-9" data-line-number="9"><span class="dt">void</span> f( <span class="dt">double</span> ) {  }</a>
<a class="sourceLine" id="cb1471-10" data-line-number="10"><span class="kw">inline</span> <span class="dt">bool</span> g()</a>
<a class="sourceLine" id="cb1471-11" data-line-number="11">{</a>
<a class="sourceLine" id="cb1471-12" data-line-number="12">    <span class="cf">return</span> f( <span class="dv">0</span> ) ;</a>
<a class="sourceLine" id="cb1471-13" data-line-number="13">}</a></code></pre></div>
<p><code>foo.cpp</code>のインライン関数<code>g</code>は<code>f(int)</code>を呼び出すが、<code>bar.cpp</code>のインライン関数<code>g</code>は<code>f(double)</code>を呼び出す。インライン関数<code>g</code>のトークン列はどちらも同じだが、意味が異なる。</p>
<p>ODRの例外的な回避の怖いところは、間違えてしまってもコンパイラーがエラーメッセージを出してくれる保証がないところだ。上の同じトークン列で違う意味のような関数は、そのままコンパイルが通ってリンクされ、実行可能なプログラムが生成されてしまうかも知れない。そのようなプログラムの挙動がどうなるかはわからない。この理由は、ODR違反を完全に発見するコンパイラーの実装が技術的に困難だからだ。ODR違反をしないのはユーザーの責任だ。</p>
<p>インライン変数とインライン関数はわざわざ翻訳単位を分けて分割コンパイルするまでもないライブラリに使うとよい。</p>
<h3 id="クラス">クラス</h3>
<p>クラスにも宣言と定義がある。</p>
<div class="sourceCode" id="cb1472"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1472-1" data-line-number="1"><span class="co">// 宣言</span></a>
<a class="sourceLine" id="cb1472-2" data-line-number="2">strut Foo ;</a>
<a class="sourceLine" id="cb1472-3" data-line-number="3"></a>
<a class="sourceLine" id="cb1472-4" data-line-number="4"><span class="co">// 定義</span></a>
<a class="sourceLine" id="cb1472-5" data-line-number="5"><span class="kw">struct</span> Foo</a>
<a class="sourceLine" id="cb1472-6" data-line-number="6">{</a>
<a class="sourceLine" id="cb1472-7" data-line-number="7">    <span class="dt">int</span> data_member ;</a>
<a class="sourceLine" id="cb1472-8" data-line-number="8">    <span class="dt">int</span> member_function() ;</a>
<a class="sourceLine" id="cb1472-9" data-line-number="9">} ;</a></code></pre></div>
<p>クラスを複数の翻訳単位で使うには、関数と同じように宣言と定義に分ければよいと考えるかも知れないが、残念ながらクラスの宣言だけでできることは少ない。</p>
<p>クラスの宣言だけでできることは、クラス名を型名として使うとか、クラスのポインター型を作るぐらいのものだ。</p>
<div class="sourceCode" id="cb1473"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1473-1" data-line-number="1"><span class="kw">struct</span> Foo ;</a>
<a class="sourceLine" id="cb1473-2" data-line-number="2"><span class="kw">using</span> Bar = Foo ;</a>
<a class="sourceLine" id="cb1473-3" data-line-number="3">Foo * ptr = <span class="kw">nullptr</span> ;</a></code></pre></div>
<p>宣言だけされたクラスのオブジェクトを作ることはできないし、ポインターの演算もできない。</p>
<div class="sourceCode" id="cb1474"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1474-1" data-line-number="1"><span class="kw">struct</span> Foo ;</a>
<a class="sourceLine" id="cb1474-2" data-line-number="2"></a>
<a class="sourceLine" id="cb1474-3" data-line-number="3"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1474-4" data-line-number="4">{</a>
<a class="sourceLine" id="cb1474-5" data-line-number="5">    <span class="co">// エラー</span></a>
<a class="sourceLine" id="cb1474-6" data-line-number="6">    Foo foo ;</a>
<a class="sourceLine" id="cb1474-7" data-line-number="7"></a>
<a class="sourceLine" id="cb1474-8" data-line-number="8">    Foo * ptr = <span class="kw">nullptr</span> ;</a>
<a class="sourceLine" id="cb1474-9" data-line-number="9">    <span class="co">// エラー</span></a>
<a class="sourceLine" id="cb1474-10" data-line-number="10">    ++ptr ;</a>
<a class="sourceLine" id="cb1474-11" data-line-number="11">}</a></code></pre></div>
<p>この理由は、宣言だけされたクラスは<code>不完全型(Incomplete type)</code>という特別な扱いの型になるからだ。クラスのオブジェクトを作ったりポインター演算をするには、クラスのオブジェクトのサイズを決定する必要があるが、そのための情報はまだコンパイラーが得ていないために起こる制約だ。</p>
<p>クラスの定義では、インライン変数やインライン関数と同じく、ODRの例外的な回避が認められている。条件も同じで、1. 異なる翻訳単位で、2. 同じトークン列で、3. 意味も同じ場合だ。</p>
<p>ODR違反を起こさないために、クラス定義はインクルードファイルに書いて<code>#include</code>するのがお作法だ。</p>
<pre><code>// Foo.h
// クラス定義
struct Foo
{
    int data_member ;
    // メンバー関数の宣言
    int member_function() const noexcept;
} ;

// Foo.cpp
#include &quot;Foo.h&quot;
// メンバー関数の定義
int Foo::member_function() const noexcept
{
    return data_member ;
} 

// main.cpp
#include &quot;Foo.h&quot;

int main()
{
    Foo foo ;
    foo.data_member = 42 ;
    int value = foo.member_function() ;
}</code></pre>
<p>クラス定義の中で定義されたメンバー関数は、自動的にインライン関数になる。</p>
<div class="sourceCode" id="cb1476"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1476-1" data-line-number="1"><span class="co">// Foo.h</span></a>
<a class="sourceLine" id="cb1476-2" data-line-number="2"><span class="kw">struct</span> Foo</a>
<a class="sourceLine" id="cb1476-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb1476-4" data-line-number="4">    <span class="dt">int</span> data_member ;</a>
<a class="sourceLine" id="cb1476-5" data-line-number="5">    <span class="co">// インライン関数</span></a>
<a class="sourceLine" id="cb1476-6" data-line-number="6">    <span class="dt">int</span> member_function() <span class="at">const</span> <span class="kw">noexcept</span></a>
<a class="sourceLine" id="cb1476-7" data-line-number="7">    {</a>
<a class="sourceLine" id="cb1476-8" data-line-number="8">        <span class="cf">return</span> data_member ;</a>
<a class="sourceLine" id="cb1476-9" data-line-number="9">    }</a>
<a class="sourceLine" id="cb1476-10" data-line-number="10">} ;</a></code></pre></div>
<p>このように書くと、ヘッダーファイル<code>Foo.h</code>を<code>#include</code>するだけでどこでもクラス<code>Foo</code>が使えるようになる。メンバー関数を定義するための<code>Foo.cpp</code>は必要がなくなる。</p>
<p>クラスのデータメンバーは具体的なオブジェクトではないので、インライン変数ではない。</p>
<div class="sourceCode" id="cb1477"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1477-1" data-line-number="1"><span class="kw">struct</span> S</a>
<a class="sourceLine" id="cb1477-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1477-3" data-line-number="3">    <span class="co">// これはオブジェクトではない</span></a>
<a class="sourceLine" id="cb1477-4" data-line-number="4">    <span class="dt">int</span> data_member ;</a>
<a class="sourceLine" id="cb1477-5" data-line-number="5">} ;</a>
<a class="sourceLine" id="cb1477-6" data-line-number="6"></a>
<a class="sourceLine" id="cb1477-7" data-line-number="7"><span class="dt">void</span> main()</a>
<a class="sourceLine" id="cb1477-8" data-line-number="8">{</a>
<a class="sourceLine" id="cb1477-9" data-line-number="9">    <span class="co">// オブジェクト</span></a>
<a class="sourceLine" id="cb1477-10" data-line-number="10">    S s ;</a>
<a class="sourceLine" id="cb1477-11" data-line-number="11">    <span class="co">// サブオブジェクト</span></a>
<a class="sourceLine" id="cb1477-12" data-line-number="12">    s.data_member ; </a>
<a class="sourceLine" id="cb1477-13" data-line-number="13">}</a></code></pre></div>
<h5 id="staticメンバー">staticメンバー</h5>
<p>クラスのメンバーは非staticメンバーとstaticメンバーにわけることができる。staticメンバーは<code>static</code>キーワードをつけて宣言する。</p>
<div class="sourceCode" id="cb1478"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1478-1" data-line-number="1"><span class="kw">struct</span> S</a>
<a class="sourceLine" id="cb1478-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1478-3" data-line-number="3">    <span class="co">// 非staticメンバー</span></a>
<a class="sourceLine" id="cb1478-4" data-line-number="4">    <span class="dt">int</span> data_member ;</a>
<a class="sourceLine" id="cb1478-5" data-line-number="5">    <span class="dt">void</span> member_function() ;</a>
<a class="sourceLine" id="cb1478-6" data-line-number="6"></a>
<a class="sourceLine" id="cb1478-7" data-line-number="7">    <span class="co">// staticメンバー</span></a>
<a class="sourceLine" id="cb1478-8" data-line-number="8">    <span class="kw">inline</span> <span class="at">static</span> <span class="dt">int</span> static_data_member ;</a>
<a class="sourceLine" id="cb1478-9" data-line-number="9">    <span class="at">static</span> <span class="dt">void</span> static_member_function() ;</a>
<a class="sourceLine" id="cb1478-10" data-line-number="10">} ;</a></code></pre></div>
<p>staticメンバー関数はクラスのオブジェクトには依存していない。そのため、クラスのオブジェクトなしで呼び出すことができる</p>
<div class="sourceCode" id="cb1479"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1479-1" data-line-number="1"><span class="kw">struct</span> S</a>
<a class="sourceLine" id="cb1479-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1479-3" data-line-number="3">    <span class="co">// 非staticメンバー</span></a>
<a class="sourceLine" id="cb1479-4" data-line-number="4">    <span class="dt">void</span> member_function() { }</a>
<a class="sourceLine" id="cb1479-5" data-line-number="5"></a>
<a class="sourceLine" id="cb1479-6" data-line-number="6">    <span class="co">// staticメンバー</span></a>
<a class="sourceLine" id="cb1479-7" data-line-number="7">    <span class="at">static</span> <span class="dt">void</span> static_member_function() { }</a>
<a class="sourceLine" id="cb1479-8" data-line-number="8">} ;</a>
<a class="sourceLine" id="cb1479-9" data-line-number="9"></a>
<a class="sourceLine" id="cb1479-10" data-line-number="10"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1479-11" data-line-number="11">{</a>
<a class="sourceLine" id="cb1479-12" data-line-number="12">    S s ;</a>
<a class="sourceLine" id="cb1479-13" data-line-number="13">    <span class="co">// オブジェクトが必要</span></a>
<a class="sourceLine" id="cb1479-14" data-line-number="14">    s.member_function() ;</a>
<a class="sourceLine" id="cb1479-15" data-line-number="15"></a>
<a class="sourceLine" id="cb1479-16" data-line-number="16">    <span class="co">// オブジェクトは不要</span></a>
<a class="sourceLine" id="cb1479-17" data-line-number="17">    S::static_member_function() ;</a>
<a class="sourceLine" id="cb1479-18" data-line-number="18">    <span class="co">// このように呼び出すこともできる</span></a>
<a class="sourceLine" id="cb1479-19" data-line-number="19">    s.static_member_function() ;</a>
<a class="sourceLine" id="cb1479-20" data-line-number="20">}</a></code></pre></div>
<p>staticメンバー関数の呼び出しにクラスのオブジェクトを必要としない。そのため、<code>this</code>も使うことはできない。</p>
<div class="sourceCode" id="cb1480"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1480-1" data-line-number="1"><span class="kw">struct</span> S</a>
<a class="sourceLine" id="cb1480-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1480-3" data-line-number="3">    <span class="dt">int</span> data_member() ;</a>
<a class="sourceLine" id="cb1480-4" data-line-number="4"></a>
<a class="sourceLine" id="cb1480-5" data-line-number="5">    <span class="dt">void</span> f()</a>
<a class="sourceLine" id="cb1480-6" data-line-number="6">    {<span class="co">// thisが使える</span></a>
<a class="sourceLine" id="cb1480-7" data-line-number="7">        <span class="kw">this</span>-&gt;data_member ;</a>
<a class="sourceLine" id="cb1480-8" data-line-number="8">    }</a>
<a class="sourceLine" id="cb1480-9" data-line-number="9"></a>
<a class="sourceLine" id="cb1480-10" data-line-number="10">    <span class="at">static</span> <span class="dt">void</span> g()</a>
<a class="sourceLine" id="cb1480-11" data-line-number="11">    {<span class="co">// thisは使えない</span></a>
<a class="sourceLine" id="cb1480-12" data-line-number="12">    }</a>
<a class="sourceLine" id="cb1480-13" data-line-number="13">} ;</a></code></pre></div>
<p>staticデータメンバーはクラスのオブジェクトの外の独立したオブジェクトだ。staticデータメンバーのクラス定義内での宣言は定義ではないので、クラスの定義外で定義する必要がある。</p>
<div class="sourceCode" id="cb1481"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1481-1" data-line-number="1"><span class="kw">struct</span> S</a>
<a class="sourceLine" id="cb1481-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1481-3" data-line-number="3">    <span class="co">// 宣言</span></a>
<a class="sourceLine" id="cb1481-4" data-line-number="4">    <span class="at">static</span> <span class="dt">int</span> static_data_member ;</a>
<a class="sourceLine" id="cb1481-5" data-line-number="5">} ;</a>
<a class="sourceLine" id="cb1481-6" data-line-number="6"><span class="co">// 定義</span></a>
<a class="sourceLine" id="cb1481-7" data-line-number="7"><span class="dt">int</span> S::static_data_member ;</a>
<a class="sourceLine" id="cb1481-8" data-line-number="8"></a>
<a class="sourceLine" id="cb1481-9" data-line-number="9"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1481-10" data-line-number="10">{</a>
<a class="sourceLine" id="cb1481-11" data-line-number="11">    S::static_data_member = <span class="dv">123</span> ;</a>
<a class="sourceLine" id="cb1481-12" data-line-number="12">}</a></code></pre></div>
<p>複数の翻訳単位からなるプログラムの場合、ODRにより定義はひとつしか書けないので、どこか1つのソースファイルだけに定義を書くことになる。</p>
<div class="sourceCode" id="cb1482"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1482-1" data-line-number="1"><span class="co">// S.h</span></a>
<a class="sourceLine" id="cb1482-2" data-line-number="2"><span class="kw">struct</span> S</a>
<a class="sourceLine" id="cb1482-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb1482-4" data-line-number="4">    <span class="co">// 宣言</span></a>
<a class="sourceLine" id="cb1482-5" data-line-number="5">    <span class="at">static</span> <span class="dt">int</span> static_data_member ;</a>
<a class="sourceLine" id="cb1482-6" data-line-number="6">} ;</a>
<a class="sourceLine" id="cb1482-7" data-line-number="7"></a>
<a class="sourceLine" id="cb1482-8" data-line-number="8"><span class="co">// S.cpp</span></a>
<a class="sourceLine" id="cb1482-9" data-line-number="9"><span class="pp">#include </span><span class="im">&quot;S.h&quot;</span></a>
<a class="sourceLine" id="cb1482-10" data-line-number="10"><span class="co">// 定義</span></a>
<a class="sourceLine" id="cb1482-11" data-line-number="11"><span class="dt">int</span> S::static_data_member ;</a></code></pre></div>
<p>これは面倒なので、通常はstatic変数はインライン変数にする。</p>
<div class="sourceCode" id="cb1483"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1483-1" data-line-number="1"><span class="co">// S.h</span></a>
<a class="sourceLine" id="cb1483-2" data-line-number="2"><span class="kw">struct</span> S</a>
<a class="sourceLine" id="cb1483-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb1483-4" data-line-number="4">    <span class="co">// インライン変数かつstatic変数</span></a>
<a class="sourceLine" id="cb1483-5" data-line-number="5">    <span class="kw">inline</span> <span class="at">static</span> <span class="dt">int</span> static_data_member ;</a>
<a class="sourceLine" id="cb1483-6" data-line-number="6">} ;</a></code></pre></div>
<p>これでstatic変数を定義するだけのソースファイルを用意する必要はない。ただしインライン変数はC++17以降の機能なので、読者が昔のC++で書かれたコードを読む際には、まだ昔ながらのstaticデータメンバーの定義に出くわすだろうから、覚えておこう。</p>
<p>staticメンバーはクラススコープの下に関数と変数というだけで、その実態は名前空間スコープ内の関数と変数と同じだ。</p>
<div class="sourceCode" id="cb1484"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1484-1" data-line-number="1"><span class="co">// 名前空間</span></a>
<a class="sourceLine" id="cb1484-2" data-line-number="2"><span class="kw">namespace</span> A {</a>
<a class="sourceLine" id="cb1484-3" data-line-number="3">    <span class="dt">int</span> variable ;</a>
<a class="sourceLine" id="cb1484-4" data-line-number="4">    <span class="dt">void</span> function() { }</a>
<a class="sourceLine" id="cb1484-5" data-line-number="5">}</a>
<a class="sourceLine" id="cb1484-6" data-line-number="6"><span class="co">// クラス</span></a>
<a class="sourceLine" id="cb1484-7" data-line-number="7"><span class="kw">struct</span> B {</a>
<a class="sourceLine" id="cb1484-8" data-line-number="8">    <span class="kw">inline</span> <span class="at">static</span> <span class="dt">int</span> variable ;</a>
<a class="sourceLine" id="cb1484-9" data-line-number="9">    <span class="at">static</span> <span class="dt">void</span> function() { }</a>
<a class="sourceLine" id="cb1484-10" data-line-number="10">} ;</a>
<a class="sourceLine" id="cb1484-11" data-line-number="11"></a>
<a class="sourceLine" id="cb1484-12" data-line-number="12"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1484-13" data-line-number="13">{</a>
<a class="sourceLine" id="cb1484-14" data-line-number="14">    <span class="co">// 名前空間</span></a>
<a class="sourceLine" id="cb1484-15" data-line-number="15">    A::variable = <span class="dv">1</span> ;</a>
<a class="sourceLine" id="cb1484-16" data-line-number="16">    A::function() ;</a>
<a class="sourceLine" id="cb1484-17" data-line-number="17">    <span class="co">// クラス</span></a>
<a class="sourceLine" id="cb1484-18" data-line-number="18">    B::variable = <span class="dv">1</span> ;</a>
<a class="sourceLine" id="cb1484-19" data-line-number="19">    B::function() ;</a>
<a class="sourceLine" id="cb1484-20" data-line-number="20">}</a></code></pre></div>
<h3 id="テンプレート-2">テンプレート</h3>
<p>テンプレートにもODRの例外が認められている。</p>
<p>テンプレートは具体的なテンプレート引数が与えられて実体化する。</p>
<div class="sourceCode" id="cb1485"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1485-1" data-line-number="1"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;</a>
<a class="sourceLine" id="cb1485-2" data-line-number="2"><span class="kw">struct</span> holder</a>
<a class="sourceLine" id="cb1485-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb1485-4" data-line-number="4">    T value ;</a>
<a class="sourceLine" id="cb1485-5" data-line-number="5">} ;</a>
<a class="sourceLine" id="cb1485-6" data-line-number="6"></a>
<a class="sourceLine" id="cb1485-7" data-line-number="7">holder&lt;<span class="dt">int</span>&gt; a ;</a>
<a class="sourceLine" id="cb1485-8" data-line-number="8">holder&lt;<span class="dt">double</span>&gt; b ;</a></code></pre></div>
<p>このため、翻訳単位ごとに、同じトークン列で同じ意味のテンプレートコードが必要だ。インクルードファイルに書いて<code>#include</code>するお作法も同じだ。</p>
<div class="sourceCode" id="cb1486"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1486-1" data-line-number="1"><span class="co">// holder.h</span></a>
<a class="sourceLine" id="cb1486-2" data-line-number="2"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;</a>
<a class="sourceLine" id="cb1486-3" data-line-number="3"><span class="kw">struct</span> holder</a>
<a class="sourceLine" id="cb1486-4" data-line-number="4">{</a>
<a class="sourceLine" id="cb1486-5" data-line-number="5">    T value ;</a>
<a class="sourceLine" id="cb1486-6" data-line-number="6">} ;</a>
<a class="sourceLine" id="cb1486-7" data-line-number="7"></a>
<a class="sourceLine" id="cb1486-8" data-line-number="8">holder&lt;<span class="dt">int</span>&gt; a ;</a>
<a class="sourceLine" id="cb1486-9" data-line-number="9">holder&lt;<span class="dt">double</span>&gt; b ;</a></code></pre></div>
<p>C++に将来的に追加される予定のモジュールが入るまでは、テンプレートコードはすべてをインクルードファイルに書いて<code>#include</code>して使う慣習が続くだろう。</p>
<h1 id="デバッガー">デバッガー</h1>
<p>本書はこのあと、更に複雑な機能やアルゴリズムを解説していく。読者は複雑な機能やアルゴリズムを使おうとして、間違ったコードを書くことだろう。間違ったコードは直せばよい。問題は、どこが間違っているのかわからない場合だ。</p>
<p>例えば以下のコードは1から10までの整数を標準出力するはずのプログラムだ。</p>
<div class="sourceCode" id="cb1487"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1487-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1487-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1487-3" data-line-number="3">    <span class="cf">for</span> ( <span class="dt">int</span> i = <span class="dv">1</span> ; i &lt; <span class="dv">10</span> ; ++i )</a>
<a class="sourceLine" id="cb1487-4" data-line-number="4">        <span class="bu">std::</span>cout &lt;&lt; i ;</a>
<a class="sourceLine" id="cb1487-5" data-line-number="5">}</a></code></pre></div>
<p>しかし実際に実行して見ると、1から9までの整数しか標準出力しない。なぜだろうか。</p>
<p>読者の中にはコード中の問題のある箇所に気がついた人もいるだろう。これはたったの5行のコードで、問題の箇所も一箇所だ。これが数百行、数千行になり、関数やクラスを複雑に使い、問題の原因は複数の箇所のコードの実行が組み合わさった結果で、しかも自分で書いたコードなので正しく書いたはずだという先入観がある場合、たとえコードとしてはささいな間違いであったとしても、発見は難しい。</p>
<p>こういうとき、実際にコードを一行ずつ実行したり、ある時点でプログラムの実行を停止させて変数の値を見たりしたいものだ。</p>
<p>そんな夢を実現するのがデバッガーだ。この章ではデバッガーとしてGDB(GNUプロジェクトデバッガー)の使い方を学ぶ。</p>
<p>GDBで快適にデバッグするには、プログラムをコンパイルするときにデバッグ情報を出力する必要がある。そのためには、GCCに<code>-g</code>オプションをつけてプログラムをコンパイルする。</p>
<pre><code>$ g++ -g -o program program.cpp</code></pre>
<p>本書のはじめに作った入門用のMakefileを使う場合は、<code>$gcc_options</code>に<code>-g</code>を加えることになる。</p>
<pre><code>gcc_options = -std=c++17 -Wall --pedantic-error -g</code></pre>
<p>コンパイラーのオプションを変更をした後は、<code>make clean</code>を実行してコンパイル済みヘッダーファイルを生成し直す必要がある。</p>
<pre><code>$ make clean</code></pre>
<h2 id="gdbのチュートリアル">GDBのチュートリアル</h2>
<p>では具体的にデバッガーを使ってみよう。以下のようなソースファイルを用意する。</p>
<div class="sourceCode" id="cb1491"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1491-1" data-line-number="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1491-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb1491-3" data-line-number="3">    <span class="dt">int</span> val = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb1491-4" data-line-number="4">    val = <span class="dv">10</span> ;</a>
<a class="sourceLine" id="cb1491-5" data-line-number="5">    val += <span class="dv">1</span> ;</a>
<a class="sourceLine" id="cb1491-6" data-line-number="6">    val *= <span class="dv">2</span> ;</a>
<a class="sourceLine" id="cb1491-7" data-line-number="7">    val *= <span class="dv">2</span> ;</a>
<a class="sourceLine" id="cb1491-8" data-line-number="8">    val /= <span class="dv">4</span> ;</a>
<a class="sourceLine" id="cb1491-9" data-line-number="9">}</a></code></pre></div>
<p>このプログラムをコンパイルする。</p>
<pre><code>$ g++ -g program.cpp -o program</code></pre>
<p>GDBを使ってプログラムのデバッグを始めるには、GDBのオプションとして“-g”オプション付きでコンパイルしたプログラムのファイル名を指定する。</p>
<pre><code>$ gdb program</code></pre>
<p>すると以下のように出力される。</p>
<pre><code>GNU gdb (Ubuntu 8.2-0ubuntu1) 8.2
Copyright (C) 2018 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type &quot;show copying&quot; and &quot;show warranty&quot; for details.
This GDB was configured as &quot;x86_64-linux-gnu&quot;.
Type &quot;show configuration&quot; for configuration details.
For bug reporting instructions, please see:
&lt;http://www.gnu.org/software/gdb/bugs/&gt;.
Find the GDB manual and other documentation resources online at:
    &lt;http://www.gnu.org/software/gdb/documentation/&gt;.

For help, type &quot;help&quot;.
Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;...
Reading symbols from program...done.
(gdb) </code></pre>
<p>大量のメッセージに戸惑うかもしれないが、最後の行以外はGDBのライセンス表記やドキュメントだ。細部は環境ごとに異なる。</p>
<p>ここで重要なのは最後の行だ。</p>
<pre><code>(gdb)</code></pre>
<p>ここにgdbのコマンドを入力する。ヘルプを表示するコマンド“help”と入力してみよう。</p>
<pre><code>(gdb) help</code></pre>
<p>ヘルプメッセージが表示される。あるコマンドのヘルプを見たい場合は“help コマンド”と入力する。今から使う予定のコマンドである“list”のヘルプを見てみよう。</p>
<pre><code>(gdb) help list</code></pre>
<p>“list”コマンドは現在のソースファイルの前後10行を表示する。</p>
<pre><code>(gdb) list
1   int main()
2   {
3       int val = 0 ;
4       val = 10 ;
5       val += 1 ;
6       val *= 2 ;
7       val *= 2 ;
8       val /= 4 ;
9   }</code></pre>
<p>さっそく実行してみよう。実行するコマンドは“run”だ。</p>
<pre><code>(gdb) run
Starting program: 実行可能ファイルへのパス
[Inferior 1 (process PID) exited normally]</code></pre>
<p>“run”コマンドを使うとデバッガーはプログラムを実行する。</p>
<p>プログラムの実行を特定の場所で止めるには“break”コマンドを使ってブレイクポイントを設定する。</p>
<pre><code>(gdb) help break</code></pre>
<p>“break”コマンドには関数や行番号を指定できる。</p>
<pre><code>(gdb) break main
(gdb) break 4
(gdb) break 5</code></pre>
<p>これで、main関数、4行目、5行目にブレイクポイントを設定した。早速もう一度最初から実行してみよう。</p>
<pre><code>(gdb) run
Starting program: プログラムへのファイルパス

Breakpoint 1, main () at main.cpp:3
3       int val = 0 ;</code></pre>
<p>main関数にブレイクポイントを設定したので、プログラムはmain関数が呼ばれたところ、最初のコードである3行目を実行する手前で止まる。</p>
<p>プログラムの実行を再開するには“continue”コマンドを使う</p>
<pre><code>(gdb) continue
Continuing.

Breakpoint 2, main () at main.cpp:4
4       val = 10 ;</code></pre>
<p>4行目にブレイクポイントを設定したので、4行目を実行する手前で止まる。</p>
<p>この時点で、変数<code>val</code>が初期化され、その値は0になっているはずだ。確かめてみよう。変数の値を調べるには“print”コマンドを使う。</p>
<pre><code>(gdb) print val
$1 = 0</code></pre>
<p>値が0になっていることが確認できた。実行を再開しよう。</p>
<pre><code>(gdb) continue
Continuing.

Breakpoint 3, main () at main.cpp:5
5       val += 1 ;</code></pre>
<p>4行目を実行し、5行目のブレイクポイントで止まる。4行目を実行したということは、変数’val’の値は10になっているはずだ。もう一度“print”コマンドで調べてみよう。</p>
<pre><code>(gdb) print val
$2 = 10</code></pre>
<p>値は10だ。GDBはprintの結果の履歴を記録している。<code>$1</code>や<code>$2</code>というのはその記録を参照するための名前だ。その値は“print”コマンドで確認できる</p>
<pre><code>(gdb) print $1
$3 = 0
(gdb) print $2
$4 = 10</code></pre>
<p>現在、プログラムは5行目を実行する手前で止まっている。このまま“continue”コマンドを使うとプログラムの終了まで実行されてしまう。もう一度1行だけ実行するには“break 6”で6行目にブレイクポイントを設定すればよいのだが、次の一行だけ実行したいときにいちいちブレイクポイントを設定するのは面倒だ。</p>
<p>そこで使うのが“step”だ。次の5行目を実行すると、変数<code>val</code>の値は11になっているはずだ。</p>
<pre><code>(gdb) step
6       val *= 2 ;
(gdb) print val
$5 = 11</code></pre>
<p>さて、残りの行も<code>step</code>して実行を1行づつ確かめてみよう。</p>
<p>GDBの基本的な使い方を覚えたので、これから詳細な使い方を学んでいく。</p>
<h2 id="プログラムの実行">プログラムの実行</h2>
<p>GDBでプログラムをデバッグするには、GDBの起動時にプログラムのオプションとしてプログラムのファイル名を指定する。プログラムのファイル名が“program”の場合、以下のようにする。</p>
<pre><code>$ ls
program
$ gdb program</code></pre>
<p>起動したGDBでプログラムを実行するには、“run”コマンドを使う。</p>
<pre><code>(gdb) run</code></pre>
<p>このとき、プログラムにオプションを指定したい場合は“run”に続けて記述する。例えばプログラムの標準出力を“out.txt”にリダイレクトしたいときは以下のようにする。</p>
<pre><code>(gdb) run &gt; out.txt</code></pre>
<h2 id="プログラムの停止方法">プログラムの停止方法</h2>
<p>デバッガーの目的は</p>
<h3 id="ブレイクポイント">ブレイクポイント</h3>
<p>コマンド“break”はブレイクポイントを設定する。プログラムの実行がブレイクポイントに達した場合、GDBはブレイクポイントの直前でプログラムの実行を中断する。</p>
<p>ブレイクポイントを設定する場所は“break”コマンドへの引数で指定する。省略して“b”だけでもよい。</p>
<pre><code>(gdb) break 場所
(gdb) b 場所</code></pre>
<p>場所として使えるのは行番号と関数名だ。</p>
<h4 id="行番号へのブレイクポイント">行番号へのブレイクポイント</h4>
<p>現在のソースファイルの123行目にブレイクポイントを設定する場合は以下のように書く。</p>
<pre><code>(gdb) break 123</code></pre>
<p>ソースファイルが複数ある場合は、</p>
<pre><code>(gdb) break ファイル名:行番号</code></pre>
<p>と書く。例えば“foo.cpp”の8行目にブレイクポイントを仕掛ける場合は、</p>
<pre><code>(gdb) break foo.cpp:8</code></pre>
<p>と書く。</p>
<h4 id="ブレイクポイントの確認">ブレイクポイントの確認</h4>
<p>設定したブレイクポイントの一覧は、“info breakpoints”コマンドで確認できる。</p>
<pre><code>(gdb) break 5
Breakpoint 1 at 0x1150: file main.cpp, line 5.
(gdb) break 6
Breakpoint 2 at 0x1157: file main.cpp, line 6.
(gdb) break 7
Breakpoint 3 at 0x115b: file main.cpp, line 7.
(gdb) info breakpoints 
Num     Type           Disp Enb Address            What
1       breakpoint     keep y   0x0000000000001150 in main() at main.cpp:5
2       breakpoint     keep y   0x0000000000001157 in main() at main.cpp:6
3       breakpoint     keep y   0x000000000000115b in main() at main.cpp:7</code></pre>
<p>これは5,6,7行目にそれぞれブレイクポイントを設定した後の“info breakpoints”の結果だ。</p>
<p>この表の意味は、左から番号(Num, Number)、種類(Type)、中断後の処理(Disposition), 有効/無効(Enb, Enable/Disable)、アドレス(Address), 内容(What)となっている。</p>
<p>ブレイクポイントには作成された順番に番号が振られる。ブレイクポイントの設定を変えるには、この番号でブレイクポイントを参照する。</p>
<p>ブレイクポイントには3種類ある。普通のブレイクポイントである<code>breakpoint</code>の他に、特殊なブレイクポイントであるウォッチポイント(watchpoint)、キャッチポイント(catchpoint)がある。</p>
<p>中断後の処理と有効/無効の切り替えはあとで説明する。</p>
<p>アドレスというのはブレイクポイントを設定した場所に該当するプログラムのコード部分であり、本書では解説しない。</p>
<p>内容はブレイクポイントを設定した場所の情報だ。</p>
<h4 id="ブレイクポイントの削除">ブレイクポイントの削除</h4>
<p>ブレイクポイントを削除するには“delete”コマンドを使う。削除するブレイクポイントは番号で指定する。</p>
<pre><code>(gdb) delete 1</code></pre>
<p>番号を指定しないとすべてのブレイクポイントを削除することができる。</p>
<pre><code>(gdb) delete
Delete all breakpoints? (y or n) y
(gdb) info breakpoints
No breakpoints or watchpoints.</code></pre>
<h4 id="ブレイクポイントの有効無効">ブレイクポイントの有効/無効</h4>
<p>ブレイクポイントは有効/無効を切り替えることができる。</p>
<p>ブレイクポイントを無効化するには“disable”コマンドを使う。</p>
<pre><code>(gdb) disable 1</code></pre>
<p>ブレイクポイントを有効化するには“enable”コマンドを使う。</p>
<pre><code>(gdb) enable 1</code></pre>
<p>ブレイクポイントは発動した後に自動で無効化させることができる。</p>
<p>“enable [breakpoints] once”コマンドで、ブレイクポイントが一度発動すると自動的に無効化されるブレイクポイントを設定できる。</p>
<pre><code>(gdb) enable 1 once</code></pre>
<p>このコマンドは、ブレイクポイント番号1が一度発動したら自動的に無効化する設定をする。</p>
<p>ブレイクポイントはn回発動した後に自動的に無効化することもできる。そのためのコマンドは“enable [breakpoints] count n”だ。</p>
<pre><code>(gdb) enable 1 count 10</code></pre>
<p>上のコマンドは、ブレイクポイント番号1が10回発動したら自動的に無効化されるよう設定している。</p>
<h4 id="関数名へのブレイクポイント">関数名へのブレイクポイント</h4>
<p>ブレイクポイントの場所として関数名を書くと、その関数名が呼び出された後、関数の本体の一行目が実行されるところにブレイクポイントが設定される。</p>
<p>現在のソースファイルの関数mainにブレイクポイントを設定する場合は以下のように書く。</p>
<pre><code>(gdb) break main</code></pre>
<p>ソースファイルが複数ある場合は、</p>
<pre><code>(gdb) ファイル名:関数名</code></pre>
<p>と書く。</p>
<p>C++では異なる引数で同じ名前の関数が使える。</p>
<div class="sourceCode" id="cb1525"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1525-1" data-line-number="1"><span class="dt">void</span> f() { }</a>
<a class="sourceLine" id="cb1525-2" data-line-number="2"><span class="dt">void</span> f(<span class="dt">int</span>) { }</a>
<a class="sourceLine" id="cb1525-3" data-line-number="3"><span class="dt">void</span> f(<span class="dt">double</span>) { }</a>
<a class="sourceLine" id="cb1525-4" data-line-number="4"></a>
<a class="sourceLine" id="cb1525-5" data-line-number="5"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1525-6" data-line-number="6">{</a>
<a class="sourceLine" id="cb1525-7" data-line-number="7">    f() ;</a>
<a class="sourceLine" id="cb1525-8" data-line-number="8">    f(<span class="dv">0</span>) ;</a>
<a class="sourceLine" id="cb1525-9" data-line-number="9">    f(<span class="fl">0.0</span>) ;</a>
<a class="sourceLine" id="cb1525-10" data-line-number="10">}</a></code></pre></div>
<p>このようなプログラムで関数fにブレイクポイントを設定すると、fという名前の関数すべてにブレイクポイントが設定される。</p>
<p>ブレイクポイントの一覧を表示する“info breakpoints”コマンドで確かめてみよう。</p>
<pre><code>(gdb) break f
Breakpoint 1 at 0x1149: f. (3 locations)
(gdb) info breakpoints 
Num     Type           Disp Enb Address            What
1       breakpoint     keep y   &lt;MULTIPLE&gt;         
1.1                         y     0x0000000000001149 in f() at main.cpp:1
1.2                         y     0x0000000000001153 in f(int) at main.cpp:2
1.3                         y     0x000000000000115f in f(double) at main.cpp:3</code></pre>
<p>関数名<code>f</code>に該当するすべての関数に、ブレイクポイント番号1としてブレイクポイントが設定される。関数にはそれぞれサブの番号が振られる。</p>
<p>この状態でブレイクポイント番号1を削除すると、1.1, 1.2, 1.3はすべて削除される。</p>
<pre><code>(gdb) delete 1
(gdb) info breakpoints
No breakpoints or watchpoints.</code></pre>
<p>TODO</p>
</body>
</html>
